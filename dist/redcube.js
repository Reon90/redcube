!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("redcube",[],t):"object"==typeof exports?exports.redcube=t():e.redcube=t()}(window,(function(){return function(e){function t(t){for(var r,i,s=t[0],o=t[1],a=0,c=[];a<s.length;a++)i=s[a],Object.prototype.hasOwnProperty.call(n,i)&&n[i]&&c.push(n[i][0]),n[i]=0;for(r in o)Object.prototype.hasOwnProperty.call(o,r)&&(e[r]=o[r]);for(l&&l(t);c.length;)c.shift()()}var r={},n={0:0};function i(t){if(r[t])return r[t].exports;var n=r[t]={i:t,l:!1,exports:{}};return e[t].call(n.exports,n,n.exports,i),n.l=!0,n.exports}i.e=function(e){var t=[],r=n[e];if(0!==r)if(r)t.push(r[2]);else{var s=new Promise((function(t,i){r=n[e]=[t,i]}));t.push(r[2]=s);var o,a=document.createElement("script");a.charset="utf-8",a.timeout=120,i.nc&&a.setAttribute("nonce",i.nc),a.src=function(e){return i.p+""+({}[e]||e)+".js"}(e);var l=new Error;o=function(t){a.onerror=a.onload=null,clearTimeout(c);var r=n[e];if(0!==r){if(r){var i=t&&("load"===t.type?"missing":t.type),s=t&&t.target&&t.target.src;l.message="Loading chunk "+e+" failed.\n("+i+": "+s+")",l.name="ChunkLoadError",l.type=i,l.request=s,r[1](l)}n[e]=void 0}};var c=setTimeout((function(){o({type:"timeout",target:a})}),12e4);a.onerror=a.onload=o,document.head.appendChild(a)}return Promise.all(t)},i.m=e,i.c=r,i.d=function(e,t,r){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(i.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)i.d(r,n,function(t){return e[t]}.bind(null,n));return r},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="dist/",i.oe=function(e){throw console.error(e),e};var s=window.webpackJsonpredcube=window.webpackJsonpredcube||[],o=s.push.bind(s);s.push=t,s=s.slice();for(var a=0;a<s.length;a++)t(s[a]);var l=o;return i(i.s=20)}([function(e,t){e.exports="#version 300 es\r\nlayout (location = 0) in vec2 pos;\r\n\r\nout vec2 uv;\r\n\r\nvoid main() {\r\n    uv = pos * 0.5 + 0.5;\r\n    gl_Position = vec4(pos, 0.0, 1.0); \r\n}\r\n"},function(e,t){},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\nout vec4 color;\r\n\r\nuniform vec2 denom;\r\nuniform sampler2D uTexture;\r\n\r\nconst float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\r\n\r\nvoid main() {             \r\n    vec2 offset = 1.0 / vec2(textureSize(uTexture, 0));\r\n    vec3 result = texture(uTexture, uv).rgb * weight[0];\r\n\r\n    for (int i = 1; i < 5; ++i) {\r\n        result += texture(uTexture, uv + denom * (offset * float(i))).rgb * weight[i];\r\n        result += texture(uTexture, uv - denom * (offset * float(i))).rgb * weight[i];\r\n    }\r\n\r\n    color = vec4(result, 1.0);\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 inPosition;\r\n\r\nuniform mat4 projection;\r\nuniform mat4 view;\r\n\r\nout vec3 outUV;\r\n\r\nvoid main() {\r\n\toutUV = inPosition;\r\n    mat4 rotView = mat4(mat3(view));\r\n    gl_Position = projection * rotView * vec4(inPosition, 1.0);\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\n// in vec4 tPos1;\r\n// in vec4 tPos2;\r\nin vec4 vPosLight1;\r\nin vec4 vPosLight2;\r\nout float color;\r\n\r\nuniform sampler2D lightTexture;\r\nuniform sampler2D cameraTexture;\r\n\r\nuniform mat4 proj;\r\nuniform mat4 light;\r\nuniform mat4 view;\r\nuniform vec3 viewPos;\r\nuniform vec3 lightPos;\r\n\r\nin vec3 outPositionView;\r\nin vec3 outPositionLight;\r\n\r\nconst int samples = 80;\r\n\r\nvoid main() {\r\n    float stp = 1.0/float(samples);\r\n\tfloat k = 0.0;\r\n    float d = 0.0;\r\n\r\n    for (int i = 0; i < samples; i++) {\r\n\r\n        //vec4 vPos = mix(tPos1,tPos2,k);\r\n        vec4 vPosLight = mix(vPosLight1,vPosLight2,k);\r\n        k += stp;\r\n\r\n        vec3 ShadowTexC = (vPosLight.xyz/vPosLight.w) * 0.5 + 0.5;\r\n\r\n        float add = step(texture(lightTexture, ShadowTexC.xy).x, ShadowTexC.z);\r\n        d += add*stp;\r\n\t}\r\n\r\n    vec3 viewDir = normalize(viewPos - outPositionView);\r\n    vec3 L = normalize(lightPos - outPositionLight);\r\n    color = min((1.0 - d), (1.0 - dot(L, viewDir)) * 0.2);\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec2 pos;\r\n\r\nout vec2 uv;\r\nout vec4 vPosLight1;\r\nout vec4 vPosLight2;\r\nout vec3 outPositionView;\r\nout vec3 outPositionLight;\r\n\r\nuniform mat4 proj;\r\nuniform mat4 light;\r\nuniform mat4 Iproj;\r\nuniform mat4 Iview;\r\nuniform mat4 view;\r\n\r\nvoid main() {\r\n    vec4 p1 = Iview * Iproj * vec4(pos, -1.0/16.0, 1.0);\r\n    vec4 p2 = Iview * Iproj * vec4(pos, 1.0/16.0, 1.0);\r\n\r\n\tvPosLight1 = proj * light * p1;\r\n    vPosLight2 = proj * light * p2;\r\n    outPositionLight = vec3(light * p1);\r\n    outPositionView = vec3(view * p1);\r\n\r\n\tuv = pos * 0.5 + 0.5;\r\n\tgl_Position = vec4(pos, 0.0, 1.0);\r\n}\r\n"},function(e,t){e.exports=function(e){e instanceof ArrayBuffer&&(e=new Uint8Array(e));var t=0,r=e.length;function n(){var n="";do{var i=e[t];if(10==i){++t;break}n+=String.fromCharCode(i)}while(++t<r);return n}for(var i=0,s=0,o=1,a=!1,l=0;l<20;l++){var c,h=n();if(c=h.match("#\\?RADIANCE"));else if(c=h.match("FORMAT=32-bit_rle_rgbe"))a=!0;else if(c=h.match("EXPOSURE=\\s*([0-9]*[.][0-9]*)"))o=Number(c[1]);else if(c=h.match("#.*"));else if(c=h.match("-Y ([0-9]+) \\+X ([0-9]+)")){s=Number(c[1]),i=Number(c[2]);break}}if(!a)throw new Error("File is not run length encoded!");var u=new Uint8Array(i*s*4);!function(e,t,r,n,i,s){var o,a,l,c=new Array(4),h=null,u=new Array(2),m=e.length;function f(t){var r=0;do{t[r++]=e[n]}while(++n<m&&r<t.length);return r}function E(t,r,i){var s=0;do{t[r+s++]=e[n]}while(++n<m&&s<i);return s}function T(e,t,r,n){var i=4*n,s=E(t,r,i);if(s<i)throw new Error("Error reading raw pixels: got "+s+" bytes, expected "+i)}for(;s>0;){if(f(c)<c.length)throw new Error("Error reading bytes: expected "+c.length);if(2!=c[0]||2!=c[1]||0!=(128&c[2]))return t[r++]=c[0],t[r++]=c[1],t[r++]=c[2],t[r++]=c[3],void T(0,t,r,i*s-1);if(((255&c[2])<<8|255&c[3])!=i)throw new Error("Wrong scanline width "+((255&c[2])<<8|255&c[3])+", expected "+i);null==h&&(h=new Array(4*i)),o=0;for(var R=0;R<4;R++)for(a=(R+1)*i;o<a;){if(f(u)<u.length)throw new Error("Error reading 2-byte buffer");if((255&u[0])>128){if(0==(l=(255&u[0])-128)||l>a-o)throw new Error("Bad scanline data");for(;l-- >0;)h[o++]=u[1]}else{if(0==(l=255&u[0])||l>a-o)throw new Error("Bad scanline data");if(h[o++]=u[1],--l>0){if(E(h,o,l)<l)throw new Error("Error reading non-run data");o+=l}}}for(R=0;R<i;R++)t[r+0]=h[R],t[r+1]=h[R+i],t[r+2]=h[R+2*i],t[r+3]=h[R+3*i],r+=4;s--}}(e,u,0,t,i,s);for(var m=new Float32Array(i*s*4),f=0;f<u.length;f+=4){var E=u[f+0]/255,T=u[f+1]/255,R=u[f+2]/255,_=u[f+3],d=Math.pow(2,_-128);E*=d,T*=d,R*=d;var A=f;m[A+0]=E,m[A+1]=T,m[A+2]=R,m[A+3]=1}return{shape:[i,s],exposure:o,gamma:1,data:m}}},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nin vec3 outUV;\r\nlayout (location = 0) out vec4 color;\r\n\r\nuniform sampler2D diffuse;\r\n\r\nconst vec2 invAtan = vec2(0.1591, 0.3183);\r\nvec2 SampleSphericalMap(vec3 v) {\r\n    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\r\n    uv *= invAtan;\r\n    uv += 0.5;\r\n    return uv;\r\n}\r\n\r\nvoid main() {\t\t\r\n    vec2 uv = SampleSphericalMap(normalize(outUV));\r\n    vec3 c = texture(diffuse, uv).rgb;\r\n    \r\n    color = vec4(c, 1.0);\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nin vec3 outUV;\r\nlayout (location = 0) out vec4 color;\r\n\r\nuniform samplerCube environmentMap;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nvoid main() {\r\n    vec3 N = normalize(outUV);\r\n    vec3 irradiance = vec3(0.0);\r\n\r\n    vec3 up    = vec3(0.0, 1.0, 0.0);\r\n    vec3 right = cross(up, N);\r\n    up         = cross(N, right);\r\n\r\n    float sampleDelta = 0.025;\r\n    float nrSamples = 0.0; \r\n    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\r\n    {\r\n        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\r\n        {\r\n            // spherical to cartesian (in tangent space)\r\n            vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\r\n            // tangent space to world\r\n            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N; \r\n\r\n            irradiance += textureLod(environmentMap, sampleVec, 3.0).rgb * cos(theta) * sin(theta);\r\n            nrSamples++;\r\n        }\r\n    }\r\n    irradiance = PI * irradiance * (1.0 / float(nrSamples));\r\n    \r\n    color = vec4(irradiance, 1.0);\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nin vec3 outUV;\r\nlayout (location = 0) out vec4 color;\r\n\r\nuniform samplerCube environmentMap;\r\nuniform float roughness;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nfloat RadicalInverse_VdC(uint bits) {\r\n    bits = (bits << 16u) | (bits >> 16u);\r\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r\n}\r\n// ----------------------------------------------------------------------------\r\nvec2 Hammersley(uint i, uint N) {\r\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\r\n}  \r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness) {\r\n    float a = roughness*roughness;\r\n\t\r\n    float phi = 2.0 * PI * Xi.x;\r\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\r\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\r\n\t\r\n    // from spherical coordinates to cartesian coordinates\r\n    vec3 H;\r\n    H.x = cos(phi) * sinTheta;\r\n    H.y = sin(phi) * sinTheta;\r\n    H.z = cosTheta;\r\n\t\r\n    // from tangent-space vector to world-space sample vector\r\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r\n    vec3 tangent   = normalize(cross(up, N));\r\n    vec3 bitangent = cross(N, tangent);\r\n\t\r\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\r\n    return normalize(sampleVec);\r\n} \r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = max(a*a, 0.0001);\r\n    float NdotH = max(dot(N, H), 0.0);\r\n    float NdotH2 = NdotH*NdotH;\r\n\r\n    float nom   = a2;\r\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n\r\n    return nom / max(denom, 0.0001);\r\n}\r\n\r\nvoid main() {\t\t\r\n    vec3 N = normalize(outUV);    \r\n    vec3 R = N;\r\n    vec3 V = R;\r\n\r\n    const uint SAMPLE_COUNT = 1024u;\r\n    float totalWeight = 0.0;   \r\n    vec3 prefilteredColor = vec3(0.0);     \r\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i) {\r\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\r\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\r\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\r\n\r\n        float NdotL = max(dot(N, L), 0.0);\r\n        if (NdotL > 0.0) {\r\n            float D = DistributionGGX(N, H, roughness);\r\n            float pdf = (D * max(dot(N, H), 0.0) / (4.0 * max(dot(H, V), 0.0))) + 0.0001;\r\n             \r\n            float saTexel = 4.0 * PI / (6.0 * 512.0 * 512.0);\r\n            float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.00001);\r\n             \r\n            float mipLevel = roughness == 0.0 ? 0.0 :  0.5 * log2( saSample / saTexel )  ;\r\n                                 \r\n            prefilteredColor += textureLod( environmentMap, L, mipLevel ).rgb * NdotL;     \r\n            totalWeight += NdotL;\r\n        }\r\n    }\r\n    prefilteredColor = prefilteredColor / totalWeight;\r\n    \r\n    color = vec4(prefilteredColor, 1.0);\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\nlayout (location = 0) out vec2 color;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\r\n    float a = roughness;\r\n    float k = (a * a) / 2.0;\r\n\r\n    float nom   = NdotV;\r\n    float denom = NdotV * (1.0 - k) + k;\r\n\r\n    return nom / denom;\r\n}\r\n\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float NdotV = max(dot(N, V), 0.0);\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\r\n\r\n    return ggx1 * ggx2;\r\n} \r\n\r\nfloat RadicalInverse_VdC(uint bits) {\r\n    bits = (bits << 16u) | (bits >> 16u);\r\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r\n}\r\n\r\nvec2 Hammersley(uint i, uint N) {\r\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\r\n}  \r\n\r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness) {\r\n    float a = roughness*roughness;\r\n\t\r\n    float phi = 2.0 * PI * Xi.x;\r\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\r\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\r\n\t\r\n    // from spherical coordinates to cartesian coordinates\r\n    vec3 H;\r\n    H.x = cos(phi) * sinTheta;\r\n    H.y = sin(phi) * sinTheta;\r\n    H.z = cosTheta;\r\n\t\r\n    // from tangent-space vector to world-space sample vector\r\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r\n    vec3 tangent   = normalize(cross(up, N));\r\n    vec3 bitangent = cross(N, tangent);\r\n\t\r\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\r\n    return normalize(sampleVec);\r\n} \r\n\r\nvec2 IntegrateBRDF(float NdotV, float roughness) {\r\n    vec3 V;\r\n    V.x = sqrt(1.0 - NdotV*NdotV);\r\n    V.y = 0.0;\r\n    V.z = NdotV;\r\n\r\n    float A = 0.0;\r\n    float B = 0.0;\r\n\r\n    vec3 N = vec3(0.0, 0.0, 1.0);\r\n\r\n    const uint SAMPLE_COUNT = 1024u;\r\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i) {\r\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\r\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\r\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\r\n\r\n        float NdotL = max(L.z, 0.0);\r\n        float NdotH = max(H.z, 0.0);\r\n        float VdotH = max(dot(V, H), 0.0);\r\n\r\n        if(NdotL > 0.0) {\r\n            float G = GeometrySmith(N, V, L, roughness);\r\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\r\n            float Fc = pow(1.0 - VdotH, 5.0);\r\n\r\n            A += (1.0 - Fc) * G_Vis;\r\n            B += Fc * G_Vis;\r\n        }\r\n    }\r\n    A /= float(SAMPLE_COUNT);\r\n    B /= float(SAMPLE_COUNT);\r\n    return vec2(A, B);\r\n}\r\n\r\nvoid main() {\t\t\r\n    vec2 integratedBRDF = IntegrateBRDF(uv.x, uv.y);\r\n    color = integratedBRDF;\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 inPosition;\r\nlayout (location = 1) in vec3 inNormal;\r\nlayout (location = 2) in vec2 inUV;\r\nlayout (location = 3) in vec4 inJoint;\r\nlayout (location = 4) in vec4 inWeight;\r\nlayout (location = 5) in vec4 inTangent;\r\nlayout (location = 6) in vec4 inColor;\r\nlayout (location = 7) in vec2 inUV2;\r\n\r\nout vec4 vColor;\r\nout vec2 outUV;\r\nout vec2 outUV2;\r\nout vec3 outPosition;\r\nout vec4 outPositionView;\r\n#ifdef TANGENT\r\n    out mat3 outTBN;\r\n#else\r\n    out vec3 outNormal;\r\n#endif\r\n\r\nuniform Matrices {\r\n    mat4 model;\r\n    mat4 normalMatrix;\r\n    mat4 view;\r\n    mat4 projection;\r\n    mat4 light;\r\n    vec4 isShadow;\r\n};\r\n\r\n#ifdef JOINTNUMBER\r\nuniform Skin {\r\n    mat4 joint[JOINTNUMBER];\r\n};\r\n#endif\r\n\r\nvoid main() {\r\n    #ifdef JOINTNUMBER\r\n        mat4 skin = inWeight.x * joint[int(inJoint.x)];\r\n        skin += inWeight.y * joint[int(inJoint.y)];\r\n        skin += inWeight.z * joint[int(inJoint.z)];\r\n        skin += inWeight.w * joint[int(inJoint.w)];\r\n    #else\r\n        mat4 skin = mat4(1.0);\r\n    #endif\r\n\r\n    #ifdef COLOR_255\r\n        vColor = inColor / 255.0;\r\n    #else\r\n        vColor = inColor;\r\n    #endif\r\n    outUV = inUV;\r\n    outUV2 = inUV2;\r\n    #ifdef TANGENT\r\n        vec3 normalW = normalize(vec3(model * vec4(inNormal.xyz, 0.0)));\r\n        vec3 tangentW = normalize(vec3(model * vec4(inTangent.xyz, 0.0)));\r\n        vec3 bitangentW = cross(normalW, tangentW) * inTangent.w;\r\n        outTBN = mat3(tangentW, bitangentW, normalW);\r\n    #else\r\n        outNormal = normalize(mat3(normalMatrix) * mat3(skin) * inNormal);\r\n    #endif\r\n    outPosition = vec3(model * skin * vec4(inPosition, 1.0));\r\n    outPositionView = projection * light * model * skin * vec4(inPosition, 1.0);\r\n    if (isShadow.x == 1.0) {\r\n        gl_Position = projection * light * model * skin * vec4(inPosition, 1.0);\r\n    } else {\r\n        gl_Position = projection * view * model * skin * vec4(inPosition, 1.0);\r\n    }\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\n#define IBL 1\r\n\r\nin vec4 vColor;\r\nin vec2 outUV;\r\nin vec2 outUV2;\r\nin vec3 outPosition;\r\nin vec4 outPositionView;\r\n#ifdef TANGENT\r\n    in mat3 outTBN;\r\n#else\r\n    in vec3 outNormal;\r\n#endif\r\n\r\nlayout (location = 0) out vec4 color;\r\nlayout (location = 1) out vec3 normalColor;\r\n\r\nuniform Material {\r\n    vec4 baseColorFactor;\r\n    vec3 viewPos;\r\n    mat3 textureMatrix;\r\n    vec3 specularFactor;\r\n    vec3 emissiveFactor;\r\n    vec4 glossinessFactor;\r\n    vec4 metallicFactor;\r\n    vec4 roughnessFactor;\r\n    vec4 clearcoatFactor;\r\n    vec4 clearcoatRoughnessFactor;\r\n    vec4 sheenColorFactor;\r\n    vec4 sheenFactor;\r\n    vec4 sheenRoughnessFactor;\r\n};\r\nuniform LightColor {\r\n    vec3 lightColor[LIGHTNUMBER];\r\n};\r\nuniform Spotdir {\r\n    vec3 spotdir[LIGHTNUMBER];\r\n};\r\nuniform LightIntensity {\r\n    vec4 lightIntensity[LIGHTNUMBER];\r\n};\r\nuniform LightPos {\r\n    vec3 lightPos[LIGHTNUMBER];\r\n};\r\nuniform SphericalHarmonics {\r\n    mat4 rotationMatrix;\r\n    vec3 vSphericalL00;\r\n    vec3 vSphericalL1_1;\r\n    vec3 vSphericalL10;\r\n    vec3 vSphericalL11;\r\n    vec3 vSphericalL2_2;\r\n    vec3 vSphericalL2_1;\r\n    vec3 vSphericalL20;\r\n    vec3 vSphericalL21;\r\n    vec3 vSphericalL22;\r\n};\r\n\r\nuniform sampler2D baseColorTexture;\r\nuniform sampler2D metallicRoughnessTexture;\r\nuniform sampler2D normalTexture;\r\nuniform sampler2D emissiveTexture;\r\nuniform sampler2D occlusionTexture;\r\nuniform sampler2D clearcoatTexture;\r\nuniform sampler2D clearcoatRoughnessTexture;\r\nuniform sampler2D sheenTexture;\r\nuniform sampler2D clearcoatNormalTexture;\r\n\r\nuniform samplerCube prefilterMap;\r\nuniform sampler2D brdfLUT;  \r\nuniform samplerCube irradianceMap;\r\nuniform sampler2D depthTexture;\r\n\r\nconst float RECIPROCAL_PI = 0.31830988618;\r\nconst float PI = 3.14159265359;\r\nconst float EPSILON = 1e-6;\r\nconst float ambientStrength = 0.1;\r\nconst float specularStrength = 2.5;\r\nconst float specularPower = 32.0;\r\nconst float gamma = 2.2;\r\n\r\nvec2 getUV(int index) {\r\n    if (index == 1) {\r\n        return outUV;\r\n    } else {\r\n        return outUV2;\r\n    }\r\n}\r\n\r\nfloat ShadowCalculation(vec4 fragPosLightSpace, float bias) {\r\n    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\r\n    projCoords = projCoords * 0.5 + 0.5;\r\n    float currentDepth = projCoords.z;\r\n\r\n    float shadow = 0.0;\r\n    vec2 texelSize = 1.0 / vec2(textureSize(depthTexture, 0));\r\n    for (int x = -2; x <= 2; ++x) {\r\n        for (int y = -2; y <= 2; ++y) {\r\n            float pcfDepth = texture(depthTexture, projCoords.xy + vec2(x, y) * texelSize).r;\r\n            shadow += currentDepth - bias > pcfDepth ? 0.5 : 0.0;\r\n        }\r\n    }\r\n    shadow /= 25.0;\r\n\r\n    return shadow;\r\n}\r\n\r\nvec3 srgbToLinear(vec4 srgbIn) {\r\n    return pow(srgbIn.rgb, vec3(2.2));\r\n}\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = max(a*a, 0.0001);\r\n    float NdotH = max(dot(N, H), 0.0);\r\n    float NdotH2 = NdotH*NdotH;\r\n\r\n    float nom   = a2;\r\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n\r\n    return nom / max(denom, 0.0001);\r\n}\r\n\r\nfloat GeometrySchlickGGX(float cosTheta, float roughness) {\r\n    float r = (roughness + 1.0);\r\n    float k = (r * r) / 8.0;\r\n\r\n    float nom   = cosTheta;\r\n    float denom = cosTheta * (1.0 - k) + k;\r\n\r\n    return nom / denom;\r\n}\r\n\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float NdotV = max(dot(N, V), 0.0);\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\r\n\r\n    return ggx1 * ggx2;\r\n}\r\n\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\r\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\n\r\nvec3 computeEnvironmentIrradiance(vec3 normal) {\r\n    return vSphericalL00\r\n        + vSphericalL1_1 * (normal.y)\r\n        + vSphericalL10 * (normal.z)\r\n        + vSphericalL11 * (normal.x)\r\n        + vSphericalL2_2 * (normal.y * normal.x)\r\n        + vSphericalL2_1 * (normal.y * normal.z)\r\n        + vSphericalL20 * ((3.0 * normal.z * normal.z) - 1.0)\r\n        + vSphericalL21 * (normal.z * normal.x)\r\n        + vSphericalL22 * (normal.x * normal.x - (normal.y * normal.y));\r\n}\r\nvec3 IBLAmbient(vec3 specularMap, vec3 baseColor, float metallic, vec3 n, float roughness, vec3 viewDir, float ao) {\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, baseColor, metallic);\r\n\r\n    #ifdef SPECULARGLOSSINESSMAP\r\n        F0 = specularMap;\r\n    #endif\r\n\r\n    vec3 F = fresnelSchlickRoughness(max(dot(n, viewDir), 0.0), F0, roughness);\r\n\r\n    vec3 kD = vec3(1.0) - F;\r\n    kD *= 1.0 - metallic;\r\n\r\n    const float MAX_REFLECTION_LOD = 4.0;\r\n    #ifdef SPHERICAL_HARMONICS\r\n    vec3 R = reflect(viewDir, n);\r\n    vec4 rotatedR = rotationMatrix * vec4(R, 0.0);\r\n    vec3 prefilteredColor = srgbToLinear(textureLod(prefilterMap, rotatedR.xyz, roughness * MAX_REFLECTION_LOD));\r\n    vec3 irradianceVector = vec3(rotationMatrix * vec4(n, 0)).xyz;\r\n    vec3 irradiance = computeEnvironmentIrradiance(irradianceVector).rgb;\r\n    #else\r\n    vec3 R = reflect(-viewDir, n);\r\n    vec3 prefilteredColor = textureLod(prefilterMap, R, roughness * MAX_REFLECTION_LOD).rgb;\r\n    vec3 irradiance = texture(irradianceMap, n).rgb;\r\n    #endif\r\n    vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(n, viewDir), 0.0), roughness)).rg;\r\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\r\n    vec3 diffuse = baseColor * irradiance;\r\n\r\n    return (kD * diffuse + specular) * ao;\r\n}\r\n\r\nvec3 CookTorranceSpecular(vec3 specularMap, vec3 baseColor, float metallic, vec3 n, vec3 H, float roughness, vec3 viewDir, vec3 lightDir) {\r\n    vec3 F0 = vec3(0.04); \r\n    F0 = mix(F0, baseColor, metallic);\r\n\r\n    #ifdef SPECULARGLOSSINESSMAP\r\n        F0 = specularMap;\r\n    #endif\r\n\r\n    float D = DistributionGGX(n, H, roughness);\r\n    float G = GeometrySmith(n, viewDir, lightDir, roughness);      \r\n    vec3 F = fresnelSchlick(max(dot(H, viewDir), 0.0), F0); \r\n\r\n    vec3 nominator = D * G * F;\r\n    float denominator = 4.0 * max(dot(n, viewDir), 0.0) * max(dot(n, lightDir), 0.0);\r\n    return nominator / max(denominator, 0.001);\r\n}\r\n\r\nvec3 LambertDiffuse(vec3 baseColor, float metallic, vec3 n, vec3 H, float roughness, vec3 viewDir, vec3 lightDir) {\r\n    float NdotL = max(dot(n, lightDir), 0.0);\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, baseColor, metallic);\r\n\r\n    vec3 F = fresnelSchlick(max(dot(H, viewDir), 0.0), F0);    \r\n\r\n    vec3 kD = vec3(1.0) - F;\r\n    kD *= 1.0 - metallic;\r\n    return baseColor * kD / PI;\r\n}\r\n\r\nfloat saturate(float a) {\r\n\tif (a > 1.0) return 1.0;\r\n\tif (a < 0.0) return 0.0;\r\n\treturn a;\r\n}\r\nvec3 ImprovedOrenNayarDiffuse(vec3 baseColor, float metallic, vec3 N, vec3 H, float a, vec3 V, vec3 L) {\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, baseColor, metallic);\r\n    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);\r\n    vec3 kD = vec3(1.0) - F;\r\n    kD *= 1.0 - metallic;\r\n    vec3 diffuseColor = baseColor * kD;\r\n\t// calculate intermediary values\r\n\tfloat dotNL = saturate(dot(N, L));\r\n\tfloat dotNV = saturate(dot(N, V));\r\n\tfloat dotLV = saturate(dot(L, V));\r\n\tfloat dotLH = saturate(dot(L, H));\r\n\r\n\tfloat s = dotLV - dotNL * dotNV;\r\n\tfloat t = mix(1.0, max(dotNL, dotNV), step(0.0, s));\r\n\tfloat st = s * (1.0 / (t + EPSILON));\r\n\r\n\tfloat sigma2 = a;\r\n\tvec3 A = diffuseColor * (0.17 * sigma2 / (sigma2 + 0.13)) + vec3(1.0 - 0.5 * sigma2 / (sigma2 + 0.33));\r\n\tfloat B = 0.45 * sigma2 / (sigma2 + 0.09);\r\n\treturn (diffuseColor * max(0.0, dotNL)) * (A + vec3(B * s / t) / PI);\r\n}\r\n\r\nfloat sheenDistribution(float sheenRoughness, vec3 N, vec3 H) {\r\n    float NdotH = max(dot(N, H), 0.0);\r\n    float alphaG = max(sheenRoughness * sheenRoughness, 0.01);\r\n    float invR = 1.0 / alphaG;\r\n    float cos2h = NdotH * NdotH;\r\n    float sin2h = 1.0 - cos2h;\r\n    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\r\n}\r\n\r\nfloat sheenVisibility(vec3 N, vec3 V, vec3 L) {\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    float NdotV = max(dot(N, V), 0.0);\r\n    return 1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV));\r\n}\r\n\r\nvoid main() {\r\n    #ifdef BASECOLORTEXTURE\r\n        vec2 uv = outUV;\r\n        #ifdef TEXTURE_TRANSFORM\r\n            uv = ( textureMatrix * vec3(uv.xy, 1.0) ).xy;\r\n        #endif\r\n        vec3 baseColor = srgbToLinear(texture(baseColorTexture, uv)) * baseColorFactor.rgb;\r\n        float alpha = min(texture(baseColorTexture, uv).a, baseColorFactor.a);\r\n    #else\r\n        vec3 baseColor = baseColorFactor.rgb;\r\n        float alpha = baseColorFactor.a;\r\n    #endif\r\n\r\n    #ifdef ALPHATEST\r\n    if ( alpha < ALPHATEST ) {\r\n        discard;\r\n    }\r\n    #else\r\n        alpha = 1.0;\r\n    #endif\r\n\r\n    if ( length(vColor.rgb) != 0.0 ) {\r\n        baseColor.rgb *= vColor.rgb;\r\n    }\r\n\r\n    #ifdef NOLIGHT\r\n        color = vec4(baseColor, alpha);\r\n        return;\r\n    #endif\r\n\r\n    #ifdef OCCLUSIONMAP\r\n        float ao = texture(occlusionTexture, outUV).r;\r\n    #else\r\n        float ao = 0.2;\r\n    #endif\r\n\r\n    float roughness = roughnessFactor.x;\r\n    float metallic = metallicFactor.x;\r\n    float clearcoatRoughness = clearcoatRoughnessFactor.x;\r\n    float clearcoat = clearcoatFactor.x;\r\n    float clearcoatBlendFactor = clearcoat;\r\n    float sheen = sheenFactor.x;\r\n    vec3 sheenColor = sheenColorFactor.xyz;\r\n    float sheenRoughness = sheenRoughnessFactor.x;\r\n    #ifdef CLEARCOATMAP\r\n        clearcoatBlendFactor = texture(clearcoatTexture, outUV).r * clearcoat;\r\n    #endif\r\n    #ifdef CLEARCOATROUGHMAP\r\n        clearcoatRoughness = texture(clearcoatRoughnessTexture, outUV).g * clearcoatRoughness;\r\n    #endif\r\n    #ifdef SHEENMAP\r\n        vec4 sheenTextureV = texture(sheenTexture, outUV);\r\n        sheenColor = sheenTextureV.rgb * sheenColor;\r\n        sheen = sheenTextureV.a * sheen;\r\n    #endif\r\n    vec3 specularMap = vec3(0);\r\n    #ifdef SPECULARGLOSSINESSMAP\r\n        #ifdef METALROUGHNESSMAP\r\n            roughness = 1.0 - texture(metallicRoughnessTexture, outUV).a;\r\n            specularMap = srgbToLinear(texture(metallicRoughnessTexture, outUV));\r\n        #else\r\n            roughness = glossinessFactor.x;\r\n            specularMap = specularFactor;\r\n        #endif\r\n    #else\r\n        #ifdef METALROUGHNESSMAP\r\n            vec4 metallicRoughness = texture(metallicRoughnessTexture, outUV);\r\n            roughness *= metallicRoughness.g;\r\n            metallic *= metallicRoughness.b;\r\n        #endif\r\n    #endif\r\n\r\n    #ifdef TANGENT\r\n        #ifdef NORMALMAP\r\n            vec3 n = texture(normalTexture, outUV).rgb;\r\n            n = normalize(outTBN * (2.0 * n - 1.0));\r\n        #else\r\n            vec3 n = outTBN[2].xyz;\r\n        #endif\r\n    #else\r\n        vec3 n = outNormal;\r\n    #endif\r\n\r\n    #ifdef TANGENT\r\n    #ifdef CLEARCOATNORMALMAP\r\n        vec3 clearcoatNormal = texture(clearcoatNormalTexture, outUV).rgb;\r\n        clearcoatNormal = normalize(outTBN * (2.0 * clearcoatNormal - 1.0));\r\n    #else\r\n        vec3 clearcoatNormal = outTBN[2].xyz;\r\n    #endif\r\n    #else\r\n        vec3 clearcoatNormal = outNormal;\r\n    #endif\r\n\r\n    vec3 viewDir = normalize(viewPos - outPosition);\r\n\r\n    #ifdef DOUBLESIDED\r\n    if (dot(n, viewDir) < 0.0) {\r\n        n = -n;\r\n        clearcoatNormal = -clearcoatNormal;\r\n    }\r\n    #endif\r\n\r\n    float shadow = 1.0;\r\n    #ifdef SHADOWMAP\r\n        vec3 l = normalize(lightPos[0] - outPosition);\r\n        float shadowBias = max(0.05 * (1.0 - dot(n, l)), 0.005);\r\n        shadow = 1.0 - ShadowCalculation(outPositionView, shadowBias);\r\n    #endif\r\n\r\n    #ifdef USE_PBR\r\n        vec3 Lo = vec3(0.0);\r\n        for (int i = 0; i < LIGHTNUMBER; ++i) {\r\n            vec3 lightDir = normalize(lightPos[i] - outPosition);\r\n            float NdotL = max(dot(n, lightDir), 0.0);\r\n            vec3 H = normalize(viewDir + lightDir);\r\n\r\n            vec3 radiance = lightColor[i] * lightIntensity[i].x;\r\n            float distance = length(lightPos[i] - outPosition);\r\n            float attenuation = 1.0 / (distance * distance);\r\n            if (lightIntensity[i].w == 1.0) { // point\r\n                radiance = radiance * attenuation;\r\n            }\r\n            if (lightIntensity[i].w == 2.0) { // spot\r\n                float lightAngleScale = 1.0 / max(0.001, cos(lightIntensity[i].y) - cos(lightIntensity[i].z));\r\n                float lightAngleOffset = -cos(lightIntensity[i].z) * lightAngleScale;\r\n\r\n                float cd = dot(spotdir[i], lightDir);\r\n                float attenuationSpot = saturate(cd * lightAngleScale + lightAngleOffset);\r\n                attenuationSpot *= attenuationSpot;\r\n\r\n                radiance = radiance * attenuationSpot * attenuation;\r\n            }\r\n\r\n            vec3 specular = CookTorranceSpecular(specularMap, baseColor, metallic, n, H, roughness, viewDir, lightDir);\r\n            vec3 f_clearcoat = CookTorranceSpecular(specularMap, vec3(0.0), 0.0, clearcoatNormal, H, clearcoatRoughness, viewDir, lightDir);\r\n            float NdotV = saturate(dot(clearcoatNormal, viewDir));\r\n            vec3 clearcoatFresnel = 1.0 - clearcoatBlendFactor * fresnelSchlick(NdotV, vec3(0.04));\r\n            vec3 diffuse = ImprovedOrenNayarDiffuse(baseColor, metallic, n, H, roughness, viewDir, lightDir);\r\n            #ifdef SPECULARGLOSSINESSMAP\r\n                diffuse = baseColor * (1.0 - max(max(specularMap.r, specularMap.g), specularMap.b));\r\n            #endif\r\n            vec3 f_sheen = sheenColor * sheen * sheenDistribution(sheenRoughness, n, H) * sheenVisibility(n, viewDir, lightDir);\r\n\r\n            Lo += (diffuse + specular * NdotL) * radiance * clearcoatFresnel + f_clearcoat * clearcoatBlendFactor + f_sheen;\r\n        }\r\n\r\n        vec3 ambient = vec3(0.0);\r\n        vec3 ambientClearcoat = vec3(0.0);\r\n        vec3 clearcoatFresnel = vec3(1.0);\r\n        #ifdef IBL\r\n            ambient = max(vec3(0.03) * baseColor, IBLAmbient(specularMap, baseColor, metallic, n, roughness, viewDir, ao));\r\n            ambientClearcoat = IBLAmbient(specularMap, vec3(0.0), 0.0, clearcoatNormal, clearcoatRoughness, viewDir, ao) * clearcoatBlendFactor;\r\n            float NdotV = saturate(dot(clearcoatNormal, viewDir));\r\n            clearcoatFresnel = (1.0 - clearcoatBlendFactor * fresnelSchlick(NdotV, vec3(0.04)));\r\n        #else\r\n            ambient = vec3(0.03) * baseColor * ao;\r\n        #endif\r\n\r\n        vec3 emissive = emissiveFactor;\r\n        #ifdef EMISSIVEMAP\r\n            emissive = srgbToLinear(texture(emissiveTexture, getUV(EMISSIVEMAP)));\r\n        #endif\r\n\r\n        color = vec4(shadow * ((emissive + ambient + Lo) * clearcoatFresnel + ambientClearcoat), alpha);\r\n    #else\r\n        vec3 lightDir = normalize(lightPos[0] - outPosition);\r\n        vec3 ambient = ambientStrength * lightColor[0];\r\n\r\n        float diff = max(dot(n, lightDir), 0.0);\r\n        vec3 diffuse = diff * lightColor[0];\r\n\r\n        vec3 reflectDir = reflect(-lightDir, n);\r\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), specularPower);\r\n        vec3 specular = specularStrength * spec * lightColor[0];\r\n\r\n        color = vec4(baseColor.rgb * (ambient + diffuse + specular) * shadow, alpha);\r\n    #endif\r\n\r\n    #ifdef TONE\r\n        color.rgb = color.rgb / (color.rgb + vec3(1.0));\r\n        color.rgb = pow(color.rgb, vec3(1.0 / gamma));\r\n    #endif\r\n\r\n    normalColor = n;\r\n}\r\n"},function(e,t){e.exports="#version 300 es\nprecision highp float;\n\nin vec2 uv;\nout float color;\n\nconst int kernelSize = 32;\nconst float power = 5.0;\n\nuniform sampler2D normBuff;\nuniform sampler2D depthBuff;\nuniform sampler2D noice;\nuniform vec2 noiseScale;\nuniform vec3 kernels[kernelSize];\nuniform mat4 proj;\nuniform mat4 projI;\nuniform mat4 view;\nuniform float zFar;\nuniform float zNear;\nuniform float bias;\n\nvec3 getPositionFromDepth(float depth) {\n\tvec4 clipSpaceLocation = vec4(0.0);\n\tclipSpaceLocation.xy = uv * 2.0 - 1.0;\n\tclipSpaceLocation.z = depth * 2.0 - 1.0;;\n\tclipSpaceLocation.w = 1.0;\n\tvec4 homogenousLocation = projI * clipSpaceLocation;\n\thomogenousLocation.xyz = homogenousLocation.xyz / homogenousLocation.w;\n\treturn homogenousLocation.xyz;\n}\n\nvoid main() {\n\tfloat depth = texture(depthBuff, uv).x;\n\tif ((2.0 * zNear) / (zFar + zNear - depth * (zFar - zNear)) > 0.99) {\n\t\tdiscard;\n\t}\n\n\tfloat radius = bias * 2.0;\n\tvec3 pos = getPositionFromDepth(depth);\n\tvec3 normal = normalize(vec3(view * texture(normBuff, uv)));\n\tvec3 rvec = normalize(texture(noice, uv * noiseScale).xyz);\n\n\tvec3 tangent = normalize(rvec - normal * dot(rvec, normal));\n\tvec3 bitangent = cross(tangent, normal);\n\tmat3 rotate = mat3(tangent, bitangent, normal);\n\n\tfloat occlusion  = 0.0;\n\tfor (int i = 0; i < kernelSize; i++) {\n\t\tvec3 samplePos = rotate * kernels[i];\n\t\tsamplePos = pos + samplePos * radius;\n\n\t\tvec4 shift = proj * vec4(samplePos, 1.0);\n\t\tshift.xy /= shift.w;\n\t\tshift.xy = shift.xy * 0.5 + 0.5;\n\n\t\tfloat sampleDepth = getPositionFromDepth(texture(depthBuff, shift.xy).r).z;\n\n\t\tfloat distanceCheck = smoothstep(0.0, 1.0, radius / abs(pos.z - sampleDepth));\n\t\tocclusion  += (sampleDepth >= samplePos.z + bias ? 1.0 : 0.0) * distanceCheck;\n\t}\n\n\tocclusion = 1.0 - (occlusion / float(kernelSize));\n\tcolor = pow(occlusion, power);\n}\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\nout vec4 color;\r\n\r\nuniform sampler2D diff;\r\n\r\nconst vec3 hdrColor = vec3(0.2126, 0.7152, 0.0722);\r\nconst float brightnessThreshold = 0.8;\r\n\r\nvoid main() {\r\n    vec3 c = texture(diff, uv).rgb;\r\n    float brightness = dot(c, hdrColor);\r\n    if (brightness > brightnessThreshold) {\r\n        color = vec4(c, 1.0);\r\n    } else {\r\n        color = vec4(0.0, 0.0, 0.0, 1.0);\r\n    }\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\nout vec4 color;\r\n\r\nuniform sampler2D original;\r\nuniform sampler2D position;\r\nuniform sampler2D normal;\r\nuniform sampler2D ssao;\r\nuniform sampler2D bloom;\r\nuniform sampler2D depth;\r\nuniform sampler2D preDepth;\r\nuniform sampler2D light;\r\n\r\nconst float gamma = 2.2;\r\n\r\nvoid main() {\r\n    vec3 c = texture(original, uv).rgb;\r\n    #ifdef BLOOM\r\n        c += texture(bloom, uv).rgb;\r\n    #endif\r\n    #ifdef SSAO\r\n        c *= texture(ssao, uv).r;\r\n    #endif\r\n    #ifdef LIGHT\r\n        c += texture(light, uv).r;\r\n    #endif\r\n\r\n    c.rgb = c.rgb / (c.rgb + vec3(1.0));\r\n    c.rgb = pow(c.rgb, vec3(1.0 / gamma));\r\n\r\n    color = vec4(c, 1.0);\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\nprecision highp sampler3D;\r\n\r\nlayout(location = 0) in vec3 a_position;\r\nlayout(location = 1) in vec3 a_velocity;\r\nlayout(location = 2) in float a_spawntime;\r\nlayout(location = 3) in float a_lifetime;\r\nout float depth;\r\n\r\nuniform sampler2D light;\r\nuniform mat4 MVPMatrix;\r\nuniform float u_time;\r\n\r\nout float alpha;\r\n\r\nvoid main() {\r\n    gl_PointSize = 2.0;\r\n    vec4 point = vec4(a_position, 1.0);\r\n    vec2 uv = (point.xy / point.w) * 0.5 + 0.5;\r\n    float life = a_lifetime - (u_time - a_spawntime);\r\n    alpha = 1.0;\r\n    if (life < 1000.0) {\r\n        alpha = life / 1000.0;\r\n    }\r\n    depth = texture(light, uv).r;\r\n    gl_Position = point;\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) out vec4 color;\r\nin float depth;\r\nin float alpha;\r\n\r\nvoid main() {\r\n    //color = vec4(0.0, 0.0, 0.8, 1.0) * texture( image, gl_PointCoord );\r\n    if (depth < 0.05) {\r\n        discard;\r\n    }\r\n    color = vec4(1.0, 1.0, 1.0, alpha);\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) out vec4 color;\r\n\r\nvoid main() {\r\n    color = vec4(1.0, 1.0, 1.0, 1.0);\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\nprecision highp sampler3D;\r\n\r\nlayout(location = 0) in vec3 a_position;\r\nlayout(location = 1) in vec3 a_velocity;\r\nlayout(location = 2) in float a_spawntime;\r\nlayout(location = 3) in float a_lifetime;\r\n\r\nout vec3 v_position;\r\nout vec3 v_velocity;\r\nout float v_spawntime;\r\nout float v_lifetime;\r\n\r\nuniform float u_time;\r\nuniform sampler3D noize;\r\nuniform float count;\r\n\r\nfloat rand(vec3 co) {\r\n    return texture(noize, co).r;\r\n}\r\n\r\nvec3 snoiseVec3( vec3 x ) {\r\n  float s  = rand(vec3( x ));\r\n  float s1 = rand(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\r\n  float s2 = rand(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\r\n  vec3 c = vec3( s , s1 , s2 );\r\n  return c;\r\n}\r\n\r\nvec3 curlNoise( vec3 p ) {\r\n  const float e = .1;\r\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\r\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\r\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\r\n\r\n  vec3 p_x0 = snoiseVec3( p - dx );\r\n  vec3 p_x1 = snoiseVec3( p + dx );\r\n  vec3 p_y0 = snoiseVec3( p - dy );\r\n  vec3 p_y1 = snoiseVec3( p + dy );\r\n  vec3 p_z0 = snoiseVec3( p - dz );\r\n  vec3 p_z1 = snoiseVec3( p + dz );\r\n\r\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\r\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\r\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\r\n\r\n  const float divisor = 1.0 / ( 2.0 * e );\r\n  return normalize( vec3( x , y , z ) * divisor );\r\n}\r\n\r\nconst float lifetime = 15000.0;\r\nconst vec3 center = vec3(0.5, 0.5, 0.5);\r\nfloat acceleration = 2.0;\r\n\r\nvoid main() {\r\n    if (a_spawntime == 0.0 || (u_time - a_spawntime) > a_lifetime) {\r\n        float x = float(gl_InstanceID) / count;\r\n        float t = u_time/1000.0 * x;\r\n        v_position = center - vec3(\r\n            rand(vec3(x, x, t)),\r\n            rand(vec3(1.0 - x, 1.0 - x, t)),\r\n            rand(vec3(x, 0.5, t))\r\n        );\r\n        v_velocity = center- vec3(\r\n            rand(vec3(x, x, t)),\r\n            rand(vec3(1.0 - x, 1.0 - x, t)),\r\n            rand(vec3(x, 0.5, t))\r\n        );\r\n        v_spawntime = u_time;\r\n        v_lifetime = rand(vec3(x, 0.5, t)) * lifetime;\r\n    } else {\r\n        vec3 curlVelocity = curlNoise(a_position) - a_velocity;\r\n        v_velocity = a_velocity + 0.01 * curlVelocity;\r\n        v_position = a_position + 0.01 * v_velocity * acceleration;\r\n        v_spawntime = a_spawntime;\r\n        v_lifetime = a_lifetime;\r\n    }\r\n}\r\n"},function(e,t,r){"use strict";r.r(t),r.d(t,"RedCube",(function(){return Ft}));class n{constructor(){this._services=new Map,this._singletons=new Map,this.update=this.update.bind(this)}register(e,t,r=[],...n){this._services.set(e,{definition:t,dependencies:r,args:n}),this._isClass(t)?t.__update=this.update:this._updateDep(e,t)}get(e){const t=this._services.get(e);if(!t)return null;if(this._isClass(t.definition)){const r=this._singletons.get(e);if(r)return r;{const r=this._createInstance(t);return this._singletons.set(e,r),r}}return t.definition}update(e,...t){this._services.get(e).args=t,this._singletons.delete(e);const r=this.get(e);this._updateDep(e,r)}_updateDep(e,t){for(const[r,n]of this._singletons)this._services.get(r).dependencies.some(t=>t===e)&&n["set"+(e.charAt(0).toUpperCase()+e.slice(1))].call(n,t);this._singletons.set(e,t)}_getResolvedDependencies(e){let t=[];return e.dependencies&&(t=e.dependencies.map(e=>[e,this.get(e)])),t}_createInstance(e){const t=new e.definition(...e.args);return this._getResolvedDependencies(e).forEach(([e,r])=>{t["set"+(e.charAt(0).toUpperCase()+e.slice(1))].call(t,r)}),t}_isClass(e){return"function"==typeof e&&/^class\s/.test(Function.prototype.toString.call(e))}}class i{constructor(e){let t,r,n;if(e&&"object"==typeof e&&e.hasOwnProperty("elements")){for(r=e.elements,n=new Float32Array(9),t=0;t<9;++t)n[t]=r[t];this.elements=n}else this.elements=new Float32Array([1,0,0,0,1,0,0,0,1])}set(e){let t,r,n;if(r=e,n=this.elements,r!==n){for(t=0;t<9;++t)n[t]=r[t];return this}}normalFromMat4(e){const t=this.elements,r=(e=e.elements)[0],n=e[1],i=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],h=e[8],u=e[9],m=e[10],f=e[11],E=e[12],T=e[13],R=e[14],_=e[15],d=r*a-n*o,A=r*l-i*o,p=r*c-s*o,F=n*l-i*a,g=n*c-s*a,v=i*c-s*l,x=h*T-u*E,N=h*R-m*E,U=h*_-f*E,I=u*R-m*T,M=u*_-f*T,b=m*_-f*R;let S=d*b-A*M+p*I+F*U-g*N+v*x;return S?(S=1/S,t[0]=(a*b-l*M+c*I)*S,t[1]=(l*U-o*b-c*N)*S,t[2]=(o*M-a*U+c*x)*S,t[3]=(i*M-n*b-s*I)*S,t[4]=(r*b-i*U+s*N)*S,t[5]=(n*U-r*M-s*x)*S,t[6]=(T*v-R*g+_*F)*S,t[7]=(R*p-E*v-_*A)*S,t[8]=(E*g-T*p+_*d)*S,this):null}multiply(e){const t=this.elements,r=e.elements,n=this.elements,i=t[0],s=t[3],o=t[6],a=t[1],l=t[4],c=t[7],h=t[2],u=t[5],m=t[8],f=r[0],E=r[3],T=r[6],R=r[1],_=r[4],d=r[7],A=r[2],p=r[5],F=r[8];return n[0]=i*f+s*R+o*A,n[3]=i*E+s*_+o*p,n[6]=i*T+s*d+o*F,n[1]=a*f+l*R+c*A,n[4]=a*E+l*_+c*p,n[7]=a*T+l*d+c*F,n[2]=h*f+u*R+m*A,n[5]=h*E+u*_+m*p,n[8]=h*T+u*d+m*F,this}}class s{constructor(e){let t,r,n;if(e&&"object"==typeof e&&e.hasOwnProperty("elements")){for(r=e.elements,n=new Float32Array(16),t=0;t<16;++t)n[t]=r[t];this.elements=n}else this.elements=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}set(e){let t,r,n;if(r=e,n=this.elements,r!==n){for(t=0;t<16;++t)n[t]=r[t];return this}}multiply(e){return this.concat(e),this}concat({elements:e}){let t,r,n,i,s,o,a,l;if(r=this.elements,n=this.elements,i=e,r===i)for(i=new Float32Array(16),t=0;t<16;++t)i[t]=r[t];for(t=0;t<4;t++)s=n[t],o=n[t+4],a=n[t+8],l=n[t+12],r[t]=s*i[0]+o*i[1]+a*i[2]+l*i[3],r[t+4]=s*i[4]+o*i[5]+a*i[6]+l*i[7],r[t+8]=s*i[8]+o*i[9]+a*i[10]+l*i[11],r[t+12]=s*i[12]+o*i[13]+a*i[14]+l*i[15];return this}setInverseOf({elements:e}){let t,r,n,i,s;if(r=e,n=this.elements,i=new Float32Array(16),i[0]=r[5]*r[10]*r[15]-r[5]*r[11]*r[14]-r[9]*r[6]*r[15]+r[9]*r[7]*r[14]+r[13]*r[6]*r[11]-r[13]*r[7]*r[10],i[4]=-r[4]*r[10]*r[15]+r[4]*r[11]*r[14]+r[8]*r[6]*r[15]-r[8]*r[7]*r[14]-r[12]*r[6]*r[11]+r[12]*r[7]*r[10],i[8]=r[4]*r[9]*r[15]-r[4]*r[11]*r[13]-r[8]*r[5]*r[15]+r[8]*r[7]*r[13]+r[12]*r[5]*r[11]-r[12]*r[7]*r[9],i[12]=-r[4]*r[9]*r[14]+r[4]*r[10]*r[13]+r[8]*r[5]*r[14]-r[8]*r[6]*r[13]-r[12]*r[5]*r[10]+r[12]*r[6]*r[9],i[1]=-r[1]*r[10]*r[15]+r[1]*r[11]*r[14]+r[9]*r[2]*r[15]-r[9]*r[3]*r[14]-r[13]*r[2]*r[11]+r[13]*r[3]*r[10],i[5]=r[0]*r[10]*r[15]-r[0]*r[11]*r[14]-r[8]*r[2]*r[15]+r[8]*r[3]*r[14]+r[12]*r[2]*r[11]-r[12]*r[3]*r[10],i[9]=-r[0]*r[9]*r[15]+r[0]*r[11]*r[13]+r[8]*r[1]*r[15]-r[8]*r[3]*r[13]-r[12]*r[1]*r[11]+r[12]*r[3]*r[9],i[13]=r[0]*r[9]*r[14]-r[0]*r[10]*r[13]-r[8]*r[1]*r[14]+r[8]*r[2]*r[13]+r[12]*r[1]*r[10]-r[12]*r[2]*r[9],i[2]=r[1]*r[6]*r[15]-r[1]*r[7]*r[14]-r[5]*r[2]*r[15]+r[5]*r[3]*r[14]+r[13]*r[2]*r[7]-r[13]*r[3]*r[6],i[6]=-r[0]*r[6]*r[15]+r[0]*r[7]*r[14]+r[4]*r[2]*r[15]-r[4]*r[3]*r[14]-r[12]*r[2]*r[7]+r[12]*r[3]*r[6],i[10]=r[0]*r[5]*r[15]-r[0]*r[7]*r[13]-r[4]*r[1]*r[15]+r[4]*r[3]*r[13]+r[12]*r[1]*r[7]-r[12]*r[3]*r[5],i[14]=-r[0]*r[5]*r[14]+r[0]*r[6]*r[13]+r[4]*r[1]*r[14]-r[4]*r[2]*r[13]-r[12]*r[1]*r[6]+r[12]*r[2]*r[5],i[3]=-r[1]*r[6]*r[11]+r[1]*r[7]*r[10]+r[5]*r[2]*r[11]-r[5]*r[3]*r[10]-r[9]*r[2]*r[7]+r[9]*r[3]*r[6],i[7]=r[0]*r[6]*r[11]-r[0]*r[7]*r[10]-r[4]*r[2]*r[11]+r[4]*r[3]*r[10]+r[8]*r[2]*r[7]-r[8]*r[3]*r[6],i[11]=-r[0]*r[5]*r[11]+r[0]*r[7]*r[9]+r[4]*r[1]*r[11]-r[4]*r[3]*r[9]-r[8]*r[1]*r[7]+r[8]*r[3]*r[5],i[15]=r[0]*r[5]*r[10]-r[0]*r[6]*r[9]-r[4]*r[1]*r[10]+r[4]*r[2]*r[9]+r[8]*r[1]*r[6]-r[8]*r[2]*r[5],s=r[0]*i[0]+r[1]*i[4]+r[2]*i[8]+r[3]*i[12],0===s)return this;for(s=1/s,t=0;t<16;t++)n[t]=i[t]*s;return this}invert(){return this.setInverseOf(this)}makeOrthographic(e,t,r,n,i,s){var o=this.elements,a=1/(t-e),l=1/(r-n),c=1/(s-i),h=(t+e)*a,u=(r+n)*l,m=(s+i)*c;return o[0]=2*a,o[4]=0,o[8]=0,o[12]=-h,o[1]=0,o[5]=2*l,o[9]=0,o[13]=-u,o[2]=0,o[6]=0,o[10]=-2*c,o[14]=-m,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}setOrtho(e,t,r,n){let i,s,o,a;return s=1/e,o=1/t,a=2/(r-n),i=this.elements,i[0]=s,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=o,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=a,i[11]=(n+r)/(r-n),i[12]=0,i[13]=0,i[14]=0,i[15]=1,this}setPerspective(e,t,r,n){let i,s,o,a;if(r===n||0===t)throw"null frustum";if(r<=0)throw"near <= 0";if(n<=0)throw"far <= 0";if(e/=2,o=Math.sin(e),0===o)throw"null frustum";return s=1/(n-r),a=Math.cos(e)/o,i=this.elements,i[0]=a/t,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=a,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=-(n+r)*s,i[11]=-1,i[12]=0,i[13]=0,i[14]=-2*r*n*s,i[15]=0,this}perspective(e,t,r,n){return this.concat((new s).setPerspective(e,t,r,n))}multiplyVector4({elements:e}){const t=this.elements,r=e,n=new c,i=n.elements;return i[0]=r[0]*t[0]+r[1]*t[4]+r[2]*t[8]+r[3]*t[12],i[1]=r[0]*t[1]+r[1]*t[5]+r[2]*t[9]+r[3]*t[13],i[2]=r[0]*t[2]+r[1]*t[6]+r[2]*t[10]+r[3]*t[14],i[3]=r[0]*t[3]+r[1]*t[7]+r[2]*t[11]+r[3]*t[15],n}getScaling(){let e=this.elements,t=e[0],r=e[1],n=e[2],i=e[4],s=e[5],o=e[6],l=e[8],c=e[9],h=e[10];return new a([Math.sqrt(t*t+r*r+n*n),Math.sqrt(i*i+s*s+o*o),Math.sqrt(l*l+c*c+h*h)])}scale(e){const t=e.elements[0],r=e.elements[1],n=e.elements[2],i=this.elements;return i[0]*=t,i[4]*=r,i[8]*=n,i[1]*=t,i[5]*=r,i[9]*=n,i[2]*=t,i[6]*=r,i[10]*=n,i[3]*=t,i[7]*=r,i[11]*=n,this}restoreScale(e){const t=e.elements[0],r=e.elements[1],n=e.elements[2],i=this.elements;return i[0]/=t,i[4]/=r,i[8]/=n,i[1]/=t,i[5]/=r,i[9]/=n,i[2]/=t,i[6]/=r,i[10]/=n,i[3]/=t,i[7]/=r,i[11]/=n,this}setTranslate(e){const t=this.elements,r=e.elements[0],n=e.elements[1],i=e.elements[2];return t[12]=r,t[13]=n,t[14]=i,t[15]=1,this}translate(e,t,r){const n=this.elements;return n[12]+=n[0]*e+n[4]*t+n[8]*r,n[13]+=n[1]*e+n[5]*t+n[9]*r,n[14]+=n[2]*e+n[6]*t+n[10]*r,n[15]+=n[3]*e+n[7]*t+n[11]*r,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],r=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],n=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,r,n))}rotate(e,t){let r,n,i,s,o,a,l,c,h,u,m,f,E,T,R,_,d,A,p,F,g,v,x,N,U=e.elements[0],I=e.elements[1],M=e.elements[2],b=Math.hypot(U,I,M);if(b<Number.EPSILON)return null;b=1/b,U*=b,I*=b,M*=b,r=Math.sin(t),n=Math.cos(t),i=1-n;let S=this.elements;return s=S[0],o=S[1],a=S[2],l=S[3],c=S[4],h=S[5],u=S[6],m=S[7],f=S[8],E=S[9],T=S[10],R=S[11],_=U*U*i+n,d=I*U*i+M*r,A=M*U*i-I*r,p=U*I*i-M*r,F=I*I*i+n,g=M*I*i+U*r,v=U*M*i+I*r,x=I*M*i-U*r,N=M*M*i+n,S[0]=s*_+c*d+f*A,S[1]=o*_+h*d+E*A,S[2]=a*_+u*d+T*A,S[3]=l*_+m*d+R*A,S[4]=s*p+c*F+f*g,S[5]=o*p+h*F+E*g,S[6]=a*p+u*F+T*g,S[7]=l*p+m*F+R*g,S[8]=s*v+c*x+f*N,S[9]=o*v+h*x+E*N,S[10]=a*v+u*x+T*N,S[11]=l*v+m*x+R*N,this}makeRotationAxis(e,t){const r=this.elements,n=Math.cos(t),i=Math.sin(t),s=1-n,o=e.elements[0],a=e.elements[1],l=e.elements[2],c=s*o,h=s*a;return r[0]=c*o+n,r[1]=c*a-i*l,r[2]=c*l+i*a,r[3]=0,r[4]=c*a+i*l,r[5]=h*a+n,r[6]=h*l-i*o,r[7]=0,r[8]=c*l-i*a,r[9]=h*l+i*o,r[10]=s*l*l+n,r[11]=0,r[15]=1,this}makeRotationFromQuaternion(e){const t=this.elements,r=e[0],n=e[1],i=e[2],s=e[3],o=r+r,a=n+n,l=i+i,c=r*o,h=r*a,u=r*l,m=n*a,f=n*l,E=i*l,T=s*o,R=s*a,_=s*l;return t[0]=1-(m+E),t[4]=h-_,t[8]=u+R,t[1]=h+_,t[5]=1-(c+E),t[9]=f-T,t[2]=u-R,t[6]=f+T,t[10]=1-(c+m),this}transpose(){let e,t;return e=this.elements,t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}}class o{constructor(e){this.elements=e.slice()}lerp(e,t,r){const n=this.elements;for(let i=0;i<n.length;i++)n[i]=e[i]+r*(t[i]-e[i]);return this}}class a{constructor(e){const t=new Float32Array(3);e&&"object"==typeof e&&(t[0]=e[0],t[1]=e[1],t[2]=e[2]),this.elements=t}get x(){return this.elements[0]}get y(){return this.elements[1]}get z(){return this.elements[2]}set x(e){this.elements[0]=e}set y(e){this.elements[1]=e}set z(e){this.elements[2]=e}static FromArrayToRef(e,t,r){r.x=e[t],r.y=e[t+1],r.z=e[t+2]}projectOnVector(e){const t=a.dot(e,this)/e.lengthSq();return new a(e).scale(t)}applyQuaternion({elements:e}){const t=this.elements[0],r=this.elements[1],n=this.elements[2],i=e[0],s=e[1],o=e[2],a=e[3],l=a*t+s*n-o*r,c=a*r+o*t-i*n,h=a*n+i*r-s*t,u=-i*t-s*r-o*n;return this.elements[0]=l*a+u*-i+c*-o-h*-s,this.elements[1]=c*a+u*-s+h*-i-l*-o,this.elements[2]=h*a+u*-o+l*-s-c*-i,this}normalize(){const e=this.elements,t=e[0],r=e[1],n=e[2];let i=Math.sqrt(t*t+r*r+n*n);return i?(1==i||(i=1/i,e[0]=t*i,e[1]=r*i,e[2]=n*i),this):(e[0]=0,e[1]=0,e[2]=0,this)}add(e){const t=this.elements;return e=e.elements,t[0]=t[0]+e[0],t[1]=t[1]+e[1],t[2]=t[2]+e[2],this}addS(e){const t=this.elements;return t[0]=t[0]+e,t[1]=t[1]+e,t[2]=t[2]+e,this}scale(e){const t=this.elements;return t[0]=t[0]*e,t[1]=t[1]*e,t[2]=t[2]*e,this}scale2(e){return new a([this.x*e,this.y*e,this.z*e])}subtract2(e){return new a([this.x-e.x,this.y-e.y,this.z-e.z])}add2(e){return new a([this.x+e.x,this.y+e.y,this.z+e.z])}distanceToSquared(e,t,r){const n=this.elements[0]-e,i=this.elements[1]-t,s=this.elements[2]-r;return n*n+i*i+s*s}subtract(e){const t=this.elements;return e=e.elements,t[0]=t[0]-e[0],t[1]=t[1]-e[1],t[2]=t[2]-e[2],this}divideScalar(e){return this.scale(1/e)}applyMatrix4({elements:e}){const t=this.elements[0],r=this.elements[1],n=this.elements[2],i=e;this.elements[0]=i[0]*t+i[4]*r+i[8]*n+i[12],this.elements[1]=i[1]*t+i[5]*r+i[9]*n+i[13],this.elements[2]=i[2]*t+i[6]*r+i[10]*n+i[14];const s=i[3]*t+i[7]*r+i[11]*n+i[15];return this.divideScalar(s)}lerp(e,t,r){const n=this.elements,i=e[0],s=e[1],o=e[2];return n[0]=i+r*(t[0]-i),n[1]=s+r*(t[1]-s),n[2]=o+r*(t[2]-o),this}lengthSq(){return this.elements[0]*this.elements[0]+this.elements[1]*this.elements[1]+this.elements[2]*this.elements[2]}multiply({elements:e}){return this.elements[0]*=e[0],this.elements[1]*=e[1],this.elements[2]*=e[2],this}static angle(e,t){const r=new a(e.elements),n=new a(t.elements);r.normalize(),n.normalize();const i=a.dot(r,n);return i>1?0:Math.acos(i)}static cross(e,t){e=e.elements,t=t.elements;const r=e[0],n=e[1],i=e[2],s=t[0],o=t[1],l=t[2],c=new a;return c.elements[0]=n*l-i*o,c.elements[1]=i*s-r*l,c.elements[2]=r*o-n*s,c}static dot(e,t){return e=e.elements,t=t.elements,e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}}class l{constructor(){this.min=new a([1/0,1/0,1/0]),this.max=new a([-1/0,-1/0,-1/0])}expand(e){this.min.min(e.min),this.max.max(e.max)}getSize(){const e=new a;return e.subVectors(this.max,this.min),e.length()}}class c{constructor(e){const t=new Float32Array(4);e&&"object"==typeof e&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3]),this.elements=t}set(e){const t=this.elements;return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],this}add(e){const t=this.elements;return e=e.elements,t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=t[3]+e[3],this}normalize(){const e=this.elements[0],t=this.elements[1],r=this.elements[2],n=this.elements[3];let i=e*e+t*t+r*r+n*n;return i>0&&(i=1/Math.sqrt(i),this.elements[0]=e*i,this.elements[1]=t*i,this.elements[2]=r*i,this.elements[3]=n*i),this}setFromRotationMatrix({elements:e}){const t=e,r=t[0],n=t[4],i=t[8],s=t[1],o=t[5],a=t[9],l=t[2],c=t[6],h=t[10],u=r+o+h;let m;return u>0?(m=.5/Math.sqrt(u+1),this.elements[3]=.25/m,this.elements[0]=(c-a)*m,this.elements[1]=(i-l)*m,this.elements[2]=(s-n)*m):r>o&&r>h?(m=2*Math.sqrt(1+r-o-h),this.elements[3]=(c-a)/m,this.elements[0]=.25*m,this.elements[1]=(n+s)/m,this.elements[2]=(i+l)/m):o>h?(m=2*Math.sqrt(1+o-r-h),this.elements[3]=(i-l)/m,this.elements[0]=(n+s)/m,this.elements[1]=.25*m,this.elements[2]=(a+c)/m):(m=2*Math.sqrt(1+h-r-o),this.elements[3]=(s-n)/m,this.elements[0]=(i+l)/m,this.elements[1]=(a+c)/m,this.elements[2]=.25*m),this}lerp(e,t,r){const n=this.elements;if(0===r)return this;if(1===r)return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],this;const i=e[0],s=e[1],o=e[2],a=e[3];let l=a*t[3]+i*t[0]+s*t[1]+o*t[2];if(l<0?(n[3]=-t[3],n[0]=-t[0],n[1]=-t[1],n[2]=-t[2],l=-l):(n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3]),l>=1)return n[3]=a,n[0]=i,n[1]=s,n[2]=o,this;const c=1-l*l;if(c<=Number.EPSILON){var h=1-r;return n[3]=h*a+r*n[3],n[0]=h*i+r*n[0],n[1]=h*s+r*n[1],n[2]=h*o+r*n[2],this.normalize()}const u=Math.sqrt(c),m=Math.atan2(u,l),f=Math.sin((1-r)*m)/u,E=Math.sin(r*m)/u;return n[3]=a*f+n[3]*E,n[0]=i*f+n[0]*E,n[1]=s*f+n[1]*E,n[2]=o*f+n[2]*E,this}inverse(){return this.elements[0]=-this.elements[0],this.elements[1]=-this.elements[1],this.elements[2]=-this.elements[2],this}}class h{constructor(e){const t=new Float32Array(2);e&&"object"==typeof e&&(t[0]=e[0],t[1]=e[1]),this.elements=t}get x(){return this.elements[0]}get y(){return this.elements[1]}set x(e){this.elements[0]=e}set y(e){this.elements[1]=e}subtract(e){const t=this.elements;return e=e.elements,t[0]=t[0]-e[0],t[1]=t[1]-e[1],this}lerp(e,t,r){const n=this.elements,i=e[0],s=e[1];return n[0]=i+r*(t[0]-i),n[1]=s+r*(t[1]-s),this}}function u(e){const t=[new c,new c,new c,new c,new c,new c],r=e.elements;let n=r[0],i=r[1],s=r[2],o=r[3],a=r[4],l=r[5],h=r[6],u=r[7],m=r[8],f=r[9],E=r[10],T=r[11],R=r[12],_=r[13],d=r[14],A=r[15];return t[0].set([o-n,u-a,T-m,A-R]).normalize(),t[1].set([o+n,u+a,T+m,A+R]).normalize(),t[2].set([o+i,u+l,T+f,A+_]).normalize(),t[3].set([o-i,u-l,T-f,A-_]).normalize(),t[4].set([o-s,u-h,T-E,A-d]).normalize(),t[5].set([o+s,u+h,T+E,A+d]).normalize(),t}class m{constructor(){this.opaqueChildren=[],this.transparentChildren=[],this.meshes=[],this.children=[],this.bin=[],this.matrixWorld=new s,this.matrix=new s}}class f{constructor(e,t){this.uuid=Math.floor(Date.now()*Math.random()),this.name=e,this.children=[],this.matrix=new s,this.matrixWorld=new s,this.parent=t}getPosition(){return new Float32Array([this.matrixWorld.elements[12],this.matrixWorld.elements[13],this.matrixWorld.elements[14]])}setPosition(e,t,r){t&&this.matrix.makeRotationFromQuaternion(t),r&&this.matrix.scale(new a(r)),e&&this.matrix.setTranslate(new a(e))}setMatrix(e){this.matrix.set(e)}setMatrixWorld(e){this.matrixWorld.set(e)}updateMatrix(){const e=new s;e.multiply(this.parent.matrixWorld),e.multiply(this.matrix),this.setMatrixWorld(e.elements)}}var E={0:"NONE",1:"ONE",2:"LINE_LOOP",3:"LINE_STRIP",4:"TRIANGLES",5:"TRIANGLE_STRIP",6:"TRIANGLE_FAN",256:"DEPTH_BUFFER_BIT",512:"NEVER",513:"LESS",514:"EQUAL",515:"LEQUAL",516:"GREATER",517:"NOTEQUAL",518:"GEQUAL",519:"ALWAYS",768:"SRC_COLOR",769:"ONE_MINUS_SRC_COLOR",770:"SRC_ALPHA",771:"ONE_MINUS_SRC_ALPHA",772:"DST_ALPHA",773:"ONE_MINUS_DST_ALPHA",774:"DST_COLOR",775:"ONE_MINUS_DST_COLOR",776:"SRC_ALPHA_SATURATE",1024:"STENCIL_BUFFER_BIT",1028:"FRONT",1029:"BACK",1032:"FRONT_AND_BACK",1280:"INVALID_ENUM",1281:"INVALID_VALUE",1282:"INVALID_OPERATION",1285:"OUT_OF_MEMORY",1286:"INVALID_FRAMEBUFFER_OPERATION",1798:"drawingBufferHeight",2304:"CW",2305:"CCW",2712:"drawingBufferWidth",2849:"LINE_WIDTH",2884:"CULL_FACE",2885:"CULL_FACE_MODE",2886:"FRONT_FACE",2928:"DEPTH_RANGE",2929:"DEPTH_TEST",2930:"DEPTH_WRITEMASK",2931:"DEPTH_CLEAR_VALUE",2932:"DEPTH_FUNC",2960:"STENCIL_TEST",2961:"STENCIL_CLEAR_VALUE",2962:"STENCIL_FUNC",2963:"STENCIL_VALUE_MASK",2964:"STENCIL_FAIL",2965:"STENCIL_PASS_DEPTH_FAIL",2966:"STENCIL_PASS_DEPTH_PASS",2967:"STENCIL_REF",2968:"STENCIL_WRITEMASK",2978:"VIEWPORT",3024:"DITHER",3042:"BLEND",3074:"READ_BUFFER",3088:"SCISSOR_BOX",3089:"SCISSOR_TEST",3106:"COLOR_CLEAR_VALUE",3107:"COLOR_WRITEMASK",3314:"UNPACK_ROW_LENGTH",3315:"UNPACK_SKIP_ROWS",3316:"UNPACK_SKIP_PIXELS",3317:"UNPACK_ALIGNMENT",3330:"PACK_ROW_LENGTH",3331:"PACK_SKIP_ROWS",3332:"PACK_SKIP_PIXELS",3333:"PACK_ALIGNMENT",3379:"MAX_TEXTURE_SIZE",3386:"MAX_VIEWPORT_DIMS",3408:"SUBPIXEL_BITS",3410:"RED_BITS",3411:"GREEN_BITS",3412:"BLUE_BITS",3413:"ALPHA_BITS",3414:"DEPTH_BITS",3415:"STENCIL_BITS",3553:"TEXTURE_2D",4352:"DONT_CARE",4353:"FASTEST",4354:"NICEST",5120:"BYTE",5121:"UNSIGNED_BYTE",5122:"SHORT",5123:"UNSIGNED_SHORT",5124:"INT",5125:"UNSIGNED_INT",5126:"FLOAT",5131:"HALF_FLOAT",5386:"INVERT",5890:"TEXTURE",6144:"COLOR",6145:"DEPTH",6146:"STENCIL",6402:"DEPTH_COMPONENT",6403:"RED",6406:"ALPHA",6407:"RGB",6408:"RGBA",6409:"LUMINANCE",6410:"LUMINANCE_ALPHA",7680:"KEEP",7681:"REPLACE",7682:"INCR",7683:"DECR",7936:"VENDOR",7937:"RENDERER",7938:"VERSION",9728:"NEAREST",9729:"LINEAR",9984:"NEAREST_MIPMAP_NEAREST",9985:"LINEAR_MIPMAP_NEAREST",9986:"NEAREST_MIPMAP_LINEAR",9987:"LINEAR_MIPMAP_LINEAR",10240:"TEXTURE_MAG_FILTER",10241:"TEXTURE_MIN_FILTER",10242:"TEXTURE_WRAP_S",10243:"TEXTURE_WRAP_T",10497:"REPEAT",10752:"POLYGON_OFFSET_UNITS",16384:"COLOR_BUFFER_BIT",32769:"CONSTANT_COLOR",32770:"ONE_MINUS_CONSTANT_COLOR",32771:"CONSTANT_ALPHA",32772:"ONE_MINUS_CONSTANT_ALPHA",32773:"BLEND_COLOR",32774:"FUNC_ADD",32775:"MIN",32776:"MAX",32777:"BLEND_EQUATION_RGB",32778:"FUNC_SUBTRACT",32779:"FUNC_REVERSE_SUBTRACT",32819:"UNSIGNED_SHORT_4_4_4_4",32820:"UNSIGNED_SHORT_5_5_5_1",32823:"POLYGON_OFFSET_FILL",32824:"POLYGON_OFFSET_FACTOR",32849:"RGB8",32854:"RGBA4",32855:"RGB5_A1",32856:"RGBA8",32857:"RGB10_A2",32873:"TEXTURE_BINDING_2D",32874:"TEXTURE_BINDING_3D",32877:"UNPACK_SKIP_IMAGES",32878:"UNPACK_IMAGE_HEIGHT",32879:"TEXTURE_3D",32882:"TEXTURE_WRAP_R",32883:"MAX_3D_TEXTURE_SIZE",32926:"SAMPLE_ALPHA_TO_COVERAGE",32928:"SAMPLE_COVERAGE",32936:"SAMPLE_BUFFERS",32937:"SAMPLES",32938:"SAMPLE_COVERAGE_VALUE",32939:"SAMPLE_COVERAGE_INVERT",32968:"BLEND_DST_RGB",32969:"BLEND_SRC_RGB",32970:"BLEND_DST_ALPHA",32971:"BLEND_SRC_ALPHA",33e3:"MAX_ELEMENTS_VERTICES",33001:"MAX_ELEMENTS_INDICES",33071:"CLAMP_TO_EDGE",33082:"TEXTURE_MIN_LOD",33083:"TEXTURE_MAX_LOD",33084:"TEXTURE_BASE_LEVEL",33085:"TEXTURE_MAX_LEVEL",33170:"GENERATE_MIPMAP_HINT",33189:"DEPTH_COMPONENT16",33190:"DEPTH_COMPONENT24",33296:"FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING",33297:"FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE",33298:"FRAMEBUFFER_ATTACHMENT_RED_SIZE",33299:"FRAMEBUFFER_ATTACHMENT_GREEN_SIZE",33300:"FRAMEBUFFER_ATTACHMENT_BLUE_SIZE",33301:"FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE",33302:"FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE",33303:"FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE",33304:"FRAMEBUFFER_DEFAULT",33306:"DEPTH_STENCIL_ATTACHMENT",33319:"RG",33320:"RG_INTEGER",33321:"R8",33323:"RG8",33325:"R16F",33326:"R32F",33327:"RG16F",33328:"RG32F",33329:"R8I",33330:"R8UI",33331:"R16I",33332:"R16UI",33333:"R32I",33334:"R32UI",33335:"RG8I",33336:"RG8UI",33337:"RG16I",33338:"RG16UI",33339:"RG32I",33340:"RG32UI",33503:"TEXTURE_IMMUTABLE_LEVELS",33635:"UNSIGNED_SHORT_5_6_5",33640:"UNSIGNED_INT_2_10_10_10_REV",33648:"MIRRORED_REPEAT",33901:"ALIASED_POINT_SIZE_RANGE",33902:"ALIASED_LINE_WIDTH_RANGE",33984:"TEXTURE0",33985:"TEXTURE1",33986:"TEXTURE2",33987:"TEXTURE3",33988:"TEXTURE4",33989:"TEXTURE5",33990:"TEXTURE6",33991:"TEXTURE7",33992:"TEXTURE8",33993:"TEXTURE9",33994:"TEXTURE10",33995:"TEXTURE11",33996:"TEXTURE12",33997:"TEXTURE13",33998:"TEXTURE14",33999:"TEXTURE15",34e3:"TEXTURE16",34001:"TEXTURE17",34002:"TEXTURE18",34003:"TEXTURE19",34004:"TEXTURE20",34005:"TEXTURE21",34006:"TEXTURE22",34007:"TEXTURE23",34008:"TEXTURE24",34009:"TEXTURE25",34010:"TEXTURE26",34011:"TEXTURE27",34012:"TEXTURE28",34013:"TEXTURE29",34014:"TEXTURE30",34015:"TEXTURE31",34016:"ACTIVE_TEXTURE",34024:"MAX_RENDERBUFFER_SIZE",34041:"DEPTH_STENCIL",34042:"UNSIGNED_INT_24_8",34045:"MAX_TEXTURE_LOD_BIAS",34055:"INCR_WRAP",34056:"DECR_WRAP",34067:"TEXTURE_CUBE_MAP",34068:"TEXTURE_BINDING_CUBE_MAP",34069:"TEXTURE_CUBE_MAP_POSITIVE_X",34070:"TEXTURE_CUBE_MAP_NEGATIVE_X",34071:"TEXTURE_CUBE_MAP_POSITIVE_Y",34072:"TEXTURE_CUBE_MAP_NEGATIVE_Y",34073:"TEXTURE_CUBE_MAP_POSITIVE_Z",34074:"TEXTURE_CUBE_MAP_NEGATIVE_Z",34076:"MAX_CUBE_MAP_TEXTURE_SIZE",34229:"VERTEX_ARRAY_BINDING",34338:"VERTEX_ATTRIB_ARRAY_ENABLED",34339:"VERTEX_ATTRIB_ARRAY_SIZE",34340:"VERTEX_ATTRIB_ARRAY_STRIDE",34341:"VERTEX_ATTRIB_ARRAY_TYPE",34342:"CURRENT_VERTEX_ATTRIB",34373:"VERTEX_ATTRIB_ARRAY_POINTER",34467:"COMPRESSED_TEXTURE_FORMATS",34660:"BUFFER_SIZE",34661:"BUFFER_USAGE",34816:"STENCIL_BACK_FUNC",34817:"STENCIL_BACK_FAIL",34818:"STENCIL_BACK_PASS_DEPTH_FAIL",34819:"STENCIL_BACK_PASS_DEPTH_PASS",34836:"RGBA32F",34837:"RGB32F",34842:"RGBA16F",34843:"RGB16F",34852:"MAX_DRAW_BUFFERS",34853:"DRAW_BUFFER0",34854:"DRAW_BUFFER1",34855:"DRAW_BUFFER2",34856:"DRAW_BUFFER3",34857:"DRAW_BUFFER4",34858:"DRAW_BUFFER5",34859:"DRAW_BUFFER6",34860:"DRAW_BUFFER7",34861:"DRAW_BUFFER8",34862:"DRAW_BUFFER9",34863:"DRAW_BUFFER10",34864:"DRAW_BUFFER11",34865:"DRAW_BUFFER12",34866:"DRAW_BUFFER13",34867:"DRAW_BUFFER14",34868:"DRAW_BUFFER15",34877:"BLEND_EQUATION_ALPHA",34892:"TEXTURE_COMPARE_MODE",34893:"TEXTURE_COMPARE_FUNC",34894:"COMPARE_REF_TO_TEXTURE",34917:"CURRENT_QUERY",34918:"QUERY_RESULT",34919:"QUERY_RESULT_AVAILABLE",34921:"MAX_VERTEX_ATTRIBS",34922:"VERTEX_ATTRIB_ARRAY_NORMALIZED",34930:"MAX_TEXTURE_IMAGE_UNITS",34962:"ARRAY_BUFFER",34963:"ELEMENT_ARRAY_BUFFER",34964:"ARRAY_BUFFER_BINDING",34965:"ELEMENT_ARRAY_BUFFER_BINDING",34975:"VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",35040:"STREAM_DRAW",35041:"STREAM_READ",35042:"STREAM_COPY",35044:"STATIC_DRAW",35045:"STATIC_READ",35046:"STATIC_COPY",35048:"DYNAMIC_DRAW",35049:"DYNAMIC_READ",35050:"DYNAMIC_COPY",35051:"PIXEL_PACK_BUFFER",35052:"PIXEL_UNPACK_BUFFER",35053:"PIXEL_PACK_BUFFER_BINDING",35055:"PIXEL_UNPACK_BUFFER_BINDING",35056:"DEPTH24_STENCIL8",35069:"VERTEX_ATTRIB_ARRAY_INTEGER",35070:"VERTEX_ATTRIB_ARRAY_DIVISOR",35071:"MAX_ARRAY_TEXTURE_LAYERS",35076:"MIN_PROGRAM_TEXEL_OFFSET",35077:"MAX_PROGRAM_TEXEL_OFFSET",35097:"SAMPLER_BINDING",35345:"UNIFORM_BUFFER",35368:"UNIFORM_BUFFER_BINDING",35369:"UNIFORM_BUFFER_START",35370:"UNIFORM_BUFFER_SIZE",35371:"MAX_VERTEX_UNIFORM_BLOCKS",35373:"MAX_FRAGMENT_UNIFORM_BLOCKS",35374:"MAX_COMBINED_UNIFORM_BLOCKS",35375:"MAX_UNIFORM_BUFFER_BINDINGS",35376:"MAX_UNIFORM_BLOCK_SIZE",35377:"MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS",35379:"MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS",35380:"UNIFORM_BUFFER_OFFSET_ALIGNMENT",35382:"ACTIVE_UNIFORM_BLOCKS",35383:"UNIFORM_TYPE",35384:"UNIFORM_SIZE",35386:"UNIFORM_BLOCK_INDEX",35387:"UNIFORM_OFFSET",35388:"UNIFORM_ARRAY_STRIDE",35389:"UNIFORM_MATRIX_STRIDE",35390:"UNIFORM_IS_ROW_MAJOR",35391:"UNIFORM_BLOCK_BINDING",35392:"UNIFORM_BLOCK_DATA_SIZE",35394:"UNIFORM_BLOCK_ACTIVE_UNIFORMS",35395:"UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES",35396:"UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER",35398:"UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER",35632:"FRAGMENT_SHADER",35633:"VERTEX_SHADER",35657:"MAX_FRAGMENT_UNIFORM_COMPONENTS",35658:"MAX_VERTEX_UNIFORM_COMPONENTS",35659:"MAX_VARYING_COMPONENTS",35660:"MAX_VERTEX_TEXTURE_IMAGE_UNITS",35661:"MAX_COMBINED_TEXTURE_IMAGE_UNITS",35663:"SHADER_TYPE",35664:"FLOAT_VEC2",35665:"FLOAT_VEC3",35666:"FLOAT_VEC4",35667:"INT_VEC2",35668:"INT_VEC3",35669:"INT_VEC4",35670:"BOOL",35671:"BOOL_VEC2",35672:"BOOL_VEC3",35673:"BOOL_VEC4",35674:"FLOAT_MAT2",35675:"FLOAT_MAT3",35676:"FLOAT_MAT4",35678:"SAMPLER_2D",35679:"SAMPLER_3D",35680:"SAMPLER_CUBE",35682:"SAMPLER_2D_SHADOW",35685:"FLOAT_MAT2x3",35686:"FLOAT_MAT2x4",35687:"FLOAT_MAT3x2",35688:"FLOAT_MAT3x4",35689:"FLOAT_MAT4x2",35690:"FLOAT_MAT4x3",35712:"DELETE_STATUS",35713:"COMPILE_STATUS",35714:"LINK_STATUS",35715:"VALIDATE_STATUS",35717:"ATTACHED_SHADERS",35718:"ACTIVE_UNIFORMS",35721:"ACTIVE_ATTRIBUTES",35723:"FRAGMENT_SHADER_DERIVATIVE_HINT",35724:"SHADING_LANGUAGE_VERSION",35725:"CURRENT_PROGRAM",35738:"IMPLEMENTATION_COLOR_READ_TYPE",35739:"IMPLEMENTATION_COLOR_READ_FORMAT",35863:"UNSIGNED_NORMALIZED",35866:"TEXTURE_2D_ARRAY",35869:"TEXTURE_BINDING_2D_ARRAY",35887:"ANY_SAMPLES_PASSED",35898:"R11F_G11F_B10F",35899:"UNSIGNED_INT_10F_11F_11F_REV",35901:"RGB9_E5",35902:"UNSIGNED_INT_5_9_9_9_REV",35904:"SRGB",35905:"SRGB8",35907:"SRGB8_ALPHA8",35967:"TRANSFORM_FEEDBACK_BUFFER_MODE",35968:"MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS",35971:"TRANSFORM_FEEDBACK_VARYINGS",35972:"TRANSFORM_FEEDBACK_BUFFER_START",35973:"TRANSFORM_FEEDBACK_BUFFER_SIZE",35976:"TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN",35977:"RASTERIZER_DISCARD",35978:"MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS",35979:"MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS",35980:"INTERLEAVED_ATTRIBS",35981:"SEPARATE_ATTRIBS",35982:"TRANSFORM_FEEDBACK_BUFFER",35983:"TRANSFORM_FEEDBACK_BUFFER_BINDING",36003:"STENCIL_BACK_REF",36004:"STENCIL_BACK_VALUE_MASK",36005:"STENCIL_BACK_WRITEMASK",36006:"FRAMEBUFFER_BINDING",36007:"RENDERBUFFER_BINDING",36008:"READ_FRAMEBUFFER",36009:"DRAW_FRAMEBUFFER",36010:"READ_FRAMEBUFFER_BINDING",36011:"RENDERBUFFER_SAMPLES",36012:"DEPTH_COMPONENT32F",36013:"DEPTH32F_STENCIL8",36048:"FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",36049:"FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",36050:"FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",36051:"FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",36052:"FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER",36053:"FRAMEBUFFER_COMPLETE",36054:"FRAMEBUFFER_INCOMPLETE_ATTACHMENT",36055:"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",36057:"FRAMEBUFFER_INCOMPLETE_DIMENSIONS",36061:"FRAMEBUFFER_UNSUPPORTED",36063:"MAX_COLOR_ATTACHMENTS",36064:"COLOR_ATTACHMENT0",36065:"COLOR_ATTACHMENT1",36066:"COLOR_ATTACHMENT2",36067:"COLOR_ATTACHMENT3",36068:"COLOR_ATTACHMENT4",36069:"COLOR_ATTACHMENT5",36070:"COLOR_ATTACHMENT6",36071:"COLOR_ATTACHMENT7",36072:"COLOR_ATTACHMENT8",36073:"COLOR_ATTACHMENT9",36074:"COLOR_ATTACHMENT10",36075:"COLOR_ATTACHMENT11",36076:"COLOR_ATTACHMENT12",36077:"COLOR_ATTACHMENT13",36078:"COLOR_ATTACHMENT14",36079:"COLOR_ATTACHMENT15",36096:"DEPTH_ATTACHMENT",36128:"STENCIL_ATTACHMENT",36160:"FRAMEBUFFER",36161:"RENDERBUFFER",36162:"RENDERBUFFER_WIDTH",36163:"RENDERBUFFER_HEIGHT",36164:"RENDERBUFFER_INTERNAL_FORMAT",36168:"STENCIL_INDEX8",36176:"RENDERBUFFER_RED_SIZE",36177:"RENDERBUFFER_GREEN_SIZE",36178:"RENDERBUFFER_BLUE_SIZE",36179:"RENDERBUFFER_ALPHA_SIZE",36180:"RENDERBUFFER_DEPTH_SIZE",36181:"RENDERBUFFER_STENCIL_SIZE",36182:"FRAMEBUFFER_INCOMPLETE_MULTISAMPLE",36183:"MAX_SAMPLES",36194:"RGB565",36202:"ANY_SAMPLES_PASSED_CONSERVATIVE",36203:"MAX_ELEMENT_INDEX",36208:"RGBA32UI",36209:"RGB32UI",36214:"RGBA16UI",36215:"RGB16UI",36220:"RGBA8UI",36221:"RGB8UI",36226:"RGBA32I",36227:"RGB32I",36232:"RGBA16I",36233:"RGB16I",36238:"RGBA8I",36239:"RGB8I",36244:"RED_INTEGER",36248:"RGB_INTEGER",36249:"RGBA_INTEGER",36255:"INT_2_10_10_10_REV",36269:"FLOAT_32_UNSIGNED_INT_24_8_REV",36289:"SAMPLER_2D_ARRAY",36292:"SAMPLER_2D_ARRAY_SHADOW",36293:"SAMPLER_CUBE_SHADOW",36294:"UNSIGNED_INT_VEC2",36295:"UNSIGNED_INT_VEC3",36296:"UNSIGNED_INT_VEC4",36298:"INT_SAMPLER_2D",36299:"INT_SAMPLER_3D",36300:"INT_SAMPLER_CUBE",36303:"INT_SAMPLER_2D_ARRAY",36306:"UNSIGNED_INT_SAMPLER_2D",36307:"UNSIGNED_INT_SAMPLER_3D",36308:"UNSIGNED_INT_SAMPLER_CUBE",36311:"UNSIGNED_INT_SAMPLER_2D_ARRAY",36336:"LOW_FLOAT",36337:"MEDIUM_FLOAT",36338:"HIGH_FLOAT",36339:"LOW_INT",36340:"MEDIUM_INT",36341:"HIGH_INT",36347:"MAX_VERTEX_UNIFORM_VECTORS",36348:"MAX_VARYING_VECTORS",36349:"MAX_FRAGMENT_UNIFORM_VECTORS",36386:"TRANSFORM_FEEDBACK",36387:"TRANSFORM_FEEDBACK_PAUSED",36388:"TRANSFORM_FEEDBACK_ACTIVE",36389:"TRANSFORM_FEEDBACK_BINDING",36662:"COPY_READ_BUFFER_BINDING",36663:"COPY_WRITE_BUFFER_BINDING",36756:"R8_SNORM",36757:"RG8_SNORM",36758:"RGB8_SNORM",36759:"RGBA8_SNORM",36764:"SIGNED_NORMALIZED",36975:"RGB10_A2UI",37137:"MAX_SERVER_WAIT_TIMEOUT",37138:"OBJECT_TYPE",37139:"SYNC_CONDITION",37140:"SYNC_STATUS",37141:"SYNC_FLAGS",37142:"SYNC_FENCE",37143:"SYNC_GPU_COMMANDS_COMPLETE",37144:"UNSIGNALED",37145:"SIGNALED",37146:"ALREADY_SIGNALED",37147:"TIMEOUT_EXPIRED",37148:"CONDITION_SATISFIED",37149:"WAIT_FAILED",37154:"MAX_VERTEX_OUTPUT_COMPONENTS",37157:"MAX_FRAGMENT_INPUT_COMPONENTS",37167:"TEXTURE_IMMUTABLE_FORMAT",37440:"UNPACK_FLIP_Y_WEBGL",37441:"UNPACK_PREMULTIPLY_ALPHA_WEBGL",37442:"CONTEXT_LOST_WEBGL",37443:"UNPACK_COLORSPACE_CONVERSION_WEBGL",37444:"BROWSER_DEFAULT_WEBGL",37447:"MAX_CLIENT_WAIT_TIMEOUT_WEBGL",4294967295:"INVALID_INDEX","-1":"TIMEOUT_IGNORED"};let T,R=31;const _=[0,0,0,1];const d=0,A=1,p=2,F=3,g=4,v=5,x=6,N=7,U=8,I=9,M=10,b=11;function S(e,t){return Math.random()*(t-e)+e}function B(e){let t;switch(e){case"MAT2":t=4;break;case"MAT3":t=9;break;case"MAT4":t=16;break;case"VEC4":t=4;break;case"VEC3":t=3;break;case"VEC2":t=2;break;case"SCALAR":t=1}return t}function L(e){return"rotation"===e?4:"translation"===e||"scale"===e?3:void 0}function P(e,t){if(0===t.length)return[-1,-1,0];let r=-1;for(let n=t.length-1;n>=0;n--)if(e>=t[n].time){r=n;break}if(-1===r||r===t.length-1)return r<0&&(r=0),[r,r,0];{const s=t[r],o=t[r+1];return e=Math.max(s.time,Math.min(e,o.time)),[r,r+1,(n=s.time,i=o.time,(e-n)/(i-n))]}var n,i}const O=new Map;function C(e,t,r){const n=function(e){let t;switch(E[e]){case"BYTE":case"UNSIGNED_BYTE":t=1;break;case"SHORT":case"UNSIGNED_SHORT":t=2;break;case"UNSIGNED_INT":case"FLOAT":t=4}return t}(t.componentType),i=B(t.type),s=(r.byteOffset||0)+(t.byteOffset||0),o=r.byteStride,a=o*t.count/n,l=t.count*i,c=a||l;let h;switch(E[t.componentType]){case"BYTE":h=new Int8Array(e,s,c);break;case"UNSIGNED_BYTE":h=new Uint8Array(e,s,c);break;case"SHORT":h=new Int16Array(e,s,c);break;case"UNSIGNED_SHORT":h=new Uint16Array(e,s,c);break;case"UNSIGNED_INT":h=new Uint32Array(e,s,c);break;case"FLOAT":h=new Float32Array(e,s,c)}if(c!==l){const e=new h.constructor(l);let t=0;for(let r=0;r<e.length;r+=i){for(let n=0;n<i;n++)e[r+n]=h[t+n];t+=o/n}return e}return h}function D(e,t,r,n){let i;switch(E[t]){case"BYTE":i=new Int8Array(e,r,n);break;case"UNSIGNED_BYTE":i=new Uint8Array(e,r,n);break;case"SHORT":i=new Int16Array(e,r,n);break;case"UNSIGNED_SHORT":i=new Uint16Array(e,r,n);break;case"UNSIGNED_INT":i=new Uint32Array(e,r,n);break;case"FLOAT":i=new Float32Array(e,r,n)}return i}function w(e,t,r){const n=T.createShader(e);T.shaderSource(n,t),T.compileShader(n),T.attachShader(r,n);const i=T.getShaderInfoLog(n);if(i)throw new Error(i)}function y(e,t){const r=T.createProgram();if(w(T.VERTEX_SHADER,e,r),w(T.FRAGMENT_SHADER,t,r),T.linkProgram(r),T.validateProgram(r),!T.getProgramParameter(r,T.LINK_STATUS)){const e=T.getProgramInfoLog(r);throw new Error("Could not compile WebGL program. "+e)}return r}function V(e=T.TEXTURE_2D,t=function(){return R--,R}()){const r=T.createTexture();return T.activeTexture(T["TEXTURE"+t]),T.bindTexture(e,r),r.index=t,r}function G(e,t){!function e(r){t(r),r.children&&r.children.forEach(e)}(e)}function X(e,t,r,n){const[i,o]=e,l=new s;l.setTranslate(new a([0,0,.05]));const h=new s(t);h.multiply(l);const u=h.multiplyVector4(new c([0,0,0,1]));u.elements[0]=(2*i/r-1)*u.elements[3],u.elements[1]=(-2*o/n+1)*u.elements[3];const m=h.invert().multiplyVector4(u);return[m.elements[0],m.elements[1]]}function H(e){const{aspect:t,zoom:r}=e;let n;if("perspective"===e.type&&e.perspective){const{yfov:r}=e.perspective;n=(new s).setPerspective(r,t,e.perspective.znear||1,e.perspective.zfar||2e6)}else"orthographic"===e.type&&e.orthographic&&(n=(new s).setOrtho(e.orthographic.xmag*r,e.orthographic.ymag*r,e.orthographic.znear,e.orthographic.zfar));return n}function z(e=0,t=0){return e+t}function k(e){let t;switch(!0){case e instanceof Uint8Array:t=e=>e/255;break;case e instanceof Int8Array:t=e=>Math.max(e/127,-1);break;case e instanceof Uint16Array:t=e=>e/65535;break;case e instanceof Int16Array:t=e=>Math.max(e/32767,-1)}if(t){const r=new Float32Array(e.length);for(let n=0;n<e.length;n++)r[n]=t(e[n]);return r}return e}O.set(Int8Array,"BYTE"),O.set(Uint8Array,"UNSIGNED_BYTE"),O.set(Int16Array,"SHORT"),O.set(Uint16Array,"UNSIGNED_SHORT"),O.set(Uint32Array,"UNSIGNED_INT"),O.set(Float32Array,"FLOAT");class W extends f{constructor(e,t){super(e,t),this.program=null,this.defines=null,this.mode=4}setDefines(e){this.defines=e}setBlend(e){this.material.blend=e}setMaterial(e){this.material=e}draw(e,{lights:t,camera:r,light:n,needUpdateView:i,needUpdateProjection:o,preDepthTexture:a,isprepender:l,fakeDepth:c}){if(e.useProgram(this.program),e.bindVertexArray(this.geometry.VAO),e.bindBufferBase(e.UNIFORM_BUFFER,0,this.geometry.UBO),this.reflow){const t=new s(this.matrixWorld);t.invert().transpose(),this.geometry.uniformBuffer.update(e,"model",this.matrixWorld.elements),this.geometry.uniformBuffer.update(e,"normalMatrix",t.elements)}if(i&&(this.geometry.uniformBuffer.update(e,"view",r.matrixWorldInvert.elements),this.geometry.uniformBuffer.update(e,"light",n.matrixWorldInvert.elements)),o&&this.geometry.uniformBuffer.update(e,"projection",r.projection.elements),this.geometry.uniformBuffer.update(e,"isShadow",l?1:0),this instanceof j&&(e.bindBufferBase(e.UNIFORM_BUFFER,2,this.geometry.SKIN),this.bones.some(e=>e.reflow))){const t=this.getJointMatrix(),r=new Float32Array(16*t.length);let n=0;for(const e of t)r.set(e.elements,0+16*n),n++;e.bufferSubData(e.UNIFORM_BUFFER,0,r)}if(this.material.UBO&&(e.bindBufferBase(e.UNIFORM_BUFFER,1,this.material.UBO),i)){const n=new Float32Array(3*t.length);t.forEach((e,t)=>{n.set(e.getPosition(),3*t)}),this.material.uniformBuffer.update(e,"viewPos",r.getPosition()),e.bindBufferBase(e.UNIFORM_BUFFER,4,this.material.lightUBO2),this.material.lightUniformBuffer2.update(e,"lightPos",n)}this.material.lightUBO1&&(e.bindBufferBase(e.UNIFORM_BUFFER,3,this.material.lightUBO1),e.bindBufferBase(e.UNIFORM_BUFFER,4,this.material.lightUBO2),e.bindBufferBase(e.UNIFORM_BUFFER,5,this.material.lightUBO3),e.bindBufferBase(e.UNIFORM_BUFFER,6,this.material.lightUBO4)),this.material.sphericalHarmonics&&e.bindBufferBase(e.UNIFORM_BUFFER,7,this.material.sphericalHarmonics),e.uniform1i(this.material.uniforms.depthTexture,a&&!l?a.index:c.index),this.material.baseColorTexture&&(e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,this.material.baseColorTexture),e.bindSampler(0,this.material.baseColorTexture.sampler)),this.material.metallicRoughnessTexture&&(e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,this.material.metallicRoughnessTexture),e.bindSampler(1,this.material.metallicRoughnessTexture.sampler)),this.material.normalTexture&&(e.activeTexture(e.TEXTURE2),e.bindTexture(e.TEXTURE_2D,this.material.normalTexture),e.bindSampler(2,this.material.normalTexture.sampler)),this.material.occlusionTexture&&(e.activeTexture(e.TEXTURE3),e.bindTexture(e.TEXTURE_2D,this.material.occlusionTexture),e.bindSampler(3,this.material.occlusionTexture.sampler)),this.material.emissiveTexture&&(e.activeTexture(e.TEXTURE4),e.bindTexture(e.TEXTURE_2D,this.material.emissiveTexture),e.bindSampler(4,this.material.emissiveTexture.sampler)),this.material.clearcoatTexture&&(e.activeTexture(e.TEXTURE8),e.bindTexture(e.TEXTURE_2D,this.material.clearcoatTexture),e.bindSampler(8,this.material.clearcoatTexture.sampler)),this.material.clearcoatRoughnessTexture&&(e.activeTexture(e.TEXTURE9),e.bindTexture(e.TEXTURE_2D,this.material.clearcoatRoughnessTexture),e.bindSampler(8,this.material.clearcoatRoughnessTexture.sampler)),this.material.sheenTexture&&(e.activeTexture(e.TEXTURE11),e.bindTexture(e.TEXTURE_2D,this.material.sheenTexture),e.bindSampler(8,this.material.sheenTexture.sampler)),this.material.clearcoatNormalTexture&&(e.activeTexture(e.TEXTURE10),e.bindTexture(e.TEXTURE_2D,this.material.clearcoatNormalTexture),e.bindSampler(8,this.material.clearcoatNormalTexture.sampler)),this.material.doubleSided&&e.disable(e.CULL_FACE),this.geometry.indicesBuffer?e.drawElements(this.mode,this.geometry.indicesBuffer.length,e[O.get(this.geometry.indicesBuffer.constructor)],0):e.drawArrays(this.mode,0,this.geometry.attributes.POSITION.length/3),this.material.doubleSided&&e.enable(e.CULL_FACE)}setGeometry(e){this.geometry=e}setProgram(e){this.program=e}setMode(e=4){this.mode=e}isVisible(e){const t=new a(this.geometry.boundingSphere.center.elements).applyMatrix4(this.matrixWorld),r=this.geometry.boundingSphere.radius*this.matrixWorld.getMaxScaleOnAxis();let n,i=!0;for(const s of e)if(n=s.elements[0]*t.elements[0]+s.elements[1]*t.elements[1]+s.elements[2]*t.elements[2]+s.elements[3],n<-r){i=!1;break}return this.distance=n+r,i}calculateBounding(){this.geometry.calculateBounding(this.matrixWorld)}}class j extends W{constructor(e,t){super(e,t)}setSkin(e,t){this.bones=t.bones,this.boneInverses=t.boneInverses;const r=this.getJointMatrix(),n=new Float32Array(16*r.length);let i=0;for(const e of r)n.set(e.elements,0+16*i),i++;const s=e.getUniformBlockIndex(this.program,"Skin");e.uniformBlockBinding(this.program,s,2);const o=e.createBuffer();return e.bindBuffer(e.UNIFORM_BUFFER,o),e.bufferData(e.UNIFORM_BUFFER,n,e.DYNAMIC_DRAW),this.geometry.SKIN=o,e.bindBuffer(e.UNIFORM_BUFFER,null),this}getJointMatrix(){const e=new s(this.matrixWorld).invert(),t=[];for(let r=0;r<this.boneInverses.length;r++){const n=(new s).multiply(e).multiply(this.bones[r].matrixWorld).multiply(this.boneInverses[r]);t.push(n)}return t}}class Y extends f{}class K extends f{constructor(e,t,r){super(t,r),this.matrixWorldInvert=new s,this.projection=new s,this.props=e,this.yaw=0,this.pitch=-Math.PI,this.z=1}setProjection(e){this.projection.set(e.elements)}setMatrixWorld(e){super.setMatrixWorld(e),this.matrixWorldInvert.setInverseOf(this.matrixWorld),this.matrixInitial||(this.matrixInitial=new s(this.matrixWorld))}setZ(e){this.matrix.elements[14]=e,this.matrixInitial=new s(this.matrix),this.setMatrixWorld(this.matrix.elements)}getViewProjMatrix(){const e=new s;return e.multiply(this.projection),e.multiply(this.matrixWorldInvert),e}pan(e,t,r,n){const i=X(e,this.projection,r,n),s=X(t,this.projection,r,n),o=new a([...i,0]),l=new a([...s,0]);if("orthographic"===this.props.type){const e=2*this.modelSize,t=o.subtract(l).scale(e);this.matrixWorld.translate(t.elements[0],t.elements[1],0)}else{const e=100*this.modelSize,t=l.subtract(o).scale(e);this.matrixWorld.translate(t.elements[0],t.elements[1],0)}this.setMatrixWorld(this.matrixWorld.elements)}rotate(e,t){var r,n,i;this.yaw+=(e[0]-t[0])/100,this.pitch+=(e[1]-t[1])/100,this.pitch=(r=this.pitch,n=-1.5*Math.PI,i=-.5*Math.PI,r<n?n:r>i?i:r);const o=new s;o.rotate(new a([1,0,0]),this.pitch),o.rotate(new a([0,1,0]),-this.yaw),o.rotate(new a([1,0,0]),3.14159),o.multiply(this.matrixInitial),this.setMatrixWorld(o.elements)}zoom(e){const t=e>this.z?-e:e;this.setZ(this.matrixWorld.elements[14]+t*this.modelSize/100),this.setMatrixWorld(this.matrixWorld.elements),this.z=e,this.updateNF()}updateNF(){if(this.props.isInitial){const e=Math.min(...this.matrixWorld.getScaling().elements),t=this.modelSize/e,r=Math.abs(this.matrixWorldInvert.elements[14]),n=this.props.perspective||this.props.orthographic;n.znear=Math.max(r-t,.5*t),n.zfar=r+t}this.setProjection(H(this.props))}}class q extends f{constructor(e,t,r){super(t,r);const{type:n,color:i,intensity:o,isInitial:l,spot:c={}}=e;this.type=n,this.color=new a(i),this.intensity=o,this.isInitial=l,this.spot=c,this.matrixWorldInvert=new s}setMatrixWorld(e){super.setMatrixWorld(e),this.matrixWorldInvert.setInverseOf(this.matrixWorld)}setZ(e){this.matrix.elements[14]=e,this.setMatrixWorld(this.matrix.elements)}update(e){if(this.isInitial||"directional"===this.type){const t=new s;t.makeRotationAxis(new a([0,1,0]),e),t.multiply(this.matrix),this.setMatrixWorld(t.elements)}}}class Z{constructor(){this.map=new Map,this.tempStore={},this.offset=0}getBuffer(e){const{length:t}=e;return 3===t?new Float32Array([e[0],e[1],e[2],0]):9===t?new Float32Array([e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0]):12===t?new Float32Array([e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,e[9],e[10],e[11],0]):6===t?new Float32Array([e[0],e[1],e[2],0,e[3],e[4],e[5],0]):e}add(e,t){void 0===t.length&&(t=[t]),this.map.set(e,this.offset);const r=this.getBuffer(t);this.tempStore[e]=r,this.offset+=Math.max(r.length,4)}update(e,t,r){void 0===r.length&&(r=new Float32Array([r]));const n=this.map.get(t),i=this.getBuffer(r);this.store.set(i,n),e.bufferSubData(e.UNIFORM_BUFFER,n*Float32Array.BYTES_PER_ELEMENT,i)}done(){this.store=new Float32Array(this.offset);for(const[e,t]of this.map)this.store.set(this.tempStore[e],t);this.tempStore=null}}const J={baseColorFactor:[1,0,0,1]},Q={directional:0,point:1,spot:2};class $ extends class{}{constructor(e=J,t,r,n){super();const s=Object.assign({},e);if(this.defines=r,!s.pbrMetallicRoughness&&s.extensions&&s.extensions.KHR_materials_pbrSpecularGlossiness){s.pbrMetallicRoughness={};const e=s.extensions.KHR_materials_pbrSpecularGlossiness;s.pbrMetallicRoughness.baseColorTexture=e.diffuseTexture,s.pbrMetallicRoughness.metallicRoughnessTexture=e.specularGlossinessTexture,s.pbrMetallicRoughness.baseColorFactor=e.diffuseFactor,s.pbrMetallicRoughness.specularFactor=e.specularFactor,s.pbrMetallicRoughness.glossinessFactor=e.glossinessFactor,r.push({name:"SPECULARGLOSSINESSMAP"})}if(s.extensions&&s.extensions.KHR_materials_clearcoat){const e=s.extensions.KHR_materials_clearcoat;this.clearcoatFactor=e.clearcoatFactor,this.clearcoatRoughnessFactor=e.clearcoatRoughnessFactor,e.clearcoatTexture&&(this.clearcoatTexture=t[e.clearcoatTexture.index],r.push({name:"CLEARCOATMAP"})),e.clearcoatNormalTexture&&(this.clearcoatNormalTexture=t[e.clearcoatNormalTexture.index],r.push({name:"CLEARCOATNORMALMAP"})),e.clearcoatRoughnessTexture&&(this.clearcoatRoughnessTexture=t[e.clearcoatRoughnessTexture.index],r.push({name:"CLEARCOATROUGHMAP"}))}if(s.extensions&&s.extensions.KHR_materials_sheen){const{intensityFactor:e,colorFactor:n,sheenRoughnessFactor:i,colorIntensityTexture:o}=s.extensions.KHR_materials_sheen;this.sheenFactor=e,this.sheenColorFactor=n,this.sheenRoughnessFactor=i,o&&(this.sheenTexture=t[o.index],r.push({name:"SHEENMAP"}))}this.uniforms={baseColorTexture:null,metallicRoughnessTexture:null,normalTexture:null,occlusionTexture:null,clearcoatTexture:null,clearcoatRoughnessTexture:null,sheenTexture:null,clearcoatNormalTexture:null,emissiveTexture:null,prefilterMap:null,brdfLUT:null,irradianceMap:null,depthTexture:null};const o=s.pbrMetallicRoughness;if(o&&(this.baseColorFactor=o.baseColorFactor,this.roughnessFactor=o.roughnessFactor,this.metallicFactor=o.metallicFactor,this.specularFactor=o.specularFactor,this.glossinessFactor=o.glossinessFactor),this.alpha="BLEND"===s.alphaMode,this.blend=s.blend,this.doubleSided=s.doubleSided,this.emissiveFactor=s.emissiveFactor,this.extras=s.extras,o&&o.metallicRoughnessTexture&&(this.metallicRoughnessTexture=t[o.metallicRoughnessTexture.index],r.push({name:"METALROUGHNESSMAP"})),s.normalTexture&&(this.normalTexture=t[s.normalTexture.index],r.push({name:"NORMALMAP"})),s.occlusionTexture&&(this.occlusionTexture=t[s.occlusionTexture.index],r.push({name:"OCCLUSIONMAP"})),o&&o.baseColorTexture){const{extensions:e}=o.baseColorTexture;if(this.baseColorTexture=t[o.baseColorTexture.index],r.push({name:"BASECOLORTEXTURE"}),e){const t=e.KHR_texture_transform;if(t){const e=t.offset&&(new i).set([1,0,0,0,1,0,t.offset[0],t.offset[1],1]),n=t.rotation&&(new i).set([-Math.sin(t.rotation),Math.cos(t.rotation),0,Math.cos(t.rotation),Math.sin(t.rotation),0,0,0,1]),s=t.scale&&(new i).set([t.scale[0],0,0,0,t.scale[1],0,0,0,1]),o=new i;s&&o.multiply(s),n&&o.multiply(n),e&&o.multiply(e),this.matrix=o,r.push({name:"TEXTURE_TRANSFORM"})}}}if(s.emissiveTexture){const{texCoord:e}=s.emissiveTexture;this.emissiveTexture=t[s.emissiveTexture.index],r.push({name:"EMISSIVEMAP",value:e?2:1})}"MASK"===s.alphaMode?r.push({name:"ALPHATEST",value:s.alphaCutoff||.5}):"BLEND"===s.alphaMode&&r.push({name:"ALPHATEST",value:.01}),this.doubleSided&&r.push({name:"DOUBLESIDED"}),r.push({name:"LIGHTNUMBER",value:n.length}),s.extensions&&s.extensions.KHR_materials_unlit&&r.push({name:"NOLIGHT"})}setHarmonics(e){this.sphericalHarmonics=e}createUniforms(e,t){e.useProgram(t),this.baseColorTexture&&(this.uniforms.baseColorTexture=e.getUniformLocation(t,"baseColorTexture"),e.uniform1i(this.uniforms.baseColorTexture,d)),this.metallicRoughnessTexture&&(this.uniforms.metallicRoughnessTexture=e.getUniformLocation(t,"metallicRoughnessTexture"),e.uniform1i(this.uniforms.metallicRoughnessTexture,A)),this.normalTexture&&(this.uniforms.normalTexture=e.getUniformLocation(t,"normalTexture"),e.uniform1i(this.uniforms.normalTexture,p)),this.occlusionTexture&&(this.uniforms.occlusionTexture=e.getUniformLocation(t,"occlusionTexture"),e.uniform1i(this.uniforms.occlusionTexture,F)),this.emissiveTexture&&(this.uniforms.emissiveTexture=e.getUniformLocation(t,"emissiveTexture"),e.uniform1i(this.uniforms.emissiveTexture,g)),this.clearcoatTexture&&(this.uniforms.clearcoatTexture=e.getUniformLocation(t,"clearcoatTexture"),e.uniform1i(this.uniforms.clearcoatTexture,U)),this.clearcoatRoughnessTexture&&(this.uniforms.clearcoatRoughnessTexture=e.getUniformLocation(t,"clearcoatRoughnessTexture"),e.uniform1i(this.uniforms.clearcoatRoughnessTexture,I)),this.clearcoatNormalTexture&&(this.uniforms.clearcoatNormalTexture=e.getUniformLocation(t,"clearcoatNormalTexture"),e.uniform1i(this.uniforms.clearcoatNormalTexture,M)),this.sheenTexture&&(this.uniforms.sheenTexture=e.getUniformLocation(t,"sheenTexture"),e.uniform1i(this.uniforms.sheenTexture,b)),this.uniforms.prefilterMap=e.getUniformLocation(t,"prefilterMap"),this.uniforms.brdfLUT=e.getUniformLocation(t,"brdfLUT"),this.uniforms.irradianceMap=e.getUniformLocation(t,"irradianceMap"),this.uniforms.depthTexture=e.getUniformLocation(t,"depthTexture"),e.uniform1i(this.uniforms.prefilterMap,x),e.uniform1i(this.uniforms.brdfLUT,N),e.uniform1i(this.uniforms.irradianceMap,v)}updateUniforms(e,t,r,n){const s=new Float32Array(3*n.length),o=new Float32Array(3*n.length),l=new Float32Array(3*n.length),c=new Float32Array(4*n.length);n.forEach((e,t)=>{s.set(new a([e.matrixWorld.elements[8],e.matrixWorld.elements[9],e.matrixWorld.elements[10]]).normalize().elements,3*t),o.set(e.getPosition(),3*t),l.set(e.color.elements,3*t),c.set([e.intensity,e.spot.innerConeAngle||0,e.spot.outerConeAngle||0,Q[e.type]],4*t)});{const n=new Z;n.add("baseColorFactor",this.baseColorFactor||[.8,.8,.8,1]),n.add("viewPos",r.getPosition()),n.add("textureMatrix",this.matrix&&this.matrix.elements||(new i).elements),n.add("specularFactor",this.specularFactor||[0,0,0]),n.add("emissiveFactor",this.emissiveFactor||[0,0,0]),n.add("glossinessFactor",this.glossinessFactor||.5),n.add("metallicFactor",this.metallicFactor||1),n.add("roughnessFactor",this.roughnessFactor||1),n.add("clearcoatFactor",this.clearcoatFactor||0),n.add("clearcoatRoughnessFactor",this.clearcoatRoughnessFactor||0),n.add("sheenColorFactor",this.sheenColorFactor||0),n.add("sheenFactor",this.sheenFactor||0),n.add("sheenRoughnessFactor",this.sheenRoughnessFactor||0),n.done();const s=e.getUniformBlockIndex(t,"Material");e.uniformBlockBinding(t,s,1);const o=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,o),e.bufferData(e.UNIFORM_BUFFER,n.store,e.STATIC_DRAW),this.UBO=o,this.uniformBuffer=n}{const r=new Z;r.add("lightColor",l),r.done();const n=e.getUniformBlockIndex(t,"LightColor");e.uniformBlockBinding(t,n,3);const i=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,i),e.bufferData(e.UNIFORM_BUFFER,r.store,e.STATIC_DRAW),this.lightUBO1=i,this.lightUniformBuffer1=r}{const r=new Z;r.add("lightPos",o),r.done();const n=e.getUniformBlockIndex(t,"LightPos");e.uniformBlockBinding(t,n,4);const i=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,i),e.bufferData(e.UNIFORM_BUFFER,r.store,e.STATIC_DRAW),this.lightUBO2=i,this.lightUniformBuffer2=r}{const r=new Z;r.add("spotdir",s),r.done();const n=e.getUniformBlockIndex(t,"Spotdir");e.uniformBlockBinding(t,n,5);const i=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,i),e.bufferData(e.UNIFORM_BUFFER,r.store,e.STATIC_DRAW),this.lightUBO3=i,this.lightUniformBuffer3=r}{const r=new Z;r.add("lightIntensity",c),r.done();const n=e.getUniformBlockIndex(t,"LightIntensity");e.uniformBlockBinding(t,n,6);const i=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,i),e.bufferData(e.UNIFORM_BUFFER,r.store,e.STATIC_DRAW),this.lightUBO4=i,this.lightUniformBuffer4=r}}hasNormal(){return Boolean(this.normalTexture)||Boolean(this.clearcoatNormalTexture)}}class ee{constructor(){this.counterEl=document.createElement("div"),this.counterEl.setAttribute("style","position: absolute; top: 0; right: 0; color: #fff; font-size: 30px; background: #000;"),document.body.appendChild(this.counterEl),this.fps=0,this.elapsedTime=0,this.lastTime=0}tick(e){this.fps++,this.elapsedTime+=e-this.lastTime,this.lastTime=e,this.elapsedTime>=1e3&&(this.counterEl.innerHTML=String(this.fps),this.fps=0,this.elapsedTime-=1e3)}}class te{setCanvas(e){this.canvas=e}setCamera(e){this.camera=e}setLight(e){this.light=e}get width(){return this.canvas.offsetWidth*devicePixelRatio}get height(){return this.canvas.offsetHeight*devicePixelRatio}}var re=r(4),ne=r.n(re),ie=r(5),se=r.n(ie);const oe=[-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1],ae=[-1,1,-1,-1,1,1,1,-1];let le,ce;class he extends te{constructor(){super(),this.scale=2}setGL(e){le=e}preProcessing(e){le.clear(le.COLOR_BUFFER_BIT|le.DEPTH_BUFFER_BIT),e.renderScene(!0,!0),le.bindFramebuffer(le.FRAMEBUFFER,this.framebuffer),le.framebufferTexture2D(le.FRAMEBUFFER,le.COLOR_ATTACHMENT0,le.TEXTURE_2D,this.texture,0),le.useProgram(this.program),le.viewport(0,0,this.width/this.scale,this.height/this.scale),le.bindVertexArray(this.quadVAO);const t=H(Object.assign({},this.camera.props,{zoom:1}));le.uniformMatrix4fv(le.getUniformLocation(this.program,"Iproj"),!1,(new s).setInverseOf(t).elements),le.uniformMatrix4fv(le.getUniformLocation(this.program,"proj"),!1,t.elements),le.uniformMatrix4fv(le.getUniformLocation(this.program,"Iview"),!1,this.camera.matrixWorld.elements),le.uniformMatrix4fv(le.getUniformLocation(this.program,"view"),!1,this.camera.matrixWorldInvert.elements),le.uniformMatrix4fv(le.getUniformLocation(this.program,"light"),!1,this.light.matrixWorldInvert.elements),le.uniform1i(le.getUniformLocation(this.program,"lightTexture"),e.preDepthTexture.index),le.uniform1i(le.getUniformLocation(this.program,"cameraTexture"),e.depthTexture.index),le.uniform3fv(le.getUniformLocation(this.program,"viewPos"),this.camera.getPosition()),le.uniform3fv(le.getUniformLocation(this.program,"lightPos"),this.light.getPosition()),le.drawArrays(le.TRIANGLE_STRIP,0,4),le.bindFramebuffer(le.FRAMEBUFFER,null),le.viewport(0,0,this.width,this.height)}buildScreenBuffer(e){this.framebuffer=le.createFramebuffer(),le.bindFramebuffer(le.FRAMEBUFFER,this.framebuffer),this.texture=e.createOneChannelTexture(this.scale),le.framebufferTexture2D(le.FRAMEBUFFER,le.COLOR_ATTACHMENT0,le.TEXTURE_2D,this.texture,0),this.program=y(se.a,ne.a),this.quadVAO=le.createVertexArray(),le.bindVertexArray(this.quadVAO);const t=le.createBuffer();return le.bindBuffer(le.ARRAY_BUFFER,t),le.bufferData(le.ARRAY_BUFFER,new Float32Array(ae),le.STATIC_DRAW),le.enableVertexAttribArray(0),le.vertexAttribPointer(0,2,le.FLOAT,!1,0,0),le.bindVertexArray(null),le.bindFramebuffer(le.FRAMEBUFFER,null),{name:"LIGHT"}}attachUniform(e){le.uniform1i(le.getUniformLocation(e,"light"),this.texture.index)}postProcessing(){}}class ue{constructor(e){this.reflow=!0,this.fps=new ee,this.getState=e,this.currentTrack=0}setEnv(e){this.env=e}setCamera(e){this.camera=e}setParticles(e){this.Particles=e}setScene(e){this.scene=e}setPp(e){this.PP=e}setGl(e){ce=e}setParser(e){this.parse=e}step(e,t){const r=P(e,t.keys);if(-1===r[0]||-1===r[1]||t.stoped)return!1;const n=t.keys[r[0]],i=L(t.type);let s;s=3===i?a:4===i?c:o;const l=new s(n.value);if("rotation"===t.type)for(const e of t.meshes)e.matrix.makeRotationFromQuaternion(l.elements);else if("scale"===t.type)for(const e of t.meshes){if(e.matrix.animated){const t=e.matrix.getScaling();e.matrix.restoreScale(t)}e.matrix.scale(l),e.matrix.animated=!0}else if("translation"===t.type)for(const e of t.meshes)e.matrix.setTranslate(l)}spline(e,t){const r=P(e,t.keys);if(-1===r[0]||-1===r[1]||t.stoped)return!1;const n=e,i=t.keys[r[1]].time,s=t.keys[r[0]].time,o=L(t.type),l=i-s,h=(n-s)/l,u=h*h,m=u*h,f=-2*m+3*u,E=m-u,T=1-f,R=E-u+h,_=new Float32Array(o);for(let e=0;e!==o;e++){const n=t.keys[r[0]].value[o+e],i=t.keys[r[0]].value[2*o+e]*l,s=t.keys[r[1]].value[o+e],a=t.keys[r[1]].value[e]*l;if(_[e]=T*n+R*i+f*s+E*a,isNaN(_[e]))return!1}if("rotation"===t.type){const e=new c(_).normalize();for(const r of t.meshes)r.matrix.makeRotationFromQuaternion(e.elements)}else if("scale"===t.type){const e=new a(_);for(const r of t.meshes){if(r.matrix.animated){const e=r.matrix.getScaling();r.matrix.restoreScale(e)}r.matrix.scale(e),r.matrix.animated=!0}}else if("translation"===t.type){const e=new a(_);for(const r of t.meshes)r.matrix.setTranslate(e)}}interpolation(e,t){const r=P(e,t.keys);if(-1===r[0]||-1===r[1]||t.stoped)return!1;const n=t.keys[r[0]],i=t.keys[r[1]],s=r[2],l=L(t.type);let h;h=3===l?a:4===l?c:o;const u=new h(n.value),m=new h(i.value);if("rotation"===t.type){const e=new c;e.lerp(u.elements,m.elements,s);for(const r of t.meshes)r.matrix.makeRotationFromQuaternion(e.elements)}else if("scale"===t.type){const e=new a;e.lerp(u.elements,m.elements,s);for(const r of t.meshes){if(r.matrix.animated){const e=r.matrix.getScaling();r.matrix.restoreScale(e)}r.matrix.scale(e),r.matrix.animated=!0}}else if("weights"===t.type){const e=new o(u.elements);e.lerp(u.elements,m.elements,s);for(const r of t.meshes){const t={};for(const n in r.geometry.targets[0])if("POSITION"===n){t[n]=r.geometry.attributes[n].slice();for(let i=0;i<e.elements.length;i++){if(0===e.elements[i])continue;const s=0;for(let o=0;o<t[n].length;o++)t[n][o]+=e.elements[i]*r.geometry.targets[i][n][o-s]}}r.geometry.update(ce,t)}}else if("translation"===t.type){const e=new a;e.lerp(u.elements,m.elements,s);for(const r of t.meshes)r.matrix.setTranslate(e)}else console.error("ERROR")}animate(e){if(!this.parse.tracks.length)return;e-=Math.floor(e/this.parse.duration)*this.parse.duration;for(const t of this.parse.tracks[this.currentTrack]){let r;switch(t.interpolation){case"LINEAR":r=this.interpolation(e,t);break;case"CUBICSPLINE":r=this.spline(e,t);break;case"STEP":r=this.step(e,t);break;default:r=this.interpolation(e,t)}if(!1!==r){for(const e of t.meshes)G(e,e=>{e.updateMatrix(),e instanceof Y&&(e.reflow=!0),e instanceof W&&(e.reflow=!0),e instanceof K&&e===this.camera&&(this.needUpdateView=!0)});this.reflow=!0}}}render(e=0){const t=e/1e3;this.animate(t),this.reflow&&(this.PP.postprocessors.length>0&&(this.PP.bindPrePass(),this.PP.preProcessing(),this.PP.bindPostPass()),ce.clear(ce.COLOR_BUFFER_BIT|ce.DEPTH_BUFFER_BIT),this.renderScene(),this.clean(),this.PP.postprocessors.some(e=>e instanceof he)&&(ce.bindFramebuffer(ce.DRAW_FRAMEBUFFER,null),this.Particles.draw(e),this.reflow=!0),this.PP.postprocessors.length>0&&this.PP.postProcessing()),this.fps.tick(e),requestAnimationFrame(this.render.bind(this))}renderScene(){if(this.needUpdateView){const e=u(this.camera.getViewProjMatrix());this.scene.meshes.forEach(t=>{t.visible=t.isVisible(e)})}this.scene.opaqueChildren.forEach(e=>{e.visible&&e.draw(ce,this.getState())}),this.scene.transparentChildren.length&&(ce.enable(ce.BLEND),ce.blendFunc(ce.SRC_ALPHA,ce.ONE_MINUS_SRC_ALPHA),this.scene.transparentChildren.forEach(e=>{e.visible&&e.draw(ce,this.getState())}),ce.disable(ce.BLEND),ce.blendFunc(ce.ONE,ce.ZERO))}clean(){G(this.scene,e=>{e.reflow=!1}),this.needUpdateView=!1,this.needUpdateProjection=!1,this.reflow=!1}}class me{constructor(e,t){this.redraw=t,this.zoomValue=0,document.addEventListener("wheel",this,{passive:!1}),e.addEventListener("mousedown",this),e.addEventListener("mousemove",this),e.addEventListener("mouseup",this),document.addEventListener("keyup",this),document.addEventListener("keydown",this),addEventListener("resize",this)}handleEvent(e){switch(e.type){case"wheel":this.zoom(e);break;case"mousedown":this.onStart(e);break;case"mousemove":this.onMove(e);break;case"mouseup":this.onEnd();break;case"keyup":this.onKeyUp();break;case"keydown":this.onKeyDown(e);break;case"resize":this.onResize()}}onResize(){this.redraw("resize")}onKeyDown(e){(e.shiftKey||e.ctrlKey)&&(this.isPan=!0)}onKeyUp(){this.isPan=!1}onStart(e){this.x=e.clientX,this.y=e.clientY,this.isDrag=!0}onMove(e){this.isDrag&&(this.isPan?this.redraw("pan",[this.x,this.y],[e.clientX,e.clientY]):this.redraw("rotate",[this.x,this.y],[e.clientX,e.clientY]),this.x=e.clientX,this.y=e.clientY)}onEnd(){this.isDrag=!1}zoom(e){e.preventDefault(),this.zoomValue=Math.min(this.zoomValue+e.deltaY,1250),this.redraw("zoom",Math.pow(1.001,this.zoomValue))}}var fe=r(6),Ee=r.n(fe),Te=r(3),Re=r.n(Te),_e=r(7),de=r.n(_e),Ae=r(8),pe=r.n(Ae),Fe=r(9),ge=r.n(Fe),ve=r(10),xe=r.n(ve),Ne=r(0),Ue=r.n(Ne);const Ie=[Math.sqrt(1/(4*Math.PI)),-Math.sqrt(3/(4*Math.PI)),Math.sqrt(3/(4*Math.PI)),-Math.sqrt(3/(4*Math.PI)),Math.sqrt(15/(4*Math.PI)),-Math.sqrt(15/(4*Math.PI)),Math.sqrt(5/(16*Math.PI)),-Math.sqrt(15/(4*Math.PI)),Math.sqrt(15/(16*Math.PI))];class Me{constructor(){this.preScaled=!1,this.l00=new a,this.l1_1=new a,this.l10=new a,this.l11=new a,this.l2_2=new a,this.l2_1=new a,this.l20=new a,this.l21=new a,this.l22=new a}scaleInPlace(e){this.l00.scale(e),this.l1_1.scale(e),this.l10.scale(e),this.l11.scale(e),this.l2_2.scale(e),this.l2_1.scale(e),this.l20.scale(e),this.l21.scale(e),this.l22.scale(e)}convertIrradianceToLambertianRadiance(){this.scaleInPlace(1/Math.PI)}preScaleForRendering(){this.preScaled=!0,this.l00.scale(Ie[0]),this.l1_1.scale(Ie[1]),this.l10.scale(Ie[2]),this.l11.scale(Ie[3]),this.l2_2.scale(Ie[4]),this.l2_1.scale(Ie[5]),this.l20.scale(Ie[6]),this.l21.scale(Ie[7]),this.l22.scale(Ie[8])}static FromArray(e){const t=new Me;return a.FromArrayToRef(e[0],0,t.l00),a.FromArrayToRef(e[1],0,t.l1_1),a.FromArrayToRef(e[2],0,t.l10),a.FromArrayToRef(e[3],0,t.l11),a.FromArrayToRef(e[4],0,t.l2_2),a.FromArrayToRef(e[5],0,t.l2_1),a.FromArrayToRef(e[6],0,t.l20),a.FromArrayToRef(e[7],0,t.l21),a.FromArrayToRef(e[8],0,t.l22),t}}class be{constructor(){this.x=new a,this.y=new a,this.z=new a,this.xx=new a,this.yy=new a,this.zz=new a,this.xy=new a,this.yz=new a,this.zx=new a}get preScaledHarmonics(){return this._harmonics.preScaled||this._harmonics.preScaleForRendering(),this._harmonics}scale(e){this.x.scale(e),this.y.scale(e),this.z.scale(e),this.xx.scale(e),this.yy.scale(e),this.zz.scale(e),this.yz.scale(e),this.zx.scale(e),this.xy.scale(e)}static FromHarmonics(e){var t=new be;return t._harmonics=e,t.x=e.l11.scale2(1.02333).scale2(-1),t.y=e.l1_1.scale2(1.02333).scale2(-1),t.z=e.l10.scale2(1.02333),t.xx=e.l00.scale2(.886277).subtract2(e.l20.scale2(.247708)).add2(e.l22.scale2(.429043)),t.yy=e.l00.scale2(.886277).subtract2(e.l20.scale2(.247708)).subtract2(e.l22.scale2(.429043)),t.zz=e.l00.scale2(.886277).add2(e.l20.scale2(.495417)),t.yz=e.l2_1.scale2(.858086).scale2(-1),t.zx=e.l21.scale2(.858086).scale2(-1),t.xy=e.l2_2.scale2(.858086),t.scale(1/Math.PI),t}}let Se;class Be{constructor(e){this.url=e,this.envMatrix=new s}setCamera(e){this.camera=e}setGl(e){Se=e}setCanvas(e){this.canvas=e}get width(){return this.canvas.offsetWidth*devicePixelRatio}get height(){return this.canvas.offsetHeight*devicePixelRatio}drawQuad(){const e=new s,t=Object.assign({},this.camera.props,{perspective:{yfov:.3,znear:.01,zfar:1e4}});e.multiply(H(t)),Se.enable(Se.CULL_FACE);const r=Se.createProgram();w(Se.VERTEX_SHADER,"#version 300 es\n        precision highp float;\n        \n        layout (location = 0) in vec2 inPosition;\n        \n        out vec2 outUV;\n\n        uniform mat4 projection;\n        uniform mat4 view;\n        \n        void main() {\n            outUV = inPosition;\n            gl_Position = projection * view * vec4(inPosition, 0.0, 1.0);\n        }\n        ",r),w(Se.FRAGMENT_SHADER,"#version 300 es\n        precision highp float;\n        \n        in vec2 outUV;\n        layout (location = 0) out vec4 color;\n\n        uniform sampler2D environmentMap;\n        \n        void main() {\n            vec3 c = texture(environmentMap, outUV).rgb;\n            \n            color = vec4(c, 1.0);\n        }\n        ",r),Se.linkProgram(r),Se.useProgram(r),Se.bindVertexArray(this.quadVAO),Se.uniformMatrix4fv(Se.getUniformLocation(r,"projection"),!1,e.elements),Se.uniform1i(Se.getUniformLocation(r,"environmentMap"),this.brdfLUTTexture.index),Se.uniformMatrix4fv(Se.getUniformLocation(r,"view"),!1,this.camera.matrixWorldInvert.elements),Se.drawArrays(Se.TRIANGLE_STRIP,0,4)}draw(){const e=new s,t=Object.assign({},this.camera.props,{perspective:{yfov:.3,znear:.01,zfar:1e4}});e.multiply(H(t)),Se.enable(Se.CULL_FACE);const r=Se.createProgram();w(Se.VERTEX_SHADER,"#version 300 es\n        precision highp float;\n        \n        layout (location = 0) in vec3 inPosition;\n        \n        out vec3 outUV;\n\n        uniform mat4 projection;\n        uniform mat4 view;\n        \n        void main() {\n            outUV = inPosition;\n            gl_Position = projection * view * vec4(inPosition, 1.0);\n        }\n        ",r),w(Se.FRAGMENT_SHADER,"#version 300 es\n        precision highp float;\n        \n        in vec3 outUV;\n        layout (location = 0) out vec4 color;\n\n        uniform samplerCube environmentMap;\n        \n        void main() {\n            vec3 c = textureLod(environmentMap, outUV, 0.0).rgb;\n            \n            color = vec4(c, 1.0);\n        }\n        ",r),Se.linkProgram(r),Se.useProgram(r),Se.bindVertexArray(this.VAO),Se.uniformMatrix4fv(Se.getUniformLocation(r,"projection"),!1,e.elements),Se.uniform1i(Se.getUniformLocation(r,"environmentMap"),this.originalCubeTexture.index),Se.uniformMatrix4fv(Se.getUniformLocation(r,"view"),!1,this.camera.matrixWorldInvert.elements),Se.drawArrays(Se.TRIANGLES,0,36)}createEnvironment(){Se.enable(Se.CULL_FACE);const e=new s,t=Object.assign({},this.camera.props,{aspect:1,perspective:{yfov:Math.PI/2,znear:.01,zfar:1e4}});if(e.multiply(H(t)),!this.envData){Se.bindFramebuffer(Se.FRAMEBUFFER,this.framebuffer),Se.useProgram(this.cubeprogram),Se.bindVertexArray(this.VAO),Se.viewport(0,0,this.framebuffer.size,this.framebuffer.size),Se.uniformMatrix4fv(Se.getUniformLocation(this.cubeprogram,"projection"),!1,e.elements),Se.uniform1i(Se.getUniformLocation(this.cubeprogram,"diffuse"),this.original2DTexture.index);const t=5;for(let e=0;e<t;++e){const t=this.framebuffer.size*Math.pow(.5,e),r=this.framebuffer.size*Math.pow(.5,e);Se.viewport(0,0,t,r);for(let t=0;t<6;t++)Se.framebufferTexture2D(Se.FRAMEBUFFER,Se.COLOR_ATTACHMENT0,Se.TEXTURE_CUBE_MAP_POSITIVE_X+t,this.originalCubeTexture,e),Se.uniformMatrix4fv(Se.getUniformLocation(this.cubeprogram,"view"),!1,this.views[t].elements),Se.clear(Se.COLOR_BUFFER_BIT|Se.DEPTH_BUFFER_BIT),Se.drawArrays(Se.TRIANGLES,0,36)}Se.bindVertexArray(null),Se.bindFramebuffer(Se.FRAMEBUFFER,null)}if(!this.envData){Se.bindFramebuffer(Se.FRAMEBUFFER,this.irradiancebuffer),Se.useProgram(this.irradianceprogram),Se.bindVertexArray(this.VAO),Se.viewport(0,0,this.irradiancebuffer.size,this.irradiancebuffer.size),Se.uniformMatrix4fv(Se.getUniformLocation(this.irradianceprogram,"projection"),!1,e.elements),Se.uniform1i(Se.getUniformLocation(this.irradianceprogram,"environmentMap"),this.originalCubeTexture.index);for(let e=0;e<6;e++)Se.framebufferTexture2D(Se.FRAMEBUFFER,Se.COLOR_ATTACHMENT0,Se.TEXTURE_CUBE_MAP_POSITIVE_X+e,this.irradiancemap,0),Se.uniformMatrix4fv(Se.getUniformLocation(this.irradianceprogram,"view"),!1,this.views[e].elements),Se.clear(Se.COLOR_BUFFER_BIT|Se.DEPTH_BUFFER_BIT),Se.drawArrays(Se.TRIANGLES,0,36);Se.bindVertexArray(null),Se.bindFramebuffer(Se.FRAMEBUFFER,null)}if(!this.envData){Se.bindFramebuffer(Se.FRAMEBUFFER,this.prefilterbuffer),Se.useProgram(this.mipmapcubeprogram),Se.bindVertexArray(this.VAO),Se.uniformMatrix4fv(Se.getUniformLocation(this.mipmapcubeprogram,"projection"),!1,e.elements),Se.uniform1i(Se.getUniformLocation(this.mipmapcubeprogram,"environmentMap"),this.originalCubeTexture.index);const t=5;for(let e=0;e<t;++e){const r=this.prefilterbuffer.size*Math.pow(.5,e),n=this.prefilterbuffer.size*Math.pow(.5,e);Se.viewport(0,0,r,n);const i=e/(t-1);Se.uniform1f(Se.getUniformLocation(this.mipmapcubeprogram,"roughness"),i);for(let t=0;t<6;t++)Se.framebufferTexture2D(Se.FRAMEBUFFER,Se.COLOR_ATTACHMENT0,Se.TEXTURE_CUBE_MAP_POSITIVE_X+t,this.prefilterMap,e),Se.uniformMatrix4fv(Se.getUniformLocation(this.mipmapcubeprogram,"view"),!1,this.views[t].elements),Se.clear(Se.COLOR_BUFFER_BIT|Se.DEPTH_BUFFER_BIT),Se.drawArrays(Se.TRIANGLES,0,36)}Se.bindVertexArray(null),Se.bindFramebuffer(Se.FRAMEBUFFER,null)}Se.bindFramebuffer(Se.FRAMEBUFFER,this.brdfbuffer),Se.useProgram(this.bdrfprogram),Se.bindVertexArray(this.quadVAO),Se.viewport(0,0,this.brdfbuffer.size,this.brdfbuffer.size),Se.framebufferTexture2D(Se.FRAMEBUFFER,Se.COLOR_ATTACHMENT0,Se.TEXTURE_2D,this.brdfLUTTexture,0),Se.clear(Se.COLOR_BUFFER_BIT|Se.DEPTH_BUFFER_BIT),Se.drawArrays(Se.TRIANGLE_STRIP,0,4),Se.bindVertexArray(null),Se.bindFramebuffer(Se.FRAMEBUFFER,null),Se.disable(Se.CULL_FACE),Se.viewport(0,0,this.width,this.height)}updateUniform(e,t){if(this.uniformBuffer){const r=e.getUniformBlockIndex(t,"SphericalHarmonics");e.uniformBlockBinding(t,r,7);const n=e.createBuffer();return e.bindBuffer(e.UNIFORM_BUFFER,n),e.bufferData(e.UNIFORM_BUFFER,this.uniformBuffer.store,e.STATIC_DRAW),n}}createEnvironmentBuffer(e){if(this.envData=e,e){const t=new s;t.makeRotationFromQuaternion(new c(e.rotation).elements);const r=Me.FromArray(e.irradianceCoefficients);r.scaleInPlace(e.intensity),r.convertIrradianceToLambertianRadiance();const n=be.FromHarmonics(r).preScaledHarmonics,i=new Z;i.add("rotationMatrix",t.elements),i.add("vSphericalL00",n.l00.elements),i.add("vSphericalL1_1",n.l1_1.elements),i.add("vSphericalL10",n.l10.elements),i.add("vSphericalL11",n.l11.elements),i.add("vSphericalL2_2",n.l2_2.elements),i.add("vSphericalL2_1",n.l2_1.elements),i.add("vSphericalL20",n.l20.elements),i.add("vSphericalL21",n.l21.elements),i.add("vSphericalL22",n.l22.elements),i.done(),this.uniformBuffer=i}{const e=Se.createSampler();Se.samplerParameteri(e,Se.TEXTURE_MIN_FILTER,Se.LINEAR),Se.samplerParameteri(e,Se.TEXTURE_MAG_FILTER,Se.LINEAR),Se.samplerParameteri(e,Se.TEXTURE_WRAP_S,Se.CLAMP_TO_EDGE),Se.samplerParameteri(e,Se.TEXTURE_WRAP_T,Se.CLAMP_TO_EDGE),this.sampler=e}{const e=Se.createSampler();Se.samplerParameteri(e,Se.TEXTURE_MIN_FILTER,Se.LINEAR_MIPMAP_LINEAR),Se.samplerParameteri(e,Se.TEXTURE_MAG_FILTER,Se.LINEAR),Se.samplerParameteri(e,Se.TEXTURE_WRAP_S,Se.CLAMP_TO_EDGE),Se.samplerParameteri(e,Se.TEXTURE_WRAP_T,Se.CLAMP_TO_EDGE),Se.samplerParameteri(e,Se.TEXTURE_WRAP_R,Se.CLAMP_TO_EDGE),this.samplerCube=e}{const e=32,t=Se.createFramebuffer();this.irradiancebuffer=t,this.irradiancebuffer.size=e,Se.bindFramebuffer(Se.FRAMEBUFFER,t);const r=V(Se.TEXTURE_CUBE_MAP,v);for(let t=0;t<6;t++)Se.texImage2D(Se.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,Se.RGBA16F,e,e,0,Se.RGBA,Se.FLOAT,null),Se.framebufferTexture2D(Se.FRAMEBUFFER,Se.COLOR_ATTACHMENT0,Se.TEXTURE_CUBE_MAP_POSITIVE_X+t,r,0);Se.texParameteri(Se.TEXTURE_CUBE_MAP,Se.TEXTURE_MIN_FILTER,Se.LINEAR),Se.texParameteri(Se.TEXTURE_CUBE_MAP,Se.TEXTURE_MAG_FILTER,Se.LINEAR),Se.texParameteri(Se.TEXTURE_CUBE_MAP,Se.TEXTURE_WRAP_S,Se.CLAMP_TO_EDGE),Se.texParameteri(Se.TEXTURE_CUBE_MAP,Se.TEXTURE_WRAP_T,Se.CLAMP_TO_EDGE),Se.texParameteri(Se.TEXTURE_CUBE_MAP,Se.TEXTURE_WRAP_R,Se.CLAMP_TO_EDGE),this.irradiancemap=r}{const e=512,t=Se.createFramebuffer();this.framebuffer=t,this.framebuffer.size=e,Se.bindFramebuffer(Se.FRAMEBUFFER,t);const r=V(Se.TEXTURE_CUBE_MAP);for(let t=0;t<6;t++)Se.texImage2D(Se.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,Se.RGBA16F,e,e,0,Se.RGBA,Se.FLOAT,null),Se.framebufferTexture2D(Se.FRAMEBUFFER,Se.COLOR_ATTACHMENT0,Se.TEXTURE_CUBE_MAP_POSITIVE_X+t,r,0);Se.bindSampler(r.index,this.samplerCube),Se.generateMipmap(Se.TEXTURE_CUBE_MAP),this.originalCubeTexture=r}{const e=128,t=Se.createFramebuffer();this.prefilterbuffer=t,this.prefilterbuffer.size=e,Se.bindFramebuffer(Se.FRAMEBUFFER,t);const r=V(Se.TEXTURE_CUBE_MAP,x);if(this.envData){const e=[Se.TEXTURE_CUBE_MAP_POSITIVE_X,Se.TEXTURE_CUBE_MAP_NEGATIVE_X,Se.TEXTURE_CUBE_MAP_NEGATIVE_Y,Se.TEXTURE_CUBE_MAP_POSITIVE_Y,Se.TEXTURE_CUBE_MAP_POSITIVE_Z,Se.TEXTURE_CUBE_MAP_NEGATIVE_Z];for(let t=0;t<this.envData.specularImages.length;t++)for(let r=0;r<6;r++)Se.texImage2D(e[r],t,Se.RGBA,Se.RGBA,Se.UNSIGNED_BYTE,this.envData.specularImages[t][r])}else for(let t=0;t<6;t++)Se.texImage2D(Se.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,Se.RGBA16F,e,e,0,Se.RGBA,Se.FLOAT,null),Se.framebufferTexture2D(Se.FRAMEBUFFER,Se.COLOR_ATTACHMENT0,Se.TEXTURE_CUBE_MAP_POSITIVE_X+t,r,t);Se.bindSampler(r.index,this.samplerCube),Se.generateMipmap(Se.TEXTURE_CUBE_MAP),this.prefilterMap=r}{const e=512,t=Se.createFramebuffer();this.brdfbuffer=t,this.brdfbuffer.size=e,Se.bindFramebuffer(Se.FRAMEBUFFER,t);const r=V(Se.TEXTURE_2D,N);Se.texImage2D(Se.TEXTURE_2D,0,Se.RG16F,e,e,0,Se.RG,Se.FLOAT,null),Se.bindSampler(r.index,this.sampler),this.brdfLUTTexture=r,this.quadVAO=Se.createVertexArray(),Se.bindVertexArray(this.quadVAO);const n=Se.createBuffer();Se.bindBuffer(Se.ARRAY_BUFFER,n),Se.bufferData(Se.ARRAY_BUFFER,new Float32Array(ae),Se.STATIC_DRAW),Se.enableVertexAttribArray(0),Se.vertexAttribPointer(0,2,Se.FLOAT,!1,0,0),Se.bindVertexArray(null)}const t=[[new a([0,1,0]),Math.PI/2],[new a([0,1,0]),-Math.PI/2],[new a([1,0,0]),-Math.PI/2],[new a([1,0,0]),Math.PI/2],[new a([0,1,0]),Math.PI],[new a([0,1,0]),0]];this.views=t.map((e,t)=>{const r=new s;if(r.makeRotationAxis(e[0],e[1]),2!==t&&3!==t){const e=new s;e.makeRotationAxis(new a([0,0,1]),Math.PI),r.multiply(e)}return r.multiply(this.camera.matrix),(new s).setInverseOf(r)}),this.VAO=Se.createVertexArray(),Se.bindVertexArray(this.VAO);{const e=Se.createBuffer();Se.bindBuffer(Se.ARRAY_BUFFER,e),Se.bufferData(Se.ARRAY_BUFFER,new Float32Array(oe),Se.STATIC_DRAW),Se.enableVertexAttribArray(0),Se.vertexAttribPointer(0,3,Se.FLOAT,!1,0,0)}return Se.bindVertexArray(null),this.cubeprogram=y(Re.a,de.a),this.irradianceprogram=y(Re.a,pe.a),this.mipmapcubeprogram=y(Re.a,ge.a),this.bdrfprogram=y(Ue.a,xe.a),fetch(`.//../src/images/${this.url}.hdr`).then(e=>e.arrayBuffer()).then(e=>{const{data:t,shape:r}=Ee()(e);return this.original2DTexture=V(),Se.pixelStorei(Se.UNPACK_FLIP_Y_WEBGL,!0),Se.texImage2D(Se.TEXTURE_2D,0,Se.RGBA16F,r[0],r[1],0,Se.RGBA,Se.FLOAT,t),Se.bindSampler(this.original2DTexture.index,this.sampler),this.createEnvironment(),!0})}}var Le=r(1);function Pe(e){return"undefined"!=typeof window?window.fetch(e).then(e=>e.arrayBuffer()):new Promise(t=>{Le.readFile(e,(e,r)=>{if(e)throw e;t(new Uint8Array(r).buffer)})})}var Oe=r(11),Ce=r.n(Oe),De=r(12),we=r.n(De);const ye={POSITION:[0,3],NORMAL:[1,3],TEXCOORD_0:[2,2],JOINTS_0:[3,4],WEIGHTS_0:[4,4],TANGENT:[5,4],COLOR_0:[6,4],TEXCOORD_1:[7,2]};class Ve{constructor(e,t,r,n,i){let s;this.boundingSphere={center:new a,radius:null,min:null,max:null},this.uniformBuffer=null,this.UBO=null,this.VAO=null,this.indicesBuffer=null,this.attributes=null,this.targets=null,this.blend=null,this.uniforms=null,this.SKIN=null,this.targets=[];const o={},l=e.accessors[i.indices],c=new Map;for(const t in i.attributes)c.set(t,e.accessors[i.attributes[t]]);const u={min:c.get("POSITION").min,max:c.get("POSITION").max},m=i.extensions&&i.extensions.KHR_draco_mesh_compression;if(m){const{decoderModule:r,decodeDracoData:i,getArray:a}=n,l=e.bufferViews[m.bufferView],h=new r.Decoder,u=i(t[l.buffer],h,l.byteOffset,l.byteLength),T=u.num_faces(),R=u.num_points();for(const e of c.keys()){const t=h.GetAttributeByUniqueId(u,m.attributes[e]),n=B(c.get(e).type),[i,s]=a((f=c.get(e).componentType,E[f]),R*n,u,t,h);for(let e=0;e<R*n;e+=n)s[e]=i.GetValue(e),s[e+1]=i.GetValue(e+1),n>2&&(s[e+2]=i.GetValue(e+2)),n>3&&(s[e+3]=i.GetValue(e+3));r.destroy(i),o[e]=s}{s=new Uint32Array(3*T),s.type="UNSIGNED_INT";const e=new r.DracoUInt32Array;for(let t=0;t<T;++t){h.GetFaceFromMesh(u,t,e);const r=3*t;s[r]=e.GetValue(0),s[r+1]=e.GetValue(1),s[r+2]=e.GetValue(2)}r.destroy(e)}r.destroy(h),r.destroy(u)}else{if(l){const r=e.bufferViews[l.bufferView];s=D(t[r.buffer],l.componentType,z(r.byteOffset,l.byteOffset),B(l.type)*l.count)}for(const r of c.keys()){const n=c.get(r),i=e.bufferViews[n.bufferView];o[r]=C(t[i.buffer],n,i)}}var f;if(i.targets){for(const r of i.targets){const n={};for(const i in r){n[i]=e.accessors[r[i]];const s=n[i],o=e.bufferViews[s.bufferView];n[i]=C(t[o.buffer],s,o)}this.targets.push(n)}for(const e of c.keys())if(this.targets[0][e]){let t=0;const n=o[e];o[e]=new n.constructor(n.length);for(let i=0;i<o[e].length;i++)"TANGENT"!==e||(i+1)%4!=0?o[e][i]=n[i]+r.reduce((n,s,o)=>n+r[o]*this.targets[o][e][i-t],0):t++}}for(const r of c.keys()){const n=c.get(r);if("COLOR_0"===r&&"VEC3"===n.type){const e=new o[r].constructor(4*n.count);let t=0;for(let n=0;n<e.length;n++)(n+1)%4==0?e[n]=1:(e[n]=o[r][t],t++);o[r]=e}if(void 0!==n.sparse){const i=B(n.type),s=e.bufferViews[n.sparse.indices.bufferView],a=e.bufferViews[n.sparse.values.bufferView],l=D(t[s.buffer],n.sparse.indices.componentType,z(s.byteOffset,n.sparse.indices.byteOffset),n.sparse.count),c=D(t[a.buffer],n.componentType,z(a.byteOffset,n.byteOffset),B(n.type)*n.sparse.count);for(let e=0,t=l.length;e<t;e++){const t=l[e];o[r][t*i]=c[e*i],i>=2&&(o[r][t*i+1]=c[e*i+1]),i>=3&&(o[r][t*i+2]=c[e*i+2]),i>=4&&(o[r][t*i+3]=c[e*i+3])}}}void 0===o.NORMAL&&s&&(o.NORMAL=function(e,t){const r=new Float32Array(t.length/3*3);for(let s=0;s<e.length;s+=3){const o=[e[s],e[s+1],e[s+2]].map(e=>i(t,e)),l=o[1].subtract(o[0]),c=o[2].subtract(o[0]),h=a.cross(l.normalize(),c.normalize()),[u,m,f]=h.elements;for(var n=0;n<3;n++)r[3*e[s+n]+0]=r[3*e[s+n]+0]+u,r[3*e[s+n]+1]=r[3*e[s+n]+1]+m,r[3*e[s+n]+2]=r[3*e[s+n]+2]+f}return r;function i(e,t,r=3){return new a([e[t*=r],e[t+1],e[t+2]])}}(s,o.POSITION),c.set("NORMAL",{componentType:5126})),void 0===o.TEXCOORD_0&&s&&(o.TEXCOORD_0=function(e,t){const r=new Float32Array(e.length/3*2),n=new h([1/0,1/0]),i=new h([-1/0,-1/0]);for(let s=0;s<e.length/3;++s){const o=[],l=[];for(let r=0;r<3;++r)o.push(e[3*s+r]),l.push(t[3*s+r]);const c=new a(l),h=["x","y","z"].sort((e,t)=>Math.abs(c[e])-Math.abs(c[t])),u=new a(o),m=u[h[0]],f=u[h[1]];r[2*s]=m,r[2*s+1]=f,i.x=Math.max(i.x,m),i.y=Math.max(i.y,f),n.x=Math.min(n.x,m),n.y=Math.min(n.y,f)}const s=new h(i.elements).subtract(n);for(let t=0;t<e.length/3;++t){const e=2*t;r[e]=(r[e]-n.x)/s.x,r[e+1]=(r[e+1]-n.y)/s.y}return r}(o.POSITION,o.NORMAL),c.set("TEXCOORD_0",{componentType:5126})),void 0===i.attributes.TANGENT&&s&&(o.TANGENT=function(e,t,r,n){const i=new Float32Array(r.length/3*4);for(let r=0;r<e.length;r+=3){const l=[e[r],e[r+1],e[r+2]],c=l.map(e=>s(t,e)),h=l.map(e=>s(n,e,2)),u=c[1].subtract(c[0]),m=c[2].subtract(c[0]),f=h[1].subtract(h[0]),E=h[2].subtract(h[0]);let T=f.elements[0]*E.elements[1]-f.elements[1]*E.elements[0];T=0!==T?1/T:1;const R=new a([(E.elements[1]*u.elements[0]-f.elements[1]*m.elements[0])*T,(E.elements[1]*u.elements[1]-f.elements[1]*m.elements[1])*T,(E.elements[1]*u.elements[2]-f.elements[1]*m.elements[2])*T]);R.normalize(),l.forEach(e=>{o(i,e,R)})}return i;function s(e,t,r=3){return t*=r,3===r?new a([e[t],e[t+1],e[t+2]]):2===r?new h([e[t],e[t+1]]):void 0}function o(e,t,r,n=4,i=((e,t)=>e+t)){t*=n;for(let s=0;s<n;++s)e[t+s]=3===s?-1:i(e[t+s],r.elements[s])}}(s,o.POSITION,o.NORMAL,o.TEXCOORD_0),c.set("TANGENT",{componentType:5126})),this.vertexAccessor=c,this.attributes=o,this.indicesBuffer=s;const{min:T,max:R}=u;this.boundingSphere.min=new a(T),this.boundingSphere.max=new a(R)}createGeometryForWebGl(e){const t=e.createVertexArray();e.bindVertexArray(t);for(const t in this.attributes){const r=this.vertexAccessor.get(t),n=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,n),e.bufferData(e.ARRAY_BUFFER,this.attributes[t],e.STATIC_DRAW);const i=ye[t];e.enableVertexAttribArray(i[0]),e.vertexAttribPointer(i[0],i[1],r.componentType,!1,0,0)}if(this.indicesBuffer){const t=e.createBuffer();e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t),e.bufferData(e.ELEMENT_ARRAY_BUFFER,this.indicesBuffer,e.STATIC_DRAW)}this.VAO=t,e.bindVertexArray(null)}calculateBounding(e){this.boundingSphere.min.applyMatrix4(e),this.boundingSphere.max.applyMatrix4(e);const t=this.attributes.POSITION;let r=0;this.boundingSphere.center.add(this.boundingSphere.min).add(this.boundingSphere.max).scale(.5);for(let e=0;e<t.length;e+=3)r=Math.max(r,this.boundingSphere.center.distanceToSquared(t[e],t[e+1],t[e+2]));this.boundingSphere.radius=Math.sqrt(r)}updateUniforms(e,t,r,n,i){const o=new s(r);o.invert().transpose();const a=new Z;a.add("model",r.elements),a.add("normalMatrix",o.elements),a.add("view",n.matrixWorldInvert.elements),a.add("projection",n.projection.elements),a.add("light",i.matrixWorldInvert.elements),a.add("isShadow",0),a.done();const l=e.getUniformBlockIndex(t,"Matrices");e.uniformBlockBinding(t,l,0);const c=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,c),e.bufferData(e.UNIFORM_BUFFER,a.store,e.DYNAMIC_DRAW),this.UBO=c,this.uniformBuffer=a,e.bindBuffer(e.UNIFORM_BUFFER,null)}update(e,t){e.bindVertexArray(this.VAO);for(const r in t){const n=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,n),e.bufferData(e.ARRAY_BUFFER,t[r],e.STATIC_DRAW);const i=ye[r];e.enableVertexAttribArray(i[0]),e.vertexAttribPointer(i[0],i[1],e[O.get(this.attributes[r].constructor)],!1,0,0)}e.bindVertexArray(null)}}let Ge;class Xe{constructor(e,t,r){this.url=e,this.host=e.substr(0,e.lastIndexOf("/")+1),this.tracks=[],this.duration=0,this.skins=[],this.textures=null,this.samplers=null,this.arrayBuffer=null,this.cameras=[],this.lights=[],this.programs={},this.defines=t,this.resize=r}setScene(e){this.scene=e}setGl(e){Ge=e}setCamera(e){this.camera=e}setLight(e){this.light=e}setCanvas(e){this.canvas=e}getBuffer(){return Promise.all(this.scene.bin.map(e=>{if("string"==typeof e){if(/base64/.test(e)){const t=e.indexOf(";base64,")+";base64,".length,r=e.substring(t),n=window.atob(r),i=new ArrayBuffer(n.length),s=new Uint8Array(i);for(let e=0;e<n.length;e++)s[e]=n.charCodeAt(e);return i}return Pe(`${this.host}${e}`)}return Promise.resolve(e)})).then(e=>{this.arrayBuffer=e})}createProgram(e){let t;const r=e.map(e=>`${e.name}${e.value||1}`).join("");if(this.programs[r])t=this.programs[r];else{const n=e.map(e=>`#define ${e.name} ${e.value||1}\n`).join("");t=y(Ce.a.replace(/\n/,"\n"+n),we.a.replace(/\n/,"\n"+n)),this.programs[r]=t}return t}buildPrim(e,t,r,n,i){const s=this.json.materials&&this.json.materials[i.material];this.json.extensions&&this.json.extensions.EXT_lights_image_based&&this.defines.push({name:"SPHERICAL_HARMONICS"});const o=[...this.defines],a=new $(s,this.textures,o,this.lights);void 0!==r&&o.push({name:"JOINTNUMBER",value:this.skins[r].jointNames.length}),(i.attributes.TANGENT||a.hasNormal())&&o.push({name:"TANGENT"});const l=void 0!==r?new j(t,e):new W(t,e),c=new Ve(this.json,this.arrayBuffer,n,this.draco,i);return c.attributes.COLOR_0&&c.attributes.COLOR_0.constructor!==Float32Array&&o.push({name:"COLOR_255"}),l.setMode(i.mode),l.setMaterial(a),l.setGeometry(c),l.setDefines(a.defines),l instanceof j&&(l.skin=r),l.updateMatrix(),l.calculateBounding(),l}buildNode(e,t){const r=this.json.nodes[t];let n;if(void 0!==r.camera){const i=Object.assign({zoom:1,aspect:this.canvas?this.canvas.offsetWidth/this.canvas.offsetHeight:1},this.json.cameras[r.camera]);Xe.__update?Xe.__update("camera",i,t,e):this.camera=new K(i,t,e),n=this.camera;const s=H(n.props);n.setProjection(s),this.cameras.push(n)}else if(r.extensions&&r.extensions.KHR_lights_punctual){const i=this.json.extensions.KHR_lights_punctual.lights[r.extensions.KHR_lights_punctual.light];i.isInitial=!1,Xe.__update?Xe.__update("light",i,t,e):this.light=new q(i,t,e),n=this.light,this.lights.push(n)}else n=void 0!==r.isBone?new Y(t,e):new f(t,e);r.translation||r.rotation||r.scale?n.setPosition(r.translation,r.rotation,r.scale):r.matrix&&n.setMatrix(r.matrix),n.updateMatrix(),n.id=r.name,e.children.push(n),e=n,void 0!==r.mesh&&e.children.push(...this.json.meshes[r.mesh].primitives.map(this.buildPrim.bind(this,e,this.json.meshes[r.mesh].name,r.skin,this.json.meshes[r.mesh].weights))),r.children&&r.children.length&&r.children.forEach(this.buildNode.bind(this,e))}calculateFov(e){const t=new l;G(this.scene,e=>{e instanceof W&&t.expand(e.geometry.boundingSphere)});const r=t.getSize();if(e){const e=(new a).add(t.min).add(t.max).scale(.5),r=new s;r.translate(e.x,e.y,e.z),r.invert(),this.scene.matrixWorld.multiply(r),G(this.scene,e=>{e instanceof f&&e.updateMatrix()})}this.cameras.forEach(e=>{e.modelSize=r}),this.resize()}async buildMesh(){this.json.extensionsUsed&&this.json.extensionsUsed.includes("KHR_draco_mesh_compression")&&(this.draco=await Promise.all([r.e(1),r.e(2)]).then(r.bind(null,31)),await this.draco.DecoderModule),this.json.scenes[void 0!==this.json.scene?this.json.scene:0].nodes.forEach(e=>{this.json.nodes[e].extensions&&this.buildNode(this.scene,e)}),0===this.lights.length&&this.light&&this.lights.push(this.light),this.json.scenes[void 0!==this.json.scene?this.json.scene:0].nodes.forEach(e=>{this.json.nodes[e].children&&this.json.nodes[e].children.length&&!this.json.nodes[e].extensions&&this.buildNode(this.scene,e),void 0!==this.json.nodes[e].mesh&&this.buildNode(this.scene,e),void 0!==this.json.nodes[e].camera&&this.buildNode(this.scene,e)}),G(this.scene,e=>{e instanceof W&&(e.material.alpha?this.scene.transparentChildren.push(e):this.scene.opaqueChildren.push(e),this.scene.meshes.push(e))}),this.scene.opaqueChildren.sort((e,t)=>e.distance-t.distance),this.scene.transparentChildren.sort((e,t)=>e.distance-t.distance)}buildAnimation(){if(!this.json.animations)return!0;for(const e of this.json.animations){const t=[];for(const r of e.channels){const n=e.samplers[r.sampler];if(n){const{target:i}=r,s=i.node,o=void 0!==e.parameters?e.parameters[n.input]:n.input,a=void 0!==e.parameters?e.parameters[n.output]:n.output,l=this.json.accessors[o],c=this.json.accessors[a],h=this.json.bufferViews[l.bufferView],u=this.json.bufferViews[c.bufferView],m=D(this.arrayBuffer[h.buffer],l.componentType,z(h.byteOffset,l.byteOffset),B(l.type)*l.count),E=D(this.arrayBuffer[u.buffer],c.componentType,z(u.byteOffset,c.byteOffset),B(c.type)*c.count),T=[];G(this.scene,e=>{e.name===s&&("weights"===i.path&&e instanceof f&&(e=e.children[0]),T.push(e))});let R=L(i.path)||T[0].geometry.targets.length;"CUBICSPLINE"===n.interpolation&&(R*=3);const _=[];for(let e=0;e<m.length;e++){const t=m[e],r=E.slice(e*R,(e+1)*R);_.push({time:t,value:k(r)})}_.length>=2&&(this.duration=Math.max(_[_.length-1].time,this.duration),T.length&&t.push({stoped:!1,meshes:T,type:i.path,name:`${T[0].name}.${i.path}`,keys:_,interpolation:n.interpolation}))}}this.tracks.push(t)}}buildSkin(){if(!this.json.skins)return!0;for(const e of this.json.skins){const t=this.json.accessors[e.inverseBindMatrices],r=this.json.bufferViews[t.bufferView],n=D(this.arrayBuffer[r.buffer],t.componentType,z(r.byteOffset,t.byteOffset),B(t.type)*t.count),i={jointNames:e.joints,inverseBindMatrices:n,bones:[],boneInverses:[]};let o=0;for(const e of i.jointNames){this.json.nodes[e].isBone=!0;const t=i.inverseBindMatrices,r=(new s).set(t.slice(16*o,16*(o+1)));i.boneInverses.push(r),o++}this.skins.push(i)}}getJson(){return/glb/.test(this.url)?Pe(this.url).then(e=>{const t=new TextDecoder("utf-8"),[r]=new Uint32Array(e,12,1),n=new Uint8Array(e,20,r),i=JSON.parse(t.decode(n)),[s]=new Uint32Array(e,20+r,1),o=e.slice(28+r,28+r+s);this.json=i,this.scene.bin.push(o)}):(e=this.url,"undefined"!=typeof window?window.fetch(e).then(e=>e.json()):new Promise(t=>{Le.readFile(e,"utf8",(e,r)=>{if(e)throw e;t(JSON.parse(r))})})).then(e=>{for(const t in e.buffers)this.scene.bin.push(e.buffers[t].uri);return this.json=e,!0});var e}createTextures(){const e=this.json.samplers||[{}];this.samplers=e.map(e=>{const t=Ge.createSampler();return Ge.samplerParameteri(t,Ge.TEXTURE_MIN_FILTER,e.minFilter||9986),Ge.samplerParameteri(t,Ge.TEXTURE_MAG_FILTER,e.magFilter||9729),Ge.samplerParameteri(t,Ge.TEXTURE_WRAP_S,e.wrapS||10497),Ge.samplerParameteri(t,Ge.TEXTURE_WRAP_T,e.wrapT||10497),t}),this.scene.meshes.forEach(e=>{const t=["baseColorTexture","metallicRoughnessTexture","emissiveTexture","normalTexture","occlusionTexture","clearcoatTexture","clearcoatRoughnessTexture","clearcoatNormalTexture","sheenTexture"];for(let r=0;r<t.length;r++){const n=t[r],i=e.material[n];if(!i)continue;const s=this.samplers[void 0!==i.sampler?i.sampler:0];e.material[n]=this.handleTextureLoaded(s,i.image,i.name)}})}initTextures(){if(!this.json.textures)return!0;const e={};this.json.textures.forEach(t=>{const r=String(t.sampler)+String(t.source);e[r]=t,e[r].name=r,t.name=r});const t=Object.values(e).map(e=>{const t=this.json.images[e.source];return function({url:e,name:t}){return"undefined"!=typeof window?new Promise((r,n)=>{const i=new Image;i.onload=()=>{r({name:t,image:i})},i.onerror=e=>{n(e)},i.crossOrigin="anonymous",i.src=e}):new Promise(r=>{Le.readFile(e,(n,i)=>{if(n)throw n;r({url:e,name:t,image:new Uint8Array(i).buffer})})})}({url:`${this.host}${t.uri}`,name:e.name})});return Promise.all(t).then(e=>(this.textures=this.json.textures.map(t=>e.find(e=>e.name===t.name)),!0))}handleTextureLoaded(e,t,r){const n=Ge.createTexture();return n.name=r,n.image=t.src.substr(t.src.lastIndexOf("/")),n.sampler=e,Ge.activeTexture(Ge.TEXTURE31),Ge.bindTexture(Ge.TEXTURE_2D,n),Ge.texImage2D(Ge.TEXTURE_2D,0,Ge.RGBA,Ge.RGBA,Ge.UNSIGNED_BYTE,t),Ge.generateMipmap(Ge.TEXTURE_2D),n}async getEnv(){if(this.json.extensions&&this.json.extensions.EXT_lights_image_based){const e=this.json.extensions.EXT_lights_image_based.lights[0];return e.specularImages=e.specularImages.map(e=>e.map(e=>{const t=this.json.images[e],r=this.json.bufferViews[t.bufferView],{buffer:n,byteLength:i,byteOffset:s}=r,o=new Uint8Array(this.arrayBuffer[n],s,i),a=new Blob([o],{type:t.mimeType}),l=window.URL.createObjectURL(a),c=new Image;return c.src=l,c})),await new Promise(e=>setTimeout(e,200)),e}}}var He=r(13),ze=r.n(He),ke=r(2),We=r.n(ke);let je;var Ye=r(14),Ke=r.n(Ye);let qe,Ze;var Je=r(15),Qe=r.n(Je);let $e;const et={bloom:class extends te{setGL(e){qe=e}attachUniform(e){qe.uniform1i(qe.getUniformLocation(e,"bloom"),this.blurTexture.index)}postProcessing(e){qe.bindFramebuffer(qe.FRAMEBUFFER,this.framebuffer),qe.useProgram(this.bloorProgram),qe.framebufferTexture2D(qe.FRAMEBUFFER,qe.COLOR_ATTACHMENT0,qe.TEXTURE_2D,this.hdrTexture,0),qe.uniform1i(qe.getUniformLocation(this.bloorProgram,"diff"),e.screenTexture.index),qe.drawArrays(qe.TRIANGLE_STRIP,0,4),qe.useProgram(this.program),qe.viewport(0,0,this.width/2,this.height/2),this.renderBlur(this.hdrTexture,this.program),this.renderBlur(this.blurTexture,this.program),this.renderBlur(this.blurTexture,this.program),this.renderBlur(this.blurTexture,this.program),this.renderBlur(this.blurTexture,this.program),qe.bindFramebuffer(qe.FRAMEBUFFER,null),qe.viewport(0,0,this.width,this.height)}buildScreenBuffer(e){return this.framebuffer=qe.createFramebuffer(),qe.bindFramebuffer(qe.FRAMEBUFFER,this.framebuffer),this.tempBlurTexture=e.createDefaultTexture(2),this.blurTexture=e.createDefaultTexture(2),this.hdrTexture=e.createByteTexture(),qe.bindFramebuffer(qe.FRAMEBUFFER,null),this.program=y(Ue.a,We.a),this.bloorProgram=y(Ue.a,Ke.a),{name:"BLOOM"}}renderBlur(e,t){qe.framebufferTexture2D(qe.FRAMEBUFFER,qe.COLOR_ATTACHMENT0,qe.TEXTURE_2D,this.tempBlurTexture,0),qe.clearColor(..._),qe.clear(qe.COLOR_BUFFER_BIT|qe.DEPTH_BUFFER_BIT|qe.STENSIL_BUFFER_BIT),qe.uniform1i(qe.getUniformLocation(t,"uTexture"),e.index),qe.uniform2f(qe.getUniformLocation(t,"denom"),1,0),qe.drawArrays(qe.TRIANGLE_STRIP,0,4),qe.framebufferTexture2D(qe.FRAMEBUFFER,qe.COLOR_ATTACHMENT0,qe.TEXTURE_2D,this.blurTexture,0),qe.uniform1i(qe.getUniformLocation(t,"uTexture"),this.tempBlurTexture.index),qe.uniform2f(qe.getUniformLocation(t,"denom"),0,1),qe.drawArrays(qe.TRIANGLE_STRIP,0,4)}preProcessing(){}},ssao:class extends te{constructor(){super(),this.scale=2}setGL(e){je=e}attachUniform(e){je.uniform1i(je.getUniformLocation(e,"ssao"),this.ssaoTexture.index)}postProcessing(e){je.bindFramebuffer(je.FRAMEBUFFER,this.framebuffer),je.framebufferTexture2D(je.FRAMEBUFFER,je.COLOR_ATTACHMENT0,je.TEXTURE_2D,this.ssaoTexture,0),je.clearColor(..._),je.clear(je.COLOR_BUFFER_BIT|je.DEPTH_BUFFER_BIT),je.useProgram(this.ssaoProgram);const t=this.camera.props.perspective||this.camera.props.orthographic;je.uniform1i(je.getUniformLocation(this.ssaoProgram,"normBuff"),e.normalTexture.index),je.uniform1i(je.getUniformLocation(this.ssaoProgram,"depthBuff"),e.depthTexture.index),je.uniform1i(je.getUniformLocation(this.ssaoProgram,"noice"),this.noice.index),je.uniform2f(je.getUniformLocation(this.ssaoProgram,"noiseScale"),this.width/this.scale/4,this.height/this.scale/4),je.uniform1f(je.getUniformLocation(this.ssaoProgram,"zFar"),t.zfar),je.uniform1f(je.getUniformLocation(this.ssaoProgram,"zNear"),t.znear),je.uniform1f(je.getUniformLocation(this.ssaoProgram,"bias"),.03*Math.sqrt(this.camera.modelSize)),je.uniformMatrix4fv(je.getUniformLocation(this.ssaoProgram,"proj"),!1,this.camera.projection.elements),je.uniformMatrix4fv(je.getUniformLocation(this.ssaoProgram,"view"),!1,this.camera.matrixWorldInvert.elements),je.uniformMatrix4fv(je.getUniformLocation(this.ssaoProgram,"projI"),!1,(new s).setInverseOf(this.camera.projection).elements),je.uniform3fv(je.getUniformLocation(this.ssaoProgram,"kernels"),this.kernels),je.viewport(0,0,this.width/this.scale,this.height/this.scale),je.drawArrays(je.TRIANGLE_STRIP,0,4),je.framebufferTexture2D(je.FRAMEBUFFER,je.COLOR_ATTACHMENT0,je.TEXTURE_2D,this.ssaoBlurTexture,0),je.clear(je.COLOR_BUFFER_BIT|je.DEPTH_BUFFER_BIT),je.useProgram(this.ssaoBlurProgram),je.uniform1i(je.getUniformLocation(this.ssaoBlurProgram,"uTexture"),this.ssaoTexture.index),je.uniform2f(je.getUniformLocation(this.ssaoBlurProgram,"denom"),1,0),je.drawArrays(je.TRIANGLE_STRIP,0,4),je.framebufferTexture2D(je.FRAMEBUFFER,je.COLOR_ATTACHMENT0,je.TEXTURE_2D,this.ssaoTexture,0),je.uniform1i(je.getUniformLocation(this.ssaoBlurProgram,"uTexture"),this.ssaoBlurTexture.index),je.uniform2f(je.getUniformLocation(this.ssaoBlurProgram,"denom"),0,1),je.drawArrays(je.TRIANGLE_STRIP,0,4),je.bindFramebuffer(je.FRAMEBUFFER,null),je.viewport(0,0,this.width,this.height)}buildScreenBuffer(e){return this.framebuffer=je.createFramebuffer(),je.bindFramebuffer(je.FRAMEBUFFER,this.framebuffer),this.ssaoTexture=e.createOneChannelTexture(this.scale),this.ssaoBlurTexture=e.createOneChannelTexture(this.scale),je.framebufferTexture2D(je.FRAMEBUFFER,je.COLOR_ATTACHMENT0,je.TEXTURE_2D,this.ssaoTexture,0),this.ssaoProgram=y(Ue.a,ze.a),this.ssaoBlurProgram=y(Ue.a,We.a),this.buildNoice(e),this.buildKernels(),je.bindFramebuffer(je.FRAMEBUFFER,null),{name:"SSAO"}}buildNoice(e){const t=new Float32Array(48);for(let e=0;e<16;e++){const r=new a([2*S(0,1)-1,2*S(0,1)-1,.1]);t[3*e]=r.elements[0],t[3*e+1]=r.elements[1],t[3*e+2]=r.elements[2]}this.noice=e.createNoiceTexture(4,t)}buildKernels(){const e=new Array(32);for(let r=0;r<e.length;r++){e[r]=new a([2*S(0,1)-1,2*S(0,1)-1,S(0,1)]),e[r].normalize(),e[r].scale(S(0,1));let n=r/e.length;n=(t=.1)+n*n*(1-t),e[r].scale(n)}var t;this.kernels=new Float32Array(3*e.length);let r=0;for(const t of e)this.kernels.set(t.elements,3*r),r++}preProcessing(){}},shadow:class extends te{setGL(e){Ze=e}preProcessing(e){Ze.clear(Ze.COLOR_BUFFER_BIT|Ze.DEPTH_BUFFER_BIT),e.renderScene(!0)}buildScreenBuffer(){return{name:"SHADOW"}}attachUniform(){}postProcessing(){}},light:he};class tt{constructor(e,t){this.renderScene=t,this.postprocessors=e.map(e=>new et[e]),this.MSAA=4}setRenderer(e){this.renderer=e}setCamera(e){this.camera=e,this.postprocessors.forEach(t=>{t.setCamera(e)})}setLight(e){this.postprocessors.forEach(t=>{t.light=e})}setGl(e){e&&($e=e,this.postprocessors.forEach(e=>{e.setGL($e)}),this.fakeDepth=this.createNoiceTexture(1,new Float32Array([1,1,0])))}setCanvas(e){this.canvas=e,this.postprocessors.forEach(t=>{t.setCanvas(e)})}get width(){return this.canvas.offsetWidth*devicePixelRatio}get height(){return this.canvas.offsetHeight*devicePixelRatio}bindPrePass(){$e.bindFramebuffer($e.FRAMEBUFFER,this.preframebuffer)}bindPostPass(){$e.bindFramebuffer($e.FRAMEBUFFER,this.renderframebuffer)}preProcessing(){this.postprocessors.forEach(e=>e.preProcessing(this))}postProcessing(){$e.bindFramebuffer($e.READ_FRAMEBUFFER,this.renderframebuffer),$e.bindFramebuffer($e.DRAW_FRAMEBUFFER,this.framebuffer),$e.readBuffer($e.COLOR_ATTACHMENT0),$e.drawBuffers([$e.COLOR_ATTACHMENT0]),$e.blitFramebuffer(0,0,this.width,this.height,0,0,this.width,this.height,$e.COLOR_BUFFER_BIT,$e.NEAREST),$e.readBuffer($e.COLOR_ATTACHMENT1),$e.drawBuffers([$e.NONE,$e.COLOR_ATTACHMENT1]),$e.blitFramebuffer(0,0,this.width,this.height,0,0,this.width,this.height,$e.COLOR_BUFFER_BIT,$e.NEAREST),$e.blitFramebuffer(0,0,this.width,this.height,0,0,this.width,this.height,$e.DEPTH_BUFFER_BIT,$e.NEAREST),$e.bindVertexArray(this.VAO),this.postprocessors.forEach(e=>e.postProcessing(this)),$e.bindFramebuffer($e.FRAMEBUFFER,null),$e.useProgram(this.program),this.postprocessors.forEach(e=>{e.attachUniform(this.program)}),$e.uniform1i($e.getUniformLocation(this.program,"original"),this.screenTexture.index),$e.uniform1i($e.getUniformLocation(this.program,"normal"),this.normalTexture.index),$e.uniform1i($e.getUniformLocation(this.program,"depth"),this.depthTexture.index),$e.uniform1i($e.getUniformLocation(this.program,"preDepth"),this.preDepthTexture.index),$e.drawArrays($e.TRIANGLE_STRIP,0,4)}createByteTexture(){const e=V();return $e.texParameteri($e.TEXTURE_2D,$e.TEXTURE_MAG_FILTER,$e.NEAREST),$e.texParameteri($e.TEXTURE_2D,$e.TEXTURE_MIN_FILTER,$e.NEAREST),$e.texImage2D($e.TEXTURE_2D,0,$e.RGBA,this.width,this.height,0,$e.RGBA,$e.UNSIGNED_BYTE,null),e}createDefaultTexture(e=1){const t=V();return $e.texParameteri($e.TEXTURE_2D,$e.TEXTURE_MAG_FILTER,$e.NEAREST),$e.texParameteri($e.TEXTURE_2D,$e.TEXTURE_MIN_FILTER,$e.NEAREST),$e.texImage2D($e.TEXTURE_2D,0,$e.RGBA16F,this.width/e,this.height/e,0,$e.RGBA,$e.FLOAT,null),t}createOneChannelTexture(e=1){const t=V();return $e.texParameteri($e.TEXTURE_2D,$e.TEXTURE_MAG_FILTER,$e.LINEAR),$e.texParameteri($e.TEXTURE_2D,$e.TEXTURE_MIN_FILTER,$e.LINEAR),$e.texImage2D($e.TEXTURE_2D,0,$e.R8,this.width/e,this.height/e,0,$e.RED,$e.UNSIGNED_BYTE,null),t}createDepthTexture(){const e=V();return $e.texParameteri($e.TEXTURE_2D,$e.TEXTURE_MAG_FILTER,$e.NEAREST),$e.texParameteri($e.TEXTURE_2D,$e.TEXTURE_MIN_FILTER,$e.NEAREST),$e.texImage2D($e.TEXTURE_2D,0,$e.DEPTH_COMPONENT24,this.width,this.height,0,$e.DEPTH_COMPONENT,$e.UNSIGNED_INT,null),e}createNoiceTexture(e,t){const r=V();return $e.texParameteri($e.TEXTURE_2D,$e.TEXTURE_MAG_FILTER,$e.NEAREST),$e.texParameteri($e.TEXTURE_2D,$e.TEXTURE_MIN_FILTER,$e.NEAREST),$e.texParameteri($e.TEXTURE_2D,$e.TEXTURE_WRAP_S,$e.REPEAT),$e.texParameteri($e.TEXTURE_2D,$e.TEXTURE_WRAP_T,$e.REPEAT),$e.texImage2D($e.TEXTURE_2D,0,$e.RGB16F,e,e,0,$e.RGB,$e.FLOAT,t),r}buildScreenBuffer(){if(0===this.postprocessors.length)return!0;const e=this.postprocessors.map(e=>e.buildScreenBuffer(this)).map(e=>`#define ${e.name} ${e.value||1}\n`).join("");this.VAO=$e.createVertexArray(),$e.bindVertexArray(this.VAO);const t=$e.createBuffer();$e.bindBuffer($e.ARRAY_BUFFER,t),$e.bufferData($e.ARRAY_BUFFER,new Float32Array(ae),$e.STATIC_DRAW),$e.enableVertexAttribArray(0),$e.vertexAttribPointer(0,2,$e.FLOAT,!1,0,0),$e.bindVertexArray(null);const r=$e.createRenderbuffer();$e.bindRenderbuffer($e.RENDERBUFFER,r),$e.renderbufferStorageMultisample($e.RENDERBUFFER,this.MSAA,$e.RGBA16F,this.width,this.height);const n=$e.createRenderbuffer();$e.bindRenderbuffer($e.RENDERBUFFER,n),$e.renderbufferStorageMultisample($e.RENDERBUFFER,this.MSAA,$e.RGBA16F,this.width,this.height);const i=$e.createRenderbuffer();$e.bindRenderbuffer($e.RENDERBUFFER,i),$e.renderbufferStorageMultisample($e.RENDERBUFFER,this.MSAA,$e.DEPTH_COMPONENT24,this.width,this.height),this.renderframebuffer=$e.createFramebuffer(),$e.bindFramebuffer($e.FRAMEBUFFER,this.renderframebuffer),$e.framebufferRenderbuffer($e.FRAMEBUFFER,$e.COLOR_ATTACHMENT0,$e.RENDERBUFFER,r),$e.framebufferRenderbuffer($e.FRAMEBUFFER,$e.COLOR_ATTACHMENT1,$e.RENDERBUFFER,n),$e.framebufferRenderbuffer($e.FRAMEBUFFER,$e.DEPTH_ATTACHMENT,$e.RENDERBUFFER,i),$e.drawBuffers([$e.COLOR_ATTACHMENT0,$e.COLOR_ATTACHMENT1]),this.framebuffer=$e.createFramebuffer(),$e.bindFramebuffer($e.FRAMEBUFFER,this.framebuffer),this.screenTexture=this.createDefaultTexture(),this.normalTexture=this.createDefaultTexture(),this.depthTexture=this.createDepthTexture(),$e.framebufferTexture2D($e.FRAMEBUFFER,$e.COLOR_ATTACHMENT0,$e.TEXTURE_2D,this.screenTexture,0),$e.framebufferTexture2D($e.FRAMEBUFFER,$e.COLOR_ATTACHMENT1,$e.TEXTURE_2D,this.normalTexture,0),$e.framebufferTexture2D($e.FRAMEBUFFER,$e.DEPTH_ATTACHMENT,$e.TEXTURE_2D,this.depthTexture,0),$e.drawBuffers([$e.COLOR_ATTACHMENT0,$e.COLOR_ATTACHMENT1]),$e.bindFramebuffer($e.FRAMEBUFFER,null),this.preframebuffer=$e.createFramebuffer(),$e.bindFramebuffer($e.FRAMEBUFFER,this.preframebuffer),this.preDepthTexture=this.createDepthTexture(),$e.framebufferTexture2D($e.FRAMEBUFFER,$e.DEPTH_ATTACHMENT,$e.TEXTURE_2D,this.preDepthTexture,0),$e.bindFramebuffer($e.FRAMEBUFFER,null),this.program=y(Ue.a.replace(/\n/,"\n"+e),Qe.a.replace(/\n/,"\n"+e))}clear(){console.error("implement")}}function rt(e,t,r){this.x=e,this.y=t,this.z=r}rt.prototype.dot2=function(e,t){return this.x*e+this.y*t},rt.prototype.dot3=function(e,t,r){return this.x*e+this.y*t+this.z*r};var nt=[new rt(1,1,0),new rt(-1,1,0),new rt(1,-1,0),new rt(-1,-1,0),new rt(1,0,1),new rt(-1,0,1),new rt(1,0,-1),new rt(-1,0,-1),new rt(0,1,1),new rt(0,-1,1),new rt(0,1,-1),new rt(0,-1,-1)],it=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],st=new Array(512),ot=new Array(512);!function(e){e>0&&e<1&&(e*=65536),(e=Math.floor(e))<256&&(e|=e<<8);for(var t=0;t<256;t++){var r;r=1&t?it[t]^255&e:it[t]^e>>8&255,st[t]=st[t+256]=r,ot[t]=ot[t+256]=nt[r%12]}}(0);Math.sqrt(3),Math.sqrt(3);function at(e){return e*e*e*(e*(6*e-15)+10)}function lt(e,t,r){return(1-r)*e+r*t}function ct(e,t,r){var n=Math.floor(e),i=Math.floor(t),s=Math.floor(r);e-=n,t-=i,r-=s;var o=ot[(n&=255)+st[(i&=255)+st[s&=255]]].dot3(e,t,r),a=ot[n+st[i+st[s+1]]].dot3(e,t,r-1),l=ot[n+st[i+1+st[s]]].dot3(e,t-1,r),c=ot[n+st[i+1+st[s+1]]].dot3(e,t-1,r-1),h=ot[n+1+st[i+st[s]]].dot3(e-1,t,r),u=ot[n+1+st[i+st[s+1]]].dot3(e-1,t,r-1),m=ot[n+1+st[i+1+st[s]]].dot3(e-1,t-1,r),f=ot[n+1+st[i+1+st[s+1]]].dot3(e-1,t-1,r-1),E=at(e),T=at(t),R=at(r);return lt(lt(lt(o,h,E),lt(a,u,E),R),lt(lt(l,m,E),lt(c,f,E),R),T)}var ht=r(16),ut=r.n(ht),mt=r(17),ft=r.n(mt),Et=r(18),Tt=r.n(Et),Rt=r(19),_t=r.n(Rt);let dt;class At{constructor(e){this.getLight=e}setGl(e){dt=e}setCamera(e){this.camera=e}build(){this.currentSourceIdx=0;const e=dt.createProgram();w(dt.VERTEX_SHADER,_t.a,e),w(dt.FRAGMENT_SHADER,Tt.a,e);dt.transformFeedbackVaryings(e,["v_position","v_velocity","v_spawntime","v_lifetime"],dt.SEPARATE_ATTRIBS),dt.linkProgram(e),this.program=e;const t=y(ut.a,ft.a);this.program2=t;const r=[dt.createVertexArray(),dt.createVertexArray()],n=[dt.createTransformFeedback(),dt.createTransformFeedback()];this.VAO=r,this.TFO=n;for(const e of[0,1]){dt.bindVertexArray(r[e]);const t=[];{const e=new Float32Array(3e3);for(let t=0;t<1e3;t++)e[3*t]=0,e[3*t+1]=0,e[3*t+2]=0;const r=dt.createBuffer();dt.bindBuffer(dt.ARRAY_BUFFER,r),dt.bufferData(dt.ARRAY_BUFFER,e,dt.STREAM_COPY),dt.enableVertexAttribArray(0),dt.vertexAttribPointer(0,3,dt.FLOAT,!1,0,0),dt.vertexAttribDivisor(0,1),t.push(r)}{const e=new Float32Array(3e3);for(let t=0;t<1e3;t++)e[3*t]=0,e[3*t+1]=0,e[3*t+2]=0;const r=dt.createBuffer();dt.bindBuffer(dt.ARRAY_BUFFER,r),dt.bufferData(dt.ARRAY_BUFFER,e,dt.STREAM_COPY),dt.enableVertexAttribArray(1),dt.vertexAttribPointer(1,3,dt.FLOAT,!1,0,0),dt.vertexAttribDivisor(1,1),t.push(r)}{const e=new Float32Array(1e3);for(let t=0;t<1e3;t++)e[2*t]=0;const r=dt.createBuffer();dt.bindBuffer(dt.ARRAY_BUFFER,r),dt.bufferData(dt.ARRAY_BUFFER,e,dt.STREAM_COPY),dt.enableVertexAttribArray(2),dt.vertexAttribPointer(2,1,dt.FLOAT,!1,0,0),dt.vertexAttribDivisor(2,1),t.push(r)}{const e=new Float32Array(1e3);for(let t=0;t<1e3;t++)e[2*t]=0;const r=dt.createBuffer();dt.bindBuffer(dt.ARRAY_BUFFER,r),dt.bufferData(dt.ARRAY_BUFFER,e,dt.STREAM_COPY),dt.enableVertexAttribArray(3),dt.vertexAttribPointer(3,1,dt.FLOAT,!1,0,0),dt.vertexAttribDivisor(3,1),t.push(r)}dt.bindBuffer(dt.ARRAY_BUFFER,null),dt.bindTransformFeedback(dt.TRANSFORM_FEEDBACK,n[e]);let i=0;for(const e of t)dt.bindBufferBase(dt.TRANSFORM_FEEDBACK_BUFFER,i,e),i++}const i=new Uint8Array(2097152);for(let e=0;e<128;++e)for(let t=0;t<128;++t)for(let r=0;r<128;++r){let n=ct(r/8,t/8,e/8);n=128*(1+n),i[r+128*t+128*e*128]=n}this.texture3d=V(dt.TEXTURE_3D),dt.texParameteri(dt.TEXTURE_3D,dt.TEXTURE_BASE_LEVEL,0),dt.texParameteri(dt.TEXTURE_3D,dt.TEXTURE_MAX_LEVEL,Math.log2(128)),dt.texParameteri(dt.TEXTURE_3D,dt.TEXTURE_MIN_FILTER,dt.LINEAR_MIPMAP_LINEAR),dt.texParameteri(dt.TEXTURE_3D,dt.TEXTURE_MAG_FILTER,dt.LINEAR),dt.texImage3D(dt.TEXTURE_3D,0,dt.R8,128,128,128,0,dt.RED,dt.UNSIGNED_BYTE,i),dt.generateMipmap(dt.TEXTURE_3D)}draw(e){dt.enable(dt.BLEND),dt.blendFunc(dt.SRC_ALPHA,dt.ONE_MINUS_SRC_ALPHA);const t=(this.currentSourceIdx+1)%2;dt.useProgram(this.program),dt.bindVertexArray(this.VAO[this.currentSourceIdx]),dt.bindTransformFeedback(dt.TRANSFORM_FEEDBACK,this.TFO[t]);const r=new s;r.multiply(this.camera.projection),r.multiply(this.camera.matrixWorldInvert),dt.uniform1f(dt.getUniformLocation(this.program,"u_time"),e+5e3),dt.uniform1f(dt.getUniformLocation(this.program,"count"),1e3),dt.uniform1i(dt.getUniformLocation(this.program,"noize"),this.texture3d.index),dt.enable(dt.RASTERIZER_DISCARD),dt.beginTransformFeedback(dt.POINTS),dt.drawArraysInstanced(dt.POINTS,0,1,1e3),dt.endTransformFeedback(),dt.disable(dt.RASTERIZER_DISCARD),dt.bindTransformFeedback(dt.TRANSFORM_FEEDBACK,null),dt.bindBuffer(dt.TRANSFORM_FEEDBACK_BUFFER,null);const n=dt.fenceSync(dt.SYNC_GPU_COMMANDS_COMPLETE,0);dt.waitSync(n,0,dt.TIMEOUT_IGNORED),dt.deleteSync(n),dt.useProgram(this.program2),dt.bindVertexArray(this.VAO[t]),dt.uniform1f(dt.getUniformLocation(this.program2,"u_time"),e+5e3),dt.uniformMatrix4fv(dt.getUniformLocation(this.program2,"MVPMatrix"),!1,r.elements),dt.uniform1i(dt.getUniformLocation(this.program2,"light"),this.getLight()),dt.drawArraysInstanced(dt.POINTS,0,1,1e3),dt.disable(dt.BLEND),this.currentSourceIdx=(this.currentSourceIdx+1)%2}}let pt;class Ft{constructor(e,t,r=[],i="env",s="pbr"){if(!e||!t)throw new Error("Url or Canvas not found");this.canvas=t,this.processors=r;const o=[];0===r.length&&o.push({name:"TONE"}),r.some(e=>"shadow"===e)&&o.push({name:"SHADOWMAP"}),"pbr"===s&&o.push({name:"USE_PBR"}),this.ioc=new n,this.ioc.register("env",Be,["camera","canvas","gl"],i),this.ioc.register("camera",K,[],{type:"perspective",isInitial:!0,zoom:1,aspect:this.canvas.offsetWidth/this.canvas.offsetHeight,perspective:{yfov:60*Math.PI/180}},"perspective"),this.ioc.register("canvas",t),this.ioc.register("scene",m),this.ioc.register("light",q,[],{type:"directional",intensity:10,color:[1,1,1],isInitial:!0,spot:{}}),this.ioc.register("pp",tt,["light","camera","canvas","gl"],r,this.renderScene.bind(this)),this.ioc.register("parser",Xe,["scene","light","camera","canvas","gl"],e,o,this.resize.bind(this)),this.ioc.register("particles",At,["camera","gl"],()=>this.PP.postprocessors.find(e=>e instanceof he).texture.index),this.ioc.register("renderer",ue,["gl","parser","pp","scene","camera","particles","env"],this.getState.bind(this)),this.events=new me(t,this.redraw.bind(this))}get renderer(){return this.ioc.get("renderer")}get scene(){return this.ioc.get("scene")}get camera(){return this.ioc.get("camera")}get light(){return this.ioc.get("light")}get env(){return this.ioc.get("env")}get PP(){return this.ioc.get("pp")}get Particles(){return this.ioc.get("particles")}get parse(){return this.ioc.get("parser")}async init(e){await this.parse.getJson(),this.glInit(),this.PP.postprocessors.some(e=>e instanceof he)&&this.Particles.build(),this.PP.postprocessors.length>0&&this.PP.buildScreenBuffer(),await this.parse.getBuffer(),await this.parse.initTextures(),this.parse.buildSkin(),await this.parse.buildMesh(),this.parse.createTextures(),0===this.parse.cameras.length&&this.parse.cameras.push(this.camera),this.parse.calculateFov(this.parse.cameras[0].props.isInitial);const t=u(this.camera.getViewProjMatrix()),r=await this.parse.getEnv();await this.env.createEnvironmentBuffer(r),this.scene.meshes.forEach(e=>{e.geometry.createGeometryForWebGl(pt);const r=this.parse.createProgram(e.defines);if(e.material.createUniforms(pt,r),e.material.updateUniforms(pt,r,this.camera,this.parse.lights),e.material.setHarmonics(this.env.updateUniform(pt,r)),e.setProgram(r),e.geometry.updateUniforms(pt,e.program,e.matrixWorld,this.camera,this.light),e.visible=e.isVisible(t),e instanceof j){for(const t of this.parse.skins[e.skin].jointNames)G(this.scene,this.buildBones.bind(this,t,this.parse.skins[e.skin]));e.setSkin(pt,this.parse.skins[e.skin])}}),this.resize(null),this.parse.buildAnimation(),this.draw(),e()}buildBones(e,t,r){r.name===e&&t.bones.push(r)}renderScene(e){this.isprepender=e,this.renderer.renderScene(),this.isprepender=!1}redraw(e,t,r){"zoom"===e&&(this.camera.zoom(t),this.renderer.needUpdateView=!0,this.renderer.needUpdateProjection=!0),"rotate"===e&&(this.camera.rotate(t,r),this.renderer.needUpdateView=!0),"pan"===e&&(this.camera.pan(t,r,this.canvas.offsetWidth,this.canvas.offsetHeight),this.renderer.needUpdateView=!0),"resize"===e&&(this.resize(e),this.renderer.needUpdateProjection=!0),this.renderer.reflow=!0}resize(e){this.camera.props.aspect=this.canvas.offsetWidth/this.canvas.offsetHeight,this.canvas.width=this.canvas.offsetWidth*devicePixelRatio,this.canvas.height=this.canvas.offsetHeight*devicePixelRatio,pt.viewport(0,0,this.canvas.offsetWidth*devicePixelRatio,this.canvas.offsetHeight*devicePixelRatio);const t=this.camera.modelSize;this.camera.props.isInitial&&this.camera.setZ(t),(this.light.isInitial||"directional"===this.light.type)&&this.light.setZ(t),this.renderer.needUpdateView=!0,this.camera.updateNF(),e&&(this.PP.clear(),this.PP.buildScreenBuffer())}glInit(){if(pt=this.canvas.getContext("webgl2",{antialias:0===this.processors.length}),this.gl=pt,!pt)throw new Error("Webgl 2 doesnt support");T=pt,this.ioc.register("gl",pt),pt.getExtension("EXT_color_buffer_float"),pt.getExtension("OES_texture_float_linear")}draw(){pt.clearColor(..._),pt.enable(pt.DEPTH_TEST),pt.enable(pt.CULL_FACE),this.renderer.render()}getState(){return{isprepender:this.isprepender,lights:this.parse.lights,camera:this.camera,light:this.light,preDepthTexture:this.PP.preDepthTexture,fakeDepth:this.PP.fakeDepth,needUpdateView:this.renderer.needUpdateView,needUpdateProjection:this.renderer.needUpdateProjection,irradiancemap:this.env.irradiancemap,prefilterMap:this.env.prefilterMap,brdfLUT:this.env.brdfLUTTexture}}}}])}));