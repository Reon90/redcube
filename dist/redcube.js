(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("redcube", [], factory);
	else if(typeof exports === 'object')
		exports["redcube"] = factory();
	else
		root["redcube"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/redcube.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/env.ts":
/*!********************!*\
  !*** ./src/env.ts ***!
  \********************/
/*! exports provided: Env */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Env\", function() { return Env; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrix */ \"./src/matrix.ts\");\n/* harmony import */ var _images_env_jpg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./images/env.jpg */ \"./src/images/env.jpg\");\n/* harmony import */ var _images_env_jpg__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_images_env_jpg__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _shaders_env_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shaders/env.glsl */ \"./src/shaders/env.glsl\");\n/* harmony import */ var _shaders_env_glsl__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_shaders_env_glsl__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _shaders_blurEnv_glsl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shaders/blurEnv.glsl */ \"./src/shaders/blurEnv.glsl\");\n/* harmony import */ var _shaders_blurEnv_glsl__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_shaders_blurEnv_glsl__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\nlet gl;\nclass Env {\n    constructor() {\n        this.envMatrix = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Matrix4\"];\n    }\n    setCamera(camera) {\n        this._camera = camera;\n    }\n    setGl(g) {\n        gl = g;\n    }\n    createEnvironment() {\n        gl.useProgram(this.program);\n        gl.bindVertexArray(this.VAO);\n        const m = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Matrix4\"];\n        m.multiply(this._camera.projection);\n        m.multiply(this._camera.matrixWorldInvert);\n        m.multiply(this.envMatrix);\n        gl.uniform1f(gl.getUniformLocation(this.program, 'level'), 3);\n        gl.uniform1i(gl.getUniformLocation(this.program, 'diffuse'), 0);\n        gl.uniformMatrix4fv(gl.getUniformLocation(this.program, 'MVPMatrix'), false, m.elements);\n        gl.drawElements(gl.TRIANGLES, this.IndexBufferLength, gl.UNSIGNED_SHORT, 0);\n    }\n    createEnvironmentBuffer() {\n        const latitudeBands = 30;\n        const longitudeBands = 30;\n        const radius = this._camera.modelSize * 10;\n        const vertexPositionData = [];\n        const normalData = [];\n        const textureCoordData = [];\n        for (let latNumber = 0; latNumber <= latitudeBands; latNumber++) {\n            const theta = latNumber * Math.PI / latitudeBands;\n            const sinTheta = Math.sin(theta);\n            const cosTheta = Math.cos(theta);\n            for (let longNumber = 0; longNumber <= longitudeBands; longNumber++) {\n                const phi = longNumber * 2 * Math.PI / longitudeBands;\n                const sinPhi = Math.sin(phi);\n                const cosPhi = Math.cos(phi);\n                const x = cosPhi * sinTheta;\n                const y = cosTheta;\n                const z = sinPhi * sinTheta;\n                const u = 1 - (longNumber / longitudeBands);\n                const v = 1 - (latNumber / latitudeBands);\n                normalData.push(x);\n                normalData.push(y);\n                normalData.push(z);\n                textureCoordData.push(u);\n                textureCoordData.push(v);\n                vertexPositionData.push(radius * x);\n                vertexPositionData.push(radius * y);\n                vertexPositionData.push(radius * z);\n            }\n        }\n        const indexData = [];\n        for (let latNumber = 0; latNumber < latitudeBands; latNumber++) {\n            for (let longNumber = 0; longNumber < longitudeBands; longNumber++) {\n                const first = (latNumber * (longitudeBands + 1)) + longNumber;\n                const second = first + longitudeBands + 1;\n                indexData.push(first);\n                indexData.push(second);\n                indexData.push(first + 1);\n                indexData.push(second);\n                indexData.push(second + 1);\n                indexData.push(first + 1);\n            }\n        }\n        this.VAO = gl.createVertexArray();\n        gl.bindVertexArray(this.VAO);\n        {\n            const VBO = gl.createBuffer();\n            gl.bindBuffer(gl.ARRAY_BUFFER, VBO);\n            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);\n            gl.enableVertexAttribArray(0);\n            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);\n        }\n        {\n            const VBO = gl.createBuffer();\n            gl.bindBuffer(gl.ARRAY_BUFFER, VBO);\n            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordData), gl.STATIC_DRAW);\n            gl.enableVertexAttribArray(1);\n            gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0);\n        }\n        {\n            const VBO = gl.createBuffer();\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, VBO);\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);\n            this.IndexBufferLength = indexData.length;\n        }\n        gl.bindVertexArray(null);\n        this.program = gl.createProgram();\n        Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"compileShader\"])(gl.VERTEX_SHADER, _shaders_env_glsl__WEBPACK_IMPORTED_MODULE_3___default.a, this.program);\n        Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"compileShader\"])(gl.FRAGMENT_SHADER, _shaders_blurEnv_glsl__WEBPACK_IMPORTED_MODULE_4___default.a, this.program);\n        gl.linkProgram(this.program);\n        return new Promise((resolve, reject) => {\n            const texture = gl.createTexture();\n            const img = new Image;\n            img.crossOrigin = 'anonymous';\n            img.onload = () => {\n                gl.activeTexture(gl.TEXTURE0);\n                gl.bindTexture(gl.TEXTURE_2D, texture);\n                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\n                gl.generateMipmap(gl.TEXTURE_2D);\n                resolve();\n            };\n            img.onerror = err => {\n                reject(err);\n            };\n            img.src = _images_env_jpg__WEBPACK_IMPORTED_MODULE_2___default.a;\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZW52LnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkY3ViZS8uL3NyYy9lbnYudHM/NzEwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb21waWxlU2hhZGVyIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi9tYXRyaXgnO1xuaW1wb3J0IGVudlRleHR1cmUgZnJvbSAnLi9pbWFnZXMvZW52LmpwZyc7XG5pbXBvcnQgZW52U2hhZGVyIGZyb20gJy4vc2hhZGVycy9lbnYuZ2xzbCc7XG5pbXBvcnQgZW52Qmx1clNoYWRlciBmcm9tICcuL3NoYWRlcnMvYmx1ckVudi5nbHNsJztcbmxldCBnbDtcbmV4cG9ydCBjbGFzcyBFbnYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVudk1hdHJpeCA9IG5ldyBNYXRyaXg0O1xuICAgIH1cbiAgICBzZXRDYW1lcmEoY2FtZXJhKSB7XG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcbiAgICB9XG4gICAgc2V0R2woZykge1xuICAgICAgICBnbCA9IGc7XG4gICAgfVxuICAgIGNyZWF0ZUVudmlyb25tZW50KCkge1xuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSh0aGlzLlZBTyk7XG4gICAgICAgIGNvbnN0IG0gPSBuZXcgTWF0cml4NDtcbiAgICAgICAgbS5tdWx0aXBseSh0aGlzLl9jYW1lcmEucHJvamVjdGlvbik7XG4gICAgICAgIG0ubXVsdGlwbHkodGhpcy5fY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJ0KTtcbiAgICAgICAgbS5tdWx0aXBseSh0aGlzLmVudk1hdHJpeCk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCAnbGV2ZWwnKSwgMyk7XG4gICAgICAgIGdsLnVuaWZvcm0xaShnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCAnZGlmZnVzZScpLCAwKTtcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCAnTVZQTWF0cml4JyksIGZhbHNlLCBtLmVsZW1lbnRzKTtcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdGhpcy5JbmRleEJ1ZmZlckxlbmd0aCwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuICAgIH1cbiAgICBjcmVhdGVFbnZpcm9ubWVudEJ1ZmZlcigpIHtcbiAgICAgICAgY29uc3QgbGF0aXR1ZGVCYW5kcyA9IDMwO1xuICAgICAgICBjb25zdCBsb25naXR1ZGVCYW5kcyA9IDMwO1xuICAgICAgICBjb25zdCByYWRpdXMgPSB0aGlzLl9jYW1lcmEubW9kZWxTaXplICogMTA7XG4gICAgICAgIGNvbnN0IHZlcnRleFBvc2l0aW9uRGF0YSA9IFtdO1xuICAgICAgICBjb25zdCBub3JtYWxEYXRhID0gW107XG4gICAgICAgIGNvbnN0IHRleHR1cmVDb29yZERhdGEgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGF0TnVtYmVyID0gMDsgbGF0TnVtYmVyIDw9IGxhdGl0dWRlQmFuZHM7IGxhdE51bWJlcisrKSB7XG4gICAgICAgICAgICBjb25zdCB0aGV0YSA9IGxhdE51bWJlciAqIE1hdGguUEkgLyBsYXRpdHVkZUJhbmRzO1xuICAgICAgICAgICAgY29uc3Qgc2luVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgICAgICBjb25zdCBjb3NUaGV0YSA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgICAgIGZvciAobGV0IGxvbmdOdW1iZXIgPSAwOyBsb25nTnVtYmVyIDw9IGxvbmdpdHVkZUJhbmRzOyBsb25nTnVtYmVyKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaGkgPSBsb25nTnVtYmVyICogMiAqIE1hdGguUEkgLyBsb25naXR1ZGVCYW5kcztcbiAgICAgICAgICAgICAgICBjb25zdCBzaW5QaGkgPSBNYXRoLnNpbihwaGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvc1BoaSA9IE1hdGguY29zKHBoaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IGNvc1BoaSAqIHNpblRoZXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBjb3NUaGV0YTtcbiAgICAgICAgICAgICAgICBjb25zdCB6ID0gc2luUGhpICogc2luVGhldGE7XG4gICAgICAgICAgICAgICAgY29uc3QgdSA9IDEgLSAobG9uZ051bWJlciAvIGxvbmdpdHVkZUJhbmRzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gMSAtIChsYXROdW1iZXIgLyBsYXRpdHVkZUJhbmRzKTtcbiAgICAgICAgICAgICAgICBub3JtYWxEYXRhLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgbm9ybWFsRGF0YS5wdXNoKHkpO1xuICAgICAgICAgICAgICAgIG5vcm1hbERhdGEucHVzaCh6KTtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlQ29vcmREYXRhLnB1c2godSk7XG4gICAgICAgICAgICAgICAgdGV4dHVyZUNvb3JkRGF0YS5wdXNoKHYpO1xuICAgICAgICAgICAgICAgIHZlcnRleFBvc2l0aW9uRGF0YS5wdXNoKHJhZGl1cyAqIHgpO1xuICAgICAgICAgICAgICAgIHZlcnRleFBvc2l0aW9uRGF0YS5wdXNoKHJhZGl1cyAqIHkpO1xuICAgICAgICAgICAgICAgIHZlcnRleFBvc2l0aW9uRGF0YS5wdXNoKHJhZGl1cyAqIHopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4RGF0YSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBsYXROdW1iZXIgPSAwOyBsYXROdW1iZXIgPCBsYXRpdHVkZUJhbmRzOyBsYXROdW1iZXIrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgbG9uZ051bWJlciA9IDA7IGxvbmdOdW1iZXIgPCBsb25naXR1ZGVCYW5kczsgbG9uZ051bWJlcisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSAobGF0TnVtYmVyICogKGxvbmdpdHVkZUJhbmRzICsgMSkpICsgbG9uZ051bWJlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWNvbmQgPSBmaXJzdCArIGxvbmdpdHVkZUJhbmRzICsgMTtcbiAgICAgICAgICAgICAgICBpbmRleERhdGEucHVzaChmaXJzdCk7XG4gICAgICAgICAgICAgICAgaW5kZXhEYXRhLnB1c2goc2Vjb25kKTtcbiAgICAgICAgICAgICAgICBpbmRleERhdGEucHVzaChmaXJzdCArIDEpO1xuICAgICAgICAgICAgICAgIGluZGV4RGF0YS5wdXNoKHNlY29uZCk7XG4gICAgICAgICAgICAgICAgaW5kZXhEYXRhLnB1c2goc2Vjb25kICsgMSk7XG4gICAgICAgICAgICAgICAgaW5kZXhEYXRhLnB1c2goZmlyc3QgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLlZBTyA9IGdsLmNyZWF0ZVZlcnRleEFycmF5KCk7XG4gICAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSh0aGlzLlZBTyk7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IFZCTyA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIFZCTyk7XG4gICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheSh2ZXJ0ZXhQb3NpdGlvbkRhdGEpLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSgwKTtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoMCwgMywgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBWQk8gPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBWQk8pO1xuICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkodGV4dHVyZUNvb3JkRGF0YSksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KDEpO1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcigxLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IFZCTyA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgVkJPKTtcbiAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG5ldyBVaW50MTZBcnJheShpbmRleERhdGEpLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgICAgICAgICB0aGlzLkluZGV4QnVmZmVyTGVuZ3RoID0gaW5kZXhEYXRhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgICAgY29tcGlsZVNoYWRlcihnbC5WRVJURVhfU0hBREVSLCBlbnZTaGFkZXIsIHRoaXMucHJvZ3JhbSk7XG4gICAgICAgIGNvbXBpbGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSLCBlbnZCbHVyU2hhZGVyLCB0aGlzLnByb2dyYW0pO1xuICAgICAgICBnbC5saW5rUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZTtcbiAgICAgICAgICAgIGltZy5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGltZyk7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCk7XG4gICAgICAgICAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltZy5vbmVycm9yID0gZXJyID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWcuc3JjID0gZW52VGV4dHVyZTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/env.ts\n");

/***/ }),

/***/ "./src/events.ts":
/*!***********************!*\
  !*** ./src/events.ts ***!
  \***********************/
/*! exports provided: Events */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Events\", function() { return Events; });\nclass Events {\n    constructor(redraw) {\n        this.redraw = redraw;\n        this.zoomValue = 0;\n        document.addEventListener('wheel', this);\n        document.addEventListener('mousedown', this);\n        document.addEventListener('mousemove', this);\n        document.addEventListener('mouseup', this);\n        document.addEventListener('keyup', this);\n        document.addEventListener('keydown', this);\n        addEventListener('resize', this);\n    }\n    handleEvent(e) {\n        switch (e.type) {\n            case 'wheel':\n                this.zoom(e);\n                break;\n            case 'mousedown':\n                this.onStart(e);\n                break;\n            case 'mousemove':\n                this.onMove(e);\n                break;\n            case 'mouseup':\n                this.onEnd();\n                break;\n            case 'keyup':\n                this.onKeyUp();\n                break;\n            case 'keydown':\n                this.onKeyDown(e);\n                break;\n            case 'resize':\n                this.onResize();\n                break;\n        }\n    }\n    onResize() {\n        this.redraw('resize');\n    }\n    onKeyDown(e) {\n        if (e.shiftKey || e.ctrlKey) {\n            this.isPan = true;\n        }\n    }\n    onKeyUp() {\n        this.isPan = false;\n    }\n    onStart(e) {\n        this.x = e.clientX;\n        this.y = e.clientY;\n        this.isDrag = true;\n    }\n    onMove(e) {\n        if (this.isDrag) {\n            if (this.isPan) {\n                this.redraw('pan', [this.x, this.y], [e.clientX, e.clientY]);\n            }\n            else {\n                this.redraw('rotate', [this.x, this.y], [e.clientX, e.clientY]);\n            }\n            this.x = e.clientX;\n            this.y = e.clientY;\n        }\n    }\n    onEnd() {\n        this.isDrag = false;\n    }\n    zoom(e) {\n        this.zoomValue = Math.min(this.zoomValue + e.deltaY, 1250);\n        this.redraw('zoom', Math.pow(1.001, this.zoomValue));\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZXZlbnRzLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkY3ViZS8uL3NyYy9ldmVudHMudHM/YTYxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBFdmVudHMge1xuICAgIGNvbnN0cnVjdG9yKHJlZHJhdykge1xuICAgICAgICB0aGlzLnJlZHJhdyA9IHJlZHJhdztcbiAgICAgICAgdGhpcy56b29tVmFsdWUgPSAwO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcyk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMpO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzKTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZSkge1xuICAgICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnd2hlZWwnOlxuICAgICAgICAgICAgICAgIHRoaXMuem9vbShlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgICAgICAgICAgdGhpcy5vblN0YXJ0KGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW92ZShlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICAgICAgICAgIHRoaXMub25FbmQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5VXAoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgICAgICAgICAgIHRoaXMub25LZXlEb3duKGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmVzaXplJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25SZXNpemUoKSB7XG4gICAgICAgIHRoaXMucmVkcmF3KCdyZXNpemUnKTtcbiAgICB9XG4gICAgb25LZXlEb3duKGUpIHtcbiAgICAgICAgaWYgKGUuc2hpZnRLZXkgfHwgZS5jdHJsS2V5KSB7XG4gICAgICAgICAgICB0aGlzLmlzUGFuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbktleVVwKCkge1xuICAgICAgICB0aGlzLmlzUGFuID0gZmFsc2U7XG4gICAgfVxuICAgIG9uU3RhcnQoZSkge1xuICAgICAgICB0aGlzLnggPSBlLmNsaWVudFg7XG4gICAgICAgIHRoaXMueSA9IGUuY2xpZW50WTtcbiAgICAgICAgdGhpcy5pc0RyYWcgPSB0cnVlO1xuICAgIH1cbiAgICBvbk1vdmUoZSkge1xuICAgICAgICBpZiAodGhpcy5pc0RyYWcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUGFuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWRyYXcoJ3BhbicsIFt0aGlzLngsIHRoaXMueV0sIFtlLmNsaWVudFgsIGUuY2xpZW50WV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWRyYXcoJ3JvdGF0ZScsIFt0aGlzLngsIHRoaXMueV0sIFtlLmNsaWVudFgsIGUuY2xpZW50WV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy54ID0gZS5jbGllbnRYO1xuICAgICAgICAgICAgdGhpcy55ID0gZS5jbGllbnRZO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uRW5kKCkge1xuICAgICAgICB0aGlzLmlzRHJhZyA9IGZhbHNlO1xuICAgIH1cbiAgICB6b29tKGUpIHtcbiAgICAgICAgdGhpcy56b29tVmFsdWUgPSBNYXRoLm1pbih0aGlzLnpvb21WYWx1ZSArIGUuZGVsdGFZLCAxMjUwKTtcbiAgICAgICAgdGhpcy5yZWRyYXcoJ3pvb20nLCBNYXRoLnBvdygxLjAwMSwgdGhpcy56b29tVmFsdWUpKTtcbiAgICB9XG59XG5leHBvcnQgeyBFdmVudHMgfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/events.ts\n");

/***/ }),

/***/ "./src/fps.ts":
/*!********************!*\
  !*** ./src/fps.ts ***!
  \********************/
/*! exports provided: FPS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FPS\", function() { return FPS; });\nclass FPS {\n    constructor() {\n        this.counterEl = document.createElement('div');\n        this.counterEl.setAttribute('style', 'position: absolute; top: 0; right: 0; color: #fff; font-size: 30px; background: #000;');\n        document.body.appendChild(this.counterEl);\n        this.fps = 0;\n        this.elapsedTime = 0;\n        this.lastTime = 0;\n    }\n    tick(time) {\n        this.fps++;\n        this.elapsedTime += (time - this.lastTime);\n        this.lastTime = time;\n        if (this.elapsedTime >= 1000) {\n            this.counterEl.innerHTML = String(this.fps);\n            this.fps = 0;\n            this.elapsedTime -= 1000;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZnBzLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkY3ViZS8uL3NyYy9mcHMudHM/NTc0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgRlBTIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb3VudGVyRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5jb3VudGVyRWwuc2V0QXR0cmlidXRlKCdzdHlsZScsICdwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgcmlnaHQ6IDA7IGNvbG9yOiAjZmZmOyBmb250LXNpemU6IDMwcHg7IGJhY2tncm91bmQ6ICMwMDA7Jyk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5jb3VudGVyRWwpO1xuICAgICAgICB0aGlzLmZwcyA9IDA7XG4gICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RUaW1lID0gMDtcbiAgICB9XG4gICAgdGljayh0aW1lKSB7XG4gICAgICAgIHRoaXMuZnBzKys7XG4gICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgKz0gKHRpbWUgLSB0aGlzLmxhc3RUaW1lKTtcbiAgICAgICAgdGhpcy5sYXN0VGltZSA9IHRpbWU7XG4gICAgICAgIGlmICh0aGlzLmVsYXBzZWRUaW1lID49IDEwMDApIHtcbiAgICAgICAgICAgIHRoaXMuY291bnRlckVsLmlubmVySFRNTCA9IFN0cmluZyh0aGlzLmZwcyk7XG4gICAgICAgICAgICB0aGlzLmZwcyA9IDA7XG4gICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lIC09IDEwMDA7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/fps.ts\n");

/***/ }),

/***/ "./src/images/env.jpg":
/*!****************************!*\
  !*** ./src/images/env.jpg ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAAAAAAD/4QGlRXhpZgAASUkqAAgAAAAEABIBAwABAAAAAQAAADEBAgCVAAAAPgAAADIBAgAUAAAA0wAAAGmHBAABAAAAZwEAAAAAAABPcGVuSW1hZ2VJTyAxLjUuMTYgOiBvaWlvdG9vbCAvdG1wL29yaWdpbmFsX3Bhbm9yYW1hLnRpZiAtLXJlc2l6ZSAyNTZ4MTI4IC0tY3BvdyAwLjQ1NDU0NTQ1LDAuNDU0NTQ1NDUsMC40NTQ1NDU0NSwxLjAgLW8gL3RtcC9kYXRhL3RodW1ibmFpbF8yNTYuanBnADIwMTc6MDY6MTQgMTQ6MTM6MjQAb2lpb3Rvb2wgL3RtcC9vcmlnaW5hbF9wYW5vcmFtYS50aWYgLS1yZXNpemUgMjU2eDEyOCAtLWNwb3cgMC40NTQ1NDU0NSwwLjQ1NDU0NTQ1LDAuNDU0NTQ1NDUsMS4wIC1vIC90bXAvZGF0YS90aHVtYm5haWxfMjU2LmpwZwAEAACQBwAEAAAAMDIyMAGRBwAEAAAAAQIDABOSAgCAAAAA5wAAAACgBwAEAAAAMDEwMAAAAAD/7QFHUGhvdG9zaG9wIDMuMAA4QklNBAQAAAAAASscAkEAjU9wZW5JbWFnZUlPIDEuNS4xNiA6IG9paW90b29sIC12IC9kYXRhL2Y0MWZhM2RhMjVlZTQ0NmJhMjAzNjBmNjk3NmUzMDE4LmV4ciAtLWNsYW1wOm1heD0xOC44OTA2MjUgLS1jbGFtcDptaW49MCAtbyAvdG1wL29yaWdpbmFsX3Bhbm9yYW1hLnRpZhwCQQCUT3BlbkltYWdlSU8gMS41LjE2IDogb2lpb3Rvb2wgL3RtcC9vcmlnaW5hbF9wYW5vcmFtYS50aWYgLS1yZXNpemUgMjU2eDEyOCAtLWNwb3cgMC40NTQ1NDU0NSwwLjQ1NDU0NTQ1LDAuNDU0NTQ1NDUsMS4wIC1vIC90bXAvZGF0YS90aHVtYm5haWxfMjU2LmpwZ//hAZ5odHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDAyIDEuMTQ4MDIyLCAyMDEyLzA3LzE1LTE4OjA2OjQ1ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcDpDcmVhdGVEYXRlPSIyMDE3OjA2OjE0IDE0OjEzOjI0Ii8+ICA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJ3Ij8+/9sAQwABAQEBAQEBAQEBAQEBAQECAQEBAQECAQEBAgICAgICAgICAwMEAwMDAwMCAgMEAwMEBAQEBAIDBQUEBAUEBAQE/9sAQwEBAQEBAQECAQECBAMCAwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE/8AAEQgAgAEAAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A/u3/AOFmeGxgSjUYSeokswdv1wx/TNXoPiD4NlXfJ4h0yyXGc6jcf2cF9mMoUA+nPNfLl9d6ggKsfNA6hhv/AJ1ylxeBydyGFh1ePKH8q/U6fA+XYiN4zkvRp/mj+YcL4wcV0pp14UqkeqcWn8nGS/Jn25D408HXD+Xb+LPDU7/3IddtZX/IPW1a39jemQWV7aXZhx5wtblLgxbs7d20nGdrYz6GvzturmVAWEzSx5yfmyy/UVFY+L9T0maK40zV9T0ueCXzo206/e1jZgpUGWLJhmUbifLuEkjyAShIGNanhpGrTbweIfN05lpfztZ/hpvrse5hPGnGKvH69gY+z+1ySfNby5tL+rV9rrdfpFXPXNx4rS+EdnpHh6500yANdXPiO5sb5E4yRAtjIjHrx5ijjrzx8Wv+0L8QdNsIre31TQNQuIohGNT8ReGm1C6uCDlnmjtLmziLHkfu1jUZHyHvcP7VXigWSQHRvC41FZd0upBLtrOVMn5FsfNDIQMfObl8/wBwV51Pw04mg+aFKnVTdvikkl/N9h/JXfeJ9NV8V+FcZTivb18PJa6U6bb/ALruqsfnou0j7kAfJyyEfwgIQR9eaj23O8EywbO6/Z2Dn8d/9K+PdH/advbiK8g1fTdPW6dFbTLvSISIYnBBKTwyznercglJEYDIAz8w6jwt4y+IXxLvVGleNvC/hgWBkt7u0sLe2lvZyY0eO4Om3Ec8s0W51TfFdW6/6wZZkIPmYjgXPcDGdXMOSlTjvKTbja17rljJ+W179Nj0qXiVw3jqtLDZZCtXrSekIJRd72s3UqU49nrLls973S+oaKpC3uns4IJb+VLtEjFxfWkEUTTuu3zCI3WRVVyD8vJAbhs4NXOcHoDzj+Ie1fGuKWzT+/79uv390j9FhUlL4oNaJ6267rRvVdemujeto3MwYCOOJlxyXmMbA+wCn+dQ3VybW3M7/Z1CY3mado41zx94IT+lUtX1ez0PTZtV1TUtJ0uxtSkdze61eLo+nRvJKkKb7hztTc7qqgg7mdQDyDXCSeKrlvCEL6neeFtc12d2hu08JatMukupkfy5IWxJJxH5TNG3GWYbiME+hhMvr4qMasIXhzqPXVvV76aK13dWuu587nfEOCyinWjXr8lRUpVFzW5VayjsnJuUrpJKTfLLsr9jH4l00D/Sbq0jPXNtM90o+vyK2T9COOtaFnrGl6g7R2d/a3EsbbJIUmHnxnaHwyH5gdpDYI6EHpXiOl6zp8KyLqnhe8umc7vtNrqW+4XrhUik8tFA4Od+WycjhRXo2g+KdBhsdO07zr61MFmkLy6tbRwSb1UAm4kiHkB2wXZo8R5Y4IPy16GPyZ4eMnRpzb8nFq3fTmdvW2/yPi+F+P55nVhHNMbhoQa2anGpzXS5W5+zgm73vFTWjXmd1RVOHULS5ne3t50mliQSSbMsgUjgh8bT1HAPGauV8/KEoO01Zn6tRr0MRFzw81KKbV001daNXXVPR9mFFFFSahRRRQAUUUUAFFRPNGjbCWL8EpGjSuoO7BIUEgHa2CeODUtNprcmM4SbjFptb+QUUUUigorJ1f7X5K/ZXlQZ/eGIhWPICgHO7r2Uc9z2PB3Mt788clzesr5WSN7yV0OeCCpbGPbpXfhcC8THmU0vxPk894pjklZ0ZYaU9N72Tv2dn6Pzvoehalq2laNbm71fU9P0q0X711qV7HY269OruQO4796zrbxd4UvFD2fifw9dKzbFa21q2nUnGcAq55x2rzF7ZYyTGixk/wBwbSfyqjLGxzksfcsTXs0sjwkoWnOTl30S+6z/APSvkfnGO8VM5o1XKhg6ah2blJ/+BLlXy5NO7O+1r4g2mlOi2Og694kVly8uivp0McJyQQ32u7gJxgHKgjDDBPOKlp8TLKcMbrw34m0vAJAvBp05fHYeReS/rivPJIj/ALQz1wawryK5TJjmkAxkDfXr0MiyydNUZQ97+a8rv8eX/wAlPjcR4s8X/WHOEoRT+zyRcV6XXN98mYmrW00QbETYJxkjOa831BTJIwZTy2MDg/hX2DP4UsZbuCw1NbtTexO1vLYW8lzbKyYyJJRHtj4ZSPM2huQCSDj5k+IWnDQpb2ex1K0vrK11KTS5Yng8nWFkgSZp3+zAljEphZBLwHZgFXBBP13Dmc0MbXWFhpK2js7PW2jtbdP7n2Z87nPCuaZJQWJxkEoczjuuZNJS1hfmV00722a7q/4j/tUf8FAfG3wW+OepeD/h3J8LvF/gfRfD1sNXh1e0uLm/h1ZjN50K6ra3uwRsBCux4Q0bhgWcEbfGdP8A+CrupXPi2yfWvhx4Oj8F6haJLeWWk+Jrm08WaE6qq3TrLMGguYo3YMCY4WKvg8jJ/Lf/AIKR3nwt8X/tA+JNU+D/AIj0PSvBHiezgvZRotjd+HrEancRu2qxXULRh7N1ui8lw2xAHboGVxX593MXjzy7pdE8L+HLq6s7JLjxd4s0xLrXdL0e0tredI4ZfKR9kE/2cJ9oZNkkk0GWXJ2/zZV8TvEbFcU4+jwvmXNBV6kaUIKnVpSjTk0nCUqd5Qat8Mrcr57K11+u4Dg/hqrk+HnjcLabhHmcuaErtK90mrSv5Xvpqf3I+E/iB4T+Jnhiz8XeAfEuleKfDWox77TVNJvFuY1YcPFKo+aORGyjxyBWVlII4qR55tzDLDHvjNfhh/wRG8U+P9b8N+ONG1nT/Hcvho3kNzaW7xadZeG/A4a03Rw6vZOiXsN1dXCXZVo2kCPHIkiJnc372S6S4Lk5yTnleK/urgXiKpn/AA3hc1zCl7KvOPvRs0uZPlbim5Pkk1zR95tJpNtpn4bxHldLJs3rZfSnzxi9H1s1dJ7arZ6LvsVdN1aK1W7FxZW1801o0EBurmeD7I7MpE0flsNzrggCTKfMcqeMeq+Fvjp4l+FNwumf2TomnpNrenza/I3h467HqGnWr7bpLMQ39ugvJo2ljS+LzRI5DvBPtKHxh9MlaRgc/QHio5tEUw/NFlQcIoOAvrxX02NyvJ80g8PmUVOlK14u71VrWu7K1r25Xd2fTXz8FmWKy6tHFYGbhVjtJOzV1Z6rXVO2+za6n6N+Ff2r/gjewabpkc2r+D4EtxaWdhqfh1obHTY4cRwwlrMzQRLsUbBuCKqgEqcKd/X/ANovwbbpZ/8ACKTf8JNPJKWukltrrR7JI9hwBcSQ5DlmQjZHKMIwYIWVh+X9loyRTq/lsdpyBnNekaXbyYUojgLxyMYr81zDwo4Pw+J+tUJVnHVuMppxbfmoqfX+a99bn6DLxe4slg3hY+yjLS04wakrW2Tk4dOsGrXVj7Qk+Klz4heN7uaO2gXOy1tt0cQyV685Y/KME8jJxjJFTjxXpwGVdiwHA+8TXy9YNdgKodsd8c4rp4JLhAS8hACF3ZjgKqgsx+gAJJ7AE9K8WvwpltD93Q92K2SPhMZnOPx2IljMbWlOq95Sd3+PbolayPeD4ignGVOOe5yalh1AzMNr5BOAByfwr5l8VfGf4WfDLwte+NPHPjrQtI8PacfLurmG6/tS4Em1iIvJgDurMUKjeFBdkXILKD7V4W+Inws1m9utM0jx34VvtSsp7W1mtBrdul2z3kVpJbKkZfcS/wBttV243B5ghAbivAxuEw+CcqUU3JdOqvon6Ozt3s7bO2McLj8WlVjCXK7+8720tfX5q/qj6O8E6pYpbGzuLi0gu2mK20TWwtZZAcZAm6SEnkL94bT1AGPRa+Yvh18VfhP8QtQ8S6X8P/iJ4E8b6j4Lvv7L8XWXhXxVY+ILjw3cAsrQ3qwyN5TBkkQhujxSIcMjKPnH4wf8FY/+Ca37NGoar4U+In7W/wAIV8d6NepY6v8ACT4V6nc/HD4t6bPMySYk8FeGYdQ1eIn7Uk0j/Y1ASQyyEKC4/Nc3wi9tPEU1LfVW0T1vrpbZ79nfY/p3w+zTG08to5Pjow/dx0d5KVtHH3Xzczd904pKyjGx+ldFfz9+Mv8Ag5B/Yf0nV4NE+G3wf/bS+ON7cXclpG3hP4BQ/Cm2/dRNLJJnxxqfh52VABuEaO43qSgU7hhT/wDBxR8K4JrKNv2A/wBvFFv4J7m2NzP8FLaWaO1lkhuHRD8QzkRvDKpyRyhFedSwGLrynGhDm5VeXK00lu22m0rde3U/QK2ZYTDKDruUee3LeE03e1tOW+t1bvdWP6IaK/n/AB/wcHfCcWVrfn9gH/godLbXjSJbzWGkfBLUopTEkEkgBT4lE/KtzATkDiVa99+Hv/BdX/gnT4vk0u18cfET4l/s6XWo3v8AZ91qH7SfwI8X/Cn4a+HJSqlDqvxElsJPBdpHI7xwRzTa0IpJ5oYUdpZYkfKphcRSV6sHHTmV9Lx01V91qtVdK6N6eKw9VpUpX1tprZ6uz/lej0dn0P2Dorzb4TfGb4P/AB88E2HxK+BXxW+Gvxp+HOq3VxY6X4/+E3jrS/iN4J1Ka0ma3u4bfVdPnmtZHhlR4pESQlHRlYAgivSawOgrz2lvcNFJLHmWBg8MyMYp4sMjlQ6kMFYxqGXO1wNrAgkUyzsobGN4oHu3V5TMxvL+fUZASACA8rswXgYUEKOcDk1bpCcdiecYFX7Spyez5ny9r6fcc7wmE+sfXHSj7Vfa5VzapJ62vqklv0Q1FKqoZ3kYKFLvgM+O5AAGfoBT6KKhu+pvFKKUUZqSag6SlLdQAT9mN1dCGebBYfOqxMEU4Vl6thvmCkFarXGmI5HBLP1O3euTknJxnt1OOo7mtuitlXlCXNTVvQ82pldLEU1TxU3U/wAVtO9rJb7ddl534260XYm8mP1Cg4b8jXMXOnspPy4HQHsfxr0x9OtZDlklJ3M7EXMqmQsc/Phvmx0UNnaOFwOKp3mnWEVncyO0kCQx/aHuGke5aFYxubAYscEKQwXBI75wR6eGzJwajJtt+X/BZ8NnPBUcTTnVpxhCMU38b6K73ikvm0ktWzyiaxYdAR3ArGu7JiD8vOO9ep2UFreyXAiaNo49yB5Y2mPDYGEUqdxGTjtjkGlu9HQuqR28sryKCnlWrRKwxk5Y/KvcYdgePcZ9mnm3sqnJNWa3PzbE8AzxeG+t4SScW7Kzvd3tolq7vRWWr030Oev77xHdTxJNqUmjL52TujW3ht0BIZpDuVmbAyI93zKQQRkGvHviTaaw+keJdc0TTz4m8Tvo1xfaTpOg6QZ5dUnjQi3VrYO7IzyeWJCzfIWBJ5APR+JfHPhjwvbXPiTx1rujeHfDlmTc32p+I9fTR9ItisZzJJd3UgVQApJDNjauPujFfkvf/wDBdL9i7Q/GPxm0mXx3qPiGx8B+MX8P+CJ/2afDN18Zm+KelDQ9KvJtQXW0t30KzeHUpNZsRDLextIunpIrDLCrrZnQ4apwxuJlTpRs7OThTi2k5NOUv8Nrv3eaybvJGeBy6txxiJ0lUrVaMasXKX72rJLSPNaypxVpN20lyuTtaFn/ACQ/tG3Oq+OPi5q1r44t/G3hvxBquranq3ja08R+An8I+LfD2pJBeT6tENL8uK6t7oXchWSCVIZInglEixscr4B8H/Duoxa5omi6zqWp22jzOX8V6rH4c1nVfD+nxhEMo1Wz0m1e4eNoQtvBK223WWWJ5JPLXn6i/a//AGv/ANnzxv46PxF/Z4+H/wAV9d+JHjPxp4h17xTYf8FMYfBPxR0TVLbWfDGq6OdOttC8NaxJJE1pe3Wla3petS6ouo2eq6FuKtB5cMnH/BD9u7wffeAE/Zj8YfCr9n/9mTw/ounHxN4b+OfwL+CGo+JfFvjvxBfz2kF9qvjRJZr0Wrz2FjPBNqNh59rPc3E0r2kENxPbQ/hHDGXYKObwlmlelKKqVKslKyjUb5bKc5uMEnJS95SScpOTnorftuPwOIwuXTp0uZNJJJRfMkm05Rik3onole6Vrd/7hfhd4Q+Fuq+A/B+sfB6PwfeeCLXw7FoHhq/8GRW50u0tbULFJYo0QyvkyxOrwyfNG6sCA2Seym8IOC2Y+gzjHFfJf7EfxX8KeAv+Cb2n+K/BfjPwD8ZvBvwX0Wbw14d8UfAr+xdS8CWel+bBPb/ZodPnkt1t9GXVHFykmL0Q6bJ5sRl2x1+VvjD/AILe6lrXgr4e6beX3h/wT448OftWXnhX4oXHw9vX8aWvjXwHpLTX0PiDSDboshs7oW8+mGSMOss0EVxg284hf+s8dx5QyKnTq5zWhRjK6V5XirRhJrnSVPRTjZ8yT1avFNr+UavCucYrH1qOX3qQhJq8k1Ldq7i/e3i09L30aTdj97D4Tk3ENEQu7sMfnUdx4WbcsYjYFR0AySTX4m/GX/guV4u8Q3Emjfsi/s26JqTSq8c3jP44eMVhOlMS6rdW3hzSyyXtvu27Wl1OzyBkgblB/Onx3+1j/wAFH/jQYv8AhNf2t9Q+HUUk00eseDfgd4W074a+GRCwjMASeFLnV9+2Rg23VF2+WDuOSB4dXx44WpUvbUa8qtrq0Iu6eu/O4K2m6b+KL16fe8JfR/8AEji2hHG0o0qFB7SqTbbto7RpxqNO62nyPVP4dV/UH478U/Dv4UJ4ZufiT4u0HwVb+MPGWm+APDc/iS/TSrfVtY1eYQadYRNJgGWeQqiKSNzMoHJGfoGw8ItGgj8pgw4YMuNpHBB/Gv4QvEul614e1Pw5b+MfjJ8Y/iXdP4iGo2kXjz4s+KvGS20rxXSma3g1XVbpNzPHA5Py72hjz90Ef2Z/8Ez/AIweMvjF+x/4P8W/FXxOviTxp4V1jW/BXizxRf28Wn3d5Ho19NHZXV+yhYzM+nmxllmGA+/e2CWArKfFunxXjp4HBUpR5YOcW/tKMoQlp0d6kOVK91zNtW16PEjwSzPw7yOhm0sWq79r7KqlHl5XODnTcVeWloVFNuWj5LLV2+prXwlOXwsfy7h24r4K/aS+KDeFNf17wZ4z8VeELDwTq9q3h+30S61CKx1vUL+5guBY2kcqzK6zTSIFK4iaSGZlO0rvk+vp/wBqv9mTxNoV0fA37U37OmoalPp/27SJbH41+G720vsxGWH95HeMRHICjCRdwxg4dcqfwF/ao/bc+B+t+KtMT446R8OfH3xu8JaKviLwdpmja1P4y8PW1o+rW0893cNpqTWltIbW2WKC0uGiku0DScRtK0X2GAz2lhaFXNM0q0qcIpJOq3GKd0072s7rm5UneTSit21+f8N8PZljccqfsJzdvhjG8l5pPore8/srX1+cNC1TVrjwR4+b4q6h49ttUubPUJTpFvr9suj3GnQXsllol9cABvJtYbsLuEzo7LHafuGWN6+QPGvxVn8S61cafpt7fLBc3097qMUPik6xpWrNEHhgtlvTiR40iLQfK7BllJKkMAft74h/tHfsy+J/hJ8Rv7P8SeCPGbXXhy08R2vwz0OJvB02iRpJFBPoc+n3DaeiiALHdhVaby47nMchf9835A/FrRdU8B+E/Bni63sNT0mPx58QNT0SPRIoYlsbG7NvdapLp0Nxbu8SraxotvblSxeKCZi8hhMjfh/iNgYYvJIwyHGQr0YQUp1E1JySqcr5pwi173M7qLjdOV17zv8Av3DfPHGNY2hKlUcmoxkml8KlpGVnolu01orPTT2i/wDCngzxP4b8O+G9UvNcPhXQrZtH0n4R6ZqzeHPg3o1jqAVdV0t9As2htbyG7MMAktr1ZoS1puEROMdsnh7Q/AQ8G+HtF8E+FvhroU1pdTeFtN8NaNZeGNH8hxbPIy2kWxX3s8cqsAoH2htowxx8P2/xfuVt10NbifSo9Lljv2RZRCwnULlpXUhzjZwqnaPbJBu+NfGfgvR/A9t4r0rxb4o8RfEjUPD8t5cGezuLPTfDV/Klp5VlLdbN+wF50YpIwXyV4wVU/JcMZvCvgqmHcrSpUpXs40r31+Jpyq823Lo5bXSuz9Ohh8XiXTnPXmqwV3GdT52TUYJavmd1HfVux9c2finVzfzQT28mm6Va3M6y6jpultbi6t0icxXMbyRbwJnyjJtLqhUkndgdxeeIfC1xDZx23xN1S7iaxed57zw+2iW9rcmaYRQLM1sAEc+WfN3Bd05yWxz8keMfi58G9S8F6l4W8G/D3WbbW9R0VbX/AITXxO7Xuv2F19qMxnt5Gv5ZAnkhITGsQ3Yf7qndWtr3xq8DeKXtrPQfgl4Q8KaQPhJP8NLy2ht7FZn1e5ltnPi0zqgk/tFEtwgJJ2i6mOQXFenHGYbCynDmpVbx3Tquzd9Fbl95b63ja2+p6cssxeIjTnyVafv2ty0lore87t+69dFaWj20PrCDxB4YtrbRbS2+KGrwaldPM2pY0e5tLCxuAsZjiSdUEciytvTzF4HlDnoB2Pg/VPHdhoJudB+LOh6XK1vqbXfhH+0GsrqaGOJY7hEhZSm65QIFBKM+07TkZHwlD8WvhzZeDtH8P6p8CLL+17DSJrC+8WWF7Zre6tMbWKCC5eRgh3JJDLNyz5Mx64yfC9D8fa1pdjBBNZXZvIo1RNVg8TajaT70D4kMJaSFiHZM8LnYFzzmuuWZ4TDqm6co602nySrxab5dJXUk2+0V7N63s7GEMlx+IdRTjLSorc8aEk0r6xtJNRXm+daWvqfsFPa3dp4E8I+OL/8AZs+H/hn4iWvkXvgz9tv4LR6p8H/2rNItFt7jSpbM/EXw9f22tKtzbTXGnzr9pt5JLeeWCTzIXeN/vn9kL/gox+2V4I+K/wCz78DvBPx6t/2hvhL47+NXgz4e+IND/bI8Iv4t+PXgbQNY17TtF1G10P4g6Le2U15NZ2t3PcR3niuy129up4YUuL6MO8tfzg+F/wBoPxToehm20jX/ABZfXTBTqGkXxgm8J6qykrK5NvLGwkVlVk86CVgw/wBYCM17t4J/b71/wB4o+H/xt8b+Fry3v/hl8QNB8cXGvJ4EfxjZW1zomoW+q2jXVlYzWc14S0YZbUXNnJdrC8C3EZcSLjSxFDELkg23aOlk9r31jZr5p6ddEPE4DFYN89SK5by1Ta7W92V7/JrXpuj/AEx68J+LP7Uf7M3wDuNMs/jp+0V8Cvgvd63fLpmi2nxX+LegfDu61i5eMSpbWseoXcLTSsjK4jjDMVIIGDX8B/xz/wCDk39qD4vpe6Z4C8DeTNJqE11a+IviZ4+1rwj4a0q3mjaO609fhz4O1C0tbuzmAZI7bxJ4n1xollPmSTFGEn5Ta7+3z+2pqi674V0b4+ad8D/DMervJd/Dz9mP4f8AhP8AZ48D3jTzSG4+xf2Rp51J23l5ZZ59RkeR3Zw/zYGUXVqNxhC2mjb63WvKruS8rwfW/R37GMXGVSV1fVLtbbmfwu9nflmultbr/TA8Z/8ABTz9jzwVrp8PyeJfjV45uPsi30erfBH9kD4w/tDeELqNm2jyNe8L+F9S02Zu5jiuGcL8xUL81eT3/wDwWj/YI0+wm1OfxN+0PBZ2uq2+j3x1X9iH41eFr60mup4raDFlqHhW3uZkaSZFaS2ilWMBi5RVJH+YTqHj/WvFHiaxTx/+0P8AGrxjo8tglxqeta/8YvGXi2eKd7aR3i+y3mqyxyhJfLhJkXB3FwFwAPJvEP8Awg8tus001rcX9vq0DWFvNp02sLbRiA75xOWLBtxEYVcYVmJropRSbdRXXbb+mZuk3CKUrS6tWa/LRPzb9ddP9ULWf+C3X/BOfw1NpsXib4mfGXw8us61B4d0q51L9jj4ymzvb25YrFAssfhZ1XOB+8kKx/N9/hsfR/gn/go7+wb8QL7StG0H9rX4E2PibXBnSfBHjX4gWPw1+Id98yrhPDurvaankFlBU24ILAEciv8AJhs5fCaRmXRLue+jXQIZb9LoPbro97ISZ1tV3fIqkJsnTEhK8sdox21h8VvjJ4fiGl6B+0B8VV0IxgajompeNZvHFrdwyMI5be5GqLdMqsnmbTAyMA3UEKRf7iUtYtLyadvW9iXQrKK5Kib80191v8j/AGOIJ4LqCG5tpori2uIlnt7iCQTQTo4DI6OOGVgQQRwQalr/ACUf2e/+Cg37T/7JcXhXRPgp451z4e+HvDTvqHhaz+FPj/XPhRBowfdCl1rmiQNeeD/E0luHBgi8TaDdxKvEjud8j/0Z/sf/APB054q8PR+DfCv7XPhaz8f6RPqNjoGrfEKXRbX4W/EDTLGK1ZdR8Q6hq1gZvBurTyXAjcwyxeCoIYZshJGjxJHs4tXjL79Pl2/EHCrD4o/Na/O26+aP7dzDCZVuDFEZ1QxLMYwZVUnJUN1xnnFPOcHaAWxwCcAn3NfJf7Mv7bX7Pv7W9k0nwd8WC+1q00O38Raz4P1xYdK8V6RZ3Sr5d0tuJHjvLXfJHF/aGnSXNizsAl05IB9/8SeJUtoZrOxZzcsWikuEk8v7KVba2OCScqR265BrajhK+IrxoQV3p1TSXe6e3X8jwM1z7Ksky+rmGKlyxTenK1KcktoppOTei5rOK6uyZ/mL/ti+P/Bf7UH7W/xr8Zaf488RfE74UeI/ifqHjv4a/wDCezeJNU0G0t71kuEbTvDOtXTf2RJA09xarBHFDhLUFYhG6KuDZaFouiRwx2d7qISZhPGiyJp2ns2QRJ9miWKPjagJYHhB1xXz3B4futP0jS/EUVjOTqfhCO4Wwt7iO01m1nmu/KggMhGI551OY5FRghlG8K4aOvrv9o34ZfDTQNW+Emg/DCy17ToPE8Vx/wAJVbvNrutXiSWcUUsMs6XEiSXBybhpktWiWbyVVyoZcfnWd1JZjjKtXEy1qOTatp1dkm2+WN7RTbdlZu+p+r5Zi8FlOWYbKOSMoRp8qcmmuWEUve2V2leTSS7JKyXyH8VLzWtSmutLW2tzrU/EOo3F9HYhLWOOQC4eQAIX3uq7ZCF2ndjd855ZtP8ADj6DPplv8Q9OvrK0tyIorLXINT1nTUEyKxtJWihkyGdg7IzGUOWBGMmP44yeGPDGrW8Nrpmt6e4gsNONlrV1JqWpI00SpdOJJBlI2mWVod7FokkjQs20k+M+DEGpapYzavbw6TEGS+gm1a5Nh/aPmMqpGDs/fTzgMqEqA+05ZBjd8tSyuo1CNN8sYu691Wb3Wjv2SVtFr30+UrYJTzOGGoWvLWNkmu/n7u1rafp7z4L1j4ufBS+8UeKvhD8WfiV8KNf8VeHW8K+ONZ+HHiOTwjqPjXSXtpbVrDWLVSdO1aH7NLMsEerW84tzKXhkikxIPOdAh1PVrTVLl/F2pax4afWFm0zXrPUp9PstShWdluYNQMyhWuLOSFI5kQy+WgaR2EeM/S3i3xb+zp4Y0S1WLxR44fxdcC90lNCXRr3VdKu57G4jtpYr4LePFbW1xJvSPz48vHmRVVQWH5vD4jfD3xY7fDTSfC2lDQ72/ufEOkx+LY0vrnw/qzTxy24spTKjFpZp5lYu0kqxzGKJAgeSu/P/AO1MRRo4SvzunT95XUZQjF/HKKct9FZKya5uqRz8TYfL6kadfCUf3yspzjFWaSWktnzR+ynole3Q/U34WeNNb8M+I7a0S803X9Fvr501vxHY31kl1Z2m1vsUMmAm6MElmSN5dzSM7bCQtfRqeNp7DxDr97BY+JfEEkaWtqNG8Pabd+Ir+8mfYoW3soVeR3VW3OY1JVFBbChiPyx/Zq0a9l8Z6N4Ncmw8QeK9ZtNFudJ8L+C7vwP4W8Oo4jKTRPcidrp43807omjjLSyBj8mD+s/hz9hG4uPt+qa58ZPi3pM+mXT6VNqNn4luvC+p3iwR/vbmK60wQusJiD/vlZQPmViEOD87hcPhMApxr1GlLZ8j95aNtRWy0tpo9LH3vh88fDKJewheCnfmnKMVtbSOrWrTs3Z7rds+dfi78WbW/wBW0qyTSNa0TXLS5a0g07VNOe41W7uLfchMCBWEayPMFj3kndHkbgRX1T8Cf+Crf7WvwN8EXnw6+E1j+0L4e0m5v5tU1BfA/wACPD+tWVzqEkUFnNqDz6xpF3J5nl2cEbIHaECHPlqSc/K/xb+DPwt8Ljw7rWgX3jAXlx45ttKtZ/EOs3oi1ZGeO4mbE5Epd1UyYGHIYerKfhX4jeHHl8b+LLPSfFfxYaceJrnTtP0+2+JfiG20wJEG+Wy8u9VEgBAAYBR0UqCRn7jKa8aDisFUlBtW5lzRettNGpK9r720TPO4r9hiac8PxBRjWpSnD3Goyi5JStL3ozjeNpK9r6tXPofUn+Ad1ez3fif9g7xJqWu6pcNf6vrn/CmLG5l1G6u5Hmubk7IMRyPK0spiO1o94GxRtFcJ498VfA7wdpVwunfBL4g+AY5p5zFbaP4DeRVvJUYS3DJZOzxliuXd0wwKZOcA+H/Er4X+IodJ8Kal4c1Xxuj3nhEarq8nh74j63JaqXZPJe5jjvECz7RKZSd5Y4yfl58h8Yabqw8KaY02rav4a1PTtaFjcSnxbqV9qDL5cjeZeN9p8ydZMxsxkkOM9CFAr16lWti405VpqSb101T+9v8ABnh4jDUI1amGpRsoJt69Fa1tFbfsz6h0v4geEf7NlsbfVfHGm/bYo5717ksDswGdJPODosXyxnawLbUGdvNfRvxE/aP0/wAWfse/DzwF4p+KXgfUfiR8O/2wbv4oxWerWenWXj/XPD+qeAPEWlzX/wBotoUt1sbC8mt7WS2SJFikvLSUBt21fzPTVfCHhDwtNqVx4xu9VuS8emyavd3xup72bfGjLawPvnliyzPtUgLGkrs+5ST0138RvBjWGum81J0vvDttIWvk0VdVXTonIZsIF3t5ZB3KjP8AMwOMMAPPweJxeWyr0sIpeyrRcJx1tJOyu1rqm15pabNp/M1MJhq9WlOcL8kuZd1pZ9G1dPXvZdkexaj8X/BWjTQXsGo2erK6zXH2bSdSGqy3PlCWW58to0YrIGVzsAJ6BAx+UcVr/wAcINX0ltH0/wALatdDUo4NPW/vmuzNJJFE6vImZEiBlDCSaIRGMNGrqEIAF34o/DnTfBVl4P8AFthNrF5e6nqNpaX0t0tu1vHGtrcSzIu2BSAqnluq+eehHHmGsXs2nXGlTRak8ttNp0iuRta4tXsvMnM0TYASST93G+BhkXGAWJPbl2Hhg0qcftb3u+m2q7d2rn1mHpQjh3OO689vvlr8o3vue/6b+0B46uoNMsZPBl7FoE8q6hdJb6LotrM7SRxszkRQrOrubaFGV5VC4yygbg27a/Fn42zWcn2Pw5m1nX7be2MniSBfOd4YLWR5FSDLM0cEEZO7LLBGOQK4qy8DeIbcW8mo6jqGjRaholjr3lLdJb21tbRZlLgBgQZCh81XIyowzAcmn4r+LHg74ZPBomnalqfibxJJewa3Nah5dWuYkkKtNBdLHj7NEySOsMMhQ5jyIdo8w+pTqY2SvUqSVlbVz2t8OstvLbV9wq/UYuLpQjK75lZU9725rKG/nvoux9B6D+0J8d9d0mDwn4gt/Fel+G7GX+yLWK81ywu9AEXlyQLaWkU8Cy4RJpdrYRdkxAk3EIOFk+OngTw5Nc+DtUurTRtbYGLUdLufD0PiTVYtkd1HbNd3NlbzNayqJY3WGVkl2SD5NwCjxueX4o/EPw9qF14Xi1Twb4MvrK21yXxL4h1CFPF2sWmqxeTbz2UqmdrC0aJXh8zebxkXJltlHknh7b4b2miTJHBby/2lp2rtPdQ6a0MujiKKNlRYwB8yzSO0rAbcvg4yxx3zqV6EY1HUk7KybcrW25Y3e3ktLLVM4qShiakqPJGN5XaUY3va/NJpb+ut30Z6F4u/aY8WST2+j/DjwfpOk6boMp+0+ItespJbzULZZYo2WDS4JTFbg7AUllkMvzsHtkYkL5t4q+M/jjUJtWfT/HOpWWhX8UH/AAkHgK/8hNBv3tv9ItG2kee7RspZZS5YblXoAK+Ufib8MNU0Lxjq8y3Zt5tV1KfWTJaSGGUC6kachpEw3DSMACeAo4rvfDNl/Z3w68RSanfXt7cy6giW819cy3ksgNnKrIkkjFkVSYzxxk9qqjUqSnGXNbbbTy+62j8jmrKEKbU0mknvd+f33V9tPI9L0adZS811JfjzI2kk2Mbe3lzy6x4GCAD15JAPJ5roI7OCFDcXGj20NvKuIS7h5emVD5J2lgO/446Vwek6pDqUVr5sUMbCFpliLbjH/Dy3tnjjp9K7F70X0kOnSCSRZY2mlcw5hhMS/dLZ6sCCvHIzXbCooxu3oZU5yq8vs1vsemQ+GtWtdDj1yRdOtRcwC9ttJ+wrLJNB1EhuQ2FYL83lgZ5wSDVjwn4XuPH4uZ013TtB0yG6FoHgsYdTu7mcDcE270AX5lLPkcMAAxzjMsPGVvYeHH0i50HT5JXjSyj1C5gK6hBtL5YsGAYESKDkfcWP+7S+E/H+l+HIJozoml6hbwvM91FdW+1J2kSBEBfcBmMxErk8eY396uV1eTmdTZXd9FoglVmqLqqSVrfIzNVsbjTNU1jStUigN3ayG0uWEaRtKwc8sBjhs7sYGOQRkEm9qGl6TbWiXZsLSKRXiaCWH5ZVO45LH0xiuU1Lxno/jC+1LWrHT7LQz5UFnJYWMBsUSWJwjb1bILH5yWU4JUc4zUbapPeQ3UcxhSCSZFtndhGqBWeMkNnaRlBnJGCTzXPTq+1ipw2PQpVYSpRm9eZL+tTo7600m3htpFudXguntvJiFtcNNlTh3OwqQUPcEEHHPWvPdX1+Tw+bqD7fLqNlqOnFolljWzleWQqGO5MhiFCnj19xX0b8CNL8Catrurr46ihfTYvDbNaJql3NbgzG+MJkgMbgrtCrgqcYlGRzXz3rWiaPrfxR1Lw3p88Oo+G49Y1C202O7G+C4iS4jEYV/m3Rrny9+SzbCfmJJrtlNUMNDFTlo76Xu/d8vM4I4iNfMZZbCNp+6r7J8yWl/mavwh/aZ+In7M/jzSPEfwS8U2PgmSwu4tXvvCl1pcN94Fv7yMybNRk01ZofK1BFAjj1CxmtL5FKqt0IwYz/AGNfsA/8HPXwzv8AQrLwZ+3Ho3jDw3fWkEdpafELwV4P1j4rQ3XJUFv7NsmvLhEXy/M+0WkNynJWTUhvnT+KfUPCOoaRrMMNhavYafpt7M7p4dmOn200HMSIyiMIsSs6sApDcYyRxXq2geHtM16CxtArPqVxbmfzLi1WLyvKVpsu6uVJbdbFQUOQX6AYHVg85xGFtOm06b+y72fn5PzVnbQ8vPuFMrz+nPC5pRvNbSXxR9JLp1tK6el0frNrH7Od/cXvg17b4feOfDiWMct1481TUI9T1i28VXttrEF7oIto0YizhtLeD7PPHCV85z5zEEvu9D8fT+PNW8RaB4lvvB2mXmreFba5g0S207+1NLt0N2oglmuRMjB/LUuyRb13swy3HH7LW8MUSbpPMMBYqv2VmlkBPYrgr79fX2q0+iQ3IEk4PltGQzzyBcYO4ZJG3oc4/KvxCosTHkpzqOSirK9lo9/htv1+/fU/RqeRUaso1K9WUmk0m21o1azUXFPTRcybSStayP5ofiB8FfiR8YbyJdX8D6q1zqVk+o6pcaXZi3iaYOpjgRJMr8gIQlVG472DYqCx/ZZ+PesSfavEmkadpC6daKdHtrPSEs5LhYXYxW/mS3SeUx5BlwQN4+U4IP8ARdqOn6XYK/lT2cs7RmdEuJ/sVvCgwpO6PlhkA1hxapo0Isn1HT9D3XLlZpw32i0CFMhvmUHODjHvnJzz2U8wxVOPLBLl9NvTtfrbsdzyfCzqwrc75opJWtt6dv0R+Anh3/gnH8VPEmprrWqeKbLTbGXX5dch8O3+izao0CXFw08sMV6l0Y4vMba0hhRd7KCd2cHIvP8Agi/8Qr7UV1dviZYWkhvft1m+iaW2k3FoVRkC+e7MeBJndGUdSThhwV/pOSOz+xlbe20wbtsjQ28ETjqMO/twCMAk7elXobvSpIUhhRftSHEsiXCpCSSDnyFReRn+I8H1qquaZjWal7SzStdKO33WfzuZyyXAuPJK9m77vfT5fhY/DX4U/sC/HD4FLLN4ZuNY+IWtXVwCdS1bxFpyT2a7SS1ss0hy3KKDwyjncTX1FqGlfth28YXUvDvjGG2B8uSygns7+0vIyxYiR7RjzIzvv3JkgKGBUAV+nYs5p7VLkzWkNvE4RXnvHdVIzgbFy+OTkYwe1UtO1K3uI7h5PtFmsUjI01/p7aTBIASgMRbl1bGQSN2MZAzXBOFXET9rVqNz7tJ/K1kvTQ6qVOpg6PscLUlGPql21do6+p+JvxV+A/xK+JkdgniX4e+MBNHqNprYzaRFbi6sZjPZZeVQuIJj5qlcOuxAoxkHxy9/ZE+L1nJrvimfw34v083rNdXVxbxraOr7tokOWAJOflIHGOcZ4/ocsNQUTMbLXmWJDlrSG5S7nmJ4LAEqAoz6dR1NVrmY6neafp13fNNb3bNMbieV4UaSI7lXyAcOoOD14wMgnFa0adWjQVL2l4pa3Sd9v8jlxGG+utLFS53prK2ttr7d3977s/m3b4R/GXRkd9H0fxXZpcL/AGfJAtu8Nxeom9lO5YCjgBjgLjjPLV4brH7OXxUvrhY77whqIMm6ePT49OurnylUczAC35xuAOB+I5z/AFe6voxmnW0juITEsZnSeVmjdWU5VSuQMEng9RgjBrg9Q0zULoyC4tLfMMrKzWunIfIOcj5iSFOO4IBHIr0MPXnCKipf8D06I5ZZcqUnNPX06dj+S65/Y4+Jh1Gy1DT/AA9qUaae7pFZW+iTrc3W9JUKzElSBiaU88HI44ArV0/9lX4ogarNP4ducXTB59NutHe3hm3RAFy5CM3KlCCOmDngY/p21vwRZ6k7NqMySW/lgq0cYtbsEnP3owuVwAOcnrya46++GuhSxiSbT7LVY4o2VRMwMoz/AHpjzkYGSRkfnnrdaVRqVSbva19Nt+iOKeU0ZS55Xbtbe35W7s/n98f+H/Hvim0t9L8QaLqHh+1sI4lsnsrV47WFFjeOULPuzKsmSCjAZx06V5jqfwUvNWtY3uPEiTxaekrwXN2b6O3/AH42yyFioDPICFbueM5xX9GUnwu8Gy3FwL2ztIILqNC7XTyHTkZcD5VXoT3YZ7etEv7OngWa6i1S1k0+OS32ukVhfFoZGHJDW7O2Se5A3Y24xW/tZdakl8/+ARPKqVSPLeWqto/6t5n4KaxoHxQ8daVo2lQeJo7K/stMh0g6xommy2mqSwwZVUVXjdElcEgylWKjBjEbYkrmPC37FHxC05pruzshfwzmWUTanqKrdXTytvaSSZslpCzM0kvWQsWY7iSf6PG+FhtIhJbC3MYXMSW8RVhkjIxjIP8AhVK5+H9zHFO09iI44ly0ktszKQOyghskYGO/StFXqOXNLETfrb/5E5aeTRo2VKUlbbVf5H406B+zh8e4tGfQ7w+GYrGHQLXQdJnN01zLZJbRSQxspSReUWV8K2QGO7vgYifsafGJd6J4i0SxE8iTPMdPk8p3SUzJuKz54fpwPxAr969J0XR7m0ivPs+lOJkH2uC7nZZWlwoPyBsKTggqy9xW9caD4btlUG00k4QZS10+KZ0z0UlSwB4711rMaslBSd+XReS+RtDLVS5uWUk5avW13p2P55Nf/YB8aeJZ31DVtW0uTULiQ/aH0uwmt7MDAXcAZiwzjJ69DxWBf/8ABOnxBPpf9kyeI797JLpbqOLTrmBZS4UjaBPGTtI5KgnkA1/Q7deDdFmEbaPDc+azFisypDYwkg/Mw27jnJ4AwKu2vhS2c5u7S3vMDOATsHQMAX+o9K6Fm1a1tF8v13MXldBx5ZXa9Wfzh3H/AAT+8W6XGlpHc6xbQxxH7P8A2hoUs0kuQSpFzFIIxyc5K45GMCmv+xD4pkRA3iqCVoiGe2ks7nfK4XAST94ScnlgBk1/RuvgbwVG90ttpskb3DhZxDdzRg4w2AwfYuCSQFx1HtTrn4Y+B5nt7m505rkWuRCtxfSSxcgIN8avmQrg4LbsZJzWP9pSWl38pP8AzGsnw6VkpJLzf+Z/ONP+xJ49YtnVdNJuAFlMpktTcYPythkLHHOMHoPesq7/AGD/ABrc6dc2sGq6bHb3S5eEXjfZ1fKgMC0e7jaDj1Ar+kS9+C3g6+bDaOjEwARz2N7LAsKkHDZLcgY4xjAGfavNtX+C1jaW8TaWurT3Es2wQzzzTBRwIzyQOSD0x069cZPMZTunKX/gT/zNFkuHcbXdvVn8+ln+wR8TLfZatqXhaeKP5vOSZ7V8ZX5ZgY2yWOSSeM8Y5NdBZ/sM/F9IrmP+0PA0EAJMIi1CQ7g5djFsaPjBcnduwc/dAHP7ox/C29t1/wBJs5rWWV87zbSiG4JA5Pzg5PHJyMd6hv8AwVaWzC21SW5tNNELGaVLya0mTcp/1TRyAn6ZHB7nms1jVG3LKSt599whkNJWUJtW21Z+Jmm/sX/FXT5ba5tPEfhjSb+KUPGX1tQZySQYw/ln5Rk8beuMHgGk8N/sEePdM1q18Uv4t8J6ReWzSSMbjUI5LSZ3mWQsF2OAQQAAmP8AdHNfs5Y+CvCduTfabfa9qsYt/OmeTVbvUkhU4AMi3E7rnOQAACR0BxXR6Z8OdD8TRte2/htp1WTYmoXmmQGSF1IBMbspD4z99CwGRyM8TPHylD2fNLl9X1KXD2HdT27k/aPd8zv08z8gtM/4J/a9rEOpvcfGKG2i1VJIy+leH01CWAvJHKJbe4aYKxXaApZSuCflPFeo6D+wfB4ctVkh1H4i/EK8hfP2a00210G3IXytyhhGpAby4zhC27aOe9frzpPwd0m1ij865kg2P5ht4I2gXAwADhsAsAM4GB7Yr0LQPDnhvSjLHpdokbXE/nzB3RkiboX65JOOSSTwOeMVyYvHYmvRVGMmuia3V/W6fzTOv+xcHNPmcrvrf8ddPwPT0vo2XEUETRnLIyRgoQcjcyKwIHQ5HFcB438cros0VpDpWuahZxTCK/uLFx5UWUBKPHuDEgMhHH45wDxT+Jrm2Z037BKnmyQEGGAFQBtDghuRnjkZB61FNdeH9StLyfVLCN5ri2NvdXTwCe3vFAI5ibgsMZXkHpgkV4jqU3ZvS59NTw8uez1sdrfeIfCun6TBql9PPLplxa/agb2zS0ndOMBY2xIo3Y2htp9RXjd18aPCcki21tp05thCfKmNpCk0TkoqJtBLY+U5PYc85FTavrngjVLf7DqmnJcQyWqR3FxFE8k0xhA2o8wOT3cgnAIxkbRWJpfhv4QHzLtVvbmWCNWktbi4kuTbEgDIiQFioyv7zG1sYBPNYqvRlpGS/U6o4WpTTdSL/Q9c0PxNa6rawyWkjFb0gxvFH5b45HI4degyGAJPrkY2vtNlp7CGOBluck3KXKlWJ5ypXrwc4zwRzniuCggsdRsf7N8LwayIFii2tZWMllYQNLyyy3MrYO5WVymCw5OD26zwx8HWnnk1XxHd6xrlpaRjGnrqIsLJQwxHNJ8u0A7lZS4w+Nu7JxW/NCovd1/ruc7i6b97R/j9x2ei6gzTW8kziCO5fySbdDI8RwdoYEHamBknt2z1q9fXMa3ZjMM98y4WzW3iW3vtzdcBpAjYBJB4zgE44FVovD2ryNYS2T6pYX9zC8dlpup2j6baQvbpm6Zoo8uYgFws0jFR5y4yxUHj9f8AEo0e51Ky1W0tor60mCTva3LRSNiJHGwumdpDhizDHzHjGM2owWijoYP3ndS1/robr6XpFi7E/aJbtWaeI6pP9qurZ5AAWGGOJQvAKnjBxmuSF7p2iePLHxZqV3qdyllo0lhbW8somsxvJMjwxkBvNchQ2OgUD0rmtQ+IrtZyS2FoGuZ50igjUK/2WJ8CRlUSAyMoPAAALFecHFedeJdf8VWOqz22tNJo2nzWYntpRAhvtRhyVmMhcFYMYYED5jwQQMEbOEFTt0Jhz8+u/wDwx9Ur4vj12DT5rS10/UWkVTIbCcW72jMSA8sMjebEozg+YQQW75pjWWvzPcX11Dp2n7V2tax3huY5ApbLNIEBOQVb5gMEHBOa8l+F0a2N5/bIW/vb/wASmBJfEFoH1jTJ4FJZITAqfuWZGA/eOdrZA4wK+i2uCY0kQTPukZRA53FsE/NvYZAGSOe3YYxXFCc4nVWhDpqcl4Ug8P6uqv4j8RJasttvgsLaJTdakAWVmSfaVkBAQ/u1RgchlU4NburfCzTr1ZNQ0Z7e2RVFuGs70ajbzwjJQtvyQRuAYZXtzwMUb+3trpB58KFEYlHMwDwOMfdYDKkEfeU8Zq5pvi3V/D8TQT2ya9ZswKXExWLWLMfLkBsBZumRuIbJ6muyE27OLOKcEtlocDe/DnWtLDRzNZ6uZVMgW3h8uYxZY4VCMEcE8OTx0zXKNpIhLNJYT2qwx+XEXs5WSAdN2du3HqV9ua98m8Tadr0ENpDdGFpX86YXEvlS2bNuVkaA4ZVJwSec+tPaDVfDWmTJ/bB1VLmx8m3sdF1jE1msxwWe3RV+QhMYwTzyQK6YSffU5pRT2R8tXp0+032kN1HBcRwi4eCGcRTKjEqzgLzgkEZYDnHIquZ7S3tFnVbq4hfDeZLfOZolPLEKX2g+5yT69K9TR3N7LNJb20/mWzRNcXcSPPGckkFmz8o/PknBqg0dmBcRzadpvmzFM3MIG117bdqlT9W546Vt7Qj2a7nDeDfEfh+f+1LM3KEaXO0TRrL5vySjzS0iKCTy0mT6Ac84roLHxR4W1i7i0/R9Yj1q/WZ7c2VoxSWALH5qoUcqFcKCSvAwM+taNvpll4Uu9QgtLNrS31RzrkotLdIWaRo41nkhXbnh0DBTnmTPRsVtXN9piLHd2iSG4uYfO/e2ogvgpHO9MblOeoPrmlGb6EunG12ZElhqlzE0D6RaWjCUXFpNqEiXAV42Bik8mIkEg4IBbGeo7VxOq23jdNWWdpL6bTkbffWk9l5mmPyAGtRCeBgElZR154r0I+I0+VJri0gLJmISTqpfryO5wB+eeKhm1xbZpVlP2Z/l8yZoypkUDC8r945IwM9+najmexUYLdI1NIka4tTKPK/dfMImg8ny9wBJUsTgDJ+X9OlX7S0u74+bD9lb7IGEksX+hxXe8g+UrHPzYADEZxwcDOKxbe1uNRU/2tK8VkzoVtDIYbu7OQyljkMqqMDB+Y8ZwBXYNf8A2e3igtLRo/KwI1WzS4togDzuAIx359xUWsaaND5tJmlt0uNSuZ9Mliu1RBptzLfRRRhQzo+77ylcck5XjHAFZRt2muJh9jnihiO2K7v7iOOKUAggBck84AIB59snGvqMV5aRxxXtrqFiLpojGwtMC5b5JQN6k54Kng4II56gc9eajJK6Ca1nIeV4hF5QeKMr8o8xuV6jqvr7VXNJat6kcsHpYx4C00btGscsiymKYKUMSGZBG6uGVmzkEAn5QTxg8jMvvD94JYdSK6DZCztHCQ6m/wBokaaPJWBm3qkKk5/e7X5AUAhuebHia10rxFquk+bDFG84gubeSRY32SoJU3DhlBEh4UjPvin6p4h1FroC2js7t/J+xyX2oW892bZjHJnNlFulnVD5WNijAkY471S9+XLb89fn0+ZnKMqacv6/4PyLek+MdI1GO9t7zRrrSZkuktLgahpC2lgZThhtmyY5f7xAyVGCwUEGuue3nhGLe5MD7lNw0UBmgMeRuK7cEZH8Q+UcYzXjmral4la10KdF8NT+EfEF9FaXOpazq83hrTVaSJ4Flit8Sz29wxPkhickhVYJkkZ0uk+PbDxTZjwt4qtR4aHkyajaa/okhtrKOLETy6XM7I0rMC2VYowOWw2cGKkOWXL/AF/XobUXzw5k/wCu3dfNeR7xFJI08cKsCoUpHJJMJIvXLqeB25YHr75qzHq9il5Gk7WUlxG4gkjjuo5yBna52E71GQw5G0Edazb2Z/szHcLK4MXlNMY2X7SG2jzlbPVehDqvIBye9GBdL04ySxaXYRX8kWH1VLFJNQvZCo3mWZV3FjtXJJOcA46YznJQh1fcuMXKXvadjNu7aGQWcOk+GUkt5VEcdmNTlN3EFAPmztMdpjLZZi2XO9AAcE0L4cYatabf3umefJLqKG7iMsHyqsUUC+TjaDlyxcuc7VPatzS9c1LxZd30l1o+rLpTag8Ph3X79YbOLWl+YSzxRxsJGJZPlaRFGwDAJLAeoeGvCiJOLOVJZzDY8zXsoAuHiMZyHzgyEM2CSAxVuBla5pzoU4c8ludFP29SfIn8K/pb9Dxy+0b7NPdT6bCE83yomglt45pzjcrEKRtAGVB6A461w114w8MeDbmS3bSJfD+qC3YiS608KGG3c0LOqlVWRhkOWGdwHYgfaNx4JszbXNw4guZbSR45bO1bbK0YHm+WjAkuAoZwFxnbj7xArL1r4bafPbpd6dogF5FbrLEv9nz6pDfsTvCOJImUMwIOWwq5OWGGFczxmHjdU+pvChWkk6239W7/AKnzp4Q/aD0jTNCtLC0u7L7HPftdyRz2L6dqdpcvsi+0LMhVQ0UZk2ruCkzScsWyPoHw74+ufF9gtxpco1uJrwX0a+Jbe30KS3nWNZZrprhJZAloSwwXhaRjkttQc+IeG/gjoN9fXWn3OiT3UEbPcXlvKsSajpzTB41gCxYEUTlnKuWB+UsFOA9dWfgH8OrRrKL+zfElxHFIsYkub6W6Sx3AvEysCRFHHtKhlQZGzdnBNclPGxi2qlvv29ev3f5nbVwVOSTpN3fkvw/S9it48+IGnarY3Ntq3hyPytS02HS7NDezLYWzTyy/abiW5BWVmQcWwXakoJJG0KV+GtUutZ0m5hitppxrmozfYXmvNZknuhaLkMZ3yfLUDDMSTtVcBuK+3PF3wmuLvSLkeHfFU0t2ZvLF4b9ZbYBgNygoF+b5Qc7R93BFfNuq/s5anotleXOux3V1ql7FjT5oNTa0nbf98PbEAyIVIB8xtoOSflrphUp15KUFr/XWxzxowoXnVevpqcbZeI5tKN3bavrvhnW7XRG+z+baXsHkST3ISWV+QpK4UDcASzE5/irH1fWri/WfVYbCwlh1WfzbWBYopYYA6pHEskhkBVmHbO1XJ6CsPx/8NvFtpHp93PYaQ620MOmwxw6Daae3DPsSCa2wko2AYEgBbaxG0/LVW50K30u3kaaWeaOKyS5uiLUJJaOWIbC5wQGRCzhm4MnXGK9GSnGlJtaLVWt/Xkc9OVGdaDi/ebs9H5enqfa/wb8Z6Y2gafpTSRaJM2y3gh3KbeOQMdsaouTkj7zH1Bycgn3PUNRsdga9kKxQxGe5kJIycZJYYC4GCAe3oa+G/g+mlzTzbYgl5Oq3NxuMdpLDcfN5rTBo/MKEjAVsDaVyAQRX0xYaleXtkwl0i4kt53VjDNbKYWKvsQiMALGu4Z5zgAcdK4KVpRUmb4hclRpbHfRarpl6k8WnpJEssa7rgsd6HaNrKpBwwGSO3GcVjPMwCrdSO8MEW7zN6vJI3Q7jgZ455Hpz2rnJfEZgklSe3lt1jOMRpHEXbHK8D5gCuAGHXuOakTWbK5jkuI/Nfz9splk5aJTwQEx0AOCpzx+BroUddNEcjZJfz2a4aTZKdpP75hM4ByNoDDPJPY/pWfb61d2E7NZ6vqViI0ZPKgnYRhGAyADlRgFenfHtWLezPJMfJDMFAiM0YRUAK8Z5LAdTnkjHNYUWnXEclwyi3aZUEUrRXDSSHOCr4OSeXB7deatz5NUwjCM9GW4NWSa9aMiS48y5aMi6s5B9oKlzId6Y2jCg7mI5YYzWtFPqDShLO2sjC7BzazPJLEmOUy2dxwQOp78iuO/sO0CPaxw28RklDyNgpP5pYMWyDkEnkqCeeewrYso9Q037T9lmluBKjw2/nw+bEZBxghuehOexORjOKcq6ekfyEqK3kR+J9d1GbUNDS4kSK/mkkstPa28yVZ2dA8sWcsFbEYYKcD5OCMYq7FB4nnhgaXw3eiMQ7FurkJaW+OmWkaQfeyCM8nP1xga3od9qlo5eCKyeAAwXUKRSC3kBDpMiHIPIyFwcheTzXT6H4jhOkJpTxxq2m7WvtGhhit7SwJHkqqNGqhkHztFvJOHbJGKuM3ZJLUylBLVbfqX18J3Xlve6hf6XbRRrHujtpDcTgMeQQVC7lPXAbqOT3saW/hcAPa3KXl0krW1xeS3q3cxbI2bDnCDgcADr3qZ7nT54Cl6ltJAGKTRz2kksmBjJzuBB5BAAPTj343TvBPhGwlnutDtp7CfVImikuNKUW6S78Pv27cbkJ3YYHO4Z937RNWaYlBbXPpK/8KWaadbWdrpup3V/qGmRXN5qOnXLRppEgYxylLhozE2dwMgAYxsMbu61YPCTeVc29pBHd2dmCllq8N01xNr7KyoI7aFj5zOeF+dcNuDZ5wOLstTubO2S2uL67jAAEQW/e3FztUKDncFBygY5z90AAjFS3124T7YuoXRZIsSpHcC5CkYYqu0lsHggJ3PasoycZadev9f18y3zSgoyeiu7ebtd/hqbfifVRb2Nl4dNtqljHoJltANcjVtTkuW+/vEeBGo2RoIUyP3e4ksWxwQuRAtvJPdq0qW7R3AhRrZCwGSERm3KDyQeenU9a5nxH48to7i2GuuA4fZbX14jgQui71G5zzjBPzDgDtV/SNa0zWrh3nvdOjV0eCBZC8NzPNHtLFOP9WASS4BDZ+U4HO13BaLQhQTtc+efif8ADPw34r8UweJrtdVSa+077N51jKVtA8G4xs5O47tj4+TAwp4GAa7/AMHT3uj3IgWW0ttP0nS4reLULjUW0/U445FImR5JFwV/dqyMGYnYAwJAY2vjL8KfGPjLw+dZ0DUzGmiwC+Ohy2wQzlvl862mVlcyRruKrtIY8HBIxm/DvwPdWXhnR73xJ4nSxtYpojFrF6BKLeQt5cgkupm+VnONsU+fvhVwAuLp1E5+5/WwVFFUU5tPpY62wuBFqd/JougeHL6+1xvtJ1ifTYtW1CfzI40kKTzplg6BTIvz9MgAZruo7C306K3GsPHokkFqXllup21KO+hVQB5Srkq/zDIALBSAFYYI424ttOhvZJNR1C/1q1stRXyNSNrMNJtHZjHC0jIBFCwy371n2FclSPmWvRYfhu2rk6nPfLBZ3EaSR6hpsSa1atycPKQ4JX5RgQk539Riiq4u0uf/ADMISSThyNJ9Xt/mcTqMen6lYprumWUekafDBDbNe6jeym61pmfdGLe0YjLsoykjqr4VgRxzo+HNSk8Q2M017p1rcaRC/k2l1eMtvO+7zY/nhTEqFNjBkClmaRCQ2OOi0vw7b6TrE1xpulwXviewt5bA6zokcOqadLE8izQma9mK/Z2KqgZArMQ7YLYNWrm6ht0stU8R39/oOoWpleze48PyW2jWDBVZmt5Dv2ld5Bml+Y8FNqk1j7S7s9jROLVk3/X9f8A9O8OaJ4TS5nJ+J+mWLPErRyy/2Vq8ESO3Cx4ZECfKhJyBkEHmmeFvFng+fUL+GbWvDd1qK6uLQakbyCI6jF/qbW5VAuAJEj+RM5C7eOc18G/EXTda8ZTWRsfCvgSxsF2m+a11qO2u7lNx8wHNoY1yrMAix5+b74xmuw8OTQ+HrC00bT/DiWGn2tuqKILi2vgxRiymSZR5kjZJ+Zuee3SuKWWVpybqVv6/r18jtjj6EILko69f6X/AP0ZsdW8PRbtSOo26o04eCeHUo1LqRszDgggLnOUIJJ6jBrrdD+Jnwwub+Wz1DxVrvhzV7Rkdr62019T8K30TgfJJMschWclcbCp6nBHSvzgbW9egs0Gh30VhKMFImtf3UYA5RY1iZVBycFcHPXNWZLjV7uGJp9Xe3vpgBc/M11Bc8YYyQsvQDgDK9fwrGeSKo7yqa/1uXHNnBKKp6H3T8V/jV+zh4DWK4g1aDWtRv90ctx4f0jUvE+us67QmwQLGoyWLMs4O0bRwAcfNT/HnRNf1GJvDuh+KNN02zTfdXPjbQ49MnlYna5tVR2KbwzMHZWx3G3keLX0J1q7in1WfRrm/t5tts4mazSzjXAXyyEEiZwCVWTBPr2kktL5HRP7StyincAdQmuw4AwOWQnjk/ezk1VLI8KpXryuvx+8meb4m1qMberVl9yPUtS+JPhATzSw+Fru71D7O9u+tNpy6y0kch52mNM5HyniJcZyD3rzDxX4vk1aOSwt0nuJLqKNYrFEu7KydNnl5/e5XzMOflVcE7s4xiol0O6mL3EetWwcRgGKa9eIkfxIcx7WyDyCeoqWymm0a8S5gWx+1KOLoOsnmjsCI0HIOOp9s161Knh6EeWhGx50/bV5c1eV2cJe+H/Fa29oupWOvW8lpp+2IXOlO9pZM6EPIhWIRrvQL1BCgHBHIrkL6xvYrK7e4s5tQWKJRKJNPW5hkXCquQgB5xtyOg9smvdoNa1b7ZHeuskN28kq3LHUBFBMj7sqqkEANkf4ehc3mmyxxefoGkSXkc4uLfU7iQf2vby5Ds6SBAq/MqkADaMHjnnV1E4ONk/UmMJKabbXp/wAFq54H8J/FV/4e8RalpU1tdHS9WQ3lno2nw/bUsZSfLkmkd38tSPMbevz4O0gg5z9Q6hJYJBbz209+kWxg0zyyrFIrMS3lqvy5ViAG3Agg9AePnTVfCM2o66mtWutzx38N091M4uZrG5m3uXlQ3kIWRkc4HUEZPBHFdBpviPxxpU15Z6lDbaxohP8AxLIXlaa9sPM+9GLmRS80YI6SYc7zliOBxcjjG1rWPQnPnlzp3/A7i/1q10q5hi1G31q/Egcx3o04SWi4AAikcMNj853NgEYOTg1Vg8Z6TIdsdjGkURKSSw38VxIvIVxIgf5VGFJU7iM81jv4zluFNld+FdbhTYy3MMT/AGq1ZHyrNEN55UZ2huxHFZ9ze+FJ3t2bw/qdoxx9nR/Da3zr8zMwZSBGFJOeSuW5xmtIqO7MpOWlj0a0u4Ndkkjt5DdTmQShlt50RhztV3CleQM8P74pZxZafGPNvbOOUuebqdoFfHI52jBGT8noM4PfzqfX5IY7ZvtXiq3W0kEUVnD4YkYzQtknKrPJEvJyVU9O4HFRT+LItTmn/tTQNdmjt8opu/DK3DSLsBV4W+Yr8ygFScYAqJU4uVylOaVj0ZJ/tUjpBPAMOVkVo5VtEP8ArOWbHBGT8oIGD7Vq2lu0ZkvIpLaZpE88rGRHG7ZVd7+/XI454rzy38baJClsj6R4jtEhRjCqWgSBOFwnk5AUErxgED2rr08a+DQy3gudViacjzrK30y6UJkDJlCKEJHovHv6w4JKy2Dmk+houjzslvdxGKaSULKkDtbBiGUhFzgE8A/LjKg5HOazr7whazXcl5p13e6VqDQCKG4R0khKqzMkc8TDDRnn73zYzhulZt58UfCNuPm1TVrR2ZT9jPhqaeGRkYESowTKHGQFY9846VOnxR8H30qmCfW5kgR8wDQmjiOcEE71XJGOzDJPQVPNKLu2UoSlok/6+8xU1S80iKGHX9PigKr5U2oW0i6lp04ydkmcAjgFxlBjPJyrV0dj4l08NdW1zrVvcXInVzZ3l7BYRWqlQvlJDhJA2Sg3SF8kA45BrIb4v+Cre4d1kvZ5cmAWUvh668yNSMgnjbuBAG4E5wAelR6n8TPh9qNncrceFr+6EkZ2Rt4WN/Ih4K+X5qHaA2Wzng9+a19pLRtXIdJN2SPRRrGnfZ43nQSF5AyQKyyNKrAjdG5IVvYHHUelJaatb3ixPHZS2cYH717pYriXYRnIjSQ7Dzj5hnjjIINfMc+reCrsPDBoHje0gVmaaSHS4oRLlt6MsDSrE5DZOzG0A4zkCuaeHX7q3udP0SPXYNNnk84XWoxCyuJpCpUPJGhdiAAASWHTGCMVTmk+YSotu3X0Pr6VPD6Tq+zzFlYRM7qYUkLfMRjj+6c7vSpbUeG5TJLaWltb3LO7pM4IuQeAV3rzyV6ZAIAr5W0q1m0ltPvZJfEOn6vFDJDrOsRanf6rFrJZwY5Fs5LfyoCq5Rsbw2dw2Ec9vpet6rcRwJPqtpL5Zd7eGSxkW5iLZyBvOG65yyrn0Aoh77V/6/AKlP2eif8AXkfQXnWk0UUEdwXRBsUwlVZM8YOeOvADYyQM81nW+gafok0utaHrui2moywbNS03xPa2pS8XzNzxRyIrCMkfxgdHIPt5XczPcLAlvO8m075orkIytgEghumc5yCO/Wq119mvY3hUrA3kiGSTUrkNFMcE/Oqjd2x0PQda19nFpx6GDclr1PR2+Id5qwkt9KjsLKKeJrecG4l1u1Ctu5RxJFCwXDgHkAKuSOM+ZT+GdPvortpvGXiHR7UyNe2y6T4gPhLR4JTh3ENpbbU+cgFsk79zZzljTY57+J0nOqWFwZkKzW0c009vjoEdGdGIz2J547Cuh03xLc6dC0T6T4ejnJzbyto8FwkWWyJFC3DYYEAr0I6d6qMKMVblRk1VT5ot/gdBonjzxOtuLbRodV157G4Cy3tzpS7IkzlpjLbBQW+UhQyHIycevqV1caH4h0mXTPFXjK20Wa7ZZ7+y0/UT4da8UtuWGee5j864jUDJUbIwXYbCMY8et/HvimBtslwUtSoDxW06WUSkjG6JlJZMYHBLgKcDHNai/EO/MturX13eRwsZJIX8bLPJcdD+832zMcMq4VSoAB57HGvh1VVoSt6IujVdGScqafz/AOGP/9k=\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW1hZ2VzL2Vudi5qcGcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWRjdWJlLy4vc3JjL2ltYWdlcy9lbnYuanBnPzBkYzAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBQUFBQUFELzRRR2xSWGhwWmdBQVNVa3FBQWdBQUFBRUFCSUJBd0FCQUFBQUFRQUFBREVCQWdDVkFBQUFQZ0FBQURJQkFnQVVBQUFBMHdBQUFHbUhCQUFCQUFBQVp3RUFBQUFBQUFCUGNHVnVTVzFoWjJWSlR5QXhMalV1TVRZZ09pQnZhV2x2ZEc5dmJDQXZkRzF3TDI5eWFXZHBibUZzWDNCaGJtOXlZVzFoTG5ScFppQXRMWEpsYzJsNlpTQXlOVFo0TVRJNElDMHRZM0J2ZHlBd0xqUTFORFUwTlRRMUxEQXVORFUwTlRRMU5EVXNNQzQwTlRRMU5EVTBOU3d4TGpBZ0xXOGdMM1J0Y0M5a1lYUmhMM1JvZFcxaWJtRnBiRjh5TlRZdWFuQm5BREl3TVRjNk1EWTZNVFFnTVRRNk1UTTZNalFBYjJscGIzUnZiMndnTDNSdGNDOXZjbWxuYVc1aGJGOXdZVzV2Y21GdFlTNTBhV1lnTFMxeVpYTnBlbVVnTWpVMmVERXlPQ0F0TFdOd2IzY2dNQzQwTlRRMU5EVTBOU3d3TGpRMU5EVTBOVFExTERBdU5EVTBOVFExTkRVc01TNHdJQzF2SUM5MGJYQXZaR0YwWVM5MGFIVnRZbTVoYVd4Zk1qVTJMbXB3WndBRUFBQ1FCd0FFQUFBQU1ESXlNQUdSQndBRUFBQUFBUUlEQUJPU0FnQ0FBQUFBNXdBQUFBQ2dCd0FFQUFBQU1ERXdNQUFBQUFELzdRRkhVR2h2ZEc5emFHOXdJRE11TUFBNFFrbE5CQVFBQUFBQUFTc2NBa0VBalU5d1pXNUpiV0ZuWlVsUElERXVOUzR4TmlBNklHOXBhVzkwYjI5c0lDMTJJQzlrWVhSaEwyWTBNV1poTTJSaE1qVmxaVFEwTm1KaE1qQXpOakJtTmprM05tVXpNREU0TG1WNGNpQXRMV05zWVcxd09tMWhlRDB4T0M0NE9UQTJNalVnTFMxamJHRnRjRHB0YVc0OU1DQXRieUF2ZEcxd0wyOXlhV2RwYm1Gc1gzQmhibTl5WVcxaExuUnBaaHdDUVFDVVQzQmxia2x0WVdkbFNVOGdNUzQxTGpFMklEb2diMmxwYjNSdmIyd2dMM1J0Y0M5dmNtbG5hVzVoYkY5d1lXNXZjbUZ0WVM1MGFXWWdMUzF5WlhOcGVtVWdNalUyZURFeU9DQXRMV053YjNjZ01DNDBOVFExTkRVME5Td3dMalExTkRVME5UUTFMREF1TkRVME5UUTFORFVzTVM0d0lDMXZJQzkwYlhBdlpHRjBZUzkwYUhWdFltNWhhV3hmTWpVMkxtcHdaLy9oQVo1b2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdkFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5TMWpNREF5SURFdU1UUTRNREl5TENBeU1ERXlMekEzTHpFMUxURTRPakEyT2pRMUlDQWdJQ0FnSUNBaVBpQThjbVJtT2xKRVJpQjRiV3h1Y3pweVpHWTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1Rrdk1ESXZNakl0Y21SbUxYTjViblJoZUMxdWN5TWlQaUE4Y21SbU9rUmxjMk55YVhCMGFXOXVJSEprWmpwaFltOTFkRDBpSWlCNGJXeHVjenA0YlhBOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOGlJSGh0Y0RwRGNtVmhkR1ZFWVhSbFBTSXlNREUzT2pBMk9qRTBJREUwT2pFek9qSTBJaTgrSUNBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSjNJajgrLzlzQVF3QUJBUUVCQVFFQkFRRUJBUUVCQVFFQ0FRRUJBUUVDQVFFQkFnSUNBZ0lDQWdJQ0F3TUVBd01EQXdNQ0FnTUVBd01FQkFRRUJBSURCUVVFQkFVRUJBUUUvOXNBUXdFQkFRRUJBUUVDQVFFQ0JBTUNBd1FFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRS84QUFFUWdBZ0FFQUF3RWlBQUlSQVFNUkFmL0VBQjhBQUFFRkFRRUJBUUVCQUFBQUFBQUFBQUFCQWdNRUJRWUhDQWtLQy8vRUFMVVFBQUlCQXdNQ0JBTUZCUVFFQUFBQmZRRUNBd0FFRVFVU0lURkJCaE5SWVFjaWNSUXlnWkdoQ0NOQ3NjRVZVdEh3SkROaWNvSUpDaFlYR0JrYUpTWW5LQ2txTkRVMk56ZzVPa05FUlVaSFNFbEtVMVJWVmxkWVdWcGpaR1ZtWjJocGFuTjBkWFozZUhsNmc0U0Zob2VJaVlxU2s1U1ZscGVZbVpxaW82U2xwcWVvcWFxeXM3UzF0cmU0dWJyQ3c4VEZ4c2ZJeWNyUzA5VFYxdGZZMmRyaDR1UGs1ZWJuNk9ucThmTHo5UFgyOS9qNSt2L0VBQjhCQUFNQkFRRUJBUUVCQVFFQUFBQUFBQUFCQWdNRUJRWUhDQWtLQy8vRUFMVVJBQUlCQWdRRUF3UUhCUVFFQUFFQ2R3QUJBZ01SQkFVaE1RWVNRVkVIWVhFVElqS0JDQlJDa2FHeHdRa2pNMUx3RldKeTBRb1dKRFRoSmZFWEdCa2FKaWNvS1NvMU5qYzRPVHBEUkVWR1IwaEpTbE5VVlZaWFdGbGFZMlJsWm1kb2FXcHpkSFYyZDNoNWVvS0RoSVdHaDRpSmlwS1RsSldXbDVpWm1xS2pwS1dtcDZpcHFyS3p0TFcydDdpNXVzTER4TVhHeDhqSnl0TFQxTlhXMTlqWjJ1TGo1T1htNStqcDZ2THo5UFgyOS9qNSt2L2FBQXdEQVFBQ0VRTVJBRDhBL3UzL0FPRm1lR3hnU2pVWVNlb2tzd2R2MXd4L1ROWG9QaUQ0TmxYZko0aDB5eVhHYzZqY2YyY0Y5bU1vVUErblBOZkxsOWQ2Z2dLc2ZOQTZoaHYvQUoxeWx4ZUJ5ZHlHRmgxZVBLSDhxL1U2ZkErWFlpTjR6a3ZScC9taitZY0w0d2NWMHBwMTRVcWtlcWNXbjhuR1MvSm4yNUQ0MDhIWEQrWGIrTFBEVTcvM0lkZHRaWC9JUFcxYTM5amVtUVdWN2FYWmh4NXd0YmxMZ3hiczdkMjBuR2RyWXo2R3Z6dHVybVZBV0V6U3g1eWZteXkvVVZGWStMOVQwbWFLNDB6VjlUMHVlQ1h6bzIwNi9lMWpaZ3BVR1dMSmhtVWJpZkx1RWtqeUFTaElHTmFuaHBHclRid2VJZk4wNWxwZnp0Wi9ocHZyc2U1aFBHbkdLdkg2OWdZK3orMXlTZk5ieTV0TCtyVjlycmRmcEZYUFhOeDRyUytFZG5wSGg2NTAweUFOZFhQaU81c2I1RTR5UkF0aklqSHJ4NWlqanJ6eDhXdiswTDhRZE5zSXJlMzFUUU5RdUlvaEdOVDhSZUdtMUM2dUNEbG5tanRMbXppTEhrZnUxalVaSHlIdmNQN1ZYaWdXU1FIUnZDNDFGWmQwdXBCTHRyT1ZNbjVGc2ZORElRTWZPYmw4L3dCd1Y1MVB3MDRtZythRktuVlRkdmlra2wvTjloL0pYZmVKOU5WOFYrRmNaVGl2YjE4UEphNlU2YmIvQUxydXFzZm5vdTBqN2tBZkp5eUVmd2dJUVI5ZWFqMjNPOEV5d2JPNi9aMkRuOGQvOUsrUGRIL2FkdmJpSzhnMWZUZFBXNmRGYlRMdlNJU0lZbkJCS1R3eXpuZXJjZ2xKRVlESUF6OHc2and0NHkrSVh4THZWR2xlTnZDL2hnV0JrdDd1MHNMZTJsdlp5WTBlTzRPbTNFYzhzMFc1MVRmRmRXNi82d1paa0lQbVlqZ1hQY0RHZFhNT1NsVGp2S1RiamExN3JsakorVzE3OU5qMHFYaVZ3M2pxdExEWlpDdFhyU2VrSUpSZDcyczNVcVU0OW5yTGxzOTczUytvYUtwQzN1bnM0SUpiK1ZMdEVqRnhmV2tFVVRUdXUzekNJM1dSVlZ5RDh2SkFiaHM0TlhPY0hvRHpqK0llMWZHdUtXelQrLzc5dXYzOTBqOUZoVWxMNG9OYUo2MjY3clJ2VmRlbXVqZXRvM013WUNPT0pseHlYbU1iQSt3Q24rZFEzVnliVzNNNy9aMUNZM21hZG80MXp4OTRJVCtsVXRYMWV6MFBUWnRWMVRVdEowdXh0U2tkemU2MWVMbytuUnZKS2tLYjdoenRUYzdxcWdnN21kUUR5RFhDU2VLcmx2Q0VMNm5lZUZ0YzEyZDJodTA4SmF0TXVrdXBrZnk1SVd4Skp4SDVUTkczR1dZYmlNRStoaE12cjRxTWFzSVhoenFQWFZ2Vjc2YUsxM2RXdXU1ODduZkVPQ3lpbldqWHI4bFJVcFZGelc1VmF5anNuSnVVcnBKS1RmTExzcjlqSDRsMDBEL1NicTBqUFhOdE05MG8rdnlLMlQ5Q09PdGFGbnJHbDZnN1IyZC9hM0VzYmJKSVVtSG54bmFId3lINWdkcERZSTZFSHBYaU9sNnpwOEt5THFuaGU4dW1jN3Z0TnJxVys0WHJoVWlrOHRGQTRPZCtXeWNqaFJYbzJnK0tkQmhzZE8wN3pyNjFNRm1rTHk2dGJSd1NiMVVBbTRraUhrQjJ3WFpvOFI1WTRJUHkxNkdQeVo0ZU1uUnB6YjhuRnEzZlRtZHZXMi95UGkrRitQNTVuVmhITk1iaG9RYTJhbkdwelhTNVc1K3pnbTczdkZUV2pYbWQxUlZPSFVMUzVuZTN0NTBtbGlRU1NiTXNnVWpnaDhiVDFIQVBHYXVWOC9LRW9PMDFabjZ0UnIwTVJGenc4MUtLYlYwMDFkYU5YWFZQUjltRkZGRlNhaFJSUlFBVVVVVUFGRlJQTkdqYkNXTDhFcEdqU3VvTzdCSVVFZ0hhMkNlT0RVdE5wcmNtTTRTYmpGcHRiK1FVVVVVaWdvckoxZjdYNUsvWlhsUVovZUdJaFdQSUNnSE83cjJVYzl6MlBCM010Nzg4Y2x6ZXNyNVdTTjd5VjBPZUNDcGJHUGJwWGZoY0M4VEhtVTB2eFBrODk0cGprbFowWllhVTlONzJUdjJkbjZQenZvZWhhbHEybGFOYm03MWZVOVAwcTBYNzExcVY3SFkyNjlPcnVRTzQ3OTZ6cmJ4ZDRVdkZEMmZpZnc5ZEt6YkZhMjFxMm5VbkdjQXE1NXgycnpGN1pZeVRHaXhrL3dCd2JTZnlxakxHeHprc2Zjc1RYczBzandrb1duT1RsMzBTKzZ6L0FQU3ZrZm5HTzhWTTVvMVhLaGc2YWgyYmxKLytCTGxYeTVOTzdPKzFyNGcybWxPaTJPZzY5NGtWbHk4dWl2cDBNY0p5UVEzMnU3Z0p4Z0hLZ2pEREJQT0tscDhUTEtjTWJydzM0bTB2QUpBdkJwMDVmSFllUmVTL3JpdlBKSWovQUxRejF3YXdyeUs1VEpqbWtBeGtEZlhyME1peXlkTlVaUTk3K2E4cnY4ZVgvd0FsUGpjUjRzOFgvV0hPRW9SVCt6eVJjVjZYWE45OG1ZbXJXMDBRYkVUWUp4a2pPYTgzMUJUSkl3WlR5Mk1EZy9oWDJEUDRVc1pidUN3MU5idFRleE8xdkxZVzhsemJLeVl5SkpSSHRqNFpTUE0yaHVRQ1NEajVrK0lXbkRRcGIyZXgxSzB2cksxMUtUUzVZbmc4bldGa2dTWnAzK3pBbGpFcGhaQkx3SFpnRlhCQlAxM0RtYzBNYlhXRmhwSzJqczdQVzJqdGJkUDduMlo4N25QQ3VhWkpRV0p4a0VvY3pqdXVaTkpTMWhmbVYwMDcyMmE3cS80ai90VWY4RkFmRzN3VytPZXBlRC9oM0o4THZGL2dmUmZEMXNOWGgxZTB1TG0vaDFaak41MEs2cmEzdXdSc0JDdXg0UTBiaGdXY0ViZkdkUDhBK0NydXBYUGkyeWZXdmh4NE9qOEY2aGFKTGVXV2srSnJtMDhXYUU2cXEzVHJMTUdndVlvM1lNQ1k0V0t2ZzhqSi9MZi9BSUtSM253dDhYL3RBK0pOVStEL0FJajBQU3ZCSGllemd2WlJvdGpkK0hyRWFuY1J1MnF4WFVMUmg3TjF1aThsdzJ4QUhib0dWeFg1OTNNWGp6eTdwZEU4TCtITHE2czdKTGp4ZDRzMHhMclhkTDBlMHRyZWRJNFpmS1I5a0UvMmNKOW9aTmtrazBHV1hKMi96WlY4VHZFYkZjVTQrand2bVhOQlY2a2FVSUtuVnBTalRrMG5DVXFkNVFhdDhNcmNyNTdLMTErdTREZy9ocXJrK0huamNMYWJoSG1jdWFFcnRLOTBtclN2NVh2cHFmM0krRS9pQjRUK0puaGl6OFhlQWZFdWxlS2ZEV294NzdUVk5KdkZ1WTFZY1BGS28rYU9SR3lqeHlCV1ZsSUk0cVI1NXR6RExESHZqTmZoaC93Ukc4VStQOWI4TitPTkcxblQvSGN2aG8za056YVc3eGFkWmVHL0E0YTAzUnc2dlpPaVhzTjFkWENYWlZvMmtDUEhJa2lKbmMzNzJTNlM0TGs1eVRubGVLL3VyZ1hpS3BuL0FBM2hjMXpDbDdLdk9QdlJzMHVaUGxiaW01UGtrMXpSOTV0SnBOdHBuNGJ4SGxkTEpzM3JaZlNuenhpOUgxczFkSjdhclo2THZzVmROMWFLMVc3RnhaVzE4MDFvMEVCdXJtZUQ3STdNcEUwZmxzTnpyZ2dDVEtmTWNxZU1lcStGdmpwNGwrRk53dW1mMlRvbW5wTnJlbnphL0kzaDQ2N0hxR25XcjdicExNUTM5dWd2Sm8ybGpTK0x6Ukk1RHZCUHRLSHhoOU1sYVJnYy9RSGlvNXRFVXcvTkZsUWNJb09BdnJ4WDAyTnl2SjgwZzhQbVVWT2xLMTR1NzFWcld1N0sxcjI1WGQyZlRYejhGbVdLeTZ0SEZZR2JoVmp0Sk96VjFaNnJYVk8yK3phNm42TitGZjJyL2dqZXdhYnBrYzJyK0Q0RXR4YVdkaHFmaDFvYkhUWTRjUnd3bHJNelFSTHNVYkJ1Q0txZ0VxY0tkL1gvQU5vdndiYnBaLzhBQ0tUZjhKTlBKS1d1a2x0cnJSN0pJOWh3QmNTUTVEbG1RalpIS01Jd1lJV1ZoK1g5bG95UlRxL2xzZHB5Qm5OZWthWGJ5WVVvamdMeHlNWXI4MXpEd280UHcrSit0VUpWbkhWdU1wcHhiZm1vcWZYK2E5OWJuNkRMeGU0c2xnM2hZK3lqTFMwNHdha3JXMlRrNGRPc0dyWFZqN1FrK0tsejRoZU43dWFPMmdYT3kxdHQwY1F5VjY4NVkvS01FOGpKeGpKRlRqeFhwd0dWZGl3SEErOFRYeTlZTmRnS29kc2Q4YzRycDRKTGhBUzhoQUNGM1pqZ0txZ3N4K2dBSko3QUU5SzhXdndwbHREOTNROTJLMlNQaE1abk9QeDJJbGpNYldsT3E5NVNkMytQYm9sYXlQZUQ0aWduR1ZPT2U1eWFsaDFBek1OcjVCT0FCeWZ3cjVsOFZmR2Y0V2ZETHd0ZStOUEhQanJRdEk4UGFjZkx1cm1HNi90UzRFbTFpSXZKZ0R1ck1VS2plRkJka1hJTEtEN1Y0VytJbndzMW05dXRNMGp4MzRWdnRTc3A3VzFtdEJyZHVsMnoza1ZwSmJLa1pmY1Mvd0J0dFYyNDNCNWdoQWJpdkF4dUV3K0NjcVVVM0pkT3F2b242T3p0M3M3Yk8yTWNMajhXbFZqQ1hLNys4NzIwdGZYNXEvcWo2TzhFNnBZcGJHenVMaTBndTJtSzIwVFd3dFpaQWNaQW02U0Vua0w5NGJUMUFHUFJhK1l2aDE4VmZoUDhRdFE4UzZYOFAvaUo0RThiNmo0THZ2N0w4WFdYaFh4VlkrSUxqdzNjQXNyUTNxd3lONVRCa2tRaHVqeFNJY01qS1BuSDR3ZjhGWS8rQ2EzN05Hb2FyNFUrSW43Vy93QUlWOGQ2TmVwWTZ2OEFDVDRWNm5jL0hENHQ2YlBNeVNZazhGZUdZZFExZUluN1VrMGovWTFBU1F5eUVLQzQvTmMzd2k5dFBFVTFMZlZXMFQxdnJwYlo3OW5mWS9wM3crelRHMDh0bzVQam93L2R4MGQ1S1Z0SEgzWHpjemQ5MDRwS3lqR3grbGRGZno5K012OEFnNUIvWWYwblY0TkUrRzN3Zi9iUytPTjdjWGNscEczaFA0QlEvQ20yL2RSTkxKSm54eHFmaDUyVkFCdUVhTzQzcVNnVTdoaFQvd0RCeFI4SzRKcktOdjJBL3dCdkZGdjRKN20yTnpQOEZMYVdhTzFsa2h1SFJEOFF6a1J2REtweVJ5aEZlZFN3R0xyeW5HaERtNVZlWEswMGx1MjJtMHJkZTNVL1FLMlpZVERLRHJ1VWVlM0xlRTAzZTF0T1crdDFidmRXUDZJYUsvbi9BQi93Y0hmQ2NXVnJmbjlnSC9nb2RMYlhqU0pieldHa2ZCTFVvcFRFa0VrZ0JUNGxFL0t0ekFUa0RpVmE5OStIdi9CZFgvZ25UNHZrMHUxOGNmRVQ0bC9zNlhXbzN2OEFaOTFxSDdTZndJOFgvQ240YStISlNxbERxdnhFbHNKUEJkcEhJN3h3UnpUYTBJcEo1b1lVZHBaWWtmS3BoY1JTVjZzSEhUbVY5THgwMVY5MXF0VmRLNk42ZUt3OVZwVXBYMXRwclo2dXovbGVqMGRuMFAyRG9yemI0VGZHYjRQL0FCODhFMkh4SytCWHhXK0d2eHArSE9xM1Z4WTZYNC8rRTNqclMvaU40SjFLYTBtYTN1NGJmVmRQbm10WkhobFI0cEVTUWxIUmxZQWdpdlNhd09ncnoybHZjTkZKTEhtV0JnOE15TVlwNHNNamxRNmtNRll4cUdYTzF3TnJBZ2tVeXpzb2JHTjRvSHUzVjVUTXh2TCtmVVpBU0FDQThyc3dYZ1lVRUtPY0RrMWJwQ2NkaWVjWUZYN1NweWV6NW55OXI2ZmNjN3dtRStzZlhIU2o3VmZhNVZ6YXBKNjJ2cWtsdjBRMUZLcW9aM2tZS0ZMdmdNK081QUFHZm9CVDZLS2h1K3B2RktLVVVacVNhZzZTbExkUUFUOW1OMWRDR2ViQllmT3F4TUVVNFZsNnRodm1Da0ZhclhHbUk1SEJMUDFPM2V1VGtuSnhudDFPT283bXR1aXRsWGxDWE5UVnZRODJwbGRMRVUxVHhVM1Uvd0FWdE85ckpiN2RkbDUzNDI2MFhZbThtUDFDZzRiOGpYTVhPbnNwUHk0SFFIc2Z4cjB4OU90WkRsa2xKM003RVhNcW1Rc2MvUGh2bXgwVU5uYU9Gd09LcDNtbldFVm5jeU8wa0NReC9hSHVHa2U1YUZZeHViQVlzY0VLUXdYQkk3NXdSNmVHekp3YWpKdHQrWC9CWjhOblBCVWNUVG5WcHhoQ01VMzhiNks3M2lrdm0wa3RXenlpYXhZZEFSM0FyR3U3SmlEOHZPTzllcDJVRnJleVhBaWFObzQ5eUI1WTJtUERZR0VVcWR4R1RqdGprR2x1OUhRdXFSMjhzcnlLQ25sV3JSS3d4azVZL0t2Y1lkZ2VQY1o5bW5tM3NxbkpOV2EzUHpiRThBenhlRyt0NFNTY1c3S3p2ZDN0b2xxN3ZSV1dyMDMwT2V2Nzd4SGRUeEpOcVVtakw1MlR1alczaHQwQklacER1Vm1iQXlJOTN6S1FRUmtHdkh2aVRhYXcra2VKZGMwVFR6NG04VHZvMXhmYVRwT2c2UVo1ZFVualFpM1ZyWU83SXp5ZVdKQ3pmSVdCSjVBUFIrSmZIUGhqd3ZiWFBpVHgxcnVqZUhmRGxtVGMzMnArSTlmVFI5SXRpc1p6SkpkM1VnVlFBcEpETmphdVB1akZma3ZmL3dEQmRMOWk3US9HUHhtMG1YeDNxUGlHeDhCK01YOFArQ0ovMmFmRE4xOFptK0tlbERROUt2SnRRWFcwdDMwS3plSFVwTlpzUkRMZXh0SXVucElyRExDcnJablE0YXB3eHVKbFRwUnM3T1RoVGkyazVOT1V2OE5ydjNlYXlidkpHZUJ5NnR4eGlKMGxVclZhTWFzWEtYNzJySkxTUE5heXB4VnBOMjBseXVUdGFGbi9BQ1EvdEczT3ErT1BpNXExcjQ0dC9HM2h2eEJxdXJhbnEzamEwOFIrQW44SStMZkQycEpCZVQ2dEVOTDh1SzZ0N29YY2hXU0NWSVpJbmdsRWl4c2NyNEI4SC9EdW94YTVvbWk2enFXcDIyanpPWDhWNnJINGMxblZmRCtueGhFTW8xV3owbTFlNGVOb1F0dkJLMjIzV1dXSjVKUExYbjZpL2EvL0FHdi9BTm56eHY0NlB4Ri9aNCtIL3dBVjlkK0pIalB4cDRoMTd4VFlmOEZNWWZCUHhSMFRWTGJXZkRHcTZPZE90dEM4TmF4SkpFMXBlM1dsYTNwZXRTNm91bzJlcTZGdUt0QjVjTW5IL0JEOXU3d2ZmZUFFL1pqOFlmQ3I5bi85bVR3L291bkh4TjRiK09md0wrQ0dvK0pmRnZqdnhCZnoya0Y5cXZqUkpacjBXcnoyRmpQQk5xTmg1OXJQYzNFMHIya0VOeFBiUS9oSERHWFlLT2J3bG1sZWxLS3FWS3NsS3lqVWI1YktjNXVNRW5KUzk1U1NjcE9Ubm9yZnR1UHdPSXd1WFRwMHVaTkpKSlJmTWttMDVSaWszb25vbGU2VnJkLzdoZmhkNFErRnVxK0EvQitzZkI2UHdmZWVDTFh3N0ZvSGhxLzhHUlc1MHUwdGJVTEZKWW8wUXl2a3l4T3J3eWZORzZzQ0EyU2V5bThJT0MyWStnempIRmZKZjdFZnhYOEtlQXYrQ2IybitLL0JmalB3RDhadkJ2d1gwV2J3MTRkOFVmQXIreGRTOENXZWwrYkJQYi9ab2RQbmt0MXQ5R1hWSEZ5a21MMFE2Yko1c1JsMngxK1Z2akQvQUlMZTZsclhncjRlNmJlWDNoL3dUNDQ4T2Z0V1huaFg0b1hIdzl2WDhhV3ZqWHdIcExUWDBQaURTRGJvc2hzN29XOCttR1NNT3NzMEVWeGcyODRoZitzOGR4NVF5S25UcTV6V2hSaks2VjVYaXJSaEpyblNWUFJUalo4eVQxYXZGTnIrVWF2Q3VjWXJIMXFPWDNxUWhKcThrMUxkcTdpL2UzaTA5TDMwYVRkajk3RDRUazNFTkVRdTdzTWZuVWR4NFdiY3NZallGUjBBeVNUWDRtL0dYL2d1VjR1OFEzRW1qZnNpL3MyNkpxVFNxOGMzalA0NGVNVmhPbE1TNnJkVzNoelN5eVh0dnUyN1dsMU96eUJrZ2JsQi9PbngzKzFqL3dBRkgvalFZdjhBaE5mMnQ5UStIVVVrMDBlc2VEZmdkNFcwNzRhK0dSQ3dqTUFTZUZMblY5KzJSZzIzVkYyK1dEdU9TQjRkWHg0NFdwVXZiVWE4cXRycTBJdTZldS9PNEsybTZiK0tMMTZmZThKZlIvOEFFamkyaEhHMG8wcUZCN1NxVGJidG83UnB4cU5PNjJueVBWUDRkVi9VSDQ3OFUvRHY0VUo0WnVmaVQ0dTBId1ZiK01QR1dtK0FQRGMvaVMvVFNyZlZ0WTFlWVFhZFlSTkpnR1dlUXFpS1NOek1vSEpHZm9HdzhJdEdnajhwZ3c0WU11TnBIQkIvR3Y0UXZFdWw2MTRlMVB3NWIrTWZqSjhZL2lYZFA0aUdvMmtYano0cytLdkdTMjByeFhTbWEzZzFYVmJwTnpQSEE1UHk3MmhqejkwRWYyWi84RXovQUl3ZU12akYreC80UDhXL0ZYeE92aVR4cDRWMWpXL0JYaXp4UmYyOFduM2Q1SG8xOU5IWlhWK3loWXpNK25teGxsbUdBKy9lMkNXQXJLZkZ1bnhYanA0SEJVcFI1WU9jVy90S01vUWxwMGQ2a09WSzkxek50VzE2UEVqd1N6UHc3eU9obTBzV3E3OXI3S3FsSGw1WE9EblRjVmVXbG9WRk51V2o1TExWMitwclh3bE9Yd3NmeTdoMjRyNEsvYVMrS0RlRk5mMTd3WjR6OFZlRUxEd1RxOXEzaCszMFM2MUNLeDF2VUwrNWd1Qlkya2Nxeks2elRTSUZLNGlhU0dabE8wcnZrK3ZwL3dCcXY5bVR4Tm9WMGZBMzdVMzdPbW9hbFBwLzI3U0piSDQxK0c3MjB2c3hHV0g5NUhlTVJISUNqQ1Jkd3hnNGRjcWZ3Ri9hby9iYytCK3QrS3RNVDQ0NlI4T2ZIM3h1OEphS3ZpTHdkcG1qYTFQNHk4UFcxbytyVzA4OTNjTnBxVFdsdEliVzJXS0MwdUdpa3UwRFNjUnRLMFgyR0F6MmxoYUZYTk0wcTBxY0lwSk9xM0dLZDAwNzJzN3JtNVVuZVRTaXQyMStmOE44UFpsamNjcWZzSnpkdmhqRzhsNXBQb3JlOC9zclgxK2NOQzFUVnJqd1I0K2I0cTZoNDl0dFV1YlBVSlRwRnZyOXN1ajNHblFYc2xsb2w5Y0FCdkp0WWJzTHVFem83TEhhZnVHV042K1FQR3Z4Vm44UzYxY2FmcHQ3ZkxCYzMwOTdxTVVQaWs2eHBXck5FSGhndGx2VGlSNDBpTFFmSzdCbGxKS2tNQWZ0NzRoL3RIZnN5K0ovaEo4UnY3UDhTZUNQR2JYWGh5MDhSMnZ3ejBPSnZCMDJpUnBKRkJQb2MrbjNEYWVpaUFMSGRoVmFieTQ3bk1jaGY5ODM1QS9GclJkVThCK0UvQm5pNjNzTlQwbVB4NThRTlQwU1BSSW9ZbHNiRzdOdmRhcExwME54YnU4U3JheG90dmJsU3hlS0NaaThoaE1qZmgvaU5nWVl2Skl3eUhHUXIwWVFVcDFFMUp5U3FjcjVwd2kxNzNNN3FMamRPVjE3enY4QXYzRGZQSEdOWTJoS2xVY21veGttbDhLbHBHVm5vbHUwMW9yUFRUMmkvd0RDbmd6eFA0YjhPK0c5VXZOY1BoWFFyWnRIMG40UjZacXplSFBnM28xanFBVmRWMHQ5QXMyaHRieUc3TU1Ba3RyMVpvUzFwdUVST01kc25oN1EvQVE4RytIdEY4RStGdmhyb1UxcGRUZUZ0TjhOYU5aZUdOSDhoeGJQSXkya1d4WDNzOGNxc0FvSDJodG93eHg4UDIveGZ1VnQxME5iaWZTbzlMbGp2MlJaUkN3blVMbHBYVWh6alp3cW5hUGJKQnUrTmZHZmd2Ui9BOXQ0cjByeGI0bzhSZkVqVVBEOHQ1Y0dlenVMUFRmRFYvS2xwNVZsTGRiTit3RjUwWXBJd1h5VjR3VlUvSmNNWnZDdmdxbUhjclNwVXBYczQwcjMxK0pweXE4MjNMbzViWFN1ejlPaGg4WGlYVG5QWG1xd1YzR2RUNTJUVVlKYXZtZDFIZlZ1eDljMmZpblZ6ZnpRVDI4bW02VmEzTTZ5NmpwdWx0Ymk2dDBpY3hYTWJ5UmJ3Sm55akp0THFoVWtuZGdkeGVlSWZDMXhEWngyM3hOMVM3aWF4ZWQ1N3p3KzJpVzlyY21hWVJRTE0xc0FFYytXZk4zQmQwNXlXeHo4a2VNZmk1OEc5UzhGNmw0VzhHL0QzV2JiVzlSMFZiWC9BSVRYeE83WHV2MkYxOXFNeG50NUd2NVpBbmtoSVRHc1EzWWY3cW5kV3RyM3hxOERlS1h0clBRZmdsNFE4S2FRUGhKUDhOTHkyaHQ3RlpuMWU1bHRuUGkwenFnay90RkV0d2dKSjJpNm1PUVhGZW5IR1liQ3luRG1wVmJ4M1RxdXpkOUZibDk1YjYzamEyK3A2Y3NzeGVJalRueVZhZnYydHkwbG9yZTg3dCs2OWRGYVdqMjBQckNEeEI0WXRyYlJiUzIrS0dyd2FsZFBNMnBZMGU1dExDeHVBc1pqaVNkVUVjaXl0dlR6RjRIbERub0IyUGcvVlBIZGhvSnVkQitMT2g2WEsxdnFiWGZoSCswR3NycWFHT0pZN2hFaFpTbTY1UUlGQktNKzA3VGtaSHdsRDhXdmh6WmVEdEg4UDZwOENMTCsxN0RTSnJDKzhXV0Y3WnJlNnRNYldLQ0M1ZVJnaDNKSkRMTnl6NU14NjR5ZkM5RDhmYTFwZGpCQk5aWFp2SW8xUk5WZzhUYWphVDcwRDRrTUphU0ZpSFpNOExuWUZ6em11dVdaNFREcW02Y282MDJueVNyeGFiNWRKWFVrMiswVjdONjNzN0dFTWx4K0lkUlRqTFNvcmM4YUVrMHI2eHRKTlJYbStkYVd2cWZzRlBhM2RwNEU4SStPTC84QVpzK0gvaG40aVd2a1h2Z3o5dHY0TFI2cDhILzJyTkl0RnQ3alNwYk0vRVh3OWYyMnRLdHpiVFhHbnpyOXB0NUpMZWVXQ1R6SVhlTi92bjlrTC9nb3grMlY0SStLL3dDejc4RHZCUHg2dC8yaHZoTDQ3K05YZ3o0ZStJTkQvYkk4SXY0dCtQWGdiUU5ZMTdUdEYxRzEwUDRnNkxlMlUxNU5aMnQzUGNSM25pdXkxMjl1cDRZVXVMNk1POHRmemcrRi93Qm9QeFRvZWhtMjBqWC9BQlpmWFRCVHFHa1h4Z204SjZxeWtySzVOdkxHd2tWbFZrODZDVmd3L3dCWUNNMTd0NEovYjcxL3dCNG8rSC94dDhiK0ZyeTN2L2hsOFFOQjhjWEd2SjRFZnhqWlcxem9tb1crcTJqWFZsWXpXYzE0UzBZWmJVWE5uSmRyQzhDM0VaY1NMalN4RkRFTGtnMjNhT2xrOXIzMWpacjVwNmRkRVBFNERGWU44OVNLNWJ5MVRhN1c5MlY3L0pyWHB1ai9BRXg2OEorTFA3VWY3TTN3RHVOTXMvanArMFY4Q3ZndmQ2M2ZMcG1pMm54WCtMZWdmRHU2MWk1ZU1TcGJXc2VvWGNMVFNzaks0ampETVZJSUdEWDhCL3h6L3dDRGszOXFENHZwZTZaNEM4RGVUTkpxRTExYStJdmlaNCsxcndqNGEwcTNtamFPNjA5Zmh6NE8xQzB0YnV6bUFaSTdieEo0bjF4b2xsUG1TVEZHRW41VGE3KzN6KzJwcWk2NzRWMGI0K2FkOEQvRE1lcnZKZC9EejltUDRmOEFoUDhBWjQ4RDNqVHpTRzQreGYyUnA1MUoyM2w1Wlo1OVJrZVIzWncvellHVVhWcU54aEMybWpiNjNXdktydVM4cndmVy9SMzdHTVhHVlNWMWZWTHRiYm1md3U5bmZsbXVsdGJyL1RBOFovOEFCVHo5anp3VnJwOFB5ZUpmalY0NXVQc2kzMGVyZkJIOWtENHcvdERlRUxxTm0yanlOZThMK0Y5UzAyWnU1aml1R2NMOHhVTDgxZVQzL3dEd1dqL1lJMCt3bTFPZnhOKzBQQloydXEyK2ozeDFYOWlINDFlRnI2MG11cDRyYURGbHFIaFczdVprYVNaRmFTMmlsV01CaTVSVkpIK1lUcUhqL1d2RkhpYXhUeC8rMFA4QUdyeGpvOHRnbHhxZXRhLzhZdkdYaTJlS2Q3YVIzaSt5M21xeXh5aEpmTGhKa1hCM0Z3RndBUEp2RVA4QXdnOHR1czAwMXJjWDl2cTBEV0Z2TnAwMnNMYlJpQTc1eE9XTEJ0eEVZVmNZVm1Kcm9wUlNiZFJYWGJiK21adWszQ0tVclM2dFdhL0xSUHpiOWRkUDlVTFdmK0MzWC9CT2Z3MU5wc1hpYjRtZkdYdzh1czYxQjRkMHE1MUw5amo0eW16dmIyNVlyRkFzc2ZoWjFYT0IrOGtLeC9OOS9oc2ZSL2duL2dvNyt3YjhRTDdTdEcwSDlyWDRFMlBpYlhCblNmQkhqWDRnV1B3MStJZDk4eXJoUER1cnZhYW5rRmxCVTI0SUxBRWNpdjhBSmhzNWZDYVJtWFJMdWUralhRSVpiOUxvUGJybzk3SVNaMXRWM2ZJcWtKc25URWhLOHNkb3gyMWg4VnZqSjRmaUdsNkIrMEI4VlYwSXhnYWpvbXBlTlp2SEZyZHd5TUk1YmU1R3FMZE1xc25tYlRBeU1BM1VFS1JmN2lVdFl0THlhZHZXOWlYUXJLSzVLaWI4MDE5MXY4ai9BR09JSjRMcUNHNXRwb3JpMnVJbG50N2lDUVRRVG80REk2T09HVmdRUVJ3UWFsci9BQ1VmMmUvK0NnMzdULzdKY1hoWFJQZ3A0NTF6NGUrSHZEVHZxSGhheitGUGovWFBoUkJvd2ZkQ2wxcm1pUU5lZUQvRTBsdUhCZ2k4VGFEZHhLdkVqdWQ4ai8wWi9zZi9BUEIwNTRxOFBSK0RmQ3Y3WFBoYXo4ZjZSUHFOam9HcmZFS1hSYlg0Vy9FRFRMR0sxWmRSOFE2aHExZ1p2QnVyVHlYQWpjd3l4ZUNvSVlac2hKR2p4SkhzNHRYakw3OVBsMi9FSENyRDRvL05hL08yNithUDdkekRDWlZ1REZFWjFReExNWXdaVlVuSlVOMXhubkZQT2NIYUFXeHdDY0FuM05mSmY3TXY3Ylg3UHY3VzlrMG53ZDhXQysxcTAwTzM4UmF6NFAxeFlkSzhWNlJaM1NyNWQwdHVKSGp2TFhmSkhGL2FHblNYTml6c0FsMDVJQjkvOFNlSlV0b1pyT3haemNzV2lrdUVrOHY3S1ZiYTJPQ1NjcVIyNjVCcmFqaEsrSXJ4b1FWM3AxVFNYZTZlM1g4andNMXo3S3NreStybUdLbHl4VGVuSzFLY2t0b3BwT1RlaTVyT0s2dXlaL21ML3RpK1AvQmY3VUg3Vy94cjhaYWY0ODhSZkU3NFVlSS9pZnFIanY0YS93RENlemVKTlUwRzB0NzFrdUViVHZET3RYVGYyUkpBMDl4YXJCSEZEaExVRlloRzZLdURaYUZvdWlSd3gyZDdxSVNaaFBHaXlKcDJuczJRUko5bWlXS1BqYWdKWUhoQjF4WHozQjRmdXRQMGpTL0VVVmpPVHFmaENPNFd3dDdpTzAxbTFubXUvS2dnTWhHSTU1MU9ZNUZSZ2hsRzhLNGFPdnJ2OW8zNFpmRFRRTlcrRW1nL0RDeTE3VG9QRThWeC93QUpWYnZOcnV0WGlTV2NVVXNNczZYRWlTWEJ5Ymhwa3RXaVdieVZWeW9aY2ZuV2QxSlpqakt0WEV5MXFPVGF0cDFka20yK1dON1JUYmRsWnUrcCtyNVppOEZsT1dZYktPU01vUnA4cWNtbXVXRVV2ZTJWMmxlVFNTN0pLeVh5SDhWTHpXdFNtdXRMVzJ0enJVL0VPbzNGOUhZaExXT09RQzRlUUFJWDN1cTdaQ0YybmRqZDg1NVp0UDhBRGo2RFBwbHY4UTlPdnJLMHR5SW9yTFhJTlQxblRVRXlLeHRKV2loa3lHZGc3SXpHVU9XQkdNbVA0NHllR1BER3JXOE5ycG10NmU0Z3NOT05sclYxSnFXcEkwMFNwZE9KSkJsSTJtV1ZvZDdGb2tralFzMjBrK00rREVHcGFwWXphdmJ3NlRFR1MrZ20xYTVOaC9hUG1NcXBHRHMvZlR6Z01xRXFBKzA1WkJqZDh0U3l1bzFDTk44c1l1NjkxV2IzV2p2MlNWdEZyMzArVXJZSlR6T0dHb1d2TFdOa211L243dTFyYWZwN3o0TDFqNHVmQlMrOFVlS3ZoRDhXZmlWOEtOZjhWZUhXOEsrT05aK0hIaU9Ud2pxUGpYU1h0cGJWckRXTFZTZE8xYUg3TkxNc0Vlclc4NHR6S1hoa2lreElQT2RBaDFQVnJUVkxsL0YycGF4NGFmV0ZtMHpYclBVcDlQc3RTaFdkbHVZTlFNeWhXdUxPU0ZJNWtReStXZ2FSMkVlTS9TM2kzeGIrenA0WTBTMVdMeFI0NGZ4ZGNDOTBsTkNYUnIzVmRLdTU3RzRqdHBZcjRMZVBGYlcxeEp2U1B6NDh2SG1SVlZRV0g1dkQ0amZEM3hZN2ZEVFNmQzJsRFE3Mi91ZkVPa3grTFkwdnJudy9xelR4eTI0c3BUS2pGcFpwNWxZdTBrcXh6R0tKQWdlU3UvUC9BTzFNUlJvNFN2enVuVDk1WFVaUWpGL0hLS2N0OUZaS3lhNXVxUno4VFlmTDZrYWRmQ1VmM3lzcHpqRldhU1drdG56Uit5bm9sZTNRL1UzNFdlTk5iOE0rSTdhMFM4MDNYOUZ2cjUwMXZ4SFkzMWtsMVoybTF2c1VNbUFtNk1FbG1TTjVkelNNN2JDUXRmUnFlTnA3RHhEcjk3QlkrSmZFRWthV3RxTkc4UGFiZCtJcis4bWZZb1czc29WZVIzVlczT1kxSlZGQmJDaGlQeXgvWnEwYTlsOFo2TjROY213OFFlSzladE5GdWRKOEwrQzd2d1A0VzhPbzRqS1RSUGNpZHJwNDM4MDdvbWpqTFN5Qmo4bUQrcy9oejloRzR1UHQrcWE1OFpQaTNwTSttWFQ2Vk5xTm40bHV2QytwM2l3Ui92Ym1LNjB3UXVzSmlEL3ZsWlFQbVZpRU9EODdoY1BoTUFweHIxR2xMWjhqOTVhTnRSV3kwdHBvOUxIM3ZoODhmREtKZXdoZUNuZm1uS01WdGJTT3JXclRzM1o3cmRzK2RmaTc4V2JXL3dCVzBxeVRTTmEwVFhMUzVhMGcwN1ZOT2U0MVc3dUxmY2hNQ0JXRWF5UE1GajNrbmRIa2JnUlgxVDhDZitDcmY3V3Z3TjhFWG53NitFMWorMEw0ZTBtNXY1dFUxQmZBL3dBQ1BEK3RXVnpxRWtVRm5OcUR6NnhwRjNKNW5sMmNFYklIYUVDSFBscVNjL0sveGIrRFB3dDhManc3cldnWDNqQVhseDQ1dHRLdFovRU9zM29pMVpHZU80bWJFNUVwZDFVeVlHSElZZXJLZmhYNGplSEhsOGIrTExQU2ZGZnhZYWNlSnJuVHRQMCsyK0pmaUcyMHdKRUcrV3k4dTlWRWdCQUFZQlIwVXFDUm43akthOGFEaXNGVWxCdFc1bHpSZXR0TkdwSzlyNzIwVFBPNHI5aGlhYzhQeEJSaldwU25EM0dveWk1SlN0TDNvemplTnBLOXI2dFhQb2ZVbitBZDFlejNmaWY5Zzd4SnFXdTZwY05mNnZybi9DbUxHNWwxRzZ1NUhtdWJrN0lNUnlQSzBzcGlPMW85NEd4UnRGY0o0OThWZkE3d2RwVnd1bmZCTDRnK0FZNXA1ekZiYVA0RGVSVnZKVVlTM0RKWk96eGxpdVhkMHd3S1pPY0ErSC9FcjRYK0lvZEo4S2FsNGMxWHh1ajNuaEVhcnE4bmg3NGo2M0phcVhaUEplNWpqdkVDejdSS1pTZDVZNHlmbDU4aDhZYWJxdzhLYVkwMnJhdjRhMVBUdGFGamNTbnhicVY5cURMNWNqZVplTjlwOHlkWk14c3hra09NOUNGQXIxNmxXdGk0MDVWcHFTYjEwMVQrOXY4QUJuaDRqRFVJMWFtR3BSc29KdDY5RmExdEZiZnN6NmgwdjRnZUVmN05sc2JmVmZIR20vYllvNTcxN2tzRHN3R2RKUE9Eb3NYeXhuYXdMYlVHZHZOZlJ2eEUvYVAwL3dBV2ZzZS9EendGNHArS1hnZlVmaVI4Ty8yd2J2NG94V2VyV2VuV1hqL1hQRCtxZUFQRVdselgvd0JvdG9VdDFzYkM4bXQ3V1MyU0pGaWt2TFNVQnQyMWZ6UFRWZkNIaER3dE5xVng0eHU5VnVTOGVteWF2ZDN4dXA3MmJmR2pMYXdQdm5saXl6UHRVZ0xHa3JzKzVTVDAxMzhSdkJqV0d1bTgxSjB2dkR0dElXdmswVmRWWFRvbklac0lGM3Q1WkIzS2pQOEFNd09NTUFQUHdlSnhlV3lyMHNJcGV5clJjSngxdEpPeXUxcnFtMTVwYWJOcC9NMU1KaHE5V2xPY0w4a3VaZDFwWjlHMWRQWHZaZGtleGFqOFgvQldqVFFYc0dvMmVySzZ6WEgyYlNkU0dxeTNQbENXVzU4dG8wWXJJR1Z6c0FKNkJBeCtVY1ZyL3dBY0lOWDBsdEgwL3dBTGF0ZERVbzROUFcvdm11ek5KSkZFNnZJbVpFaUJsRENTYUlSR01OR3JxRUlBRjM0by9EblRmQlZsNFA4QUZ0aE5yRjVlNm5xTnBhWDB0MHR1MXZIR3RyY1N6SXUyQlNBcW5sdXErZWVoSEhtR3NYczJuWEdsVFJhazh0dE5wMGl1UnRhNHRYc3ZNbk0wVFlBU1NUOTNHK0Joa1hHQVdKUGJsMkhoZzBxY2Z0YjN1K20ycTdkMnJuMW1IcFFqaDNPTzY4OXZ2bHI4bzN2dWUvNmIrMEI0NnVvTk1zWlBCbDdGb0U4cTZoZEpiNkxvdHJNN1NSeHN6a1JRck9ydWJhRkdWNVZDNHl5Z2JnMjdhL0ZuNDJ6V2NuMlB3NW0xblg3YmUyTW5pU0JmT2Q0WUxXUjVGU0RMTTBjRUVaTzdMTEJHT1FLNHF5OERlSWJjVzhtbzZqcUdqUmFob2xqcjNsTGRKYjIxdGJSWmxMZ0JnUVpDaDgxWEl5b3d6QWNtbjRyK0xIZzc0WlBCb21uYWxxZmlieEpKZXdhM05haDVkV3VZa2tLdE5CZExIajdORXlTT3NNTWhRNWp5SWRvOHcrcFRxWTJTdlVxU1ZsYlZ6MnQ4T3N0dkxiVjl3cS9VWXVMcFFqSzc1bFpVOTcyNXJLRy9udm91eDlCNkQrMEo4ZDlkMG1Ed240Z3QvRmVsK0c3R1greUxXSzgxeXd1OUFFWGx5UUxhV2tVOEN5NFJKcGRyWVJka3hBazNFSU9GaytPbmdUdzVOYytEdFV1clRSdGJZR0xVZEx1ZkQwUGlUVll0a2QxSGJOZDNObGJ6TmF5cUpZM1dHVmtsMlNENU53Q2p4dWVYNG8vRVB3OXFGMTRYaTFUd2I0TXZySzIxeVh4TDRoMUNGUEYyc1dtcXhlVGJ6MlVxbWRyQzBhSlhoOHplYnhrWEpsdGxIa25oN2I0YjJtaVRKSEJieS8ybHAycnRQZFE2YTBNdWppS0tObFJZd0I4eXpTTzByQWJjdmc0eXh4M3pxVjZFWTFIVWs3S3liY3JXMjVZM2Uza3RMTFZNNHFTaGlha3FQSkdONVhhVVkzdmEvTkpwYit1dDMwWjZGNHUvYVk4V1NUMitqL0Rqd2ZwT2s2Ym9NcCswK0l0ZXNwSmJ6VUxaWllvMldEUzRKVEZiZzdBVWxsa012enNIdGtZa0w1dDRxK00vampVSnRXZlQvSE9wV1doWDhVSC9BQWtIZ0svOGhOQnYzdHY5SXRHMmtlZTdSc3BaWlM1WWJsWG9BSytVZmliOE1OVTBMeGpxOHkzWnQ1dFYxS2ZXVEphU0dHVUM2a2FjaHBFdzNEU01BQ2VBbzRydmZETmwvWjN3NjhSU2FuZlh0N2N5NmdpVzgxOWN5M2tzZ05uS3JJa2tqRmtWU1l6eHhrOXFxalVxU25HWE5iYmJUeSs2Mmo4am1yS0VLYlUwbWtudmQrZjMzVjl0UEk5TDBhZFpTODExSmZqekkya2syTWJlM2x6eTZ4NEdDQUQxNUpBUEo1cm9JN09DRkRjWEdqMjBOdkt1SVM3aDVlbVZENUoybGdPLzQ0NlZ3ZWs2cERxVVZyNXNVTWJDRnBsaUxiakgvRHkzdG5qanA5SzdGNzBYMGtPblNDU1JaWTJtbGN3NWhoTVMvZExaNnNDQ3ZISXpYYkNvb3h1M29aVTV5cTh2czF2c2VtUStHdFd0ZERqMXlSZE90UmN3Qzl0dEord3JMSk5CMUVodVEyRllMODNsZ1o1d1NEVmp3bjRYdVBINHVaMDEzVHRCMHlHNkZvSGdzWWRUdTdtY0RjRTI3MEFYNWxMUGtjTUFBeHpqTXNQR1Z2WWVISDBpNTBIVDVKWGpTeWoxQzVnSzZoQnRMNVlzR0FZRVNLRGtmY1dQKzdTK0UvSCtsK0hJSm96b21sNmhid3ZNOTFGZFcrMUoya1NCRUJmY0JtTXhFcms4ZVkzOTZ1VjFlVG1kVFpYZDlGb2dsVm1xTHFxU1ZyZkl6TlZzYmpUTlUxalN0VWlnTjNheUcwdVdFYVJ0S3djOHNCamhzN3NZR09RUmtFbTlxR2w2VGJXaVhac0xTS1JYaWFDV0g1WlZPNDVMSDB4aXVVMUx4bm8vakMrMUxXckhUN0xRejVVRm5KWVdNQnNVU1dKd2piMWJJTEg1eVdVNEpVYzR6VWJhcFBlUTNVY3hoU0NTWkZ0bmRoR3FCV2VNa05uYVJsQm5KR0NUelhQVHErMWlwdzJQUXBWWVNwUm05ZVpMK3RUbzc2MDBtM2h0cEZ1ZFhndW50dkppRnRjTk5sVGgzT3dxUVVQY0VFSEhQV3ZQZFgxK1R3K2JxRDdmTHFObHFPbkZvbGxqV3psZVdRcUdPNU1oaUZDbmoxOXhYMGI4Q05MOENhdHJ1cnI0NmloZlRZdkRiTmFKcWwzTmJnekcrTUprZ01iZ3J0Q3JncWNZbEdSelh6M3JXaWFQcmZ4UjFMdzNwODhPbytHNDlZMUMyMDJPN0crQzRpUzRqRVlWL20zUnJueTkrU3piQ2ZtSkpydGxOVU1OREZUbG83Nlh1L2Q4dk00STRpTmZNWlpiQ05wKzZyN0o4eVdsL21hdndoL2FaK0luN00vanpTUEVmd1M4VTJQZ21Td3U0dFh2dkNsMXBjTjk0RnY3eU15Yk5SazAxWm9mSzFCRkFqajFDeG10TDVGS3F0MEl3WXovQUdOZnNBLzhIUFh3enY4QVFyTHdaKzNIbzNqRHczZldrRWRwYWZFTHdWNFAxajRyUTNYSlVGdjdOc212TGhFWHkvTSswV2tOeW5KV1RVaHZuVCtLZlVQQ09vYVJyTU1OaGF2WWFmcHQ3TTdwNGRtT24yMDBITVNJeWlNSXNTczZzQXBEY1l5UnhYcTJnZUh0TTE2Q3h0QXJQcVZ4Ym1mekxpMVdMeXZLVnBzdTZ1VkpiZGJGUVVPUVg2QVlIVmc4NXhHRnRPbTA2Yit5NzJmbjVQelZuYlE4dlB1Rk1yeituUEM1cFJ2TmJTWHhSOUpMcDF0SzZlbDBmck5ySDdPZC9jWHZnMTdiNGZlT2ZEaVdNY3QxNDgxVFVJOVQxaTI4Vlh0dHJFRjdvSXRvMFlpemh0TGVEN1BQSENWODV6NXpFRXZ1OUQ4ZlQrUE5XOFJhQjRsdnZCMm1YbXJlRmJhNWcwUzIwNysxTkx0ME4yb2dsbXVSTWpCL0xVdXlSYjEzc3d5M0hIN0xXOE1VU2JwUE1NQllxdjJWbWxrQlBZcmdyNzlmWDJxMCtpUTNJRWs0UGx0R1F6enlCY1lPNFpKRzNvYzQvS3Z4Q29zVEhrcHpxT1Npcks5bG85L2h0djErL2ZVL1JxZVJVYXNvMUs5V1VtazBtMjFvMWF6VVhGUFRSY3liU1N0YXlQNW9maUI4RmZpUjhZYnlKZFg4RDZxMXpxVmsrbzZwY2FYWmkzaWFZT3BqZ1JKTXI4Z0lRbFZHNDcyRFlxQ3gvWlorUGVzU2ZhdkVta2FkcEM2ZGFLZEh0clBTRXM1TGhZWFl4Vy9tUzNTZVV4NUJsd1FONCtVNElQOEFSZHFPbjZYWUsvbFQyY3M3Um1kRXVKL3NWdkNnd3BPNlBsaGtBMWh4YXBvMElzbjFIVDlEM1hMbFpwdzMyaTBDRk1odm1VSE9Eakh2bkp6ejJVOHd4Vk9QTEJMbDlOdlR0ZnJic2R6eWZDenF3cmM3NW9wSld0dDZkdjBSK0FuaDMvZ25IOFZQRW1wcnJXcWVLYkxUYkdYWDVkY2g4TzMraXphbzBDWEZ3MDhzTVY2bDBZNHZNYmEwaGhSZDdLQ2QyY0hJdlA4QWdpLzhRcjdVVjFkdmlaWVdraHZmdDFtK2lhVzJrM0ZvVlJrQytlN01lQkpuZEdVZFNUaGh3Vi9wT1NPeit4bGJlMjB3YnRzalEyOEVUanFNTy90d0NNQWs3ZWxYb2J2U3BJVWhoUmZ0U0hFc2lYQ3BDU1NEbnlGUmVSbitJOEgxcXF1YVpqV2FsN1N6U3RkS08zM1dmenVaeXlYQXVQSks5bTc3dmZUNWZoWS9EWDRVL3NDL0hENEZMTE40WnVOWStJV3RYVndDZFMxYnhGcHlUMmE3U1Mxc3MwaHkzS0tEd3lqbmNUWDFGcUdsZnRoMjhZWFV2RHZqR0cyQjh1U3lnbnM3KzB2SXl4WWlSN1Jqekl6dnYzSmtnS0dCVUFWK25ZczVwN1ZMa3pXa052RTRSWG52SGRWSXpnYkZ5K09Ua1l3ZTFVdE8xSzN1STdoNVB0Rm1zVWpJMDEvcDdhVEJJQVNnTVJibDFiR1FTTjJNWkF6WEJPRlhFVDlyVnFOejd0Si9LMWt2VFE2cVZPcGc2UHNjTFVsR1BxbDIxZG82K3ArSnZ4VitBL3hLK0prZGduaVg0ZStNQk5IcU5wcll6YVJGYmk2c1pqUFpaZVZRdUlKajVxbGNPdXhBb3hrSHh5OS9aRStMMW5KcnZpbWZ3MzR2MDgzck5kWFZ4YnhyYU9yN3Rva09XQUpPZmxJSEdPY1o0L29jc05RVVRNYkxYbVdKRGxyU0c1UzdubUo0TEFFcUFvejZkUjFOVnJtWTZuZWFmcDEzZk5OYjNiTk1iaWVWNFVhU0k3bFh5QWNPb09EMTR3TWduRmEwYWRXalFWTDJsNHBhM1NkOXY4amx4R0crdXRMRlM1M3BySzJ0dHI3ZDM5NzdzL20zYjRSL0dYUmtkOUgwZnhYWnBjTC9BR2ZKQXR1OE54ZW9tOWxPNVlDamdCamdMampQTFY0YnJIN09YeFV2cmhZNzd3aHFJTW02ZVBUNDlPdXJueWxVY3pBQzM1eHVBT0IrSTV6L0FGZTZ2b3htblcwanVJVEVzWm5TZVZtamRXVTVWU3VRTUVuZzlSZ2pCcmc5UTB6VUxveUM0dExmTU1yS3pXdW5JZklPY2o1aVNGT080SUJISXIwTVBYbkNLaXBmOEQwNkk1WlpjcVVuTlBYMDZkaitTNjUvWTQrSmgxR3kxRFQvQUE5cVVhYWU3cEZaVytpVHJjM1c5SlVLekVsU0JpYVU4OEhJNDRBclYwLzlsWDRvZ2FyTlA0ZHVjWFRCNTlOdXRIZTNobTNSQUZ5NUNNM0tsQ0NPbURuZ1kvcDIxdndSWjZrN05xTXlTVy9sZ3EwY1l0YnNFblAzb3d1VndBT2NucnlhNDYrK0d1aFN4aVNiVDdMVlk0bzJWUk13TW96L0FIcGp6a1lHU1JrZm5ucmRhVlJxVlNidmExOU50K2lPS2VVMFpTNTVYYnRiZTM1VzdzL245OGYrSC9IdmltMHQ5TDhRYUxxSGgrMXNJNGxzbnNyVjQ3V0ZGamVPVUxQdXpLc21TQ2pBWngwNlY1anFmd1V2Tld0WTN1UEVpVHhhZWtyd1hOMmI2TzMvQUg0Mnl5RmlvRFBJQ0ZidWVNNXhYOUdVbnd1OEd5M0Z3TDJ6dElJTHFOQzdYVHlIVGtaY0Q1VlhvVDNZWjdldEV2N09uZ1dhNmkxUzFrMCtPUzMydWtWaGZGb1pHSEpEVzdPMlNlNUEzWTI0eFcvdFpkYWtsOC8rQVJQS3FWU1BMZVdxdG8vNnQ1bjRLYXhvSHhROGRhVm8ybFFlSm83Sy9zdE1oMGc2eG9tbXkybXFTd3daVlVWWGpkRWxjRWd5bFdLakJqRWJZa3JtUEMzN0ZIeEMwNXBydXpzaGZ3em1XVVRhbnFLcmRYVHl0dmFTU1pzbHBDek0wa3ZXUXNXWTdpU2Y2UEcrRmh0SWhKYkMzTVlYTVNXOFJWaGtqSXhqSVA4QWhWSzUrSDl6SEZPMDlpSTQ0bHkwa3RzektRT3lnaHNrWUdPL1N0RlhxT1hOTEVUZnJiLzVFNWFlVFJvMlZLVWxiYlZmNUg0MDZCK3poOGU0dEdmUTd3K0dZckdIUUxYUWRKbk4wMXpMWkpiUlNReHNwU1JlVVdWOEsyUUdPN3ZnWWlmc2FmR0pkNko0aTBTeEU4aVRQTWRQazhwM1NVekp1S3o1NGZwd1B4QXI5NjlKMFhSN20waXZQcytsT0prSDJ1QzduWlpXbHdvUHlCc0tUZ2dxeTl4VzljYUQ0YnRsVUcwMGs0UVpTMTArS1owejBVbFN3QjQ3MTFyTWFzbEJTZCtYUmVTK1J0RExWUzV1V1VrNWF2VzEzcDJQNTVOZi9ZQjhhZUpaMzFEVnRXMHVUVUxpUS9hSDB1d210N01EQVhjQVppd3pqSjY5RHhXQmYvOEFCT254QlBwZjlreWVJNzk3SkxwYnFPTFRybUJaUzRVamFCUEdUdEk1S2dua0ExL1E3ZGVEZEZtRWJhUERjK2F6RmlzeXBEWXdrZy9NdzI3am5KNEF3S3UydmhTMmM1dTdTM3ZNRE9BVHNIUU1BWCtvOUs2Rm0xYTF0Rjh2MTNNWGxkQng1WlhhOVdmemgzSC9BQVQrOFc2WEdscEhjNnhiUXh4SDdQOEEyaG9VczBrdVFTcEZ6RklJeHljNUs0NUdNQ212K3hENHBrUkEzaXFDVm9pR2Uya3M3bmZLNFhBU1Q5NFNjbmxnQmsxL1J1dmdid1ZHOTB0dHBza2IzRGhaeERkelJnNHcyQXdmWXVDU1FGeDFIdFRybjRZK0I1bnQ3bTUwNXJrV3VSQ3R4ZlNTeGNnSU44YXZtUXJnNExic1pKeldQOXBTV2wzOHBQOEF6R3NudzZWa3BKTHpmK1ovT05QK3hKNDlZdG5WZE5KdUFGbE1wa3RUY1lQeXRoa0xISE9NSG9QZXNxNy9BR0QvQUJyYzZkYzJzR3E2YkhiM1M1ZUVYamZaMWZLZ01DMGU3amFEajFBcitrUzkrQzNnNitiRGFPakV3QVJ6Mk43TEFzS2tIRFpMY2dZNHhqQUdmYXZOdFgrQzFqYVc4VGFXdXJUM0VzMndRenp6VEJSd0l6eVFPU0QweDA2OWNaUE1aVHVuS1gvZ1Qvek5Ga3VIY2JYZHZWbjgrbG4rd1I4VExmWmF0cVhoYWVLUDV2T1NaN1Y4Wlg1WmdZMnlXT1NTZU04WTVOZEJaL3NNL0Y5SXJtUCswUEEwRUFKTUlpMUNRN2c1ZGpGc2FQakJjbmR1d2MvZEFIUDdveC9DMjl0MS93QkpzNXJXV1Y4N3piU2lHNEpBNVB6ZzVQSEp5TWQ2aHY4QXdWYVd6QzIxU1c1dE5ORUxHYVZMeWEwbVRjcC8xVFJ5QW42WkhCN25tczFqVkczTEtTdDU5OXdoa05KV1VKdFcyMVorSm1tL3NYL0ZYVDViYTV0UEVmaGpTYitLVVBHWDF0UVp5U1FZdy9sbjVSazhiZXVNSGdHazhOL3NFZVBkTTFxMThVdjR0OEo2UmVXelNTTWJqVUk1TFNaM21XUXNGMk9BUVFBQW1QOEFkSE5mczVZK0N2Q2R1VGZhYmZhOXFzWXQvT21lVFZidlVraFU0QU1pM0U3cm5PUUFBQ1IwQnhYUjZaOE9kRDhUUnRlMi9odHAxV1RZbW9YbW1RR1NGMUlCTWJzcEQ0ejk5Q3dHUnlNOFRQSHlsRDJmTkxsOVgxS1hEMkhkVDI3ay9hUGQ4enYwOHo4Z3RNLzRKL2E5ckVPcHZjZkdLRzJpMVZKSXkrbGVIMDFDV0F2SkhLSmJlNGFZS3hYYUFwWlN1Q2ZsUEZlbzZEK3dmQjRjdFZraDFINGkvRUs4aGZQMmEwMDIxMEczSVh5dHloaEdwQWJ5NHpoQzI3YU9lOWZyenBQd2QwbTFpajg2NWtnMlA1aHQ0STJnWEF3QURoc0FzQU00R0I3WXIwTFFQRG5odlNqTEhwZG9rYlhFL256QjNSa2lib1g2NUpPT1NTVHdPZU1WeVl2SFltdlJWR01tdWlhM1YvVzZmelRPdit4Y0hOUG1jcnZyZjhkZFB3UFQwdm8yWEVVRVRSbkxJeVJnb1FjamN5S3dJSFE1SEZjQjQzOGNyb3MwVnBEcFd1YWhaeFRDSy91TEZ4NVVXVUJLUEh1REVnTWhISDQ1d0R4VCtKcm0yWjAzN0JLbm15UUVHR0FGUUJ0RGdodVJuamtaQjYxRk5kZUg5U3RMeWZWTENONXJpMk52ZFhUd0NlM3ZGQUk1aWJnc01aWGtIcGdrVjRqcVUzWnZTNTlOVHc4dWV6MXNkcmZlSWZDdW42VEJxbDlQUExwbHhhL2FnYjJ6UzBuZE9NQlkyeElvM1kyaHRwOVJYamQxOGFQQ2NraTIxdHAwNXRoQ2ZLbU5wQ2swVGtvcUp0QkxZK1U1UFljODVGVGF2cm5nalZMZjdEcW1uSmNReVdxUjNGeEZFOGsweGhBMm84d09UM2NnbkFJeGtiUldKcGZodjRRSHpMdFZ2Ym1XQ05Xa3RiaTRrdVRiRWdESWlRRmlveXY3ekcxc1lCUE5ZcXZSbHBHUy9VNm80V3BUVGRTTC9ROWMwUHhOYTZyYXd5V2tqRmIwZ3h2Rkg1YjQ1SEk0ZGVneUdBSlBya1kydnRObHA3Q0dPQmx1Y2szS1hLbFdKNXlwWHJ3YzR6d1J6bml1Q2dnc2RSc2Y3TjhMd2F5SUZpaTJ0WldNbGxZUU5MeXl5M01yWU81V1Z5bUN3NU9EMjZ6d3g4SFdubmsxWHhIZDZ4cmxwYVJqR25ycUlzTEpRd3hITko4dTBBN2xaUzR3K051N0p4Vy9OQ292ZDEvcnVjN2k2Yjk3Ui9qOXgyZWk2Z3pUVzhremlDTzVmeVNiZERJOFJ3ZG9ZRUhhbUJrbnQyejFxOWZYTWEzWmpNTTk4eTRXelczaVczdnR6ZGNCcEFqWUJKQjR6Z0U0NEZWb3ZEMnJ5TllTMlQ2cFlYOXpDOGRscHVwMmo2YmFRdmJwbTZab284dVlnRndzMGpGUjV5NHl4VUhqOWY4QUVvMGU1MUt5MVcwdG9yNjBtQ1R2YTNMUlNOaUpIR3d1bWRwRGhpekRIekhqR00yb3dXaWpvWVAzbmRTMS9yb2JyNlhwRmk3RS9hSmJ0V2FlSTZwUDlxdXJaNUFBV0dHT0pRdkFLbmpCeG11U0Y3cDJpZVBMSHhacVYzcWR5bGxvMGxoYlc4c29tc3h2Sk1qd3hrQnZOY2hRMk9nVUQwcm10UStJcnRaeVMyRm9HdVo1MGlnalVLLzJXSjhDUmxVU0F5TW9QQUFBTEZlY0hGZWRlSmRmOFZXT3F6MjJ0TkpvMm56V1ludHBSQWh2dFJoeVZtTWhjRllNWVlFRDVqd1FRTUViT0VGVHQwSmh6OCt1L3dEd3g5VXI0dmoxMkRUNXJTMTAvVVdrVlRJYkNjVzcyak1TQThzTWplYkVvemcrWVFRVzc1cGpXV3Z6UGNYMTFEcDJuN1YydGF4M2h1WTVBcGJMTklFQk9RVmI1Z01FSEJPYThsK0YwYTJONS9iSVcvdmIvd0FTbUJKZkVGb0gxalRKNEZKWklUQXFmdVdaR0EvZU9kclpBNHdLK2kydUNZMGtRVFB1a1pSQTUzRnNFL052WVpBR1NPZTNZWXhYRkNjNG5WV2hEcHFjbDRVZzhQNnVxdjRqOFJKYXN0dHZnc0xhSlRkYWtBV1ZtU2ZhVmtCQVEvdTFSZ2NobFU0TmJ1cmZDelRyMVpOUTBaN2UyUlZGdUdzNzBhamJ6d2pKUXR2eVFSdUFZWlh0endNVWIrM3RycEI1OEtGRVlsSE13RHdPTWZkWURLa0VmZVU4WnE1cHZpM1YvRDhUUVQyeWE5WnN3S1hFeFdMV0xNZkxrQnNCWnVtUnVJYko2bXV5RTI3T0xPS2NFdGxvY0RlL0RuV3RMRFJ6Tlo2dVpWTWdXM2g4dVl4Wlk0VkNNRWNFOE9UeDB6WEtOcEloTE5KWVQycXd4K1hFWHM1V1NBZE4yZHUzSHFWOXVhOThtOFRhZHIwRU5wRGRHRnBYODZZWEV2bFMyYk51VmthQTRaVkp3U2VjK3RQYURWZkRXbVRKL2JCMVZMbXg4bTNzZEYxakUxbXN4d1dlM1JWK1FoTVl3VHp5UUs2WVNmZlU1cFJUMlI4dFhwMCswMzJrTjFIQmNSd2k0ZUNHY1JUS2pFcXpnTHpna0VaWURuSElxdVo3UzN0Rm5WYnE0aGZEZVpMZk9ab2xQTEVLWDJnKzV5VDY5SzlUUjNON0xOSmIyMC9tV3pSTmNYY1NQUEdja2tGbXo4by9Qa25CcWcwZG1CY1J6YWRwdm16Rk0zTUlHMTE3YmRxbFQ5VzU0NlZ0N1FqMmE3bkRlRGZFZmgrZisxTE0zS0VhWE8wVFJyTDV2eVNqelMwaUtDVHkwbVQ2QWM4NHJvTEh4UjRXMWk3aTAvUjlZajFxL1daN2MyVm94U1dBTEg1cW9VY3FGY0tDU3ZBd00rdGFOdnBsbDRVdTlRZ3RMTnJTMzFSenJrb3RMZElXYVJvNDFua2hYYm5oMERCVG5tVFBSc1Z0WE45cGlMSGQyaVNHNHVZZk8vZTJvZ3ZncEhPOU1ibE9lb1BybWxHYjZFdW5HMTJaRWxocWx6RTBENlJhV2pDVVhGcE5xRWlYQVY0MkJpazhtSWtFZzRJQmJHZW83VnhPcTIzamROV1dkcEw2YlRrYmZmV2s5bDVtbVB5QUd0UkNlQmdFbFpSMTU0cjBJK0kwK1ZKcmkwZ0xKbUlTVHFwZnJ5TzV3QitlZUtobTF4YlpwVmxQMlovbDh5Wm95cGtVREM4cjk0NUl3TTkrbmFqbWV4VVlMZEkxTklrYTR0VEtQSy9kZk1JbWc4bnk5d0JKVXNUZ0RKK1g5T2xYN1MwdTc0K2JEOWxiN0lHRWtzWCtoeFhlOGcrVXJIUHpZQURFWnh3Y0RPS3hiZTF1TlJVLzJ0SzhWa3pvVnRESVlidTdPUXlsamtNcXFNREIrWThad0JYWU5mOEEyZTNpZ3RMUm8vS3dJMVd6UzR0b2dEenVBSXgzNTl4VVdzYWFORDV0Sm1sdDB1TlN1WjlNbGl1MVJCcHR6TGZSUlJoUXpvKzc3eWxjY2s1WGpIQUZaUnQybXVKaDlqbmloaU8ySzd2N2lPT0tVQWdnQmNrODRBSUI1OXNuR3ZxTVY1YVJ4eFh0cnFGaUxwb2pHd3RNQzViNUpRTjZrNTRLbmc0SUk1NmdjOWVhakpLNkNhMW5JZVY0aEY1UWVLTXI4bzh4dVY2anF2cjdWWE5KYXQ2a2NzSHBZeDRDMDBidEdzY3NpeW1LWUtVTVNHWkJHNnVHVm16a0VBbjVRVHhnOGpNdnZEOTRKWWRTSzZEWkN6dEhDUTZtL3dCb2thYVBKV0JtM3FrS2s1L2U3WDVBVUFodWViSGlhMTByeEZxdWsrYkRGRzg0Z3ViZVNSWTMyU29KVTNEaGxCRWg0VWpQdmluNnA0aDFGcm9DMmpzN3QvSit4eVgyb1c4OTJiWmpISm5ObEZ1bG5WRDVXTmlqQWtZNDcxUzkrWExiODlmbjArWm5LTXFhY3Y2LzRQeUxlaytNZEkxR085dDd6UnJyU1prdWt0TGdhaHBDMmxnWlRoaHRteVk1Zjd4QXlWR0N3VUVHdXVlM25oR0xlNU1EN2xOdzBVQm1nTWVSdUs3Y0VaSDhRK1VjWXpYam1yYWw0bGExMEtkRjhOVCtFZkVGOUZhWE9wYXpxODNoclRWYVNKNEZsaXQ4U3oyOXd4UGtoaWNraFZZSmtrWjB1aytQYkR4VFpqd3Q0cXRSNGFIa3lhamFhL29raHRyS09MRVR5NlhNN0kwck1DMlZZb3dPV3cyY0dLa09XWEwvQUYvWG9iVVh6dzVrL3dDdTNkZk5lUjd4RkpJMDhjS3NDb1VwSEpKTUpJdlhMcWVCMjVZSHI3NXF6SHE5aWw1R2s3V1VseEc0Z2tqanVvNXlCbmE1MkU3MUdRdzVHMEVkYXpiMlovc3pIY0xLNE1YbE5NWTJYN1NHMmp6bGJQVmVoRHF2SUJ5ZTlHQmRMMDR5U3hhWFlSWDhrV0gxVkxGSk5RdlpDbzNtV1pWM0ZqdFhKSk9jQTQ2WXpuSlFoMWZjdU1YS1h2YWRqTnU3YUdRV2NPaytHVWt0NVZFY2RtTlRsTjNFRkFQbXp0TWRwakxaWmkyWE85QUFjRTBMNGNZYXRhYmYzdW1lZkpMcUtHN2lNc0h5cXNVVUMrVGphRGx5eGN1YzdWUGF0elM5YzFMeFpkMzBsMW8rckxwVGFnOFBoM1g3OVliT0xXbCtZU3p4UnhzSkdKWlBsYVJGR3dEQUpMQWVvZUd2Q2lKT0xPVkpaekRZOHpYc29BdUhpTVp5SHpneUVNMkNTQXhWdUJsYTVwem9VNGM4bHVkRlAyOVNmSW44Sy9wYjlEeHkrMGI3TlBkVDZiQ0U4M3lvbWdsdDQ1cHpqY3JFS1J0QUdWQjZBNDYxdzExNHc4TWVEYm1TM2JTSmZEK3FDM1lpUzYwOEtHRzNjMExPcWxWV1Joa09XR2R3SFlnZmFOeDRKc3piWE53NGd1WmJTUjQ1Yk8xYmJLMFlIbStXakFrdUFvWndGeG5iajd4QXJMMXI0YmFmUGJwZDZkb2dGNUZickxFdjluejZwRGZzVHZDT0pJbVVNd0lPV3dxNU9XR0dGY3p4bUhqZFUrcHZDaFdrazYyMzlXNy9BS256cDRRL2FEMGpUTkN0TEMwdTdMN0hQZnRkeVJ6Mkw2ZHFkcGN2c2krMExNaFZRMFVaazJydUNrelNjc1d5UG9Idzc0K3VmRjlndHhwY28xdUpyd1gwYStKYmUzMEtTM25XTlpacnByaEpaQWxvU3d3WGhhUmprdHRRYytJZUcvZ2pvTjlmWFduM09pVDNVRWJQY1hsdktzU2FqcHpUQjQxZ0N4WUVVVGxuS3VXQitVc0ZPQTlkV2ZnSDhPclJyS0wremZFbHhIRklzWWt1YjZXNlN4M0F2RXlzQ1JGSEh0S2hsUVpHemRuQk5jbFBHeGkycWx2djI5ZXYzZjVuYlZ3Vk9TVHBOM2ZrdncvUzlpdDQ4K0lHbmFyWTNOdHEzaHlQeXRTMDJIUzdORGV6TFlXelR5eS9hYmlXNUJXVm1RY1d3WGFrb0pKRzBLVitHdFV1dFowbTVoaXRwcHhybW96ZllYbXZOWmtudWhhTGtNWjN5ZkxVRERNU1R0VmNCdUsrM1BGM3dtdUx2U0xrZUhmRlUwdDJadkxGNGI5WmJZQmdOeWdvRitiNVFjN1I5M0JGZk51cS9zNWFub3RsZVhPdXgzVjFxbDdGalQ1b05UYTBuYmY5OFBiRUF5SVZJQjh4dG9PU2ZscnBoVXAxNUtVRnIvWFd4enhvd29YblZldnBxY2JaZUk1dEtOM2JhdnJ2aG5XN1hSRyt6K2JhWHNIa1NUM0lTV1YrUXBLNFVEY0FTekU1L2lySDFmV3JpL1dmVlliQ3dsaDFXZnpiV0JZb3BZWUE2cEhFc2toa0JWbUhiTzFYSjZDc1B4LzhOdkZ0cEhwOTNQWWFRNjIwTU9td3h3NkRhYWUzRFBzU0NhMndrbzJBWUVnQmJheEcwL0xWVzUwSzMwdTNrYWFXZWFPS3lTNXVpTFVKSmFPV0liQzV3UUdSQ3pobTRNblhHSzlHU25HbEp0YUxWV3QvWGtjOU9WR2RhRGkvZWJzOUg1ZW5xZmEvd2I4WjZZMmdhZnBUU1JhSk0yeTNnaDNLYmVPUU1kc2FvdVRrajd6SDFCeWNnbjNQVU5Sc2RnYTlrS3hReEdlNWtKSXljWkpZWUM0R0NBZTNvYStHL2crbWx6VHpiWWdsNU9xM054dU1kcExEY2ZONXJUQm8vTUtFakFWc0RhVnlBUVJYMHhZYWxlWHRrd2wwaTRrdDUzVmpETmJLWVdLdnNRaU1BTEd1NFo1emdBY2RLNEtWcFJVbWI0aGNsUnBiSGZSYXJwbDZrOFducEpFc3NhN3Jnc2Q2SGFOcktwQnd3R1NPM0djVmpQTXdDcmRTTzhNRVc3ek42dkpJM1E3amdaNDU1SHB6MnJuSmZFWmdrbFNlM2x0MWpPTVJwSEVYYkhLOEQ1Z0N1QUdIWHVPYWtUV2JLNWprdUkvTmZ6OXNwbGs1YUpUd1FFeDBBT0NwengrQnJvVWRkTkVjalpKZnoyYTRhVFpLZHBQNzVoTTRCeU5vRERQSlBZL3BXZmI2MWQyRTdOWjZ2cVZpSTBaUEtnbllSaEdBeUFEbFJnRmVuZkh0V0xlelBKTWZKRE1GQWlNMFlSVUFLOFo1TEFkVG5rakhOWVVXblhFY2x3eWkzYVpVRVVyUlhEU1NIT0NyNE9TZVhCN2RlYXR6NU5Vd2pDTTlHVzROV1NhOWFNaVM0OHk1YU1pNnM1QjlvS2x6SWQ2WTJqQ2c3bUk1WVl6V3RGUHFEU2hMTzJzakM3QnphelBKTEVtT1V5MmR4d1FPcDc4aXVPL3NPMENQYXh3MjhSa2xEeU5ncFA1cFlNV3lEa0Vua3FDZWVld3JZc285UTAzN1Q5bG1sdUJLancyL253K2JFWkJ4Z2h1ZWhPZXhPUmpPS2NxNmVrZnlFcUsza1IrSjlkMUdiVU5EUzRrU0svbWtrc3RQYTI4eVZaMmRBOHNXY3NGYkVZWUtjRDVPQ01ZcTdGQjRubmhnYVh3M2VpTVE3RnVya0phVytPbVdrYVFmZXlDTThuUDF4Z2Ezb2Q5cWxvNWVDS3llQUF3WFVLUlNDM2tCRHBNaUhJUEl5RndjaGVUelhUNkg0amhPa0pwVHh4cTJtN1d2dEdoaGl0N1N3SkhrcXFOR3Foa0h6dEZ2Sk9IYkpHS3VNM1pKTFV5bEJMVmJmcVgxOEozWGx2ZTZoZjZYYlJSckh1anRwRGNUZ01lUVFWQzdsUFhBYnFPVDNzYVcvaGNBUGEzS1hsMGtyVzF4ZVMzcTNjeGJJMmJEbkNEZ2NBRHIzcVo3blQ1NENsNmx0SkFHS1RSejJra3NtQmpKenVCQjVCQUFQVGozNDNUdkJQaEd3bG51dER0cDdDZlZJbWlrdU5LVVc2Uzc4UHYyN2Nia0ozWVlITzRaOTM3Uk5XYVlsQmJYUHBLLzhLV2FhZGJXZHJwdXAzVi9xR21SWE41cU9uWExScHBFZ1l4eWxMaG96RTJkd01nQVl4c01idTYxWVBDVGVWYzI5cEJIZDJkbUNsbHE4TjAxeE5yN0t5b0k3YUZqNXpPZUYrZGNOdURaNXdPTHN0VHViTzJTMnVMNjdqQUFFUVcvZTNGenRVS0RuY0ZCeWdZNXo5MEFBakZTMzEyNFQ3WXVvWFJaSXNTcEhjQzVDa1lZcXUwbHNIZ2dKM1Bhc295Y1phZGV2OWYxOHkzelNnb3llaXU3ZWJ0ZC9ocWJmaWZWUmIyTmw0ZE50cWxqSG9KbHRBTmNqVnRUa3VXKy92RWVCR28yUm9JVXlQM2U0a3NXeHdRdVJBdHZKUGRxMHFXN1IzQWhSclpDd0dTRVJtM0tEeVFlZW5VOWE1bnhINDh0bzdpMkd1dUE0ZlpiWDE0amdRdWk3MUc1enpqQlB6RGdEdFYvU05hMHpXcmgzbnZkT2pWMGVDQlpDOE56UE5IdExGT1A5V0FTUzRCRForVTRITzEzQmFMUWhRVHRjK2VmaWY4QURQdzM0cjhVd2VKcnRkVlNhKzA3N041MWpLVnRBOEc0eHM1TzQ3dGo0K1RBd3A0R0FhNy9BTUhUM3VqM0lnV1cwdHRQMG5TNHJlTFVMalVXMC9VNDQ1RkltUjVKRndWL2RxeU1HWW5ZQXdKQVkydmpMOEtmR1BqTHcrZFowRFV6R21pd0MrT2h5MndRemx2bDg2Mm1WbGN5UnJ1S3J0SVk4SEJJeG0vRHZ3UGRXWGhuUjczeEo0blN4dFlwb2pGckY2QktMZVF0NWNna3VwbStWbk9Oc1UrZnZoVndBdUxwMUU1KzUvV3dWRkZVVTV0UHBZNjJ3dUJGcWQvSm91Z2VITDYrMXh2dEoxaWZUWXRXMUNmekk0MGtLVHpwbGc2QlRJdno5TWdBWnJ1bzdDMzA2SzNHc1BIb2trRnFYbGx1cDIxS08raFZRQjVTcmtxL3pESUFMQlNBRllZSTQyNHR0T2h2WkpOUjFDLzFxMXN0Ulh5TlNOck1OSnRIWmpIQzBqSUJGQ3d5MzcxbjJGY2xTUG1XdlJZZmh1MnJrNm5QZkxCWjNFYVNSNmhwc1NhMWF0eWNQS1E0Slg1UmdRazUzOVJpaXE0dTB1Zi9BRE1JU1NUaHlOSjlYdC9tY1RxTWVuNmxZcHJ1bVdVZWthZkRCRGJOZTZqZXltNjFwbWZkR0xlMFlqTHNveWtqcXI0VmdSeHpvK0hOU2s4UTJNMDE3cDFyY2FSQy9rMmwxZU10dk8rN3pZL25oVEVxRk5qQmtDbG1hUkNRMk9PaTB2dzdiNlRyRTF4cHVsd1h2aWV3dDViQTZ6b2tjT3FhZExFOGl6UW1hOW1LL1oyS3FnWkFyTVE3WUxZTldybTZodDBzdFU4UjM5L29Pb1dwbGV6ZTQ4UHlXMmpXREJWWm10NUR2MmxkNUJtbCtZOEZOcWsxajdTN3M5alJPTFZrMy9YOWY4QTlPOE9hSjRUUzVuSitKK21XTFBFclJ5eS8yVnE4RVNPM0N4NFpFQ2ZLaEp5QmtFSG1tZUZ2Rm5nK2ZVTCtHYld2RGQxcUs2dUxRYWtieUNJNmpGL3FiVzVWQXVBSkVqK1JNNUM3ZU9jMThHL0VYVGRhOFpUV1JzZkN2Z1N4c0YybSthMTFxTzJ1N2xOeDh3SE5vWTF5ck1BaXg1K2I3NHhtdXc4T1RRK0hyQzAwYlQvRGlXR24ydHVxS0lMaTJ2Z3hSaXltU1pSNWtqWkorWnVlZTNTdUtXV1ZweWJxVnY2L3IxOGp0amo2RUlMa282OWY2WC9BUDBac2RXOFBSYnRTT28yNm8wNGVDZUhVbzFMcVJzekRnZ2dMbk9VSUpKNmpCcnJkRCtKbnd3dWIrV3oxRHhWcnZoelY3UmtkcjYyMDE5VDhLMzBUZ2ZKSk1zY2hXY2xjYkNwNm5CSFN2emdiVzllZ3MwR2gzMFZoS01GSW10ZjNVWUE1UlkxaVpWQnljRmNIUFhOV1pMalY3dUdKcDlYZTN2cGdCYy9NMTFCYzhZWXlRc3ZRRGdESzlmd3JHZVNLbzd5cWEvMXVYSE5uQktLcDZIM1Q4Vi9qVit6aDREV0s0ZzFhRFd0UnY5MGN0eDRmMGpVdkUrdXM2N1Ftd1FMR295V0xNczRPMGJSd0FjZk5UL0huUk5mMUdKdkR1aCtLTk4wMnpUZmRYUGpiUTQ5TW5sWW5hNXRWUjJLYnd6TUhaV3gzRzNrZUxYMEoxcTdpbjFXZlJybS90NXR0czRtYXpTempYQVh5eUVFaVp3Q1ZXVEJQcjJra3RMNUhSUDdTdHlpbmNBZFFtdXc0QXdPV1FuamsvZXprMVZMSThLcFhyeXV2eCs4bWViNG0xcU1iZXJWbDl5UFV0UytKUGhBVHpTdytGcnU3MUQ3Tzl1K3ROcHk2eTBrY2g1Mm1OTTVIeW5pSmNaeUQzcnpEeFg0dmsxYU9Td3QwbnVKTHFLTllyRkV1N0t5ZE5ubDUvZTVYek1PZmxWY0U3czR4aW9sME82bUwzRWV0V3djUmdHS2E5ZUlrZnhJY3g3V3lEeUNlb3FXeW1tMGE4UzVnV3grMUtPTG9Pc25tanNDSTBISU9PcDlzMTYxS25oNkVlV2hHeDUwL2JWNWMxZVYyY0plK0gvRmEyOW91cFdPdlc4bHBwKzJJWE9sTzlwWk02RVBJaFdJUnJ2UUwxQkNnSEJISXJrTDZ4dllySzdlNHM1dFFXS0pSS0pOUFc1aGtYQ3F1UWdCNXh0eU9nOXNtdmRvTmExYjdaSGV1c2tOMjhrcTNMSFVCRkJNajdzcXFrRUFOa2Y0ZWhjM21teXh4ZWZvR2tTWGtjNHVMZlU3aVFmMnZieTVEczZTQkFxL01xa0FEYU1Iam5uVjFFNE9Oay9VbU1KS2FiYlhwL3dBRnE1NEg4Si9GVi80ZThSYWxwVTF0ZEhTOVdRM2xubzJudy9iVXNaU2ZMa21rZDM4dFNQTWJldno0TzBnZzV6OVE2aEpZSkJiejIwOStrV3hnMHp5eXJGSXJNUzNscXZ5NVZpQUczQWdnOUFlUG5UVmZDTTJvNjZtdFd1dHp4MzhOMDkxTTR1WnJHNW0zdVhsUTNrSVdSa2M0SFVFWlBCSEZkQnB2aVB4eHBVMTVaNmxEYmF4b2hQOEF4TElYbGFhOXNQTSs5R0xtUlM4MFlJNlNZYzd6bGlPQnhjampHMXJXUFFuUG5senAzL0E3aS8xcTEwcTVoaTFHMzFxL0VnY3gzbzA0U1dpNEFBaWtjTU5qODUzTmdFWU9UZzFWZzhaNlRJZHNkakdrVVJLU1N3MzhWeEl2SVZ4SWdmNVZHRkpVN2lNODFqdjR6bHVGTmxkK0ZkYmhUWXkzTU1UL0FHcTFaSHlyTkVONTVVWjJodXhIRlo5emUrRkozdDJidy9xZG94eDluUi9EYTN6cjh6TXdaU0JHRkpPZVN1VzV4bXRJcU83TXBPV2xqMGEwdTROZGtranQ1RGRUbVFTaGx0NTBSaHp0VjNDbGVRTThQNzRwWnhaYWZHUE52Yk9PVXVlYnFkb0ZmSEk1MmpCR1Q4bm9NNFBmenFmWDVJWTdadnRYaXEzVzBrRVVWbkQ0WWtZelF0a25LclBKRXZKeVZVOU80SEZSVCtMSXRUbW4vdFRRTmRtanQ4b3B1L0RLM0RTTHNCVjRXK1lyOHlnRlNjWUFxSlU0dVZ5bE9hVmowWkovdFVqcEJQQU1PVmtWbzVWdEVQOEFyT1diSEJHVDhvSUdEN1ZxMmx1MFprdklwTGFacEU4OHJHUkhHN1pWZDcrL1hJNDU0cnp5MzhiYUpDbHNqNlI0anRFaFJqQ3FXZ1NCT0Z3bms1QVVFcnhnRUQycnIwOGErRFF5M2d1ZFZpYWNqenJLMzB5NlVKa0RKbENLRUpIb3ZIdjZ3NEpLeTJEbWsraG91anpzbHZkeEdLYVNVTEtrRHRiQmlHVWhGemdFOEEvTGpLZzVIT2F6cjd3aGF6WGNsNXAxM2U2VnFEUUNLRzRSMGtoS3F6TWtjOFRERFJubjczell6aHVsWnQ1OFVmQ051UG0xVFZyUjJaVDlqUGhxYWVHUmtZRVNvd1RLSEdRRlk5ODQ2Vk9ueFI4SDMwcW1DZlc1a2dSOHdEUW1qaU9jRUU3MVhKR096REpQUVZQTktMdTJVb1Nsb2svNis4eFUxUzgwaUtHSFg5UGlnS3I1VTJvVzBpNmxwMDR5ZGttY0FqZ0Z4bEJqUEp5clYwZGo0bDA4TmRXMXpyVnZjWEluVnpaM2w3QllSV3FsUXZsSkRoSkEyU2czU0Y4a0E0NUJySWI0ditDcmU0ZDFrdlo1Y21BV1V2aDY2OHlOU01nbmpidUJBRzRFNXdBZWxSNm44VFBoOXFObmNyY2VGcis2RWtaMlJ0NFdOL0loNEsrWDVxSGFBMld6bmc5K2ExOXBMUnRYSWRKTjJTUFJSckduZlo0M25RU0Y1QXlRS3l5TktyQWpkRzVJVnZZSEhVZWxKYWF0YjNpeFBIWlMyY1lINzE3cFlyaVhZUm5JalNRN0R6ajVobmpqSUlOZk1jK3JlQ3JzUERCb0hqZTBnVm1hYVNIUzRvUkxsdDZNc0RTckU1RFpPekcwQTR6a0N1YWVIWDdxM3VkUDBTUFhZTk5uazg0WFdveEN5dUpwQ3BVUEpHaGRpQUFBU1dIVEdDTVZUbWsrWVNvdHUzWDBQcjZWUEQ2VHErenpGbFlSTTdxWVVrTGZNUmpqKzZjN3ZTcGJVZUc1VEpMYVdsdGIzTE83cE00SXVRZUFWM3J6eVY2WkFJQXI1VzBxMW0wbHRQdlpKZkVPbjZ2RkRKRHJPc1JhbmY2ckZySlp3WTVGczVMZnlvQ3E1UnNidzJkdzJFYzl2cGV0NnJjUndKUHF0cEw1WmQ3ZUdTeGtXNWlMWnlCdk9HNjV5eXJuMEFvaDc3Vi82L0FLbFAyZWlmOEFYa2ZRWG5XazBVVUVkd1hSQnNVd2xWWk04WU9lT3ZBRFl5UU04MW5XK2dhZm9rMHV0YUhydWkybW95d2JOUzAzeFBhMnBTOFh6Tnp4UnlJckNNa2Z4Z2RISVB0NVhjelBjTEFsdk84bTA3NW9ya0l5dGdFZ2h1bWM1eUNPL1dxMTE5bXZZM2hVckEza2lHU1RVcmtORk1jRS9PcWpkMngwUFFkYTE5bkZweDZHRGNscjFQUjIrSWQ1cXdrdDlLanNMS0tlSnJlY0c0bDF1MUN0dTVSeEpGQ3dYRGdIa0FLdVNPTStaVCtHZFB2b3J0cHZHWGlIUjdVeU5lMnk2VDRnUGhMUjRKVGgzRU5wYmJVK2NnRnNrNzl6WnpsalRZNTcrSjBuT3FXRndaa0t6VzBjMDA5dmpvRWRHZEdJejJKNTQ3Q3VoMDN4TGM2ZEMwVDZUNGVqbkp6Ynl0bzhGd2tXV3lKRkMzRFlZRUFyMEk2ZDZxTUtNVmJsUmsxVlQ1b3QvZ2RCb25qenhPdHVMYlJvZFYxNTdHNEN5M3R6cFM3SWt6bHBqTGJCUVcrVWhReUhJeWNldnFWMWNhSDRoMG1YVFBGWGpLMjBXYTdaWjcreTAvVVQ0ZGE4VXR1V0dlZTVqODY0alVESlViSXdYWWJDTVk4ZXQvSHZpbUJ0c2x3VXRTb0R4VzA2V1VTa2pHNkpsSlpNWUhCTGdLY0RITmFpL0VPL010dXJYMTNlUndzWkpJWDhiTFBKY2REKzgzMnpNY01xNFZTb0FCNTdIR3ZoMVZWb1N0Nkl1alZkR1NjcWFmei9BT0dQLzlrPVwiIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/images/env.jpg\n");

/***/ }),

/***/ "./src/matrix.ts":
/*!***********************!*\
  !*** ./src/matrix.ts ***!
  \***********************/
/*! exports provided: Matrix2, Matrix3, Matrix4, Vector2, Vector3, Vector4, Frustum */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Matrix2\", function() { return Matrix2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Matrix3\", function() { return Matrix3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Matrix4\", function() { return Matrix4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector2\", function() { return Vector2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector3\", function() { return Vector3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector4\", function() { return Vector4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Frustum\", function() { return Frustum; });\n/* eslint-disable */\n/**\n * This is a class treating 4x4 matrix.\n * This class contains the function that is equivalent to OpenGL matrix stack.\n * The matrix after conversion is calculated by multiplying a conversion matrix from the right.\n * The matrix is replaced by the calculated result.\n */\nclass Matrix2 {\n    constructor(opt_src) {\n        let i;\n        let s;\n        let d;\n        if (opt_src && typeof opt_src === 'object' && opt_src.hasOwnProperty('elements')) {\n            s = opt_src.elements;\n            d = new Float32Array(4);\n            for (i = 0; i < 4; ++i) {\n                d[i] = s[i];\n            }\n            this.elements = d;\n        }\n        else {\n            this.elements = new Float32Array([1, 0, 0, 1]);\n        }\n    }\n    set(src) {\n        let i;\n        let s;\n        let d;\n        s = src;\n        d = this.elements;\n        if (s === d) {\n            return;\n        }\n        for (i = 0; i < 4; ++i) {\n            d[i] = s[i];\n        }\n        return this;\n    }\n}\n/**\n * Constructor of Matrix3\n * If opt_src is specified, new matrix is initialized by opt_src.\n * Otherwise, new matrix is initialized by identity matrix.\n * @param opt_src source matrix(option)\n */\nclass Matrix3 {\n    constructor(opt_src) {\n        let i;\n        let s;\n        let d;\n        if (opt_src && typeof opt_src === 'object' && opt_src.hasOwnProperty('elements')) {\n            s = opt_src.elements;\n            d = new Float32Array(9);\n            for (i = 0; i < 9; ++i) {\n                d[i] = s[i];\n            }\n            this.elements = d;\n        }\n        else {\n            this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);\n        }\n    }\n    set(src) {\n        let i;\n        let s;\n        let d;\n        s = src;\n        d = this.elements;\n        if (s === d) {\n            return;\n        }\n        for (i = 0; i < 9; ++i) {\n            d[i] = s[i];\n        }\n        return this;\n    }\n    normalFromMat4(a) {\n        const e = this.elements;\n        a = a.elements;\n        const a00 = a[0];\n        const a01 = a[1];\n        const a02 = a[2];\n        const a03 = a[3];\n        const a10 = a[4];\n        const a11 = a[5];\n        const a12 = a[6];\n        const a13 = a[7];\n        const a20 = a[8];\n        const a21 = a[9];\n        const a22 = a[10];\n        const a23 = a[11];\n        const a30 = a[12];\n        const a31 = a[13];\n        const a32 = a[14];\n        const a33 = a[15];\n        const b00 = a00 * a11 - a01 * a10;\n        const b01 = a00 * a12 - a02 * a10;\n        const b02 = a00 * a13 - a03 * a10;\n        const b03 = a01 * a12 - a02 * a11;\n        const b04 = a01 * a13 - a03 * a11;\n        const b05 = a02 * a13 - a03 * a12;\n        const b06 = a20 * a31 - a21 * a30;\n        const b07 = a20 * a32 - a22 * a30;\n        const b08 = a20 * a33 - a23 * a30;\n        const b09 = a21 * a32 - a22 * a31;\n        const b10 = a21 * a33 - a23 * a31;\n        const b11 = a22 * a33 - a23 * a32;\n        let // Calculate the determinant\n        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n        if (!det) {\n            return null;\n        }\n        det = 1.0 / det;\n        e[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n        e[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n        e[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n        e[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n        e[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n        e[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n        e[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n        e[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n        e[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n        return this;\n    }\n}\n/**\n * Constructor of Matrix4\n * If opt_src is specified, new matrix is initialized by opt_src.\n * Otherwise, new matrix is initialized by identity matrix.\n * @param opt_src source matrix(option)\n */\nclass Matrix4 {\n    constructor(opt_src) {\n        let i;\n        let s;\n        let d;\n        if (opt_src && typeof opt_src === 'object' && opt_src.hasOwnProperty('elements')) {\n            s = opt_src.elements;\n            d = new Float32Array(16);\n            for (i = 0; i < 16; ++i) {\n                d[i] = s[i];\n            }\n            this.elements = d;\n        }\n        else {\n            this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n        }\n    }\n    getScaleZ() {\n        const te = this.elements;\n        const x = te[8];\n        const y = te[9];\n        const z = te[10];\n        return Math.sqrt(x * x + y * y + z * z);\n    }\n    /**\n     * Copy matrix.\n     * @param src source matrix\n     * @return this\n     */\n    set(src) {\n        let i;\n        let s;\n        let d;\n        s = src;\n        d = this.elements;\n        if (s === d) {\n            return;\n        }\n        for (i = 0; i < 16; ++i) {\n            d[i] = s[i];\n        }\n        return this;\n    }\n    multiply(matrix) {\n        this.concat(matrix);\n        return this;\n    }\n    /**\n     * Multiply the matrix from the right.\n     * @param other The multiply matrix\n     * @return this\n     */\n    concat({ elements }) {\n        let i;\n        let e;\n        let a;\n        let b;\n        let ai0;\n        let ai1;\n        let ai2;\n        let ai3;\n        // Calculate e = a * b\n        e = this.elements;\n        a = this.elements;\n        b = elements;\n        // If e equals b, copy b to temporary matrix.\n        if (e === b) {\n            b = new Float32Array(16);\n            for (i = 0; i < 16; ++i) {\n                b[i] = e[i];\n            }\n        }\n        for (i = 0; i < 4; i++) {\n            ai0 = a[i];\n            ai1 = a[i + 4];\n            ai2 = a[i + 8];\n            ai3 = a[i + 12];\n            e[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];\n            e[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];\n            e[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];\n            e[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];\n        }\n        return this;\n    }\n    /**\n     * Calculate the inverse matrix of specified matrix, and set to this.\n     * @param other The source matrix\n     * @return this\n     */\n    setInverseOf({ elements }) {\n        let i;\n        let s;\n        let d;\n        let inv;\n        let det;\n        s = elements;\n        d = this.elements;\n        inv = new Float32Array(16);\n        inv[0] = s[5] * s[10] * s[15] - s[5] * s[11] * s[14] - s[9] * s[6] * s[15]\n            + s[9] * s[7] * s[14] + s[13] * s[6] * s[11] - s[13] * s[7] * s[10];\n        inv[4] = -s[4] * s[10] * s[15] + s[4] * s[11] * s[14] + s[8] * s[6] * s[15]\n            - s[8] * s[7] * s[14] - s[12] * s[6] * s[11] + s[12] * s[7] * s[10];\n        inv[8] = s[4] * s[9] * s[15] - s[4] * s[11] * s[13] - s[8] * s[5] * s[15]\n            + s[8] * s[7] * s[13] + s[12] * s[5] * s[11] - s[12] * s[7] * s[9];\n        inv[12] = -s[4] * s[9] * s[14] + s[4] * s[10] * s[13] + s[8] * s[5] * s[14]\n            - s[8] * s[6] * s[13] - s[12] * s[5] * s[10] + s[12] * s[6] * s[9];\n        inv[1] = -s[1] * s[10] * s[15] + s[1] * s[11] * s[14] + s[9] * s[2] * s[15]\n            - s[9] * s[3] * s[14] - s[13] * s[2] * s[11] + s[13] * s[3] * s[10];\n        inv[5] = s[0] * s[10] * s[15] - s[0] * s[11] * s[14] - s[8] * s[2] * s[15]\n            + s[8] * s[3] * s[14] + s[12] * s[2] * s[11] - s[12] * s[3] * s[10];\n        inv[9] = -s[0] * s[9] * s[15] + s[0] * s[11] * s[13] + s[8] * s[1] * s[15]\n            - s[8] * s[3] * s[13] - s[12] * s[1] * s[11] + s[12] * s[3] * s[9];\n        inv[13] = s[0] * s[9] * s[14] - s[0] * s[10] * s[13] - s[8] * s[1] * s[14]\n            + s[8] * s[2] * s[13] + s[12] * s[1] * s[10] - s[12] * s[2] * s[9];\n        inv[2] = s[1] * s[6] * s[15] - s[1] * s[7] * s[14] - s[5] * s[2] * s[15]\n            + s[5] * s[3] * s[14] + s[13] * s[2] * s[7] - s[13] * s[3] * s[6];\n        inv[6] = -s[0] * s[6] * s[15] + s[0] * s[7] * s[14] + s[4] * s[2] * s[15]\n            - s[4] * s[3] * s[14] - s[12] * s[2] * s[7] + s[12] * s[3] * s[6];\n        inv[10] = s[0] * s[5] * s[15] - s[0] * s[7] * s[13] - s[4] * s[1] * s[15]\n            + s[4] * s[3] * s[13] + s[12] * s[1] * s[7] - s[12] * s[3] * s[5];\n        inv[14] = -s[0] * s[5] * s[14] + s[0] * s[6] * s[13] + s[4] * s[1] * s[14]\n            - s[4] * s[2] * s[13] - s[12] * s[1] * s[6] + s[12] * s[2] * s[5];\n        inv[3] = -s[1] * s[6] * s[11] + s[1] * s[7] * s[10] + s[5] * s[2] * s[11]\n            - s[5] * s[3] * s[10] - s[9] * s[2] * s[7] + s[9] * s[3] * s[6];\n        inv[7] = s[0] * s[6] * s[11] - s[0] * s[7] * s[10] - s[4] * s[2] * s[11]\n            + s[4] * s[3] * s[10] + s[8] * s[2] * s[7] - s[8] * s[3] * s[6];\n        inv[11] = -s[0] * s[5] * s[11] + s[0] * s[7] * s[9] + s[4] * s[1] * s[11]\n            - s[4] * s[3] * s[9] - s[8] * s[1] * s[7] + s[8] * s[3] * s[5];\n        inv[15] = s[0] * s[5] * s[10] - s[0] * s[6] * s[9] - s[4] * s[1] * s[10]\n            + s[4] * s[2] * s[9] + s[8] * s[1] * s[6] - s[8] * s[2] * s[5];\n        det = s[0] * inv[0] + s[1] * inv[4] + s[2] * inv[8] + s[3] * inv[12];\n        if (det === 0) {\n            return this;\n        }\n        det = 1 / det;\n        for (i = 0; i < 16; i++) {\n            d[i] = inv[i] * det;\n        }\n        return this;\n    }\n    /**\n     * Calculate the inverse matrix of this, and set to this.\n     * @return this\n     */\n    invert() {\n        return this.setInverseOf(this);\n    }\n    /**\n     * Set the orthographic projection matrix.\n     * @param left The coordinate of the left of clipping plane.\n     * @param right The coordinate of the right of clipping plane.\n     * @param bottom The coordinate of the bottom of clipping plane.\n     * @param top The coordinate of the top top clipping plane.\n     * @param near The distances to the nearer depth clipping plane. This value is minus if the plane is to be behind the viewer.\n     * @param far The distances to the farther depth clipping plane. This value is minus if the plane is to be behind the viewer.\n     * @return this\n     */\n    setOrtho(r, t, near, far) {\n        let e;\n        let rw;\n        let rh;\n        let rd;\n        rw = 1 / r;\n        rh = 1 / t;\n        rd = 2 / (near - far);\n        e = this.elements;\n        e[0] = rw;\n        e[1] = 0;\n        e[2] = 0;\n        e[3] = 0;\n        e[4] = 0;\n        e[5] = rh;\n        e[6] = 0;\n        e[7] = 0;\n        e[8] = 0;\n        e[9] = 0;\n        e[10] = rd;\n        e[11] = (far + near) / (near - far);\n        e[12] = 0;\n        e[13] = 0;\n        e[14] = 0;\n        e[15] = 1;\n        return this;\n    }\n    /**\n     * Set the perspective projection matrix by fovy and aspect.\n     * @param fovy The angle between the upper and lower sides of the frustum.\n     * @param aspect The aspect ratio of the frustum. (width/height)\n     * @param near The distances to the nearer depth clipping plane. This value must be plus value.\n     * @param far The distances to the farther depth clipping plane. This value must be plus value.\n     * @return this\n     */\n    setPerspective(fovy, aspect, near, far) {\n        let e;\n        let rd;\n        let s;\n        let ct;\n        if (near === far || aspect === 0) {\n            throw 'null frustum';\n        }\n        if (near <= 0) {\n            throw 'near <= 0';\n        }\n        if (far <= 0) {\n            throw 'far <= 0';\n        }\n        fovy = Math.PI * fovy / 180 / 2;\n        s = Math.sin(fovy);\n        if (s === 0) {\n            throw 'null frustum';\n        }\n        rd = 1 / (far - near);\n        ct = Math.cos(fovy) / s;\n        e = this.elements;\n        e[0] = ct / aspect;\n        e[1] = 0;\n        e[2] = 0;\n        e[3] = 0;\n        e[4] = 0;\n        e[5] = ct;\n        e[6] = 0;\n        e[7] = 0;\n        e[8] = 0;\n        e[9] = 0;\n        e[10] = -(far + near) * rd;\n        e[11] = -1;\n        e[12] = 0;\n        e[13] = 0;\n        e[14] = -2 * near * far * rd;\n        e[15] = 0;\n        return this;\n    }\n    /**\n     * Multiply the perspective projection matrix from the right.\n     * @param fovy The angle between the upper and lower sides of the frustum.\n     * @param aspect The aspect ratio of the frustum. (width/height)\n     * @param near The distances to the nearer depth clipping plane. This value must be plus value.\n     * @param far The distances to the farther depth clipping plane. This value must be plus value.\n     * @return this\n     */\n    perspective(fovy, aspect, near, far) {\n        return this.concat(new Matrix4().setPerspective(fovy, aspect, near, far));\n    }\n    /**\n     * Multiply the four-dimensional vector.\n     * @param pos  The multiply vector\n     * @return The result of multiplication(Float32Array)\n     */\n    multiplyVector4({ elements }) {\n        const e = this.elements;\n        const p = elements;\n        const v = new Vector4();\n        const result = v.elements;\n        result[0] = p[0] * e[0] + p[1] * e[4] + p[2] * e[8] + p[3] * e[12];\n        result[1] = p[0] * e[1] + p[1] * e[5] + p[2] * e[9] + p[3] * e[13];\n        result[2] = p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + p[3] * e[14];\n        result[3] = p[0] * e[3] + p[1] * e[7] + p[2] * e[11] + p[3] * e[15];\n        return v;\n    }\n    scale(vec3) {\n        const x = vec3.elements[0];\n        const y = vec3.elements[1];\n        const z = vec3.elements[2];\n        const e = this.elements;\n        e[0] *= x;\n        e[4] *= y;\n        e[8] *= z;\n        e[1] *= x;\n        e[5] *= y;\n        e[9] *= z;\n        e[2] *= x;\n        e[6] *= y;\n        e[10] *= z;\n        e[3] *= x;\n        e[7] *= y;\n        e[11] *= z;\n        return this;\n    }\n    setTranslate(vec3) {\n        const e = this.elements;\n        const x = vec3.elements[0];\n        const y = vec3.elements[1];\n        const z = vec3.elements[2];\n        e[12] = x;\n        e[13] = y;\n        e[14] = z;\n        e[15] = 1;\n        return this;\n    }\n    /**\n     * Multiply the matrix for translation from the right.\n     * @param x The X value of a translation.\n     * @param y The Y value of a translation.\n     * @param z The Z value of a translation.\n     * @return this\n     */\n    translate(x, y, z) {\n        const e = this.elements;\n        e[12] += e[0] * x + e[4] * y + e[8] * z;\n        e[13] += e[1] * x + e[5] * y + e[9] * z;\n        e[14] += e[2] * x + e[6] * y + e[10] * z;\n        e[15] += e[3] * x + e[7] * y + e[11] * z;\n        return this;\n    }\n    getMaxScaleOnAxis() {\n        const te = this.elements;\n        const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n        const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n        const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n    }\n    makeRotationAxis(axis, angle) {\n        // Based on http://www.gamedev.net/reference/articles/article1199.asp\n        const te = this.elements;\n        const c = Math.cos(angle);\n        const s = Math.sin(angle);\n        const t = 1 - c;\n        const x = axis.elements[0], y = axis.elements[1], z = axis.elements[2];\n        const tx = t * x, ty = t * y;\n        te[0] = tx * x + c;\n        te[1] = tx * y - s * z;\n        te[2] = tx * z + s * y;\n        te[3] = 0;\n        te[4] = tx * y + s * z;\n        te[5] = ty * y + c;\n        te[6] = ty * z - s * x;\n        te[7] = 0;\n        te[8] = tx * z - s * y;\n        te[9] = ty * z + s * x;\n        te[10] = t * z * z + c;\n        te[11] = 0;\n        // te[12] = 0; \n        // te[13] = 0; \n        // te[14] = 0; \n        te[15] = 1;\n        return this;\n    }\n    makeRotationFromQuaternion(q) {\n        const te = this.elements;\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n        te[0] = 1 - (yy + zz);\n        te[4] = xy - wz;\n        te[8] = xz + wy;\n        te[1] = xy + wz;\n        te[5] = 1 - (xx + zz);\n        te[9] = yz - wx;\n        te[2] = xz - wy;\n        te[6] = yz + wx;\n        te[10] = 1 - (xx + yy);\n        return this;\n    }\n    transpose() {\n        let e;\n        let t;\n        e = this.elements;\n        t = e[1];\n        e[1] = e[4];\n        e[4] = t;\n        t = e[2];\n        e[2] = e[8];\n        e[8] = t;\n        t = e[3];\n        e[3] = e[12];\n        e[12] = t;\n        t = e[6];\n        e[6] = e[9];\n        e[9] = t;\n        t = e[7];\n        e[7] = e[13];\n        e[13] = t;\n        t = e[11];\n        e[11] = e[14];\n        e[14] = t;\n        return this;\n    }\n}\n/**\n * Constructor of Vector3\n * If opt_src is specified, new vector is initialized by opt_src.\n * @param opt_src source vector(option)\n */\nclass Vector3 {\n    constructor(opt_src) {\n        const v = new Float32Array(3);\n        if (opt_src && typeof opt_src === 'object') {\n            v[0] = opt_src[0];\n            v[1] = opt_src[1];\n            v[2] = opt_src[2];\n        }\n        this.elements = v;\n    }\n    applyQuaternion({ elements }) {\n        const x = this.elements[0];\n        const y = this.elements[1];\n        const z = this.elements[2];\n        const qx = elements[0];\n        const qy = elements[1];\n        const qz = elements[2];\n        const qw = elements[3];\n        // calculate quat * vector\n        const ix = qw * x + qy * z - qz * y;\n        const iy = qw * y + qz * x - qx * z;\n        const iz = qw * z + qx * y - qy * x;\n        const iw = -qx * x - qy * y - qz * z;\n        // calculate result * inverse quat\n        this.elements[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        this.elements[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        this.elements[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n        return this;\n    }\n    /**\n      * Normalize.\n      * @return this\n      */\n    normalize() {\n        const v = this.elements;\n        const c = v[0];\n        const d = v[1];\n        const e = v[2];\n        let g = Math.sqrt(c * c + d * d + e * e);\n        if (g) {\n            if (g == 1) {\n                return this;\n            }\n        }\n        else {\n            v[0] = 0;\n            v[1] = 0;\n            v[2] = 0;\n            return this;\n        }\n        g = 1 / g;\n        v[0] = c * g;\n        v[1] = d * g;\n        v[2] = e * g;\n        return this;\n    }\n    /**\n         * Scales a vec3 by a scalar number\n         *\n         * @param {vec3} out the receiving vector\n         * @param {vec3} a the vector to scale\n         * @param {Number} b amount to scale the vector by\n         * @returns {vec3} out\n         */\n    add(b) {\n        const a = this.elements;\n        b = b.elements;\n        a[0] = a[0] + b[0];\n        a[1] = a[1] + b[1];\n        a[2] = a[2] + b[2];\n        return this;\n    }\n    addS(b) {\n        const a = this.elements;\n        a[0] = a[0] + b;\n        a[1] = a[1] + b;\n        a[2] = a[2] + b;\n        return this;\n    }\n    scale(b) {\n        const a = this.elements;\n        a[0] = a[0] * b;\n        a[1] = a[1] * b;\n        a[2] = a[2] * b;\n        return this;\n    }\n    distanceToSquared(x, y, z) {\n        const dx = this.elements[0] - x;\n        const dy = this.elements[1] - y;\n        const dz = this.elements[2] - z;\n        return dx * dx + dy * dy + dz * dz;\n    }\n    subtract(b) {\n        const out = this.elements;\n        b = b.elements;\n        out[0] = out[0] - b[0];\n        out[1] = out[1] - b[1];\n        out[2] = out[2] - b[2];\n        return this;\n    }\n    divideScalar(scalar) {\n        return this.scale(1 / scalar);\n    }\n    applyMatrix4({ elements }) {\n        const x = this.elements[0];\n        const y = this.elements[1];\n        const z = this.elements[2];\n        const e = elements;\n        this.elements[0] = e[0] * x + e[4] * y + e[8] * z + e[12];\n        this.elements[1] = e[1] * x + e[5] * y + e[9] * z + e[13];\n        this.elements[2] = e[2] * x + e[6] * y + e[10] * z + e[14];\n        const w = e[3] * x + e[7] * y + e[11] * z + e[15];\n        return this.divideScalar(w);\n    }\n    lerp(a, b, t) {\n        const out = this.elements;\n        const ax = a[0];\n        const ay = a[1];\n        const az = a[2];\n        out[0] = ax + t * (b[0] - ax);\n        out[1] = ay + t * (b[1] - ay);\n        out[2] = az + t * (b[2] - az);\n        return this;\n    }\n    lengthSq() {\n        return this.elements[0] * this.elements[0] + this.elements[1] * this.elements[1] + this.elements[2] * this.elements[2];\n    }\n    multiply({ elements }) {\n        this.elements[0] *= elements[0];\n        this.elements[1] *= elements[1];\n        this.elements[2] *= elements[2];\n        return this;\n    }\n    static angle(a, b) {\n        const tempA = new Vector3(a.elements);\n        const tempB = new Vector3(b.elements);\n        tempA.normalize();\n        tempB.normalize();\n        const cosine = Vector3.dot(tempA, tempB);\n        if (cosine > 1.0) {\n            return 0;\n        }\n        else {\n            return Math.acos(cosine);\n        }\n    }\n    static cross(a, b) {\n        a = a.elements;\n        b = b.elements;\n        const ax = a[0];\n        const ay = a[1];\n        const az = a[2];\n        const bx = b[0];\n        const by = b[1];\n        const bz = b[2];\n        const out = new Vector3();\n        out.elements[0] = ay * bz - az * by;\n        out.elements[1] = az * bx - ax * bz;\n        out.elements[2] = ax * by - ay * bx;\n        return out;\n    }\n    static dot(a, b) {\n        a = a.elements;\n        b = b.elements;\n        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n    }\n}\n/**\n * Constructor of Vector4\n * If opt_src is specified, new vector is initialized by opt_src.\n * @param opt_src source vector(option)\n */\nclass Vector4 {\n    constructor(opt_src) {\n        const v = new Float32Array(4);\n        if (opt_src && typeof opt_src === 'object') {\n            v[0] = opt_src[0];\n            v[1] = opt_src[1];\n            v[2] = opt_src[2];\n            v[3] = opt_src[3];\n        }\n        this.elements = v;\n    }\n    set(e) {\n        const a = this.elements;\n        a[0] = e[0];\n        a[1] = e[1];\n        a[2] = e[2];\n        a[3] = e[3];\n        return this;\n    }\n    add(b) {\n        const a = this.elements;\n        b = b.elements;\n        a[0] = b[0];\n        a[1] = b[1];\n        a[2] = b[2];\n        a[3] = a[3] + b[3];\n        return this;\n    }\n    normalize() {\n        const x = this.elements[0];\n        const y = this.elements[1];\n        const z = this.elements[2];\n        const w = this.elements[3];\n        let len = x * x + y * y + z * z + w * w;\n        if (len > 0) {\n            len = 1 / Math.sqrt(len);\n            this.elements[0] = x * len;\n            this.elements[1] = y * len;\n            this.elements[2] = z * len;\n            this.elements[3] = w * len;\n        }\n        return this;\n    }\n    setFromRotationMatrix({ elements }) {\n        const te = elements;\n        const m11 = te[0];\n        const m12 = te[4];\n        const m13 = te[8];\n        const m21 = te[1];\n        const m22 = te[5];\n        const m23 = te[9];\n        const m31 = te[2];\n        const m32 = te[6];\n        const m33 = te[10];\n        const trace = m11 + m22 + m33;\n        let s;\n        if (trace > 0) {\n            s = 0.5 / Math.sqrt(trace + 1.0);\n            this.elements[3] = 0.25 / s;\n            this.elements[0] = (m32 - m23) * s;\n            this.elements[1] = (m13 - m31) * s;\n            this.elements[2] = (m21 - m12) * s;\n        }\n        else if (m11 > m22 && m11 > m33) {\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n            this.elements[3] = (m32 - m23) / s;\n            this.elements[0] = 0.25 * s;\n            this.elements[1] = (m12 + m21) / s;\n            this.elements[2] = (m13 + m31) / s;\n        }\n        else if (m22 > m33) {\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n            this.elements[3] = (m13 - m31) / s;\n            this.elements[0] = (m12 + m21) / s;\n            this.elements[1] = 0.25 * s;\n            this.elements[2] = (m23 + m32) / s;\n        }\n        else {\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n            this.elements[3] = (m21 - m12) / s;\n            this.elements[0] = (m13 + m31) / s;\n            this.elements[1] = (m23 + m32) / s;\n            this.elements[2] = 0.25 * s;\n        }\n        return this;\n    }\n    lerp(a, b, t) {\n        const out = this.elements;\n        const ax = a[0];\n        const ay = a[1];\n        const az = a[2];\n        const aw = a[3];\n        out[0] = ax + t * (b[0] - ax);\n        out[1] = ay + t * (b[1] - ay);\n        out[2] = az + t * (b[2] - az);\n        out[3] = aw + t * (b[3] - aw);\n        return this;\n    }\n}\nclass Vector2 {\n    constructor(opt_src) {\n        const v = new Float32Array(2);\n        if (opt_src && typeof opt_src === 'object') {\n            v[0] = opt_src[0];\n            v[1] = opt_src[1];\n        }\n        this.elements = v;\n    }\n    subtract(b) {\n        const out = this.elements;\n        b = b.elements;\n        out[0] = out[0] - b[0];\n        out[1] = out[1] - b[1];\n        return this;\n    }\n    lerp(a, b, t) {\n        const out = this.elements;\n        const ax = a[0];\n        const ay = a[1];\n        out[0] = ax + t * (b[0] - ax);\n        out[1] = ay + t * (b[1] - ay);\n        return this;\n    }\n}\n// { 0: right, 1: left, 2: bottom. 3: top, 4: far, 5: near }\nfunction Frustum(m) {\n    const planes = [new Vector4, new Vector4, new Vector4, new Vector4, new Vector4, new Vector4];\n    const me = m.elements;\n    let me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];\n    let me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];\n    let me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];\n    let me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];\n    planes[0].set([me3 - me0, me7 - me4, me11 - me8, me15 - me12]).normalize();\n    planes[1].set([me3 + me0, me7 + me4, me11 + me8, me15 + me12]).normalize();\n    planes[2].set([me3 + me1, me7 + me5, me11 + me9, me15 + me13]).normalize();\n    planes[3].set([me3 - me1, me7 - me5, me11 - me9, me15 - me13]).normalize();\n    planes[4].set([me3 - me2, me7 - me6, me11 - me10, me15 - me14]).normalize();\n    planes[5].set([me3 + me2, me7 + me6, me11 + me10, me15 + me14]).normalize();\n    return planes;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWF0cml4LnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkY3ViZS8uL3NyYy9tYXRyaXgudHM/NDI0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBUaGlzIGlzIGEgY2xhc3MgdHJlYXRpbmcgNHg0IG1hdHJpeC5cbiAqIFRoaXMgY2xhc3MgY29udGFpbnMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgZXF1aXZhbGVudCB0byBPcGVuR0wgbWF0cml4IHN0YWNrLlxuICogVGhlIG1hdHJpeCBhZnRlciBjb252ZXJzaW9uIGlzIGNhbGN1bGF0ZWQgYnkgbXVsdGlwbHlpbmcgYSBjb252ZXJzaW9uIG1hdHJpeCBmcm9tIHRoZSByaWdodC5cbiAqIFRoZSBtYXRyaXggaXMgcmVwbGFjZWQgYnkgdGhlIGNhbGN1bGF0ZWQgcmVzdWx0LlxuICovXG5jbGFzcyBNYXRyaXgyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRfc3JjKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgcztcbiAgICAgICAgbGV0IGQ7XG4gICAgICAgIGlmIChvcHRfc3JjICYmIHR5cGVvZiBvcHRfc3JjID09PSAnb2JqZWN0JyAmJiBvcHRfc3JjLmhhc093blByb3BlcnR5KCdlbGVtZW50cycpKSB7XG4gICAgICAgICAgICBzID0gb3B0X3NyYy5lbGVtZW50cztcbiAgICAgICAgICAgIGQgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgICAgICAgIGRbaV0gPSBzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cyA9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldChzcmMpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBzO1xuICAgICAgICBsZXQgZDtcbiAgICAgICAgcyA9IHNyYztcbiAgICAgICAgZCA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGlmIChzID09PSBkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgICAgZFtpXSA9IHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLyoqXG4gKiBDb25zdHJ1Y3RvciBvZiBNYXRyaXgzXG4gKiBJZiBvcHRfc3JjIGlzIHNwZWNpZmllZCwgbmV3IG1hdHJpeCBpcyBpbml0aWFsaXplZCBieSBvcHRfc3JjLlxuICogT3RoZXJ3aXNlLCBuZXcgbWF0cml4IGlzIGluaXRpYWxpemVkIGJ5IGlkZW50aXR5IG1hdHJpeC5cbiAqIEBwYXJhbSBvcHRfc3JjIHNvdXJjZSBtYXRyaXgob3B0aW9uKVxuICovXG5jbGFzcyBNYXRyaXgzIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRfc3JjKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgcztcbiAgICAgICAgbGV0IGQ7XG4gICAgICAgIGlmIChvcHRfc3JjICYmIHR5cGVvZiBvcHRfc3JjID09PSAnb2JqZWN0JyAmJiBvcHRfc3JjLmhhc093blByb3BlcnR5KCdlbGVtZW50cycpKSB7XG4gICAgICAgICAgICBzID0gb3B0X3NyYy5lbGVtZW50cztcbiAgICAgICAgICAgIGQgPSBuZXcgRmxvYXQzMkFycmF5KDkpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDk7ICsraSkge1xuICAgICAgICAgICAgICAgIGRbaV0gPSBzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cyA9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldChzcmMpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBzO1xuICAgICAgICBsZXQgZDtcbiAgICAgICAgcyA9IHNyYztcbiAgICAgICAgZCA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGlmIChzID09PSBkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDk7ICsraSkge1xuICAgICAgICAgICAgZFtpXSA9IHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG5vcm1hbEZyb21NYXQ0KGEpIHtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGEgPSBhLmVsZW1lbnRzO1xuICAgICAgICBjb25zdCBhMDAgPSBhWzBdO1xuICAgICAgICBjb25zdCBhMDEgPSBhWzFdO1xuICAgICAgICBjb25zdCBhMDIgPSBhWzJdO1xuICAgICAgICBjb25zdCBhMDMgPSBhWzNdO1xuICAgICAgICBjb25zdCBhMTAgPSBhWzRdO1xuICAgICAgICBjb25zdCBhMTEgPSBhWzVdO1xuICAgICAgICBjb25zdCBhMTIgPSBhWzZdO1xuICAgICAgICBjb25zdCBhMTMgPSBhWzddO1xuICAgICAgICBjb25zdCBhMjAgPSBhWzhdO1xuICAgICAgICBjb25zdCBhMjEgPSBhWzldO1xuICAgICAgICBjb25zdCBhMjIgPSBhWzEwXTtcbiAgICAgICAgY29uc3QgYTIzID0gYVsxMV07XG4gICAgICAgIGNvbnN0IGEzMCA9IGFbMTJdO1xuICAgICAgICBjb25zdCBhMzEgPSBhWzEzXTtcbiAgICAgICAgY29uc3QgYTMyID0gYVsxNF07XG4gICAgICAgIGNvbnN0IGEzMyA9IGFbMTVdO1xuICAgICAgICBjb25zdCBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gICAgICAgIGNvbnN0IGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgICAgICAgY29uc3QgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICAgICAgICBjb25zdCBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gICAgICAgIGNvbnN0IGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgICAgICAgY29uc3QgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICAgICAgICBjb25zdCBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gICAgICAgIGNvbnN0IGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgICAgICAgY29uc3QgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICAgICAgICBjb25zdCBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gICAgICAgIGNvbnN0IGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgICAgICAgY29uc3QgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuICAgICAgICBsZXQgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG4gICAgICAgIGlmICghZGV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgICAgIGVbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICAgICAgZVsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgICAgICBlWzJdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gICAgICAgIGVbM10gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICAgICAgZVs0XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgICAgICBlWzVdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gICAgICAgIGVbNl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICAgICAgZVs3XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgICAgICBlWzhdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbi8qKlxuICogQ29uc3RydWN0b3Igb2YgTWF0cml4NFxuICogSWYgb3B0X3NyYyBpcyBzcGVjaWZpZWQsIG5ldyBtYXRyaXggaXMgaW5pdGlhbGl6ZWQgYnkgb3B0X3NyYy5cbiAqIE90aGVyd2lzZSwgbmV3IG1hdHJpeCBpcyBpbml0aWFsaXplZCBieSBpZGVudGl0eSBtYXRyaXguXG4gKiBAcGFyYW0gb3B0X3NyYyBzb3VyY2UgbWF0cml4KG9wdGlvbilcbiAqL1xuY2xhc3MgTWF0cml4NCB7XG4gICAgY29uc3RydWN0b3Iob3B0X3NyYykge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IHM7XG4gICAgICAgIGxldCBkO1xuICAgICAgICBpZiAob3B0X3NyYyAmJiB0eXBlb2Ygb3B0X3NyYyA9PT0gJ29iamVjdCcgJiYgb3B0X3NyYy5oYXNPd25Qcm9wZXJ0eSgnZWxlbWVudHMnKSkge1xuICAgICAgICAgICAgcyA9IG9wdF9zcmMuZWxlbWVudHM7XG4gICAgICAgICAgICBkID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICAgICAgICAgIGRbaV0gPSBzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cyA9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFNjYWxlWigpIHtcbiAgICAgICAgY29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICBjb25zdCB4ID0gdGVbOF07XG4gICAgICAgIGNvbnN0IHkgPSB0ZVs5XTtcbiAgICAgICAgY29uc3QgeiA9IHRlWzEwXTtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3B5IG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gc3JjIHNvdXJjZSBtYXRyaXhcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBzZXQoc3JjKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgcztcbiAgICAgICAgbGV0IGQ7XG4gICAgICAgIHMgPSBzcmM7XG4gICAgICAgIGQgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICBpZiAocyA9PT0gZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgICAgICBkW2ldID0gc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbXVsdGlwbHkobWF0cml4KSB7XG4gICAgICAgIHRoaXMuY29uY2F0KG1hdHJpeCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSB0aGUgbWF0cml4IGZyb20gdGhlIHJpZ2h0LlxuICAgICAqIEBwYXJhbSBvdGhlciBUaGUgbXVsdGlwbHkgbWF0cml4XG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgY29uY2F0KHsgZWxlbWVudHMgfSkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IGU7XG4gICAgICAgIGxldCBhO1xuICAgICAgICBsZXQgYjtcbiAgICAgICAgbGV0IGFpMDtcbiAgICAgICAgbGV0IGFpMTtcbiAgICAgICAgbGV0IGFpMjtcbiAgICAgICAgbGV0IGFpMztcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGUgPSBhICogYlxuICAgICAgICBlID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgYSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGIgPSBlbGVtZW50cztcbiAgICAgICAgLy8gSWYgZSBlcXVhbHMgYiwgY29weSBiIHRvIHRlbXBvcmFyeSBtYXRyaXguXG4gICAgICAgIGlmIChlID09PSBiKSB7XG4gICAgICAgICAgICBiID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICAgICAgICAgIGJbaV0gPSBlW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIGFpMCA9IGFbaV07XG4gICAgICAgICAgICBhaTEgPSBhW2kgKyA0XTtcbiAgICAgICAgICAgIGFpMiA9IGFbaSArIDhdO1xuICAgICAgICAgICAgYWkzID0gYVtpICsgMTJdO1xuICAgICAgICAgICAgZVtpXSA9IGFpMCAqIGJbMF0gKyBhaTEgKiBiWzFdICsgYWkyICogYlsyXSArIGFpMyAqIGJbM107XG4gICAgICAgICAgICBlW2kgKyA0XSA9IGFpMCAqIGJbNF0gKyBhaTEgKiBiWzVdICsgYWkyICogYls2XSArIGFpMyAqIGJbN107XG4gICAgICAgICAgICBlW2kgKyA4XSA9IGFpMCAqIGJbOF0gKyBhaTEgKiBiWzldICsgYWkyICogYlsxMF0gKyBhaTMgKiBiWzExXTtcbiAgICAgICAgICAgIGVbaSArIDEyXSA9IGFpMCAqIGJbMTJdICsgYWkxICogYlsxM10gKyBhaTIgKiBiWzE0XSArIGFpMyAqIGJbMTVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGludmVyc2UgbWF0cml4IG9mIHNwZWNpZmllZCBtYXRyaXgsIGFuZCBzZXQgdG8gdGhpcy5cbiAgICAgKiBAcGFyYW0gb3RoZXIgVGhlIHNvdXJjZSBtYXRyaXhcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBzZXRJbnZlcnNlT2YoeyBlbGVtZW50cyB9KSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgcztcbiAgICAgICAgbGV0IGQ7XG4gICAgICAgIGxldCBpbnY7XG4gICAgICAgIGxldCBkZXQ7XG4gICAgICAgIHMgPSBlbGVtZW50cztcbiAgICAgICAgZCA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGludiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICAgICAgICBpbnZbMF0gPSBzWzVdICogc1sxMF0gKiBzWzE1XSAtIHNbNV0gKiBzWzExXSAqIHNbMTRdIC0gc1s5XSAqIHNbNl0gKiBzWzE1XVxuICAgICAgICAgICAgKyBzWzldICogc1s3XSAqIHNbMTRdICsgc1sxM10gKiBzWzZdICogc1sxMV0gLSBzWzEzXSAqIHNbN10gKiBzWzEwXTtcbiAgICAgICAgaW52WzRdID0gLXNbNF0gKiBzWzEwXSAqIHNbMTVdICsgc1s0XSAqIHNbMTFdICogc1sxNF0gKyBzWzhdICogc1s2XSAqIHNbMTVdXG4gICAgICAgICAgICAtIHNbOF0gKiBzWzddICogc1sxNF0gLSBzWzEyXSAqIHNbNl0gKiBzWzExXSArIHNbMTJdICogc1s3XSAqIHNbMTBdO1xuICAgICAgICBpbnZbOF0gPSBzWzRdICogc1s5XSAqIHNbMTVdIC0gc1s0XSAqIHNbMTFdICogc1sxM10gLSBzWzhdICogc1s1XSAqIHNbMTVdXG4gICAgICAgICAgICArIHNbOF0gKiBzWzddICogc1sxM10gKyBzWzEyXSAqIHNbNV0gKiBzWzExXSAtIHNbMTJdICogc1s3XSAqIHNbOV07XG4gICAgICAgIGludlsxMl0gPSAtc1s0XSAqIHNbOV0gKiBzWzE0XSArIHNbNF0gKiBzWzEwXSAqIHNbMTNdICsgc1s4XSAqIHNbNV0gKiBzWzE0XVxuICAgICAgICAgICAgLSBzWzhdICogc1s2XSAqIHNbMTNdIC0gc1sxMl0gKiBzWzVdICogc1sxMF0gKyBzWzEyXSAqIHNbNl0gKiBzWzldO1xuICAgICAgICBpbnZbMV0gPSAtc1sxXSAqIHNbMTBdICogc1sxNV0gKyBzWzFdICogc1sxMV0gKiBzWzE0XSArIHNbOV0gKiBzWzJdICogc1sxNV1cbiAgICAgICAgICAgIC0gc1s5XSAqIHNbM10gKiBzWzE0XSAtIHNbMTNdICogc1syXSAqIHNbMTFdICsgc1sxM10gKiBzWzNdICogc1sxMF07XG4gICAgICAgIGludls1XSA9IHNbMF0gKiBzWzEwXSAqIHNbMTVdIC0gc1swXSAqIHNbMTFdICogc1sxNF0gLSBzWzhdICogc1syXSAqIHNbMTVdXG4gICAgICAgICAgICArIHNbOF0gKiBzWzNdICogc1sxNF0gKyBzWzEyXSAqIHNbMl0gKiBzWzExXSAtIHNbMTJdICogc1szXSAqIHNbMTBdO1xuICAgICAgICBpbnZbOV0gPSAtc1swXSAqIHNbOV0gKiBzWzE1XSArIHNbMF0gKiBzWzExXSAqIHNbMTNdICsgc1s4XSAqIHNbMV0gKiBzWzE1XVxuICAgICAgICAgICAgLSBzWzhdICogc1szXSAqIHNbMTNdIC0gc1sxMl0gKiBzWzFdICogc1sxMV0gKyBzWzEyXSAqIHNbM10gKiBzWzldO1xuICAgICAgICBpbnZbMTNdID0gc1swXSAqIHNbOV0gKiBzWzE0XSAtIHNbMF0gKiBzWzEwXSAqIHNbMTNdIC0gc1s4XSAqIHNbMV0gKiBzWzE0XVxuICAgICAgICAgICAgKyBzWzhdICogc1syXSAqIHNbMTNdICsgc1sxMl0gKiBzWzFdICogc1sxMF0gLSBzWzEyXSAqIHNbMl0gKiBzWzldO1xuICAgICAgICBpbnZbMl0gPSBzWzFdICogc1s2XSAqIHNbMTVdIC0gc1sxXSAqIHNbN10gKiBzWzE0XSAtIHNbNV0gKiBzWzJdICogc1sxNV1cbiAgICAgICAgICAgICsgc1s1XSAqIHNbM10gKiBzWzE0XSArIHNbMTNdICogc1syXSAqIHNbN10gLSBzWzEzXSAqIHNbM10gKiBzWzZdO1xuICAgICAgICBpbnZbNl0gPSAtc1swXSAqIHNbNl0gKiBzWzE1XSArIHNbMF0gKiBzWzddICogc1sxNF0gKyBzWzRdICogc1syXSAqIHNbMTVdXG4gICAgICAgICAgICAtIHNbNF0gKiBzWzNdICogc1sxNF0gLSBzWzEyXSAqIHNbMl0gKiBzWzddICsgc1sxMl0gKiBzWzNdICogc1s2XTtcbiAgICAgICAgaW52WzEwXSA9IHNbMF0gKiBzWzVdICogc1sxNV0gLSBzWzBdICogc1s3XSAqIHNbMTNdIC0gc1s0XSAqIHNbMV0gKiBzWzE1XVxuICAgICAgICAgICAgKyBzWzRdICogc1szXSAqIHNbMTNdICsgc1sxMl0gKiBzWzFdICogc1s3XSAtIHNbMTJdICogc1szXSAqIHNbNV07XG4gICAgICAgIGludlsxNF0gPSAtc1swXSAqIHNbNV0gKiBzWzE0XSArIHNbMF0gKiBzWzZdICogc1sxM10gKyBzWzRdICogc1sxXSAqIHNbMTRdXG4gICAgICAgICAgICAtIHNbNF0gKiBzWzJdICogc1sxM10gLSBzWzEyXSAqIHNbMV0gKiBzWzZdICsgc1sxMl0gKiBzWzJdICogc1s1XTtcbiAgICAgICAgaW52WzNdID0gLXNbMV0gKiBzWzZdICogc1sxMV0gKyBzWzFdICogc1s3XSAqIHNbMTBdICsgc1s1XSAqIHNbMl0gKiBzWzExXVxuICAgICAgICAgICAgLSBzWzVdICogc1szXSAqIHNbMTBdIC0gc1s5XSAqIHNbMl0gKiBzWzddICsgc1s5XSAqIHNbM10gKiBzWzZdO1xuICAgICAgICBpbnZbN10gPSBzWzBdICogc1s2XSAqIHNbMTFdIC0gc1swXSAqIHNbN10gKiBzWzEwXSAtIHNbNF0gKiBzWzJdICogc1sxMV1cbiAgICAgICAgICAgICsgc1s0XSAqIHNbM10gKiBzWzEwXSArIHNbOF0gKiBzWzJdICogc1s3XSAtIHNbOF0gKiBzWzNdICogc1s2XTtcbiAgICAgICAgaW52WzExXSA9IC1zWzBdICogc1s1XSAqIHNbMTFdICsgc1swXSAqIHNbN10gKiBzWzldICsgc1s0XSAqIHNbMV0gKiBzWzExXVxuICAgICAgICAgICAgLSBzWzRdICogc1szXSAqIHNbOV0gLSBzWzhdICogc1sxXSAqIHNbN10gKyBzWzhdICogc1szXSAqIHNbNV07XG4gICAgICAgIGludlsxNV0gPSBzWzBdICogc1s1XSAqIHNbMTBdIC0gc1swXSAqIHNbNl0gKiBzWzldIC0gc1s0XSAqIHNbMV0gKiBzWzEwXVxuICAgICAgICAgICAgKyBzWzRdICogc1syXSAqIHNbOV0gKyBzWzhdICogc1sxXSAqIHNbNl0gLSBzWzhdICogc1syXSAqIHNbNV07XG4gICAgICAgIGRldCA9IHNbMF0gKiBpbnZbMF0gKyBzWzFdICogaW52WzRdICsgc1syXSAqIGludls4XSArIHNbM10gKiBpbnZbMTJdO1xuICAgICAgICBpZiAoZGV0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBkZXQgPSAxIC8gZGV0O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgZFtpXSA9IGludltpXSAqIGRldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBpbnZlcnNlIG1hdHJpeCBvZiB0aGlzLCBhbmQgc2V0IHRvIHRoaXMuXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW52ZXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRJbnZlcnNlT2YodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgb3J0aG9ncmFwaGljIHByb2plY3Rpb24gbWF0cml4LlxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IG9mIGNsaXBwaW5nIHBsYW5lLlxuICAgICAqIEBwYXJhbSByaWdodCBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgb2YgY2xpcHBpbmcgcGxhbmUuXG4gICAgICogQHBhcmFtIGJvdHRvbSBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tIG9mIGNsaXBwaW5nIHBsYW5lLlxuICAgICAqIEBwYXJhbSB0b3AgVGhlIGNvb3JkaW5hdGUgb2YgdGhlIHRvcCB0b3AgY2xpcHBpbmcgcGxhbmUuXG4gICAgICogQHBhcmFtIG5lYXIgVGhlIGRpc3RhbmNlcyB0byB0aGUgbmVhcmVyIGRlcHRoIGNsaXBwaW5nIHBsYW5lLiBUaGlzIHZhbHVlIGlzIG1pbnVzIGlmIHRoZSBwbGFuZSBpcyB0byBiZSBiZWhpbmQgdGhlIHZpZXdlci5cbiAgICAgKiBAcGFyYW0gZmFyIFRoZSBkaXN0YW5jZXMgdG8gdGhlIGZhcnRoZXIgZGVwdGggY2xpcHBpbmcgcGxhbmUuIFRoaXMgdmFsdWUgaXMgbWludXMgaWYgdGhlIHBsYW5lIGlzIHRvIGJlIGJlaGluZCB0aGUgdmlld2VyLlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHNldE9ydGhvKHIsIHQsIG5lYXIsIGZhcikge1xuICAgICAgICBsZXQgZTtcbiAgICAgICAgbGV0IHJ3O1xuICAgICAgICBsZXQgcmg7XG4gICAgICAgIGxldCByZDtcbiAgICAgICAgcncgPSAxIC8gcjtcbiAgICAgICAgcmggPSAxIC8gdDtcbiAgICAgICAgcmQgPSAyIC8gKG5lYXIgLSBmYXIpO1xuICAgICAgICBlID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgZVswXSA9IHJ3O1xuICAgICAgICBlWzFdID0gMDtcbiAgICAgICAgZVsyXSA9IDA7XG4gICAgICAgIGVbM10gPSAwO1xuICAgICAgICBlWzRdID0gMDtcbiAgICAgICAgZVs1XSA9IHJoO1xuICAgICAgICBlWzZdID0gMDtcbiAgICAgICAgZVs3XSA9IDA7XG4gICAgICAgIGVbOF0gPSAwO1xuICAgICAgICBlWzldID0gMDtcbiAgICAgICAgZVsxMF0gPSByZDtcbiAgICAgICAgZVsxMV0gPSAoZmFyICsgbmVhcikgLyAobmVhciAtIGZhcik7XG4gICAgICAgIGVbMTJdID0gMDtcbiAgICAgICAgZVsxM10gPSAwO1xuICAgICAgICBlWzE0XSA9IDA7XG4gICAgICAgIGVbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggYnkgZm92eSBhbmQgYXNwZWN0LlxuICAgICAqIEBwYXJhbSBmb3Z5IFRoZSBhbmdsZSBiZXR3ZWVuIHRoZSB1cHBlciBhbmQgbG93ZXIgc2lkZXMgb2YgdGhlIGZydXN0dW0uXG4gICAgICogQHBhcmFtIGFzcGVjdCBUaGUgYXNwZWN0IHJhdGlvIG9mIHRoZSBmcnVzdHVtLiAod2lkdGgvaGVpZ2h0KVxuICAgICAqIEBwYXJhbSBuZWFyIFRoZSBkaXN0YW5jZXMgdG8gdGhlIG5lYXJlciBkZXB0aCBjbGlwcGluZyBwbGFuZS4gVGhpcyB2YWx1ZSBtdXN0IGJlIHBsdXMgdmFsdWUuXG4gICAgICogQHBhcmFtIGZhciBUaGUgZGlzdGFuY2VzIHRvIHRoZSBmYXJ0aGVyIGRlcHRoIGNsaXBwaW5nIHBsYW5lLiBUaGlzIHZhbHVlIG11c3QgYmUgcGx1cyB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBzZXRQZXJzcGVjdGl2ZShmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICAgICAgICBsZXQgZTtcbiAgICAgICAgbGV0IHJkO1xuICAgICAgICBsZXQgcztcbiAgICAgICAgbGV0IGN0O1xuICAgICAgICBpZiAobmVhciA9PT0gZmFyIHx8IGFzcGVjdCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgJ251bGwgZnJ1c3R1bSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lYXIgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgJ25lYXIgPD0gMCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZhciA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyAnZmFyIDw9IDAnO1xuICAgICAgICB9XG4gICAgICAgIGZvdnkgPSBNYXRoLlBJICogZm92eSAvIDE4MCAvIDI7XG4gICAgICAgIHMgPSBNYXRoLnNpbihmb3Z5KTtcbiAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93ICdudWxsIGZydXN0dW0nO1xuICAgICAgICB9XG4gICAgICAgIHJkID0gMSAvIChmYXIgLSBuZWFyKTtcbiAgICAgICAgY3QgPSBNYXRoLmNvcyhmb3Z5KSAvIHM7XG4gICAgICAgIGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICBlWzBdID0gY3QgLyBhc3BlY3Q7XG4gICAgICAgIGVbMV0gPSAwO1xuICAgICAgICBlWzJdID0gMDtcbiAgICAgICAgZVszXSA9IDA7XG4gICAgICAgIGVbNF0gPSAwO1xuICAgICAgICBlWzVdID0gY3Q7XG4gICAgICAgIGVbNl0gPSAwO1xuICAgICAgICBlWzddID0gMDtcbiAgICAgICAgZVs4XSA9IDA7XG4gICAgICAgIGVbOV0gPSAwO1xuICAgICAgICBlWzEwXSA9IC0oZmFyICsgbmVhcikgKiByZDtcbiAgICAgICAgZVsxMV0gPSAtMTtcbiAgICAgICAgZVsxMl0gPSAwO1xuICAgICAgICBlWzEzXSA9IDA7XG4gICAgICAgIGVbMTRdID0gLTIgKiBuZWFyICogZmFyICogcmQ7XG4gICAgICAgIGVbMTVdID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IHRoZSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCBmcm9tIHRoZSByaWdodC5cbiAgICAgKiBAcGFyYW0gZm92eSBUaGUgYW5nbGUgYmV0d2VlbiB0aGUgdXBwZXIgYW5kIGxvd2VyIHNpZGVzIG9mIHRoZSBmcnVzdHVtLlxuICAgICAqIEBwYXJhbSBhc3BlY3QgVGhlIGFzcGVjdCByYXRpbyBvZiB0aGUgZnJ1c3R1bS4gKHdpZHRoL2hlaWdodClcbiAgICAgKiBAcGFyYW0gbmVhciBUaGUgZGlzdGFuY2VzIHRvIHRoZSBuZWFyZXIgZGVwdGggY2xpcHBpbmcgcGxhbmUuIFRoaXMgdmFsdWUgbXVzdCBiZSBwbHVzIHZhbHVlLlxuICAgICAqIEBwYXJhbSBmYXIgVGhlIGRpc3RhbmNlcyB0byB0aGUgZmFydGhlciBkZXB0aCBjbGlwcGluZyBwbGFuZS4gVGhpcyB2YWx1ZSBtdXN0IGJlIHBsdXMgdmFsdWUuXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgcGVyc3BlY3RpdmUoZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uY2F0KG5ldyBNYXRyaXg0KCkuc2V0UGVyc3BlY3RpdmUoZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgdGhlIGZvdXItZGltZW5zaW9uYWwgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBwb3MgIFRoZSBtdWx0aXBseSB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIFRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24oRmxvYXQzMkFycmF5KVxuICAgICAqL1xuICAgIG11bHRpcGx5VmVjdG9yNCh7IGVsZW1lbnRzIH0pIHtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGNvbnN0IHAgPSBlbGVtZW50cztcbiAgICAgICAgY29uc3QgdiA9IG5ldyBWZWN0b3I0KCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHYuZWxlbWVudHM7XG4gICAgICAgIHJlc3VsdFswXSA9IHBbMF0gKiBlWzBdICsgcFsxXSAqIGVbNF0gKyBwWzJdICogZVs4XSArIHBbM10gKiBlWzEyXTtcbiAgICAgICAgcmVzdWx0WzFdID0gcFswXSAqIGVbMV0gKyBwWzFdICogZVs1XSArIHBbMl0gKiBlWzldICsgcFszXSAqIGVbMTNdO1xuICAgICAgICByZXN1bHRbMl0gPSBwWzBdICogZVsyXSArIHBbMV0gKiBlWzZdICsgcFsyXSAqIGVbMTBdICsgcFszXSAqIGVbMTRdO1xuICAgICAgICByZXN1bHRbM10gPSBwWzBdICogZVszXSArIHBbMV0gKiBlWzddICsgcFsyXSAqIGVbMTFdICsgcFszXSAqIGVbMTVdO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgc2NhbGUodmVjMykge1xuICAgICAgICBjb25zdCB4ID0gdmVjMy5lbGVtZW50c1swXTtcbiAgICAgICAgY29uc3QgeSA9IHZlYzMuZWxlbWVudHNbMV07XG4gICAgICAgIGNvbnN0IHogPSB2ZWMzLmVsZW1lbnRzWzJdO1xuICAgICAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgZVswXSAqPSB4O1xuICAgICAgICBlWzRdICo9IHk7XG4gICAgICAgIGVbOF0gKj0gejtcbiAgICAgICAgZVsxXSAqPSB4O1xuICAgICAgICBlWzVdICo9IHk7XG4gICAgICAgIGVbOV0gKj0gejtcbiAgICAgICAgZVsyXSAqPSB4O1xuICAgICAgICBlWzZdICo9IHk7XG4gICAgICAgIGVbMTBdICo9IHo7XG4gICAgICAgIGVbM10gKj0geDtcbiAgICAgICAgZVs3XSAqPSB5O1xuICAgICAgICBlWzExXSAqPSB6O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0VHJhbnNsYXRlKHZlYzMpIHtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGNvbnN0IHggPSB2ZWMzLmVsZW1lbnRzWzBdO1xuICAgICAgICBjb25zdCB5ID0gdmVjMy5lbGVtZW50c1sxXTtcbiAgICAgICAgY29uc3QgeiA9IHZlYzMuZWxlbWVudHNbMl07XG4gICAgICAgIGVbMTJdID0geDtcbiAgICAgICAgZVsxM10gPSB5O1xuICAgICAgICBlWzE0XSA9IHo7XG4gICAgICAgIGVbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IHRoZSBtYXRyaXggZm9yIHRyYW5zbGF0aW9uIGZyb20gdGhlIHJpZ2h0LlxuICAgICAqIEBwYXJhbSB4IFRoZSBYIHZhbHVlIG9mIGEgdHJhbnNsYXRpb24uXG4gICAgICogQHBhcmFtIHkgVGhlIFkgdmFsdWUgb2YgYSB0cmFuc2xhdGlvbi5cbiAgICAgKiBAcGFyYW0geiBUaGUgWiB2YWx1ZSBvZiBhIHRyYW5zbGF0aW9uLlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHRyYW5zbGF0ZSh4LCB5LCB6KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICBlWzEyXSArPSBlWzBdICogeCArIGVbNF0gKiB5ICsgZVs4XSAqIHo7XG4gICAgICAgIGVbMTNdICs9IGVbMV0gKiB4ICsgZVs1XSAqIHkgKyBlWzldICogejtcbiAgICAgICAgZVsxNF0gKz0gZVsyXSAqIHggKyBlWzZdICogeSArIGVbMTBdICogejtcbiAgICAgICAgZVsxNV0gKz0gZVszXSAqIHggKyBlWzddICogeSArIGVbMTFdICogejtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldE1heFNjYWxlT25BeGlzKCkge1xuICAgICAgICBjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGNvbnN0IHNjYWxlWFNxID0gdGVbMF0gKiB0ZVswXSArIHRlWzFdICogdGVbMV0gKyB0ZVsyXSAqIHRlWzJdO1xuICAgICAgICBjb25zdCBzY2FsZVlTcSA9IHRlWzRdICogdGVbNF0gKyB0ZVs1XSAqIHRlWzVdICsgdGVbNl0gKiB0ZVs2XTtcbiAgICAgICAgY29uc3Qgc2NhbGVaU3EgPSB0ZVs4XSAqIHRlWzhdICsgdGVbOV0gKiB0ZVs5XSArIHRlWzEwXSAqIHRlWzEwXTtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLm1heChzY2FsZVhTcSwgc2NhbGVZU3EsIHNjYWxlWlNxKSk7XG4gICAgfVxuICAgIG1ha2VSb3RhdGlvbkF4aXMoYXhpcywgYW5nbGUpIHtcbiAgICAgICAgLy8gQmFzZWQgb24gaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC9yZWZlcmVuY2UvYXJ0aWNsZXMvYXJ0aWNsZTExOTkuYXNwXG4gICAgICAgIGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgY29uc3QgcyA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgY29uc3QgdCA9IDEgLSBjO1xuICAgICAgICBjb25zdCB4ID0gYXhpcy5lbGVtZW50c1swXSwgeSA9IGF4aXMuZWxlbWVudHNbMV0sIHogPSBheGlzLmVsZW1lbnRzWzJdO1xuICAgICAgICBjb25zdCB0eCA9IHQgKiB4LCB0eSA9IHQgKiB5O1xuICAgICAgICB0ZVswXSA9IHR4ICogeCArIGM7XG4gICAgICAgIHRlWzFdID0gdHggKiB5IC0gcyAqIHo7XG4gICAgICAgIHRlWzJdID0gdHggKiB6ICsgcyAqIHk7XG4gICAgICAgIHRlWzNdID0gMDtcbiAgICAgICAgdGVbNF0gPSB0eCAqIHkgKyBzICogejtcbiAgICAgICAgdGVbNV0gPSB0eSAqIHkgKyBjO1xuICAgICAgICB0ZVs2XSA9IHR5ICogeiAtIHMgKiB4O1xuICAgICAgICB0ZVs3XSA9IDA7XG4gICAgICAgIHRlWzhdID0gdHggKiB6IC0gcyAqIHk7XG4gICAgICAgIHRlWzldID0gdHkgKiB6ICsgcyAqIHg7XG4gICAgICAgIHRlWzEwXSA9IHQgKiB6ICogeiArIGM7XG4gICAgICAgIHRlWzExXSA9IDA7XG4gICAgICAgIC8vIHRlWzEyXSA9IDA7IFxuICAgICAgICAvLyB0ZVsxM10gPSAwOyBcbiAgICAgICAgLy8gdGVbMTRdID0gMDsgXG4gICAgICAgIHRlWzE1XSA9IDE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihxKSB7XG4gICAgICAgIGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgY29uc3QgeCA9IHFbMF07XG4gICAgICAgIGNvbnN0IHkgPSBxWzFdO1xuICAgICAgICBjb25zdCB6ID0gcVsyXTtcbiAgICAgICAgY29uc3QgdyA9IHFbM107XG4gICAgICAgIGNvbnN0IHgyID0geCArIHg7XG4gICAgICAgIGNvbnN0IHkyID0geSArIHk7XG4gICAgICAgIGNvbnN0IHoyID0geiArIHo7XG4gICAgICAgIGNvbnN0IHh4ID0geCAqIHgyO1xuICAgICAgICBjb25zdCB4eSA9IHggKiB5MjtcbiAgICAgICAgY29uc3QgeHogPSB4ICogejI7XG4gICAgICAgIGNvbnN0IHl5ID0geSAqIHkyO1xuICAgICAgICBjb25zdCB5eiA9IHkgKiB6MjtcbiAgICAgICAgY29uc3QgenogPSB6ICogejI7XG4gICAgICAgIGNvbnN0IHd4ID0gdyAqIHgyO1xuICAgICAgICBjb25zdCB3eSA9IHcgKiB5MjtcbiAgICAgICAgY29uc3Qgd3ogPSB3ICogejI7XG4gICAgICAgIHRlWzBdID0gMSAtICh5eSArIHp6KTtcbiAgICAgICAgdGVbNF0gPSB4eSAtIHd6O1xuICAgICAgICB0ZVs4XSA9IHh6ICsgd3k7XG4gICAgICAgIHRlWzFdID0geHkgKyB3ejtcbiAgICAgICAgdGVbNV0gPSAxIC0gKHh4ICsgenopO1xuICAgICAgICB0ZVs5XSA9IHl6IC0gd3g7XG4gICAgICAgIHRlWzJdID0geHogLSB3eTtcbiAgICAgICAgdGVbNl0gPSB5eiArIHd4O1xuICAgICAgICB0ZVsxMF0gPSAxIC0gKHh4ICsgeXkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdHJhbnNwb3NlKCkge1xuICAgICAgICBsZXQgZTtcbiAgICAgICAgbGV0IHQ7XG4gICAgICAgIGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICB0ID0gZVsxXTtcbiAgICAgICAgZVsxXSA9IGVbNF07XG4gICAgICAgIGVbNF0gPSB0O1xuICAgICAgICB0ID0gZVsyXTtcbiAgICAgICAgZVsyXSA9IGVbOF07XG4gICAgICAgIGVbOF0gPSB0O1xuICAgICAgICB0ID0gZVszXTtcbiAgICAgICAgZVszXSA9IGVbMTJdO1xuICAgICAgICBlWzEyXSA9IHQ7XG4gICAgICAgIHQgPSBlWzZdO1xuICAgICAgICBlWzZdID0gZVs5XTtcbiAgICAgICAgZVs5XSA9IHQ7XG4gICAgICAgIHQgPSBlWzddO1xuICAgICAgICBlWzddID0gZVsxM107XG4gICAgICAgIGVbMTNdID0gdDtcbiAgICAgICAgdCA9IGVbMTFdO1xuICAgICAgICBlWzExXSA9IGVbMTRdO1xuICAgICAgICBlWzE0XSA9IHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbi8qKlxuICogQ29uc3RydWN0b3Igb2YgVmVjdG9yM1xuICogSWYgb3B0X3NyYyBpcyBzcGVjaWZpZWQsIG5ldyB2ZWN0b3IgaXMgaW5pdGlhbGl6ZWQgYnkgb3B0X3NyYy5cbiAqIEBwYXJhbSBvcHRfc3JjIHNvdXJjZSB2ZWN0b3Iob3B0aW9uKVxuICovXG5jbGFzcyBWZWN0b3IzIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRfc3JjKSB7XG4gICAgICAgIGNvbnN0IHYgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICBpZiAob3B0X3NyYyAmJiB0eXBlb2Ygb3B0X3NyYyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZbMF0gPSBvcHRfc3JjWzBdO1xuICAgICAgICAgICAgdlsxXSA9IG9wdF9zcmNbMV07XG4gICAgICAgICAgICB2WzJdID0gb3B0X3NyY1syXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnRzID0gdjtcbiAgICB9XG4gICAgYXBwbHlRdWF0ZXJuaW9uKHsgZWxlbWVudHMgfSkge1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5lbGVtZW50c1swXTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuZWxlbWVudHNbMV07XG4gICAgICAgIGNvbnN0IHogPSB0aGlzLmVsZW1lbnRzWzJdO1xuICAgICAgICBjb25zdCBxeCA9IGVsZW1lbnRzWzBdO1xuICAgICAgICBjb25zdCBxeSA9IGVsZW1lbnRzWzFdO1xuICAgICAgICBjb25zdCBxeiA9IGVsZW1lbnRzWzJdO1xuICAgICAgICBjb25zdCBxdyA9IGVsZW1lbnRzWzNdO1xuICAgICAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY3RvclxuICAgICAgICBjb25zdCBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcbiAgICAgICAgY29uc3QgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gICAgICAgIGNvbnN0IGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuICAgICAgICBjb25zdCBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICAgICAgdGhpcy5lbGVtZW50c1swXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgICAgICB0aGlzLmVsZW1lbnRzWzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAgKiBOb3JtYWxpemUuXG4gICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAgKi9cbiAgICBub3JtYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICBjb25zdCBjID0gdlswXTtcbiAgICAgICAgY29uc3QgZCA9IHZbMV07XG4gICAgICAgIGNvbnN0IGUgPSB2WzJdO1xuICAgICAgICBsZXQgZyA9IE1hdGguc3FydChjICogYyArIGQgKiBkICsgZSAqIGUpO1xuICAgICAgICBpZiAoZykge1xuICAgICAgICAgICAgaWYgKGcgPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdlswXSA9IDA7XG4gICAgICAgICAgICB2WzFdID0gMDtcbiAgICAgICAgICAgIHZbMl0gPSAwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZyA9IDEgLyBnO1xuICAgICAgICB2WzBdID0gYyAqIGc7XG4gICAgICAgIHZbMV0gPSBkICogZztcbiAgICAgICAgdlsyXSA9IGUgKiBnO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICAgICAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gICAgICAgICAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAgICAgICAgICovXG4gICAgYWRkKGIpIHtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGIgPSBiLmVsZW1lbnRzO1xuICAgICAgICBhWzBdID0gYVswXSArIGJbMF07XG4gICAgICAgIGFbMV0gPSBhWzFdICsgYlsxXTtcbiAgICAgICAgYVsyXSA9IGFbMl0gKyBiWzJdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkUyhiKSB7XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICBhWzBdID0gYVswXSArIGI7XG4gICAgICAgIGFbMV0gPSBhWzFdICsgYjtcbiAgICAgICAgYVsyXSA9IGFbMl0gKyBiO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2NhbGUoYikge1xuICAgICAgICBjb25zdCBhID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgYVswXSA9IGFbMF0gKiBiO1xuICAgICAgICBhWzFdID0gYVsxXSAqIGI7XG4gICAgICAgIGFbMl0gPSBhWzJdICogYjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpc3RhbmNlVG9TcXVhcmVkKHgsIHksIHopIHtcbiAgICAgICAgY29uc3QgZHggPSB0aGlzLmVsZW1lbnRzWzBdIC0geDtcbiAgICAgICAgY29uc3QgZHkgPSB0aGlzLmVsZW1lbnRzWzFdIC0geTtcbiAgICAgICAgY29uc3QgZHogPSB0aGlzLmVsZW1lbnRzWzJdIC0gejtcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcbiAgICB9XG4gICAgc3VidHJhY3QoYikge1xuICAgICAgICBjb25zdCBvdXQgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICBiID0gYi5lbGVtZW50cztcbiAgICAgICAgb3V0WzBdID0gb3V0WzBdIC0gYlswXTtcbiAgICAgICAgb3V0WzFdID0gb3V0WzFdIC0gYlsxXTtcbiAgICAgICAgb3V0WzJdID0gb3V0WzJdIC0gYlsyXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpdmlkZVNjYWxhcihzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUoMSAvIHNjYWxhcik7XG4gICAgfVxuICAgIGFwcGx5TWF0cml4NCh7IGVsZW1lbnRzIH0pIHtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuZWxlbWVudHNbMF07XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLmVsZW1lbnRzWzFdO1xuICAgICAgICBjb25zdCB6ID0gdGhpcy5lbGVtZW50c1syXTtcbiAgICAgICAgY29uc3QgZSA9IGVsZW1lbnRzO1xuICAgICAgICB0aGlzLmVsZW1lbnRzWzBdID0gZVswXSAqIHggKyBlWzRdICogeSArIGVbOF0gKiB6ICsgZVsxMl07XG4gICAgICAgIHRoaXMuZWxlbWVudHNbMV0gPSBlWzFdICogeCArIGVbNV0gKiB5ICsgZVs5XSAqIHogKyBlWzEzXTtcbiAgICAgICAgdGhpcy5lbGVtZW50c1syXSA9IGVbMl0gKiB4ICsgZVs2XSAqIHkgKyBlWzEwXSAqIHogKyBlWzE0XTtcbiAgICAgICAgY29uc3QgdyA9IGVbM10gKiB4ICsgZVs3XSAqIHkgKyBlWzExXSAqIHogKyBlWzE1XTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHcpO1xuICAgIH1cbiAgICBsZXJwKGEsIGIsIHQpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgY29uc3QgYXggPSBhWzBdO1xuICAgICAgICBjb25zdCBheSA9IGFbMV07XG4gICAgICAgIGNvbnN0IGF6ID0gYVsyXTtcbiAgICAgICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgICAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxlbmd0aFNxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50c1swXSAqIHRoaXMuZWxlbWVudHNbMF0gKyB0aGlzLmVsZW1lbnRzWzFdICogdGhpcy5lbGVtZW50c1sxXSArIHRoaXMuZWxlbWVudHNbMl0gKiB0aGlzLmVsZW1lbnRzWzJdO1xuICAgIH1cbiAgICBtdWx0aXBseSh7IGVsZW1lbnRzIH0pIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1swXSAqPSBlbGVtZW50c1swXTtcbiAgICAgICAgdGhpcy5lbGVtZW50c1sxXSAqPSBlbGVtZW50c1sxXTtcbiAgICAgICAgdGhpcy5lbGVtZW50c1syXSAqPSBlbGVtZW50c1syXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN0YXRpYyBhbmdsZShhLCBiKSB7XG4gICAgICAgIGNvbnN0IHRlbXBBID0gbmV3IFZlY3RvcjMoYS5lbGVtZW50cyk7XG4gICAgICAgIGNvbnN0IHRlbXBCID0gbmV3IFZlY3RvcjMoYi5lbGVtZW50cyk7XG4gICAgICAgIHRlbXBBLm5vcm1hbGl6ZSgpO1xuICAgICAgICB0ZW1wQi5ub3JtYWxpemUoKTtcbiAgICAgICAgY29uc3QgY29zaW5lID0gVmVjdG9yMy5kb3QodGVtcEEsIHRlbXBCKTtcbiAgICAgICAgaWYgKGNvc2luZSA+IDEuMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hY29zKGNvc2luZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGNyb3NzKGEsIGIpIHtcbiAgICAgICAgYSA9IGEuZWxlbWVudHM7XG4gICAgICAgIGIgPSBiLmVsZW1lbnRzO1xuICAgICAgICBjb25zdCBheCA9IGFbMF07XG4gICAgICAgIGNvbnN0IGF5ID0gYVsxXTtcbiAgICAgICAgY29uc3QgYXogPSBhWzJdO1xuICAgICAgICBjb25zdCBieCA9IGJbMF07XG4gICAgICAgIGNvbnN0IGJ5ID0gYlsxXTtcbiAgICAgICAgY29uc3QgYnogPSBiWzJdO1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICBvdXQuZWxlbWVudHNbMF0gPSBheSAqIGJ6IC0gYXogKiBieTtcbiAgICAgICAgb3V0LmVsZW1lbnRzWzFdID0gYXogKiBieCAtIGF4ICogYno7XG4gICAgICAgIG91dC5lbGVtZW50c1syXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBzdGF0aWMgZG90KGEsIGIpIHtcbiAgICAgICAgYSA9IGEuZWxlbWVudHM7XG4gICAgICAgIGIgPSBiLmVsZW1lbnRzO1xuICAgICAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xuICAgIH1cbn1cbi8qKlxuICogQ29uc3RydWN0b3Igb2YgVmVjdG9yNFxuICogSWYgb3B0X3NyYyBpcyBzcGVjaWZpZWQsIG5ldyB2ZWN0b3IgaXMgaW5pdGlhbGl6ZWQgYnkgb3B0X3NyYy5cbiAqIEBwYXJhbSBvcHRfc3JjIHNvdXJjZSB2ZWN0b3Iob3B0aW9uKVxuICovXG5jbGFzcyBWZWN0b3I0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRfc3JjKSB7XG4gICAgICAgIGNvbnN0IHYgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICBpZiAob3B0X3NyYyAmJiB0eXBlb2Ygb3B0X3NyYyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZbMF0gPSBvcHRfc3JjWzBdO1xuICAgICAgICAgICAgdlsxXSA9IG9wdF9zcmNbMV07XG4gICAgICAgICAgICB2WzJdID0gb3B0X3NyY1syXTtcbiAgICAgICAgICAgIHZbM10gPSBvcHRfc3JjWzNdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSB2O1xuICAgIH1cbiAgICBzZXQoZSkge1xuICAgICAgICBjb25zdCBhID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgYVswXSA9IGVbMF07XG4gICAgICAgIGFbMV0gPSBlWzFdO1xuICAgICAgICBhWzJdID0gZVsyXTtcbiAgICAgICAgYVszXSA9IGVbM107XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGQoYikge1xuICAgICAgICBjb25zdCBhID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgYiA9IGIuZWxlbWVudHM7XG4gICAgICAgIGFbMF0gPSBiWzBdO1xuICAgICAgICBhWzFdID0gYlsxXTtcbiAgICAgICAgYVsyXSA9IGJbMl07XG4gICAgICAgIGFbM10gPSBhWzNdICsgYlszXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG5vcm1hbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuZWxlbWVudHNbMF07XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLmVsZW1lbnRzWzFdO1xuICAgICAgICBjb25zdCB6ID0gdGhpcy5lbGVtZW50c1syXTtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMuZWxlbWVudHNbM107XG4gICAgICAgIGxldCBsZW4gPSB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdztcbiAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbMF0gPSB4ICogbGVuO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1sxXSA9IHkgKiBsZW47XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzWzJdID0geiAqIGxlbjtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbM10gPSB3ICogbGVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRGcm9tUm90YXRpb25NYXRyaXgoeyBlbGVtZW50cyB9KSB7XG4gICAgICAgIGNvbnN0IHRlID0gZWxlbWVudHM7XG4gICAgICAgIGNvbnN0IG0xMSA9IHRlWzBdO1xuICAgICAgICBjb25zdCBtMTIgPSB0ZVs0XTtcbiAgICAgICAgY29uc3QgbTEzID0gdGVbOF07XG4gICAgICAgIGNvbnN0IG0yMSA9IHRlWzFdO1xuICAgICAgICBjb25zdCBtMjIgPSB0ZVs1XTtcbiAgICAgICAgY29uc3QgbTIzID0gdGVbOV07XG4gICAgICAgIGNvbnN0IG0zMSA9IHRlWzJdO1xuICAgICAgICBjb25zdCBtMzIgPSB0ZVs2XTtcbiAgICAgICAgY29uc3QgbTMzID0gdGVbMTBdO1xuICAgICAgICBjb25zdCB0cmFjZSA9IG0xMSArIG0yMiArIG0zMztcbiAgICAgICAgbGV0IHM7XG4gICAgICAgIGlmICh0cmFjZSA+IDApIHtcbiAgICAgICAgICAgIHMgPSAwLjUgLyBNYXRoLnNxcnQodHJhY2UgKyAxLjApO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1szXSA9IDAuMjUgLyBzO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1swXSA9IChtMzIgLSBtMjMpICogcztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbMV0gPSAobTEzIC0gbTMxKSAqIHM7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzWzJdID0gKG0yMSAtIG0xMikgKiBzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0xMSA+IG0yMiAmJiBtMTEgPiBtMzMpIHtcbiAgICAgICAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTExIC0gbTIyIC0gbTMzKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbM10gPSAobTMyIC0gbTIzKSAvIHM7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzWzBdID0gMC4yNSAqIHM7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzWzFdID0gKG0xMiArIG0yMSkgLyBzO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1syXSA9IChtMTMgKyBtMzEpIC8gcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtMjIgPiBtMzMpIHtcbiAgICAgICAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTIyIC0gbTExIC0gbTMzKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbM10gPSAobTEzIC0gbTMxKSAvIHM7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzWzBdID0gKG0xMiArIG0yMSkgLyBzO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1sxXSA9IDAuMjUgKiBzO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1syXSA9IChtMjMgKyBtMzIpIC8gcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTMzIC0gbTExIC0gbTIyKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbM10gPSAobTIxIC0gbTEyKSAvIHM7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzWzBdID0gKG0xMyArIG0zMSkgLyBzO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1sxXSA9IChtMjMgKyBtMzIpIC8gcztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbMl0gPSAwLjI1ICogcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbGVycChhLCBiLCB0KSB7XG4gICAgICAgIGNvbnN0IG91dCA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGNvbnN0IGF4ID0gYVswXTtcbiAgICAgICAgY29uc3QgYXkgPSBhWzFdO1xuICAgICAgICBjb25zdCBheiA9IGFbMl07XG4gICAgICAgIGNvbnN0IGF3ID0gYVszXTtcbiAgICAgICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgICAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgICAgICAgb3V0WzNdID0gYXcgKyB0ICogKGJbM10gLSBhdyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmNsYXNzIFZlY3RvcjIge1xuICAgIGNvbnN0cnVjdG9yKG9wdF9zcmMpIHtcbiAgICAgICAgY29uc3QgdiA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG4gICAgICAgIGlmIChvcHRfc3JjICYmIHR5cGVvZiBvcHRfc3JjID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdlswXSA9IG9wdF9zcmNbMF07XG4gICAgICAgICAgICB2WzFdID0gb3B0X3NyY1sxXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnRzID0gdjtcbiAgICB9XG4gICAgc3VidHJhY3QoYikge1xuICAgICAgICBjb25zdCBvdXQgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICBiID0gYi5lbGVtZW50cztcbiAgICAgICAgb3V0WzBdID0gb3V0WzBdIC0gYlswXTtcbiAgICAgICAgb3V0WzFdID0gb3V0WzFdIC0gYlsxXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxlcnAoYSwgYiwgdCkge1xuICAgICAgICBjb25zdCBvdXQgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICBjb25zdCBheCA9IGFbMF07XG4gICAgICAgIGNvbnN0IGF5ID0gYVsxXTtcbiAgICAgICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4vLyB7IDA6IHJpZ2h0LCAxOiBsZWZ0LCAyOiBib3R0b20uIDM6IHRvcCwgNDogZmFyLCA1OiBuZWFyIH1cbmZ1bmN0aW9uIEZydXN0dW0obSkge1xuICAgIGNvbnN0IHBsYW5lcyA9IFtuZXcgVmVjdG9yNCwgbmV3IFZlY3RvcjQsIG5ldyBWZWN0b3I0LCBuZXcgVmVjdG9yNCwgbmV3IFZlY3RvcjQsIG5ldyBWZWN0b3I0XTtcbiAgICBjb25zdCBtZSA9IG0uZWxlbWVudHM7XG4gICAgbGV0IG1lMCA9IG1lWzBdLCBtZTEgPSBtZVsxXSwgbWUyID0gbWVbMl0sIG1lMyA9IG1lWzNdO1xuICAgIGxldCBtZTQgPSBtZVs0XSwgbWU1ID0gbWVbNV0sIG1lNiA9IG1lWzZdLCBtZTcgPSBtZVs3XTtcbiAgICBsZXQgbWU4ID0gbWVbOF0sIG1lOSA9IG1lWzldLCBtZTEwID0gbWVbMTBdLCBtZTExID0gbWVbMTFdO1xuICAgIGxldCBtZTEyID0gbWVbMTJdLCBtZTEzID0gbWVbMTNdLCBtZTE0ID0gbWVbMTRdLCBtZTE1ID0gbWVbMTVdO1xuICAgIHBsYW5lc1swXS5zZXQoW21lMyAtIG1lMCwgbWU3IC0gbWU0LCBtZTExIC0gbWU4LCBtZTE1IC0gbWUxMl0pLm5vcm1hbGl6ZSgpO1xuICAgIHBsYW5lc1sxXS5zZXQoW21lMyArIG1lMCwgbWU3ICsgbWU0LCBtZTExICsgbWU4LCBtZTE1ICsgbWUxMl0pLm5vcm1hbGl6ZSgpO1xuICAgIHBsYW5lc1syXS5zZXQoW21lMyArIG1lMSwgbWU3ICsgbWU1LCBtZTExICsgbWU5LCBtZTE1ICsgbWUxM10pLm5vcm1hbGl6ZSgpO1xuICAgIHBsYW5lc1szXS5zZXQoW21lMyAtIG1lMSwgbWU3IC0gbWU1LCBtZTExIC0gbWU5LCBtZTE1IC0gbWUxM10pLm5vcm1hbGl6ZSgpO1xuICAgIHBsYW5lc1s0XS5zZXQoW21lMyAtIG1lMiwgbWU3IC0gbWU2LCBtZTExIC0gbWUxMCwgbWUxNSAtIG1lMTRdKS5ub3JtYWxpemUoKTtcbiAgICBwbGFuZXNbNV0uc2V0KFttZTMgKyBtZTIsIG1lNyArIG1lNiwgbWUxMSArIG1lMTAsIG1lMTUgKyBtZTE0XSkubm9ybWFsaXplKCk7XG4gICAgcmV0dXJuIHBsYW5lcztcbn1cbmV4cG9ydCB7IE1hdHJpeDIsIE1hdHJpeDMsIE1hdHJpeDQsIFZlY3RvcjIsIFZlY3RvcjMsIFZlY3RvcjQsIEZydXN0dW0gfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/matrix.ts\n");

/***/ }),

/***/ "./src/objects.ts":
/*!************************!*\
  !*** ./src/objects.ts ***!
  \************************/
/*! exports provided: Scene, Object3D, Mesh, SkinnedMesh, Bone, Camera */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scene\", function() { return Scene; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Object3D\", function() { return Object3D; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Mesh\", function() { return Mesh; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SkinnedMesh\", function() { return SkinnedMesh; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Bone\", function() { return Bone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Camera\", function() { return Camera; });\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matrix */ \"./src/matrix.ts\");\n\nclass Object3D {\n    constructor(name, parent) {\n        this.uuid = Math.floor(Date.now() * Math.random());\n        this.name = name;\n        this.children = [];\n        this.matrix = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"];\n        this.matrixWorld = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"];\n        this.parent = parent;\n    }\n    setPosition(translation, rotation, scale) {\n        if (rotation) {\n            this.matrix.makeRotationFromQuaternion(rotation);\n        }\n        if (scale) {\n            this.matrix.scale(new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](scale));\n        }\n        if (translation) {\n            this.matrix.setTranslate(new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](translation));\n        }\n    }\n    setMatrix(matrix) {\n        this.matrix.set(matrix);\n    }\n    setMatrixWorld(matrix) {\n        this.matrixWorld.set(matrix);\n    }\n    updateMatrix() {\n        const m = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"];\n        m.multiply(this.parent.matrixWorld);\n        m.multiply(this.matrix);\n        this.setMatrixWorld(m.elements);\n    }\n}\nclass Mesh extends Object3D {\n    constructor(name, parent) {\n        super(name, parent);\n        this.geometry = {\n            boundingSphere: {\n                center: new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"],\n                radius: null,\n                min: null,\n                max: null\n            },\n            UBO: null,\n            VAO: null,\n            indicesBuffer: null,\n            attributes: null,\n            targets: null,\n            blend: null,\n            uniforms: null,\n            SKIN: null\n        };\n        this.material = {\n            blend: null,\n            uniforms: null,\n            alphaMode: null,\n            UBO: null,\n            pbrMetallicRoughness: null\n        };\n        this.program = null;\n        this.defines = null;\n        this.mode = 4;\n    }\n    setBlend(value) {\n        this.material.blend = value;\n    }\n    setMaterial(material) {\n        this.material = material;\n        this.material.uniforms = {\n            baseColorTexture: null,\n            metallicRoughnessTexture: null,\n            normalTexture: null,\n            occlusionTexture: null,\n            emissiveTexture: null\n        };\n    }\n    calculateBounding() {\n        const vertices = this.geometry.attributes.POSITION;\n        let maxRadiusSq = 0;\n        this.geometry.boundingSphere.center\n            .add(this.geometry.boundingSphere.min)\n            .add(this.geometry.boundingSphere.max)\n            .scale(0.5);\n        for (let i = 0; i < vertices.length; i = i + 3) {\n            maxRadiusSq = Math.max(maxRadiusSq, this.geometry.boundingSphere.center.distanceToSquared(vertices[i], vertices[i + 1], vertices[i + 2]));\n        }\n        this.geometry.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n    }\n    setBoundingBox({ min, max }) {\n        this.geometry.boundingSphere.min = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](min);\n        this.geometry.boundingSphere.max = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](max);\n        this.calculateBounding();\n    }\n    setIndicesBuffer(value) {\n        this.geometry.indicesBuffer = value;\n    }\n    setAttributes(value) {\n        this.geometry.attributes = value;\n    }\n    setTargets(value) {\n        this.geometry.targets = value;\n    }\n    setProgram(value) {\n        this.program = value;\n    }\n    setMode(value) {\n        this.mode = value;\n    }\n    isVisible(planes) {\n        const c = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](this.geometry.boundingSphere.center.elements).applyMatrix4(this.matrixWorld);\n        const r = this.geometry.boundingSphere.radius * this.matrixWorld.getMaxScaleOnAxis();\n        let dist;\n        let visible = true;\n        for (const p of planes) {\n            dist = p.elements[0] * c.elements[0] + p.elements[1] * c.elements[1] + p.elements[2] * c.elements[2] + p.elements[3];\n            if (dist < -r) {\n                visible = false;\n                break;\n            }\n        }\n        this.distance = dist + r;\n        return visible;\n    }\n}\nclass SkinnedMesh extends Mesh {\n    constructor(name, parent) {\n        super(name, parent);\n    }\n    setSkin(value) {\n        this.skin = value;\n        return this;\n    }\n    getJointMatrix() {\n        const m = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"](this.matrixWorld).invert();\n        const resArray = [];\n        for (let mi = 0; mi < this.boneInverses.length; mi++) {\n            const res = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"]()\n                .multiply(m)\n                .multiply(this.bones[mi].matrixWorld)\n                .multiply(this.boneInverses[mi]);\n            resArray.push(res);\n        }\n        return resArray;\n    }\n}\nclass Bone extends Object3D {\n}\nclass Camera extends Object3D {\n    constructor(name, parent) {\n        super(name, parent);\n        this.matrixWorldInvert = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"];\n        this.projection = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"];\n    }\n    setProps(props) {\n        this.props = props;\n    }\n    setProjection(matrix) {\n        this.projection.set(matrix.elements);\n    }\n    setMatrixWorld(matrix) {\n        super.setMatrixWorld(matrix);\n        this.matrixWorldInvert.setInverseOf(this.matrixWorld);\n    }\n    setZ(z) {\n        this.matrix.elements[14] = z;\n        this.setMatrixWorld(this.matrix.elements);\n    }\n    getViewProjMatrix() {\n        const m = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"];\n        m.multiply(this.projection);\n        m.multiply(this.matrixWorldInvert);\n        return m;\n    }\n}\nclass Scene {\n    constructor() {\n        this.opaqueChildren = [];\n        this.transparentChildren = [];\n        this.children = [];\n        this.bin = [];\n        this.matrixWorld = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"];\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvb2JqZWN0cy50cy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGN1YmUvLi9zcmMvb2JqZWN0cy50cz9iOGU0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hdHJpeDQsIFZlY3RvcjMgfSBmcm9tICcuL21hdHJpeCc7XG5jbGFzcyBPYmplY3QzRCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgcGFyZW50KSB7XG4gICAgICAgIHRoaXMudXVpZCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAqIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQ7XG4gICAgICAgIHRoaXMubWF0cml4V29ybGQgPSBuZXcgTWF0cml4NDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHNldFBvc2l0aW9uKHRyYW5zbGF0aW9uLCByb3RhdGlvbiwgc2NhbGUpIHtcbiAgICAgICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1hdHJpeC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihyb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLm1hdHJpeC5zY2FsZShuZXcgVmVjdG9yMyhzY2FsZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2xhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tYXRyaXguc2V0VHJhbnNsYXRlKG5ldyBWZWN0b3IzKHRyYW5zbGF0aW9uKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0TWF0cml4KG1hdHJpeCkge1xuICAgICAgICB0aGlzLm1hdHJpeC5zZXQobWF0cml4KTtcbiAgICB9XG4gICAgc2V0TWF0cml4V29ybGQobWF0cml4KSB7XG4gICAgICAgIHRoaXMubWF0cml4V29ybGQuc2V0KG1hdHJpeCk7XG4gICAgfVxuICAgIHVwZGF0ZU1hdHJpeCgpIHtcbiAgICAgICAgY29uc3QgbSA9IG5ldyBNYXRyaXg0O1xuICAgICAgICBtLm11bHRpcGx5KHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkKTtcbiAgICAgICAgbS5tdWx0aXBseSh0aGlzLm1hdHJpeCk7XG4gICAgICAgIHRoaXMuc2V0TWF0cml4V29ybGQobS5lbGVtZW50cyk7XG4gICAgfVxufVxuY2xhc3MgTWVzaCBleHRlbmRzIE9iamVjdDNEIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwYXJlbnQpIHtcbiAgICAgICAgc3VwZXIobmFtZSwgcGFyZW50KTtcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IHtcbiAgICAgICAgICAgIGJvdW5kaW5nU3BoZXJlOiB7XG4gICAgICAgICAgICAgICAgY2VudGVyOiBuZXcgVmVjdG9yMyxcbiAgICAgICAgICAgICAgICByYWRpdXM6IG51bGwsXG4gICAgICAgICAgICAgICAgbWluOiBudWxsLFxuICAgICAgICAgICAgICAgIG1heDogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFVCTzogbnVsbCxcbiAgICAgICAgICAgIFZBTzogbnVsbCxcbiAgICAgICAgICAgIGluZGljZXNCdWZmZXI6IG51bGwsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBudWxsLFxuICAgICAgICAgICAgdGFyZ2V0czogbnVsbCxcbiAgICAgICAgICAgIGJsZW5kOiBudWxsLFxuICAgICAgICAgICAgdW5pZm9ybXM6IG51bGwsXG4gICAgICAgICAgICBTS0lOOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWF0ZXJpYWwgPSB7XG4gICAgICAgICAgICBibGVuZDogbnVsbCxcbiAgICAgICAgICAgIHVuaWZvcm1zOiBudWxsLFxuICAgICAgICAgICAgYWxwaGFNb2RlOiBudWxsLFxuICAgICAgICAgICAgVUJPOiBudWxsLFxuICAgICAgICAgICAgcGJyTWV0YWxsaWNSb3VnaG5lc3M6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZWZpbmVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb2RlID0gNDtcbiAgICB9XG4gICAgc2V0QmxlbmQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5ibGVuZCA9IHZhbHVlO1xuICAgIH1cbiAgICBzZXRNYXRlcmlhbChtYXRlcmlhbCkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMgPSB7XG4gICAgICAgICAgICBiYXNlQ29sb3JUZXh0dXJlOiBudWxsLFxuICAgICAgICAgICAgbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlOiBudWxsLFxuICAgICAgICAgICAgbm9ybWFsVGV4dHVyZTogbnVsbCxcbiAgICAgICAgICAgIG9jY2x1c2lvblRleHR1cmU6IG51bGwsXG4gICAgICAgICAgICBlbWlzc2l2ZVRleHR1cmU6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2FsY3VsYXRlQm91bmRpbmcoKSB7XG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLlBPU0lUSU9OO1xuICAgICAgICBsZXQgbWF4UmFkaXVzU3EgPSAwO1xuICAgICAgICB0aGlzLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNlbnRlclxuICAgICAgICAgICAgLmFkZCh0aGlzLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLm1pbilcbiAgICAgICAgICAgIC5hZGQodGhpcy5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5tYXgpXG4gICAgICAgICAgICAuc2NhbGUoMC41KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkgPSBpICsgMykge1xuICAgICAgICAgICAgbWF4UmFkaXVzU3EgPSBNYXRoLm1heChtYXhSYWRpdXNTcSwgdGhpcy5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQodmVydGljZXNbaV0sIHZlcnRpY2VzW2kgKyAxXSwgdmVydGljZXNbaSArIDJdKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgPSBNYXRoLnNxcnQobWF4UmFkaXVzU3EpO1xuICAgIH1cbiAgICBzZXRCb3VuZGluZ0JveCh7IG1pbiwgbWF4IH0pIHtcbiAgICAgICAgdGhpcy5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5taW4gPSBuZXcgVmVjdG9yMyhtaW4pO1xuICAgICAgICB0aGlzLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLm1heCA9IG5ldyBWZWN0b3IzKG1heCk7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQm91bmRpbmcoKTtcbiAgICB9XG4gICAgc2V0SW5kaWNlc0J1ZmZlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLmdlb21ldHJ5LmluZGljZXNCdWZmZXIgPSB2YWx1ZTtcbiAgICB9XG4gICAgc2V0QXR0cmlidXRlcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMgPSB2YWx1ZTtcbiAgICB9XG4gICAgc2V0VGFyZ2V0cyh2YWx1ZSkge1xuICAgICAgICB0aGlzLmdlb21ldHJ5LnRhcmdldHMgPSB2YWx1ZTtcbiAgICB9XG4gICAgc2V0UHJvZ3JhbSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnByb2dyYW0gPSB2YWx1ZTtcbiAgICB9XG4gICAgc2V0TW9kZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1vZGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgaXNWaXNpYmxlKHBsYW5lcykge1xuICAgICAgICBjb25zdCBjID0gbmV3IFZlY3RvcjModGhpcy5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jZW50ZXIuZWxlbWVudHMpLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKTtcbiAgICAgICAgY29uc3QgciA9IHRoaXMuZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUucmFkaXVzICogdGhpcy5tYXRyaXhXb3JsZC5nZXRNYXhTY2FsZU9uQXhpcygpO1xuICAgICAgICBsZXQgZGlzdDtcbiAgICAgICAgbGV0IHZpc2libGUgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgcGxhbmVzKSB7XG4gICAgICAgICAgICBkaXN0ID0gcC5lbGVtZW50c1swXSAqIGMuZWxlbWVudHNbMF0gKyBwLmVsZW1lbnRzWzFdICogYy5lbGVtZW50c1sxXSArIHAuZWxlbWVudHNbMl0gKiBjLmVsZW1lbnRzWzJdICsgcC5lbGVtZW50c1szXTtcbiAgICAgICAgICAgIGlmIChkaXN0IDwgLXIpIHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IGRpc3QgKyByO1xuICAgICAgICByZXR1cm4gdmlzaWJsZTtcbiAgICB9XG59XG5jbGFzcyBTa2lubmVkTWVzaCBleHRlbmRzIE1lc2gge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHBhcmVudCkge1xuICAgICAgICBzdXBlcihuYW1lLCBwYXJlbnQpO1xuICAgIH1cbiAgICBzZXRTa2luKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2tpbiA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0Sm9pbnRNYXRyaXgoKSB7XG4gICAgICAgIGNvbnN0IG0gPSBuZXcgTWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcbiAgICAgICAgY29uc3QgcmVzQXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbWkgPSAwOyBtaSA8IHRoaXMuYm9uZUludmVyc2VzLmxlbmd0aDsgbWkrKykge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IE1hdHJpeDQoKVxuICAgICAgICAgICAgICAgIC5tdWx0aXBseShtKVxuICAgICAgICAgICAgICAgIC5tdWx0aXBseSh0aGlzLmJvbmVzW21pXS5tYXRyaXhXb3JsZClcbiAgICAgICAgICAgICAgICAubXVsdGlwbHkodGhpcy5ib25lSW52ZXJzZXNbbWldKTtcbiAgICAgICAgICAgIHJlc0FycmF5LnB1c2gocmVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzQXJyYXk7XG4gICAgfVxufVxuY2xhc3MgQm9uZSBleHRlbmRzIE9iamVjdDNEIHtcbn1cbmNsYXNzIENhbWVyYSBleHRlbmRzIE9iamVjdDNEIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwYXJlbnQpIHtcbiAgICAgICAgc3VwZXIobmFtZSwgcGFyZW50KTtcbiAgICAgICAgdGhpcy5tYXRyaXhXb3JsZEludmVydCA9IG5ldyBNYXRyaXg0O1xuICAgICAgICB0aGlzLnByb2plY3Rpb24gPSBuZXcgTWF0cml4NDtcbiAgICB9XG4gICAgc2V0UHJvcHMocHJvcHMpIHtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIH1cbiAgICBzZXRQcm9qZWN0aW9uKG1hdHJpeCkge1xuICAgICAgICB0aGlzLnByb2plY3Rpb24uc2V0KG1hdHJpeC5lbGVtZW50cyk7XG4gICAgfVxuICAgIHNldE1hdHJpeFdvcmxkKG1hdHJpeCkge1xuICAgICAgICBzdXBlci5zZXRNYXRyaXhXb3JsZChtYXRyaXgpO1xuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkSW52ZXJ0LnNldEludmVyc2VPZih0aGlzLm1hdHJpeFdvcmxkKTtcbiAgICB9XG4gICAgc2V0Wih6KSB7XG4gICAgICAgIHRoaXMubWF0cml4LmVsZW1lbnRzWzE0XSA9IHo7XG4gICAgICAgIHRoaXMuc2V0TWF0cml4V29ybGQodGhpcy5tYXRyaXguZWxlbWVudHMpO1xuICAgIH1cbiAgICBnZXRWaWV3UHJvak1hdHJpeCgpIHtcbiAgICAgICAgY29uc3QgbSA9IG5ldyBNYXRyaXg0O1xuICAgICAgICBtLm11bHRpcGx5KHRoaXMucHJvamVjdGlvbik7XG4gICAgICAgIG0ubXVsdGlwbHkodGhpcy5tYXRyaXhXb3JsZEludmVydCk7XG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cbn1cbmNsYXNzIFNjZW5lIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5vcGFxdWVDaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLnRyYW5zcGFyZW50Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLmJpbiA9IFtdO1xuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkID0gbmV3IE1hdHJpeDQ7XG4gICAgfVxufVxuZXhwb3J0IHsgU2NlbmUsIE9iamVjdDNELCBNZXNoLCBTa2lubmVkTWVzaCwgQm9uZSwgQ2FtZXJhIH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/objects.ts\n");

/***/ }),

/***/ "./src/parse.ts":
/*!**********************!*\
  !*** ./src/parse.ts ***!
  \**********************/
/*! exports provided: Parse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Parse\", function() { return Parse; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n/* harmony import */ var _objects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./objects */ \"./src/objects.ts\");\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./matrix */ \"./src/matrix.ts\");\n/* harmony import */ var _shaders_vertex_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shaders/vertex.glsl */ \"./src/shaders/vertex.glsl\");\n/* harmony import */ var _shaders_vertex_glsl__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_shaders_vertex_glsl__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _shaders_fragment_glsl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shaders/fragment.glsl */ \"./src/shaders/fragment.glsl\");\n/* harmony import */ var _shaders_fragment_glsl__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_shaders_fragment_glsl__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\nlet gl;\nlet sceneTextureCount = 1;\nclass Parse {\n    constructor(url) {\n        this.url = url;\n        this.host = url.substr(0, url.lastIndexOf('/') + 1);\n        this.tracks = [];\n        this.skins = [];\n        this.textures = null;\n        this.samplers = null;\n        this.arrayBuffer = null;\n        this.cameras = [];\n        this.programs = {};\n    }\n    setScene(scene) {\n        this.scene = scene;\n    }\n    setGl(g) {\n        gl = g;\n    }\n    setCamera(camera) {\n        this._camera = camera;\n    }\n    setCanvas(canvas) {\n        this.canvas = canvas;\n    }\n    setResize(resize) {\n        this.resize = resize;\n    }\n    setUpdateCamera(updateCamera) {\n        this.updateCamera = updateCamera;\n    }\n    get width() {\n        return this.canvas.offsetWidth;\n    }\n    getBuffer() {\n        return Promise.all(this.scene.bin.map(url => fetch(`${this.host}${url}`).then(res => res.arrayBuffer())))\n            .then(buffers => {\n            this.arrayBuffer = buffers;\n        });\n    }\n    compileShader(vertexShader, fragmentShader) {\n        const program = gl.createProgram();\n        Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"compileShader\"])(gl.VERTEX_SHADER, vertexShader, program);\n        Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"compileShader\"])(gl.FRAGMENT_SHADER, fragmentShader, program);\n        gl.linkProgram(program);\n        return program;\n    }\n    buildPrim(parent, name, skin, weights, p) {\n        const indicesAccessor = this.json.accessors[p.indices];\n        const vertexAccessor = new Map;\n        for (const a in p.attributes) {\n            vertexAccessor.set(a, this.json.accessors[p.attributes[a]]);\n        }\n        const targets = [];\n        if (p.targets) {\n            for (const target of p.targets) {\n                const vertexAcc = {};\n                for (const a in target) {\n                    vertexAcc[a] = this.json.accessors[target[a]];\n                    const accessor = vertexAcc[a];\n                    const bufferView = this.json.bufferViews[accessor.bufferView];\n                    vertexAcc[a] = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"buildArray\"])(this.arrayBuffer[bufferView.buffer], accessor.componentType, Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"calculateOffset\"])(bufferView.byteOffset, accessor.byteOffset), Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getDataType\"])(accessor.type) * accessor.count);\n                }\n                targets.push(vertexAcc);\n            }\n        }\n        const material = p.material !== undefined ? JSON.parse(JSON.stringify(this.json.materials[p.material])) : { pbrMetallicRoughness: { baseColorFactor: [0.8, 0.8, 0.8, 1.0] } };\n        const defines = [];\n        if (material.pbrMetallicRoughness.metallicRoughnessTexture) {\n            material.pbrMetallicRoughness.metallicRoughnessTexture = Object.assign({}, this.textures[material.pbrMetallicRoughness.metallicRoughnessTexture.index]);\n            defines.push({ name: 'USE_PBR' });\n            defines.push({ name: 'METALROUGHNESSMAP' });\n        }\n        if (material.normalTexture) {\n            material.normalTexture = Object.assign({}, this.textures[material.normalTexture.index]);\n            defines.push({ name: 'NORMALMAP' });\n        }\n        if (material.occlusionTexture) {\n            material.occlusionTexture = Object.assign({}, this.textures[material.occlusionTexture.index]);\n            defines.push({ name: 'OCCLUSIONMAP' });\n        }\n        if (material.pbrMetallicRoughness.baseColorTexture) {\n            material.pbrMetallicRoughness.baseColorTexture = Object.assign({}, this.textures[material.pbrMetallicRoughness.baseColorTexture.index]);\n            defines.push({ name: 'BASECOLORTEXTURE' });\n        }\n        if (material.emissiveTexture) {\n            material.emissiveTexture = Object.assign({}, this.textures[material.emissiveTexture.index]);\n            defines.push({ name: 'EMISSIVEMAP' });\n        }\n        if (skin !== undefined) {\n            defines.push({ name: 'JOINTNUMBER', value: this.skins[skin].jointNames.length });\n        }\n        if (p.attributes.TANGENT || material.normalTexture) {\n            defines.push({ name: 'TANGENT' });\n        }\n        let program;\n        if (this.programs[defines.map(define => define.name).join('')]) {\n            program = this.programs[defines.map(define => define.name).join('')];\n        }\n        else {\n            const defineStr = defines.map(define => `#define ${define.name} ${define.value || 1}` + '\\n').join('');\n            program = this.compileShader(_shaders_vertex_glsl__WEBPACK_IMPORTED_MODULE_3___default.a.replace(/\\n/, `\\n${defineStr}`), _shaders_fragment_glsl__WEBPACK_IMPORTED_MODULE_4___default.a.replace(/\\n/, `\\n${defineStr}`));\n            this.programs[defines.map(define => define.name).join('')] = program;\n        }\n        let indicesBuffer;\n        if (indicesAccessor) {\n            const bufferView = this.json.bufferViews[indicesAccessor.bufferView];\n            indicesBuffer = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"buildArray\"])(this.arrayBuffer[bufferView.buffer], indicesAccessor.componentType, Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"calculateOffset\"])(bufferView.byteOffset, indicesAccessor.byteOffset), Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getDataType\"])(indicesAccessor.type) * indicesAccessor.count);\n        }\n        const boundingBox = {\n            min: vertexAccessor.get('POSITION').min,\n            max: vertexAccessor.get('POSITION').max\n        };\n        const vertexBuffers = {};\n        for (const k of vertexAccessor.keys()) {\n            const accessor = vertexAccessor.get(k);\n            const bufferView = this.json.bufferViews[accessor.bufferView];\n            vertexBuffers[k] = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"buildArray\"])(this.arrayBuffer[bufferView.buffer], accessor.componentType, Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"calculateOffset\"])(bufferView.byteOffset, accessor.byteOffset), Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getDataType\"])(accessor.type) * accessor.count, bufferView.byteStride, accessor.count);\n            if (p.targets && k in p.targets[0]) {\n                let offset = 0;\n                const geometry = vertexBuffers[k];\n                vertexBuffers[k] = new Float32Array(geometry.length);\n                for (let i = 0; i < vertexBuffers[k].length; i++) {\n                    if (k === 'TANGENT' && (i + 1) % 4 === 0) {\n                        offset++;\n                        continue;\n                    }\n                    vertexBuffers[k][i] = geometry[i] + weights[0] * targets[0][k][i - offset] + weights[1] * targets[1][k][i - offset];\n                }\n            }\n        }\n        if (material.normalTexture && p.attributes.TANGENT === undefined) {\n            vertexBuffers.TANGENT = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"calculateBinormals\"])(indicesBuffer, vertexBuffers.POSITION, vertexBuffers.NORMAL, vertexBuffers.TEXCOORD_0);\n        }\n        const mesh = skin !== undefined ? new _objects__WEBPACK_IMPORTED_MODULE_1__[\"SkinnedMesh\"](name, parent).setSkin(skin) : new _objects__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"](name, parent);\n        mesh.setProgram(program);\n        mesh.setMode(p.mode);\n        mesh.setMaterial(material);\n        mesh.setAttributes(vertexBuffers);\n        mesh.setIndicesBuffer(indicesBuffer);\n        mesh.setBoundingBox(boundingBox);\n        mesh.setTargets(targets);\n        mesh.updateMatrix();\n        const VAO = gl.createVertexArray();\n        gl.bindVertexArray(VAO);\n        for (const k in vertexBuffers) {\n            const VBO = gl.createBuffer();\n            gl.bindBuffer(gl.ARRAY_BUFFER, VBO);\n            gl.bufferData(gl.ARRAY_BUFFER, vertexBuffers[k], gl.STATIC_DRAW);\n            const index = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getAttributeIndex\"])(k);\n            gl.enableVertexAttribArray(index[0]);\n            gl.vertexAttribPointer(index[0], index[1], index[2], false, 0, 0);\n        }\n        if (indicesBuffer) {\n            const VBO = gl.createBuffer();\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, VBO);\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer, gl.STATIC_DRAW);\n        }\n        mesh.geometry.VAO = VAO;\n        gl.bindVertexArray(null);\n        if (material.pbrMetallicRoughness.baseColorTexture) {\n            mesh.material.uniforms.baseColorTexture = gl.getUniformLocation(mesh.program, 'baseColorTexture');\n        }\n        if (material.pbrMetallicRoughness.metallicRoughnessTexture) {\n            mesh.material.uniforms.metallicRoughnessTexture = gl.getUniformLocation(mesh.program, 'metallicRoughnessTexture');\n        }\n        if (material.normalTexture) {\n            mesh.material.uniforms.normalTexture = gl.getUniformLocation(mesh.program, 'normalTexture');\n        }\n        if (material.occlusionTexture) {\n            mesh.material.uniforms.occlusionTexture = gl.getUniformLocation(mesh.program, 'occlusionTexture');\n        }\n        if (material.emissiveTexture) {\n            mesh.material.uniforms.emissiveTexture = gl.getUniformLocation(mesh.program, 'emissiveTexture');\n        }\n        return mesh;\n    }\n    walkByMesh(parent, name) {\n        const el = this.json.nodes[name];\n        let child;\n        if (el.camera !== undefined) {\n            const proj = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"calculateProjection\"])(this.json.cameras[el.camera]);\n            child = new _objects__WEBPACK_IMPORTED_MODULE_1__[\"Camera\"](name, parent);\n            child.setProps(Object.assign({\n                zoom: 1,\n                aspect: this.canvas.offsetWidth / this.canvas.offsetHeight\n            }, this.json.cameras[el.camera]));\n            child.setProjection(proj);\n            this._camera = child;\n            this.updateCamera(this._camera);\n            this.cameras.push(child);\n        }\n        else {\n            if (el.isBone !== undefined) {\n                child = new _objects__WEBPACK_IMPORTED_MODULE_1__[\"Bone\"](name, parent);\n            }\n            else {\n                child = new _objects__WEBPACK_IMPORTED_MODULE_1__[\"Object3D\"](name, parent);\n            }\n        }\n        if (el.translation || el.rotation || el.scale) {\n            child.setPosition(el.translation, el.rotation, el.scale);\n        }\n        else if (el.matrix) {\n            child.setMatrix(el.matrix);\n        }\n        child.updateMatrix();\n        parent.children.push(child);\n        parent = child;\n        if (el.mesh !== undefined) {\n            if (el.skin !== undefined) {\n                for (const join of this.skins[el.skin].jointNames) {\n                    Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"walk\"])(this.scene, this.buildBones.bind(this, join, this.skins[el.skin]));\n                }\n            }\n            parent.children.push(...this.json.meshes[el.mesh].primitives.map(this.buildPrim.bind(this, parent, this.json.meshes[el.mesh].name, el.skin, this.json.meshes[el.mesh].weights)));\n        }\n        if (el.children && el.children.length) {\n            el.children.forEach(this.walkByMesh.bind(this, parent));\n        }\n    }\n    calculateFov() {\n        let biggestMesh;\n        Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"walk\"])(this.scene, node => {\n            if (node instanceof _objects__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"]) {\n                if (!biggestMesh) {\n                    biggestMesh = node;\n                }\n                if (node.geometry.boundingSphere.radius > biggestMesh.geometry.boundingSphere.radius) {\n                    biggestMesh = node;\n                }\n            }\n        });\n        const a = Math.abs;\n        const min = biggestMesh.geometry.boundingSphere.min.elements;\n        const max = biggestMesh.geometry.boundingSphere.max.elements;\n        const z = biggestMesh.matrixWorld.getScaleZ();\n        this._camera.modelXSize = Math.max(a(min[0]), a(min[2]), a(max[0]), a(max[2]), Math.sqrt(min[0] * min[0] + min[2] * min[2]), Math.sqrt(max[0] * max[0] + max[2] * max[2]));\n        this._camera.modelYSize = Math.max(a(min[1]), a(min[2]), a(max[1]), a(max[2]));\n        this._camera.modelSize = Math.max(this._camera.modelYSize, this._camera.modelXSize) * z;\n        this.resize();\n    }\n    buildMesh() {\n        this.json.scenes[this.json.scene !== undefined ? this.json.scene : 0].nodes.forEach(n => {\n            if (this.json.nodes[n].children && this.json.nodes[n].children.length) {\n                this.walkByMesh(this.scene, n);\n            }\n            if (this.json.nodes[n].mesh !== undefined) {\n                this.walkByMesh(this.scene, n);\n            }\n            if (this.json.nodes[n].camera !== undefined) {\n                this.walkByMesh(this.scene, n);\n            }\n        });\n        this.calculateFov();\n        const planes = Object(_matrix__WEBPACK_IMPORTED_MODULE_2__[\"Frustum\"])(this._camera.getViewProjMatrix());\n        Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"walk\"])(this.scene, mesh => {\n            if (mesh instanceof _objects__WEBPACK_IMPORTED_MODULE_1__[\"SkinnedMesh\"]) {\n                mesh.bones = this.skins[mesh.skin].bones;\n                mesh.boneInverses = this.skins[mesh.skin].boneInverses;\n                const jointMatrix = mesh.getJointMatrix();\n                const matrices = new Float32Array(jointMatrix.length * 16);\n                let i = 0;\n                for (const j of jointMatrix) {\n                    matrices.set(j.elements, 0 + 16 * i);\n                    i++;\n                }\n                const uIndex = gl.getUniformBlockIndex(mesh.program, 'Skin');\n                gl.uniformBlockBinding(mesh.program, uIndex, 2);\n                const UBO = gl.createBuffer();\n                gl.bindBuffer(gl.UNIFORM_BUFFER, UBO);\n                gl.bufferData(gl.UNIFORM_BUFFER, matrices, gl.DYNAMIC_DRAW);\n                mesh.geometry.SKIN = UBO;\n                gl.bindBuffer(gl.UNIFORM_BUFFER, null);\n            }\n            if (mesh instanceof _objects__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"]) {\n                const materials = new Float32Array(12);\n                materials.set(mesh.material.pbrMetallicRoughness.baseColorFactor || [0.8, 0.8, 0.8, 1.0]);\n                materials.set([this._camera.matrixWorld.elements[12], this._camera.matrixWorld.elements[13], this._camera.matrixWorld.elements[14]], 4);\n                materials.set([this._camera.matrixWorld.elements[12], this._camera.matrixWorld.elements[13], this._camera.matrixWorld.elements[14]], 8);\n                const mIndex = gl.getUniformBlockIndex(mesh.program, 'Material');\n                gl.uniformBlockBinding(mesh.program, mIndex, 1);\n                const mUBO = gl.createBuffer();\n                gl.bindBuffer(gl.UNIFORM_BUFFER, mUBO);\n                gl.bufferData(gl.UNIFORM_BUFFER, materials, gl.STATIC_DRAW);\n                mesh.material.UBO = mUBO;\n                const normalMatrix = new _matrix__WEBPACK_IMPORTED_MODULE_2__[\"Matrix4\"](mesh.matrixWorld);\n                normalMatrix.invert().transpose();\n                const matrices = new Float32Array(64);\n                matrices.set(mesh.matrixWorld.elements, 0);\n                matrices.set(normalMatrix.elements, 16);\n                matrices.set(this._camera.matrixWorldInvert.elements, 32);\n                matrices.set(this._camera.projection.elements, 48);\n                const uIndex = gl.getUniformBlockIndex(mesh.program, 'Matrices');\n                gl.uniformBlockBinding(mesh.program, uIndex, 0);\n                const UBO = gl.createBuffer();\n                gl.bindBuffer(gl.UNIFORM_BUFFER, UBO);\n                gl.bufferData(gl.UNIFORM_BUFFER, matrices, gl.DYNAMIC_DRAW);\n                mesh.geometry.UBO = UBO;\n                gl.bindBuffer(gl.UNIFORM_BUFFER, null);\n                if (mesh.isVisible(planes)) {\n                    if (mesh.material.alphaMode) {\n                        this.scene.transparentChildren.push(mesh);\n                    }\n                    else {\n                        this.scene.opaqueChildren.push(mesh);\n                    }\n                }\n            }\n        });\n        this.scene.transparentChildren.sort((a, b) => b.distance - a.distance);\n        return true;\n    }\n    buildAnimation() {\n        if (!this.json.animations) {\n            return true;\n        }\n        for (const animation of this.json.animations) {\n            for (const channel of animation.channels) {\n                const sampler = animation.samplers[channel.sampler];\n                if (sampler) {\n                    const { target } = channel;\n                    const name = target.node;\n                    const input = animation.parameters !== undefined ? animation.parameters[sampler.input] : sampler.input;\n                    const output = animation.parameters !== undefined ? animation.parameters[sampler.output] : sampler.output;\n                    const inputAccessor = this.json.accessors[input];\n                    const outputAccessor = this.json.accessors[output];\n                    const inputBuffer = this.json.bufferViews[inputAccessor.bufferView];\n                    const outputBuffer = this.json.bufferViews[outputAccessor.bufferView];\n                    const inputArray = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"buildArray\"])(this.arrayBuffer[inputBuffer.buffer], inputAccessor.componentType, Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"calculateOffset\"])(inputBuffer.byteOffset, inputAccessor.byteOffset), Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getDataType\"])(inputAccessor.type) * inputAccessor.count);\n                    const outputArray = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"buildArray\"])(this.arrayBuffer[outputBuffer.buffer], outputAccessor.componentType, Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"calculateOffset\"])(outputBuffer.byteOffset, outputAccessor.byteOffset), Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getDataType\"])(outputAccessor.type) * outputAccessor.count);\n                    const component = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getAnimationComponent\"])(target.path);\n                    const keys = [];\n                    for (let i = 0; i < inputArray.length; i++) {\n                        const firstT = inputArray[i];\n                        const firstV = outputArray.slice(i * component, (i + 1) * component);\n                        keys.push({\n                            time: firstT,\n                            value: firstV\n                        });\n                    }\n                    const meshes = [];\n                    Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"walk\"])(this.scene, node => {\n                        if (node.name === name) {\n                            if (target.path === 'weights' && node instanceof _objects__WEBPACK_IMPORTED_MODULE_1__[\"Object3D\"]) {\n                                // eslint-disable-next-line\n                                node = node.children[0];\n                            }\n                            meshes.push(node);\n                        }\n                    });\n                    if (meshes.length) {\n                        this.tracks.push({\n                            stoped: false,\n                            meshes: meshes,\n                            type: target.path,\n                            name: `${meshes[0].name}.${target.path}`,\n                            keys: keys,\n                            interpolation: sampler.interpolation\n                        });\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    buildSkin() {\n        if (!this.json.skins) {\n            return true;\n        }\n        for (const skin of this.json.skins) {\n            const acc = this.json.accessors[skin.inverseBindMatrices];\n            const buffer = this.json.bufferViews[acc.bufferView];\n            const array = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"buildArray\"])(this.arrayBuffer[buffer.buffer], acc.componentType, Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"calculateOffset\"])(buffer.byteOffset, acc.byteOffset), Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getDataType\"])(acc.type) * acc.count);\n            const v = {\n                jointNames: skin.joints,\n                inverseBindMatrices: array,\n                bones: [],\n                boneInverses: []\n            };\n            let i = 0;\n            for (const join of v.jointNames) {\n                //walk(this.scene, this.buildBones.bind(this, join, v));\n                this.json.nodes[join].isBone = true;\n                const m = v.inverseBindMatrices;\n                const mat = new _matrix__WEBPACK_IMPORTED_MODULE_2__[\"Matrix4\"]().set(m.slice(i * 16, (i + 1) * 16));\n                v.boneInverses.push(mat);\n                i++;\n            }\n            this.skins.push(v);\n        }\n        return true;\n    }\n    buildBones(join, v, node) {\n        if (node.name === join) {\n            v.bones.push(node);\n        }\n    }\n    getJson() {\n        return fetch(this.url)\n            .then(res => res.json())\n            .then(j => {\n            for (const key in j.buffers) {\n                this.scene.bin.push(j.buffers[key].uri);\n            }\n            this.json = j;\n            return true;\n        });\n    }\n    initTextures() {\n        if (!this.json.textures) {\n            return true;\n        }\n        const samplers = this.json.samplers || [{}];\n        this.samplers = samplers.map(s => {\n            const sampler = gl.createSampler();\n            gl.samplerParameteri(sampler, gl.TEXTURE_MIN_FILTER, s.minFilter || 9986);\n            gl.samplerParameteri(sampler, gl.TEXTURE_MAG_FILTER, s.magFilter || 9729);\n            gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_S, s.wrapS || 10497);\n            gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_T, s.wrapT || 10497);\n            return sampler;\n        });\n        const promiseArr = this.json.textures.map(t => {\n            return new Promise((resolve, reject) => {\n                const sampler = this.samplers[t.sampler !== undefined ? t.sampler : 0];\n                const source = this.json.images[t.source];\n                const image = new Image();\n                image.onload = () => {\n                    resolve(this.handleTextureLoaded(sampler, image));\n                };\n                image.onerror = err => {\n                    reject(err);\n                };\n                image.crossOrigin = 'anonymous';\n                image.src = `${this.host}${source.uri}`;\n            });\n        });\n        return Promise.all(promiseArr)\n            .then(textures => {\n            this.textures = textures;\n            return true;\n        });\n    }\n    handleTextureLoaded(sampler, image) {\n        const t = {\n            image: image.src.substr(image.src.lastIndexOf('/')),\n            data: gl.createTexture(),\n            count: sceneTextureCount\n        };\n        gl.activeTexture(gl[`TEXTURE${sceneTextureCount}`]);\n        gl.bindTexture(gl.TEXTURE_2D, t.data);\n        gl.bindSampler(sceneTextureCount, sampler);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n        gl.generateMipmap(gl.TEXTURE_2D);\n        sceneTextureCount++;\n        return t;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFyc2UudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWRjdWJlLy4vc3JjL3BhcnNlLnRzPzU5MGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYnVpbGRBcnJheSwgZ2V0RGF0YVR5cGUsIHdhbGssIGdldEFuaW1hdGlvbkNvbXBvbmVudCwgY2FsY3VsYXRlUHJvamVjdGlvbiwgY29tcGlsZVNoYWRlciwgY2FsY3VsYXRlT2Zmc2V0LCBnZXRBdHRyaWJ1dGVJbmRleCwgY2FsY3VsYXRlQmlub3JtYWxzIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBNZXNoLCBTa2lubmVkTWVzaCwgQm9uZSwgQ2FtZXJhLCBPYmplY3QzRCB9IGZyb20gJy4vb2JqZWN0cyc7XG5pbXBvcnQgeyBNYXRyaXg0LCBGcnVzdHVtIH0gZnJvbSAnLi9tYXRyaXgnO1xuaW1wb3J0IHZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlcnMvdmVydGV4Lmdsc2wnO1xuaW1wb3J0IGZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVycy9mcmFnbWVudC5nbHNsJztcbmxldCBnbDtcbmxldCBzY2VuZVRleHR1cmVDb3VudCA9IDE7XG5leHBvcnQgY2xhc3MgUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKHVybCkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5ob3N0ID0gdXJsLnN1YnN0cigwLCB1cmwubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuICAgICAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLnNraW5zID0gW107XG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnNhbXBsZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FtZXJhcyA9IFtdO1xuICAgICAgICB0aGlzLnByb2dyYW1zID0ge307XG4gICAgfVxuICAgIHNldFNjZW5lKHNjZW5lKSB7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB9XG4gICAgc2V0R2woZykge1xuICAgICAgICBnbCA9IGc7XG4gICAgfVxuICAgIHNldENhbWVyYShjYW1lcmEpIHtcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xuICAgIH1cbiAgICBzZXRDYW52YXMoY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIH1cbiAgICBzZXRSZXNpemUocmVzaXplKSB7XG4gICAgICAgIHRoaXMucmVzaXplID0gcmVzaXplO1xuICAgIH1cbiAgICBzZXRVcGRhdGVDYW1lcmEodXBkYXRlQ2FtZXJhKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2FtZXJhID0gdXBkYXRlQ2FtZXJhO1xuICAgIH1cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgICB9XG4gICAgZ2V0QnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5zY2VuZS5iaW4ubWFwKHVybCA9PiBmZXRjaChgJHt0aGlzLmhvc3R9JHt1cmx9YCkudGhlbihyZXMgPT4gcmVzLmFycmF5QnVmZmVyKCkpKSlcbiAgICAgICAgICAgIC50aGVuKGJ1ZmZlcnMgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGJ1ZmZlcnM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb21waWxlU2hhZGVyKHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpIHtcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgICAgY29tcGlsZVNoYWRlcihnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTaGFkZXIsIHByb2dyYW0pO1xuICAgICAgICBjb21waWxlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTaGFkZXIsIHByb2dyYW0pO1xuICAgICAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfVxuICAgIGJ1aWxkUHJpbShwYXJlbnQsIG5hbWUsIHNraW4sIHdlaWdodHMsIHApIHtcbiAgICAgICAgY29uc3QgaW5kaWNlc0FjY2Vzc29yID0gdGhpcy5qc29uLmFjY2Vzc29yc1twLmluZGljZXNdO1xuICAgICAgICBjb25zdCB2ZXJ0ZXhBY2Nlc3NvciA9IG5ldyBNYXA7XG4gICAgICAgIGZvciAoY29uc3QgYSBpbiBwLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHZlcnRleEFjY2Vzc29yLnNldChhLCB0aGlzLmpzb24uYWNjZXNzb3JzW3AuYXR0cmlidXRlc1thXV0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldHMgPSBbXTtcbiAgICAgICAgaWYgKHAudGFyZ2V0cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgb2YgcC50YXJnZXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVydGV4QWNjID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhIGluIHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhBY2NbYV0gPSB0aGlzLmpzb24uYWNjZXNzb3JzW3RhcmdldFthXV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjY2Vzc29yID0gdmVydGV4QWNjW2FdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJWaWV3ID0gdGhpcy5qc29uLmJ1ZmZlclZpZXdzW2FjY2Vzc29yLmJ1ZmZlclZpZXddO1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhBY2NbYV0gPSBidWlsZEFycmF5KHRoaXMuYXJyYXlCdWZmZXJbYnVmZmVyVmlldy5idWZmZXJdLCBhY2Nlc3Nvci5jb21wb25lbnRUeXBlLCBjYWxjdWxhdGVPZmZzZXQoYnVmZmVyVmlldy5ieXRlT2Zmc2V0LCBhY2Nlc3Nvci5ieXRlT2Zmc2V0KSwgZ2V0RGF0YVR5cGUoYWNjZXNzb3IudHlwZSkgKiBhY2Nlc3Nvci5jb3VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldHMucHVzaCh2ZXJ0ZXhBY2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hdGVyaWFsID0gcC5tYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmpzb24ubWF0ZXJpYWxzW3AubWF0ZXJpYWxdKSkgOiB7IHBick1ldGFsbGljUm91Z2huZXNzOiB7IGJhc2VDb2xvckZhY3RvcjogWzAuOCwgMC44LCAwLjgsIDEuMF0gfSB9O1xuICAgICAgICBjb25zdCBkZWZpbmVzID0gW107XG4gICAgICAgIGlmIChtYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpIHtcbiAgICAgICAgICAgIG1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMudGV4dHVyZXNbbWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlLmluZGV4XSk7XG4gICAgICAgICAgICBkZWZpbmVzLnB1c2goeyBuYW1lOiAnVVNFX1BCUicgfSk7XG4gICAgICAgICAgICBkZWZpbmVzLnB1c2goeyBuYW1lOiAnTUVUQUxST1VHSE5FU1NNQVAnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRlcmlhbC5ub3JtYWxUZXh0dXJlKSB7XG4gICAgICAgICAgICBtYXRlcmlhbC5ub3JtYWxUZXh0dXJlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy50ZXh0dXJlc1ttYXRlcmlhbC5ub3JtYWxUZXh0dXJlLmluZGV4XSk7XG4gICAgICAgICAgICBkZWZpbmVzLnB1c2goeyBuYW1lOiAnTk9STUFMTUFQJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0ZXJpYWwub2NjbHVzaW9uVGV4dHVyZSkge1xuICAgICAgICAgICAgbWF0ZXJpYWwub2NjbHVzaW9uVGV4dHVyZSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMudGV4dHVyZXNbbWF0ZXJpYWwub2NjbHVzaW9uVGV4dHVyZS5pbmRleF0pO1xuICAgICAgICAgICAgZGVmaW5lcy5wdXNoKHsgbmFtZTogJ09DQ0xVU0lPTk1BUCcgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUpIHtcbiAgICAgICAgICAgIG1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnRleHR1cmVzW21hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUuaW5kZXhdKTtcbiAgICAgICAgICAgIGRlZmluZXMucHVzaCh7IG5hbWU6ICdCQVNFQ09MT1JURVhUVVJFJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0ZXJpYWwuZW1pc3NpdmVUZXh0dXJlKSB7XG4gICAgICAgICAgICBtYXRlcmlhbC5lbWlzc2l2ZVRleHR1cmUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnRleHR1cmVzW21hdGVyaWFsLmVtaXNzaXZlVGV4dHVyZS5pbmRleF0pO1xuICAgICAgICAgICAgZGVmaW5lcy5wdXNoKHsgbmFtZTogJ0VNSVNTSVZFTUFQJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWZpbmVzLnB1c2goeyBuYW1lOiAnSk9JTlROVU1CRVInLCB2YWx1ZTogdGhpcy5za2luc1tza2luXS5qb2ludE5hbWVzLmxlbmd0aCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocC5hdHRyaWJ1dGVzLlRBTkdFTlQgfHwgbWF0ZXJpYWwubm9ybWFsVGV4dHVyZSkge1xuICAgICAgICAgICAgZGVmaW5lcy5wdXNoKHsgbmFtZTogJ1RBTkdFTlQnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcm9ncmFtO1xuICAgICAgICBpZiAodGhpcy5wcm9ncmFtc1tkZWZpbmVzLm1hcChkZWZpbmUgPT4gZGVmaW5lLm5hbWUpLmpvaW4oJycpXSkge1xuICAgICAgICAgICAgcHJvZ3JhbSA9IHRoaXMucHJvZ3JhbXNbZGVmaW5lcy5tYXAoZGVmaW5lID0+IGRlZmluZS5uYW1lKS5qb2luKCcnKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkZWZpbmVTdHIgPSBkZWZpbmVzLm1hcChkZWZpbmUgPT4gYCNkZWZpbmUgJHtkZWZpbmUubmFtZX0gJHtkZWZpbmUudmFsdWUgfHwgMX1gICsgJ1xcbicpLmpvaW4oJycpO1xuICAgICAgICAgICAgcHJvZ3JhbSA9IHRoaXMuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIucmVwbGFjZSgvXFxuLywgYFxcbiR7ZGVmaW5lU3RyfWApLCBmcmFnbWVudFNoYWRlci5yZXBsYWNlKC9cXG4vLCBgXFxuJHtkZWZpbmVTdHJ9YCkpO1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtc1tkZWZpbmVzLm1hcChkZWZpbmUgPT4gZGVmaW5lLm5hbWUpLmpvaW4oJycpXSA9IHByb2dyYW07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZGljZXNCdWZmZXI7XG4gICAgICAgIGlmIChpbmRpY2VzQWNjZXNzb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclZpZXcgPSB0aGlzLmpzb24uYnVmZmVyVmlld3NbaW5kaWNlc0FjY2Vzc29yLmJ1ZmZlclZpZXddO1xuICAgICAgICAgICAgaW5kaWNlc0J1ZmZlciA9IGJ1aWxkQXJyYXkodGhpcy5hcnJheUJ1ZmZlcltidWZmZXJWaWV3LmJ1ZmZlcl0sIGluZGljZXNBY2Nlc3Nvci5jb21wb25lbnRUeXBlLCBjYWxjdWxhdGVPZmZzZXQoYnVmZmVyVmlldy5ieXRlT2Zmc2V0LCBpbmRpY2VzQWNjZXNzb3IuYnl0ZU9mZnNldCksIGdldERhdGFUeXBlKGluZGljZXNBY2Nlc3Nvci50eXBlKSAqIGluZGljZXNBY2Nlc3Nvci5jb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm91bmRpbmdCb3ggPSB7XG4gICAgICAgICAgICBtaW46IHZlcnRleEFjY2Vzc29yLmdldCgnUE9TSVRJT04nKS5taW4sXG4gICAgICAgICAgICBtYXg6IHZlcnRleEFjY2Vzc29yLmdldCgnUE9TSVRJT04nKS5tYXhcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdmVydGV4QnVmZmVycyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgdmVydGV4QWNjZXNzb3Iua2V5cygpKSB7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NvciA9IHZlcnRleEFjY2Vzc29yLmdldChrKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclZpZXcgPSB0aGlzLmpzb24uYnVmZmVyVmlld3NbYWNjZXNzb3IuYnVmZmVyVmlld107XG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJzW2tdID0gYnVpbGRBcnJheSh0aGlzLmFycmF5QnVmZmVyW2J1ZmZlclZpZXcuYnVmZmVyXSwgYWNjZXNzb3IuY29tcG9uZW50VHlwZSwgY2FsY3VsYXRlT2Zmc2V0KGJ1ZmZlclZpZXcuYnl0ZU9mZnNldCwgYWNjZXNzb3IuYnl0ZU9mZnNldCksIGdldERhdGFUeXBlKGFjY2Vzc29yLnR5cGUpICogYWNjZXNzb3IuY291bnQsIGJ1ZmZlclZpZXcuYnl0ZVN0cmlkZSwgYWNjZXNzb3IuY291bnQpO1xuICAgICAgICAgICAgaWYgKHAudGFyZ2V0cyAmJiBrIGluIHAudGFyZ2V0c1swXSkge1xuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gdmVydGV4QnVmZmVyc1trXTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJzW2tdID0gbmV3IEZsb2F0MzJBcnJheShnZW9tZXRyeS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGV4QnVmZmVyc1trXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoayA9PT0gJ1RBTkdFTlQnICYmIChpICsgMSkgJSA0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZlcnRleEJ1ZmZlcnNba11baV0gPSBnZW9tZXRyeVtpXSArIHdlaWdodHNbMF0gKiB0YXJnZXRzWzBdW2tdW2kgLSBvZmZzZXRdICsgd2VpZ2h0c1sxXSAqIHRhcmdldHNbMV1ba11baSAtIG9mZnNldF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRlcmlhbC5ub3JtYWxUZXh0dXJlICYmIHAuYXR0cmlidXRlcy5UQU5HRU5UID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlcnMuVEFOR0VOVCA9IGNhbGN1bGF0ZUJpbm9ybWFscyhpbmRpY2VzQnVmZmVyLCB2ZXJ0ZXhCdWZmZXJzLlBPU0lUSU9OLCB2ZXJ0ZXhCdWZmZXJzLk5PUk1BTCwgdmVydGV4QnVmZmVycy5URVhDT09SRF8wKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNoID0gc2tpbiAhPT0gdW5kZWZpbmVkID8gbmV3IFNraW5uZWRNZXNoKG5hbWUsIHBhcmVudCkuc2V0U2tpbihza2luKSA6IG5ldyBNZXNoKG5hbWUsIHBhcmVudCk7XG4gICAgICAgIG1lc2guc2V0UHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgbWVzaC5zZXRNb2RlKHAubW9kZSk7XG4gICAgICAgIG1lc2guc2V0TWF0ZXJpYWwobWF0ZXJpYWwpO1xuICAgICAgICBtZXNoLnNldEF0dHJpYnV0ZXModmVydGV4QnVmZmVycyk7XG4gICAgICAgIG1lc2guc2V0SW5kaWNlc0J1ZmZlcihpbmRpY2VzQnVmZmVyKTtcbiAgICAgICAgbWVzaC5zZXRCb3VuZGluZ0JveChib3VuZGluZ0JveCk7XG4gICAgICAgIG1lc2guc2V0VGFyZ2V0cyh0YXJnZXRzKTtcbiAgICAgICAgbWVzaC51cGRhdGVNYXRyaXgoKTtcbiAgICAgICAgY29uc3QgVkFPID0gZ2wuY3JlYXRlVmVydGV4QXJyYXkoKTtcbiAgICAgICAgZ2wuYmluZFZlcnRleEFycmF5KFZBTyk7XG4gICAgICAgIGZvciAoY29uc3QgayBpbiB2ZXJ0ZXhCdWZmZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBWQk8gPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBWQk8pO1xuICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlcnNba10sIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0QXR0cmlidXRlSW5kZXgoayk7XG4gICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleFswXSk7XG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGluZGV4WzBdLCBpbmRleFsxXSwgaW5kZXhbMl0sIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kaWNlc0J1ZmZlcikge1xuICAgICAgICAgICAgY29uc3QgVkJPID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBWQk8pO1xuICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kaWNlc0J1ZmZlciwgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICB9XG4gICAgICAgIG1lc2guZ2VvbWV0cnkuVkFPID0gVkFPO1xuICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gICAgICAgIGlmIChtYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlKSB7XG4gICAgICAgICAgICBtZXNoLm1hdGVyaWFsLnVuaWZvcm1zLmJhc2VDb2xvclRleHR1cmUgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24obWVzaC5wcm9ncmFtLCAnYmFzZUNvbG9yVGV4dHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpIHtcbiAgICAgICAgICAgIG1lc2gubWF0ZXJpYWwudW5pZm9ybXMubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKG1lc2gucHJvZ3JhbSwgJ21ldGFsbGljUm91Z2huZXNzVGV4dHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRlcmlhbC5ub3JtYWxUZXh0dXJlKSB7XG4gICAgICAgICAgICBtZXNoLm1hdGVyaWFsLnVuaWZvcm1zLm5vcm1hbFRleHR1cmUgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24obWVzaC5wcm9ncmFtLCAnbm9ybWFsVGV4dHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRlcmlhbC5vY2NsdXNpb25UZXh0dXJlKSB7XG4gICAgICAgICAgICBtZXNoLm1hdGVyaWFsLnVuaWZvcm1zLm9jY2x1c2lvblRleHR1cmUgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24obWVzaC5wcm9ncmFtLCAnb2NjbHVzaW9uVGV4dHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRlcmlhbC5lbWlzc2l2ZVRleHR1cmUpIHtcbiAgICAgICAgICAgIG1lc2gubWF0ZXJpYWwudW5pZm9ybXMuZW1pc3NpdmVUZXh0dXJlID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKG1lc2gucHJvZ3JhbSwgJ2VtaXNzaXZlVGV4dHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNoO1xuICAgIH1cbiAgICB3YWxrQnlNZXNoKHBhcmVudCwgbmFtZSkge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMuanNvbi5ub2Rlc1tuYW1lXTtcbiAgICAgICAgbGV0IGNoaWxkO1xuICAgICAgICBpZiAoZWwuY2FtZXJhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2ogPSBjYWxjdWxhdGVQcm9qZWN0aW9uKHRoaXMuanNvbi5jYW1lcmFzW2VsLmNhbWVyYV0pO1xuICAgICAgICAgICAgY2hpbGQgPSBuZXcgQ2FtZXJhKG5hbWUsIHBhcmVudCk7XG4gICAgICAgICAgICBjaGlsZC5zZXRQcm9wcyhPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICB6b29tOiAxLFxuICAgICAgICAgICAgICAgIGFzcGVjdDogdGhpcy5jYW52YXMub2Zmc2V0V2lkdGggLyB0aGlzLmNhbnZhcy5vZmZzZXRIZWlnaHRcbiAgICAgICAgICAgIH0sIHRoaXMuanNvbi5jYW1lcmFzW2VsLmNhbWVyYV0pKTtcbiAgICAgICAgICAgIGNoaWxkLnNldFByb2plY3Rpb24ocHJvaik7XG4gICAgICAgICAgICB0aGlzLl9jYW1lcmEgPSBjaGlsZDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FtZXJhKHRoaXMuX2NhbWVyYSk7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYXMucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZWwuaXNCb25lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5ldyBCb25lKG5hbWUsIHBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5ldyBPYmplY3QzRChuYW1lLCBwYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbC50cmFuc2xhdGlvbiB8fCBlbC5yb3RhdGlvbiB8fCBlbC5zY2FsZSkge1xuICAgICAgICAgICAgY2hpbGQuc2V0UG9zaXRpb24oZWwudHJhbnNsYXRpb24sIGVsLnJvdGF0aW9uLCBlbC5zY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWwubWF0cml4KSB7XG4gICAgICAgICAgICBjaGlsZC5zZXRNYXRyaXgoZWwubWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZC51cGRhdGVNYXRyaXgoKTtcbiAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICBwYXJlbnQgPSBjaGlsZDtcbiAgICAgICAgaWYgKGVsLm1lc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGVsLnNraW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgam9pbiBvZiB0aGlzLnNraW5zW2VsLnNraW5dLmpvaW50TmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Fsayh0aGlzLnNjZW5lLCB0aGlzLmJ1aWxkQm9uZXMuYmluZCh0aGlzLCBqb2luLCB0aGlzLnNraW5zW2VsLnNraW5dKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2goLi4udGhpcy5qc29uLm1lc2hlc1tlbC5tZXNoXS5wcmltaXRpdmVzLm1hcCh0aGlzLmJ1aWxkUHJpbS5iaW5kKHRoaXMsIHBhcmVudCwgdGhpcy5qc29uLm1lc2hlc1tlbC5tZXNoXS5uYW1lLCBlbC5za2luLCB0aGlzLmpzb24ubWVzaGVzW2VsLm1lc2hdLndlaWdodHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLmNoaWxkcmVuICYmIGVsLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgZWwuY2hpbGRyZW4uZm9yRWFjaCh0aGlzLndhbGtCeU1lc2guYmluZCh0aGlzLCBwYXJlbnQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxjdWxhdGVGb3YoKSB7XG4gICAgICAgIGxldCBiaWdnZXN0TWVzaDtcbiAgICAgICAgd2Fsayh0aGlzLnNjZW5lLCBub2RlID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgTWVzaCkge1xuICAgICAgICAgICAgICAgIGlmICghYmlnZ2VzdE1lc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgYmlnZ2VzdE1lc2ggPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgPiBiaWdnZXN0TWVzaC5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5yYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYmlnZ2VzdE1lc2ggPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGEgPSBNYXRoLmFicztcbiAgICAgICAgY29uc3QgbWluID0gYmlnZ2VzdE1lc2guZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUubWluLmVsZW1lbnRzO1xuICAgICAgICBjb25zdCBtYXggPSBiaWdnZXN0TWVzaC5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5tYXguZWxlbWVudHM7XG4gICAgICAgIGNvbnN0IHogPSBiaWdnZXN0TWVzaC5tYXRyaXhXb3JsZC5nZXRTY2FsZVooKTtcbiAgICAgICAgdGhpcy5fY2FtZXJhLm1vZGVsWFNpemUgPSBNYXRoLm1heChhKG1pblswXSksIGEobWluWzJdKSwgYShtYXhbMF0pLCBhKG1heFsyXSksIE1hdGguc3FydChtaW5bMF0gKiBtaW5bMF0gKyBtaW5bMl0gKiBtaW5bMl0pLCBNYXRoLnNxcnQobWF4WzBdICogbWF4WzBdICsgbWF4WzJdICogbWF4WzJdKSk7XG4gICAgICAgIHRoaXMuX2NhbWVyYS5tb2RlbFlTaXplID0gTWF0aC5tYXgoYShtaW5bMV0pLCBhKG1pblsyXSksIGEobWF4WzFdKSwgYShtYXhbMl0pKTtcbiAgICAgICAgdGhpcy5fY2FtZXJhLm1vZGVsU2l6ZSA9IE1hdGgubWF4KHRoaXMuX2NhbWVyYS5tb2RlbFlTaXplLCB0aGlzLl9jYW1lcmEubW9kZWxYU2l6ZSkgKiB6O1xuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH1cbiAgICBidWlsZE1lc2goKSB7XG4gICAgICAgIHRoaXMuanNvbi5zY2VuZXNbdGhpcy5qc29uLnNjZW5lICE9PSB1bmRlZmluZWQgPyB0aGlzLmpzb24uc2NlbmUgOiAwXS5ub2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuanNvbi5ub2Rlc1tuXS5jaGlsZHJlbiAmJiB0aGlzLmpzb24ubm9kZXNbbl0uY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrQnlNZXNoKHRoaXMuc2NlbmUsIG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuanNvbi5ub2Rlc1tuXS5tZXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhbGtCeU1lc2godGhpcy5zY2VuZSwgbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5qc29uLm5vZGVzW25dLmNhbWVyYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrQnlNZXNoKHRoaXMuc2NlbmUsIG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVGb3YoKTtcbiAgICAgICAgY29uc3QgcGxhbmVzID0gRnJ1c3R1bSh0aGlzLl9jYW1lcmEuZ2V0Vmlld1Byb2pNYXRyaXgoKSk7XG4gICAgICAgIHdhbGsodGhpcy5zY2VuZSwgbWVzaCA9PiB7XG4gICAgICAgICAgICBpZiAobWVzaCBpbnN0YW5jZW9mIFNraW5uZWRNZXNoKSB7XG4gICAgICAgICAgICAgICAgbWVzaC5ib25lcyA9IHRoaXMuc2tpbnNbbWVzaC5za2luXS5ib25lcztcbiAgICAgICAgICAgICAgICBtZXNoLmJvbmVJbnZlcnNlcyA9IHRoaXMuc2tpbnNbbWVzaC5za2luXS5ib25lSW52ZXJzZXM7XG4gICAgICAgICAgICAgICAgY29uc3Qgam9pbnRNYXRyaXggPSBtZXNoLmdldEpvaW50TWF0cml4KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KGpvaW50TWF0cml4Lmxlbmd0aCAqIDE2KTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBqIG9mIGpvaW50TWF0cml4KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpY2VzLnNldChqLmVsZW1lbnRzLCAwICsgMTYgKiBpKTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB1SW5kZXggPSBnbC5nZXRVbmlmb3JtQmxvY2tJbmRleChtZXNoLnByb2dyYW0sICdTa2luJyk7XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybUJsb2NrQmluZGluZyhtZXNoLnByb2dyYW0sIHVJbmRleCwgMik7XG4gICAgICAgICAgICAgICAgY29uc3QgVUJPID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5VTklGT1JNX0JVRkZFUiwgVUJPKTtcbiAgICAgICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLlVOSUZPUk1fQlVGRkVSLCBtYXRyaWNlcywgZ2wuRFlOQU1JQ19EUkFXKTtcbiAgICAgICAgICAgICAgICBtZXNoLmdlb21ldHJ5LlNLSU4gPSBVQk87XG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5VTklGT1JNX0JVRkZFUiwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzaCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRlcmlhbHMgPSBuZXcgRmxvYXQzMkFycmF5KDEyKTtcbiAgICAgICAgICAgICAgICBtYXRlcmlhbHMuc2V0KG1lc2gubWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yIHx8IFswLjgsIDAuOCwgMC44LCAxLjBdKTtcbiAgICAgICAgICAgICAgICBtYXRlcmlhbHMuc2V0KFt0aGlzLl9jYW1lcmEubWF0cml4V29ybGQuZWxlbWVudHNbMTJdLCB0aGlzLl9jYW1lcmEubWF0cml4V29ybGQuZWxlbWVudHNbMTNdLCB0aGlzLl9jYW1lcmEubWF0cml4V29ybGQuZWxlbWVudHNbMTRdXSwgNCk7XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxzLnNldChbdGhpcy5fY2FtZXJhLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzEyXSwgdGhpcy5fY2FtZXJhLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzEzXSwgdGhpcy5fY2FtZXJhLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzE0XV0sIDgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1JbmRleCA9IGdsLmdldFVuaWZvcm1CbG9ja0luZGV4KG1lc2gucHJvZ3JhbSwgJ01hdGVyaWFsJyk7XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybUJsb2NrQmluZGluZyhtZXNoLnByb2dyYW0sIG1JbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbVVCTyA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuVU5JRk9STV9CVUZGRVIsIG1VQk8pO1xuICAgICAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuVU5JRk9STV9CVUZGRVIsIG1hdGVyaWFscywgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICAgICAgICAgIG1lc2gubWF0ZXJpYWwuVUJPID0gbVVCTztcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4NChtZXNoLm1hdHJpeFdvcmxkKTtcbiAgICAgICAgICAgICAgICBub3JtYWxNYXRyaXguaW52ZXJ0KCkudHJhbnNwb3NlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KDY0KTtcbiAgICAgICAgICAgICAgICBtYXRyaWNlcy5zZXQobWVzaC5tYXRyaXhXb3JsZC5lbGVtZW50cywgMCk7XG4gICAgICAgICAgICAgICAgbWF0cmljZXMuc2V0KG5vcm1hbE1hdHJpeC5lbGVtZW50cywgMTYpO1xuICAgICAgICAgICAgICAgIG1hdHJpY2VzLnNldCh0aGlzLl9jYW1lcmEubWF0cml4V29ybGRJbnZlcnQuZWxlbWVudHMsIDMyKTtcbiAgICAgICAgICAgICAgICBtYXRyaWNlcy5zZXQodGhpcy5fY2FtZXJhLnByb2plY3Rpb24uZWxlbWVudHMsIDQ4KTtcbiAgICAgICAgICAgICAgICBjb25zdCB1SW5kZXggPSBnbC5nZXRVbmlmb3JtQmxvY2tJbmRleChtZXNoLnByb2dyYW0sICdNYXRyaWNlcycpO1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1CbG9ja0JpbmRpbmcobWVzaC5wcm9ncmFtLCB1SW5kZXgsIDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IFVCTyA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuVU5JRk9STV9CVUZGRVIsIFVCTyk7XG4gICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5VTklGT1JNX0JVRkZFUiwgbWF0cmljZXMsIGdsLkRZTkFNSUNfRFJBVyk7XG4gICAgICAgICAgICAgICAgbWVzaC5nZW9tZXRyeS5VQk8gPSBVQk87XG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5VTklGT1JNX0JVRkZFUiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc2guaXNWaXNpYmxlKHBsYW5lcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc2gubWF0ZXJpYWwuYWxwaGFNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnRyYW5zcGFyZW50Q2hpbGRyZW4ucHVzaChtZXNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUub3BhcXVlQ2hpbGRyZW4ucHVzaChtZXNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2NlbmUudHJhbnNwYXJlbnRDaGlsZHJlbi5zb3J0KChhLCBiKSA9PiBiLmRpc3RhbmNlIC0gYS5kaXN0YW5jZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBidWlsZEFuaW1hdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmpzb24uYW5pbWF0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBhbmltYXRpb24gb2YgdGhpcy5qc29uLmFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hhbm5lbCBvZiBhbmltYXRpb24uY2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzYW1wbGVyID0gYW5pbWF0aW9uLnNhbXBsZXJzW2NoYW5uZWwuc2FtcGxlcl07XG4gICAgICAgICAgICAgICAgaWYgKHNhbXBsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0YXJnZXQgfSA9IGNoYW5uZWw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0YXJnZXQubm9kZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBhbmltYXRpb24ucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkID8gYW5pbWF0aW9uLnBhcmFtZXRlcnNbc2FtcGxlci5pbnB1dF0gOiBzYW1wbGVyLmlucHV0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBhbmltYXRpb24ucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkID8gYW5pbWF0aW9uLnBhcmFtZXRlcnNbc2FtcGxlci5vdXRwdXRdIDogc2FtcGxlci5vdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0QWNjZXNzb3IgPSB0aGlzLmpzb24uYWNjZXNzb3JzW2lucHV0XTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0QWNjZXNzb3IgPSB0aGlzLmpzb24uYWNjZXNzb3JzW291dHB1dF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0QnVmZmVyID0gdGhpcy5qc29uLmJ1ZmZlclZpZXdzW2lucHV0QWNjZXNzb3IuYnVmZmVyVmlld107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dEJ1ZmZlciA9IHRoaXMuanNvbi5idWZmZXJWaWV3c1tvdXRwdXRBY2Nlc3Nvci5idWZmZXJWaWV3XTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRBcnJheSA9IGJ1aWxkQXJyYXkodGhpcy5hcnJheUJ1ZmZlcltpbnB1dEJ1ZmZlci5idWZmZXJdLCBpbnB1dEFjY2Vzc29yLmNvbXBvbmVudFR5cGUsIGNhbGN1bGF0ZU9mZnNldChpbnB1dEJ1ZmZlci5ieXRlT2Zmc2V0LCBpbnB1dEFjY2Vzc29yLmJ5dGVPZmZzZXQpLCBnZXREYXRhVHlwZShpbnB1dEFjY2Vzc29yLnR5cGUpICogaW5wdXRBY2Nlc3Nvci5jb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dEFycmF5ID0gYnVpbGRBcnJheSh0aGlzLmFycmF5QnVmZmVyW291dHB1dEJ1ZmZlci5idWZmZXJdLCBvdXRwdXRBY2Nlc3Nvci5jb21wb25lbnRUeXBlLCBjYWxjdWxhdGVPZmZzZXQob3V0cHV0QnVmZmVyLmJ5dGVPZmZzZXQsIG91dHB1dEFjY2Vzc29yLmJ5dGVPZmZzZXQpLCBnZXREYXRhVHlwZShvdXRwdXRBY2Nlc3Nvci50eXBlKSAqIG91dHB1dEFjY2Vzc29yLmNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gZ2V0QW5pbWF0aW9uQ29tcG9uZW50KHRhcmdldC5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0VCA9IGlucHV0QXJyYXlbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFYgPSBvdXRwdXRBcnJheS5zbGljZShpICogY29tcG9uZW50LCAoaSArIDEpICogY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogZmlyc3RULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmaXJzdFZcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc2hlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB3YWxrKHRoaXMuc2NlbmUsIG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQucGF0aCA9PT0gJ3dlaWdodHMnICYmIG5vZGUgaW5zdGFuY2VvZiBPYmplY3QzRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc2hlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2tzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzaGVzOiBtZXNoZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdGFyZ2V0LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogYCR7bWVzaGVzWzBdLm5hbWV9LiR7dGFyZ2V0LnBhdGh9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBrZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRpb246IHNhbXBsZXIuaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGJ1aWxkU2tpbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmpzb24uc2tpbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgc2tpbiBvZiB0aGlzLmpzb24uc2tpbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjYyA9IHRoaXMuanNvbi5hY2Nlc3NvcnNbc2tpbi5pbnZlcnNlQmluZE1hdHJpY2VzXTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuanNvbi5idWZmZXJWaWV3c1thY2MuYnVmZmVyVmlld107XG4gICAgICAgICAgICBjb25zdCBhcnJheSA9IGJ1aWxkQXJyYXkodGhpcy5hcnJheUJ1ZmZlcltidWZmZXIuYnVmZmVyXSwgYWNjLmNvbXBvbmVudFR5cGUsIGNhbGN1bGF0ZU9mZnNldChidWZmZXIuYnl0ZU9mZnNldCwgYWNjLmJ5dGVPZmZzZXQpLCBnZXREYXRhVHlwZShhY2MudHlwZSkgKiBhY2MuY291bnQpO1xuICAgICAgICAgICAgY29uc3QgdiA9IHtcbiAgICAgICAgICAgICAgICBqb2ludE5hbWVzOiBza2luLmpvaW50cyxcbiAgICAgICAgICAgICAgICBpbnZlcnNlQmluZE1hdHJpY2VzOiBhcnJheSxcbiAgICAgICAgICAgICAgICBib25lczogW10sXG4gICAgICAgICAgICAgICAgYm9uZUludmVyc2VzOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgam9pbiBvZiB2LmpvaW50TmFtZXMpIHtcbiAgICAgICAgICAgICAgICAvL3dhbGsodGhpcy5zY2VuZSwgdGhpcy5idWlsZEJvbmVzLmJpbmQodGhpcywgam9pbiwgdikpO1xuICAgICAgICAgICAgICAgIHRoaXMuanNvbi5ub2Rlc1tqb2luXS5pc0JvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSB2LmludmVyc2VCaW5kTWF0cmljZXM7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0ID0gbmV3IE1hdHJpeDQoKS5zZXQobS5zbGljZShpICogMTYsIChpICsgMSkgKiAxNikpO1xuICAgICAgICAgICAgICAgIHYuYm9uZUludmVyc2VzLnB1c2gobWF0KTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNraW5zLnB1c2godik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGJ1aWxkQm9uZXMoam9pbiwgdiwgbm9kZSkge1xuICAgICAgICBpZiAobm9kZS5uYW1lID09PSBqb2luKSB7XG4gICAgICAgICAgICB2LmJvbmVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0SnNvbigpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoKHRoaXMudXJsKVxuICAgICAgICAgICAgLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpXG4gICAgICAgICAgICAudGhlbihqID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGouYnVmZmVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuYmluLnB1c2goai5idWZmZXJzW2tleV0udXJpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuanNvbiA9IGo7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluaXRUZXh0dXJlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmpzb24udGV4dHVyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNhbXBsZXJzID0gdGhpcy5qc29uLnNhbXBsZXJzIHx8IFt7fV07XG4gICAgICAgIHRoaXMuc2FtcGxlcnMgPSBzYW1wbGVycy5tYXAocyA9PiB7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVyID0gZ2wuY3JlYXRlU2FtcGxlcigpO1xuICAgICAgICAgICAgZ2wuc2FtcGxlclBhcmFtZXRlcmkoc2FtcGxlciwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBzLm1pbkZpbHRlciB8fCA5OTg2KTtcbiAgICAgICAgICAgIGdsLnNhbXBsZXJQYXJhbWV0ZXJpKHNhbXBsZXIsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgcy5tYWdGaWx0ZXIgfHwgOTcyOSk7XG4gICAgICAgICAgICBnbC5zYW1wbGVyUGFyYW1ldGVyaShzYW1wbGVyLCBnbC5URVhUVVJFX1dSQVBfUywgcy53cmFwUyB8fCAxMDQ5Nyk7XG4gICAgICAgICAgICBnbC5zYW1wbGVyUGFyYW1ldGVyaShzYW1wbGVyLCBnbC5URVhUVVJFX1dSQVBfVCwgcy53cmFwVCB8fCAxMDQ5Nyk7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlcjtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByb21pc2VBcnIgPSB0aGlzLmpzb24udGV4dHVyZXMubWFwKHQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzYW1wbGVyID0gdGhpcy5zYW1wbGVyc1t0LnNhbXBsZXIgIT09IHVuZGVmaW5lZCA/IHQuc2FtcGxlciA6IDBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuanNvbi5pbWFnZXNbdC5zb3VyY2VdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuaGFuZGxlVGV4dHVyZUxvYWRlZChzYW1wbGVyLCBpbWFnZSkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW1hZ2Uub25lcnJvciA9IGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcbiAgICAgICAgICAgICAgICBpbWFnZS5zcmMgPSBgJHt0aGlzLmhvc3R9JHtzb3VyY2UudXJpfWA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlQXJyKVxuICAgICAgICAgICAgLnRoZW4odGV4dHVyZXMgPT4ge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlcyA9IHRleHR1cmVzO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVUZXh0dXJlTG9hZGVkKHNhbXBsZXIsIGltYWdlKSB7XG4gICAgICAgIGNvbnN0IHQgPSB7XG4gICAgICAgICAgICBpbWFnZTogaW1hZ2Uuc3JjLnN1YnN0cihpbWFnZS5zcmMubGFzdEluZGV4T2YoJy8nKSksXG4gICAgICAgICAgICBkYXRhOiBnbC5jcmVhdGVUZXh0dXJlKCksXG4gICAgICAgICAgICBjb3VudDogc2NlbmVUZXh0dXJlQ291bnRcbiAgICAgICAgfTtcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbFtgVEVYVFVSRSR7c2NlbmVUZXh0dXJlQ291bnR9YF0pO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0LmRhdGEpO1xuICAgICAgICBnbC5iaW5kU2FtcGxlcihzY2VuZVRleHR1cmVDb3VudCwgc2FtcGxlcik7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xuICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcbiAgICAgICAgc2NlbmVUZXh0dXJlQ291bnQrKztcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/parse.ts\n");

/***/ }),

/***/ "./src/redcube.ts":
/*!************************!*\
  !*** ./src/redcube.ts ***!
  \************************/
/*! exports provided: RedCube */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RedCube\", function() { return RedCube; });\n/* harmony import */ var _objects__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objects */ \"./src/objects.ts\");\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrix */ \"./src/matrix.ts\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events */ \"./src/events.ts\");\n/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./env */ \"./src/env.ts\");\n/* harmony import */ var _fps__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fps */ \"./src/fps.ts\");\n/* harmony import */ var _parse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parse */ \"./src/parse.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n/// <reference path='../index.d.ts'/>\n\n\n\n\n\n\n\nlet gl;\nclass RedCube {\n    constructor(url, canvas, znear) {\n        this.reflow = true;\n        this.scene = new _objects__WEBPACK_IMPORTED_MODULE_0__[\"Scene\"];\n        this.canvas = canvas;\n        this.camera = new _objects__WEBPACK_IMPORTED_MODULE_0__[\"Camera\"];\n        this.camera.setProps({\n            type: 'perspective',\n            isInitial: true,\n            zoom: 1,\n            aspect: this.canvas.offsetWidth / this.canvas.offsetHeight,\n            perspective: {\n                yfov: 0.6,\n                znear: 1,\n                zfar: 2e6\n            }\n        });\n        this.events = new _events__WEBPACK_IMPORTED_MODULE_2__[\"Events\"](this.redraw.bind(this));\n        this.fps = new _fps__WEBPACK_IMPORTED_MODULE_4__[\"FPS\"];\n        this.env = new _env__WEBPACK_IMPORTED_MODULE_3__[\"Env\"];\n        this.env.setCamera(this.camera);\n        // this.PP = new PostProcessing;\n        // this.PP.setCanvas(this.canvas);\n        // this.PP.setCamera(this.camera);\n        this.parse = new _parse__WEBPACK_IMPORTED_MODULE_5__[\"Parse\"](url);\n        this.parse.setScene(this.scene);\n        this.parse.setCamera(this.camera);\n        this.parse.setUpdateCamera(this.updateCamera.bind(this));\n        this.parse.setCanvas(this.canvas);\n        this.parse.setResize(this.resize.bind(this));\n    }\n    init() {\n        return this.parse.getJson()\n            .then(this.glInit.bind(this))\n            .then(this.parse.initTextures.bind(this.parse))\n            .then(this.parse.getBuffer.bind(this.parse))\n            .then(this.parse.buildSkin.bind(this.parse))\n            .then(this.parse.buildMesh.bind(this.parse))\n            .then(this.parse.buildAnimation.bind(this.parse))\n            .then(this.env.createEnvironmentBuffer.bind(this.env))\n            .then(this.draw.bind(this))\n            .catch(console.error);\n    }\n    updateCamera(camera) {\n        this.camera = camera;\n        this.env.setCamera(this.camera);\n    }\n    redraw(type, coordsStart, coordsMove) {\n        if (type === 'zoom') {\n            this.camera.props.zoom = coordsStart;\n            this.camera.setProjection(Object(_utils__WEBPACK_IMPORTED_MODULE_6__[\"calculateProjection\"])(this.camera.props));\n            this.needUpdateProjection = true;\n        }\n        if (type === 'rotate') {\n            const coordsStartWorld = Object(_utils__WEBPACK_IMPORTED_MODULE_6__[\"canvasToWorld\"])(coordsStart, this.camera.projection, this.canvas.offsetWidth, this.canvas.offsetHeight);\n            const coordsMoveWorld = Object(_utils__WEBPACK_IMPORTED_MODULE_6__[\"canvasToWorld\"])(coordsMove, this.camera.projection, this.canvas.offsetWidth, this.canvas.offsetHeight);\n            const p0 = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](Object(_utils__WEBPACK_IMPORTED_MODULE_6__[\"sceneToArcBall\"])(coordsStartWorld));\n            const p1 = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](Object(_utils__WEBPACK_IMPORTED_MODULE_6__[\"sceneToArcBall\"])(coordsMoveWorld));\n            const angle = _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"].angle(p1, p0) * 5;\n            if (angle < 1e-6 || isNaN(angle)) {\n                return;\n            }\n            p0.applyMatrix4(this.camera.matrixWorld);\n            p1.applyMatrix4(this.camera.matrixWorld);\n            const v = _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"].cross(p1, p0).normalize();\n            const m = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Matrix4\"];\n            m.makeRotationAxis(v, angle);\n            m.multiply(this.camera.matrixWorld);\n            this.camera.setMatrixWorld(m.elements);\n            this.needUpdateView = true;\n        }\n        if (type === 'pan') {\n            const coordsStartWorld = Object(_utils__WEBPACK_IMPORTED_MODULE_6__[\"canvasToWorld\"])(coordsStart, this.camera.projection, this.canvas.offsetWidth, this.canvas.offsetHeight);\n            const coordsMoveWorld = Object(_utils__WEBPACK_IMPORTED_MODULE_6__[\"canvasToWorld\"])(coordsMove, this.camera.projection, this.canvas.offsetWidth, this.canvas.offsetHeight);\n            const p0 = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]([...coordsStartWorld, 0]);\n            const p1 = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"]([...coordsMoveWorld, 0]);\n            const pan = this.camera.modelSize * 100;\n            const delta = p1.subtract(p0).scale(pan);\n            this.camera.matrixWorld.translate(delta.elements[0], delta.elements[1], 0);\n            this.camera.setMatrixWorld(this.camera.matrixWorld.elements);\n            this.needUpdateView = true;\n        }\n        if (type === 'resize') {\n            this.resize();\n            this.needUpdateProjection = true;\n        }\n        this.reflow = true;\n    }\n    resize() {\n        this.camera.props.aspect = this.canvas.offsetWidth / this.canvas.offsetHeight;\n        this.canvas.width = this.canvas.offsetWidth * devicePixelRatio;\n        this.canvas.height = this.canvas.offsetHeight * devicePixelRatio;\n        gl.viewport(0, 0, this.canvas.offsetWidth * devicePixelRatio, this.canvas.offsetHeight * devicePixelRatio);\n        this.camera.setProjection(Object(_utils__WEBPACK_IMPORTED_MODULE_6__[\"calculateProjection\"])(this.camera.props));\n        if (this.camera.props.isInitial) {\n            const z = 1 / this.canvas.width * this.camera.modelSize * 5000;\n            this.camera.setZ(z);\n            if (this.camera.modelSize < 1) {\n                this.camera.props.perspective.znear = 0.01;\n                this.camera.setProjection(Object(_utils__WEBPACK_IMPORTED_MODULE_6__[\"calculateProjection\"])(this.camera.props));\n            }\n            this.needUpdateView = true;\n        }\n    }\n    glInit() {\n        gl = this.canvas.getContext('webgl2');\n        if (!gl) {\n            throw new Error('Webgl 2 doesnt support');\n        }\n        Object(_utils__WEBPACK_IMPORTED_MODULE_6__[\"setGl\"])(gl);\n        this.env.setGl(gl);\n        //this.PP.setGl(gl);\n        this.parse.setGl(gl);\n        return true;\n    }\n    animate(sec) {\n        for (const v of this.parse.tracks) {\n            const val = Object(_utils__WEBPACK_IMPORTED_MODULE_6__[\"interpolation\"])(sec, v.keys);\n            if (val[0] === -1 || val[1] === -1 || v.stoped) {\n                continue;\n            }\n            if (val[0] === v.keys.length - 1) {\n                v.stoped = true;\n            }\n            const startFrame = v.keys[val[0]];\n            const endFrame = v.keys[val[1]];\n            // eslint-disable-next-line\n            const t = val[2];\n            const component = Object(_utils__WEBPACK_IMPORTED_MODULE_6__[\"getAnimationComponent\"])(v.type);\n            let vectorC;\n            if (component === 3) {\n                vectorC = _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"];\n            }\n            else if (component === 4) {\n                vectorC = _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Vector4\"];\n            }\n            else if (component === 2) {\n                vectorC = _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Vector2\"];\n            }\n            const vector = new vectorC(startFrame.value);\n            const vector2 = new vectorC(endFrame.value);\n            if (v.type === 'rotation') {\n                const out = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Vector4\"];\n                out.lerp(vector.elements, vector2.elements, t);\n                for (const mesh of v.meshes) {\n                    mesh.matrix.makeRotationFromQuaternion(out.elements);\n                }\n            }\n            else if (v.type === 'scale') {\n                const out = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"];\n                out.lerp(vector.elements, vector2.elements, t);\n                for (const mesh of v.meshes) {\n                    mesh.matrix.scale(out);\n                }\n            }\n            else if (v.type === 'weights') {\n                const out = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Vector2\"];\n                out.lerp(vector.elements, vector2.elements, t);\n                for (const mesh of v.meshes) {\n                    const geometry = {};\n                    for (const k in mesh.geometry.targets[0]) {\n                        let offset = 0;\n                        geometry[k] = new Float32Array(mesh.geometry.attributes[k].length);\n                        for (let i = 0; i < geometry[k].length; i++) {\n                            if (k === 'TANGENT' && (i + 1) % 4 === 0) {\n                                offset++;\n                                continue;\n                            }\n                            geometry[k][i] = mesh.geometry.attributes[k][i] + out.elements[0] * mesh.geometry.targets[0][k][i - offset] + out.elements[1] * mesh.geometry.targets[1][k][i - offset];\n                        }\n                    }\n                    gl.bindVertexArray(mesh.geometry.VAO);\n                    for (const k in geometry) {\n                        const VBO = gl.createBuffer();\n                        gl.bindBuffer(gl.ARRAY_BUFFER, VBO);\n                        gl.bufferData(gl.ARRAY_BUFFER, geometry[k], gl.STATIC_DRAW);\n                        const index = Object(_utils__WEBPACK_IMPORTED_MODULE_6__[\"getAttributeIndex\"])(k);\n                        gl.enableVertexAttribArray(index[0]);\n                        gl.vertexAttribPointer(index[0], index[1], index[2], false, 0, 0);\n                    }\n                    gl.bindVertexArray(null);\n                }\n            }\n            else if (v.type === 'translation') {\n                const out = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"];\n                out.lerp(vector.elements, vector2.elements, t);\n                for (const mesh of v.meshes) {\n                    mesh.matrix.setTranslate(out);\n                }\n            }\n            else {\n                console.error('ERROR');\n            }\n            for (const mesh of v.meshes) {\n                Object(_utils__WEBPACK_IMPORTED_MODULE_6__[\"walk\"])(mesh, node => {\n                    node.updateMatrix();\n                    if (node instanceof _objects__WEBPACK_IMPORTED_MODULE_0__[\"Bone\"]) {\n                        node.reflow = true;\n                    }\n                    if (node instanceof _objects__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"]) {\n                        node.reflow = true;\n                    }\n                    if (node instanceof _objects__WEBPACK_IMPORTED_MODULE_0__[\"Camera\"] && node === this.camera) {\n                        this.needUpdateView = true;\n                    }\n                });\n            }\n            this.reflow = true;\n        }\n    }\n    draw() {\n        gl.clearColor(0.8, 0.8, 0.8, 1.0);\n        this.render();\n    }\n    render(time = 0) {\n        const sec = time / 1000;\n        this.animate(sec);\n        if (this.reflow) {\n            //this.PP.bindBuffer();\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n            this.env.createEnvironment();\n            gl.enable(gl.DEPTH_TEST);\n            gl.enable(gl.CULL_FACE);\n            this.scene.opaqueChildren.forEach(mesh => this._draw(mesh));\n            if (this.scene.transparentChildren.length) {\n                gl.enable(gl.BLEND);\n                gl.depthMask(false);\n                gl.blendFuncSeparate(gl.SRC_COLOR, gl.DST_COLOR, gl.ONE, gl.ZERO);\n                // gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n                this.scene.transparentChildren.forEach(mesh => this._draw(mesh));\n                gl.disable(gl.BLEND);\n                gl.depthMask(true);\n                gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);\n            }\n            Object(_utils__WEBPACK_IMPORTED_MODULE_6__[\"walk\"])(this.scene, node => {\n                if (node instanceof _objects__WEBPACK_IMPORTED_MODULE_0__[\"Bone\"]) {\n                    node.reflow = false;\n                }\n            });\n            this.needUpdateView = false;\n            this.needUpdateProjection = false;\n            //this.PP.postProcessing();\n        }\n        this.fps.tick(time);\n        this.reflow = false;\n        requestAnimationFrame(this.render.bind(this));\n    }\n    _draw(mesh) {\n        gl.useProgram(mesh.program);\n        gl.bindVertexArray(mesh.geometry.VAO);\n        gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, mesh.geometry.UBO);\n        if (mesh.reflow) {\n            const normalMatrix = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Matrix4\"](mesh.matrixWorld);\n            normalMatrix.invert().transpose();\n            const matrices = new Float32Array(32);\n            matrices.set(mesh.matrixWorld.elements);\n            matrices.set(normalMatrix.elements, 16);\n            gl.bufferSubData(gl.UNIFORM_BUFFER, 0, matrices);\n            mesh.reflow = false;\n        }\n        if (this.needUpdateView) {\n            gl.bufferSubData(gl.UNIFORM_BUFFER, 32 * Float32Array.BYTES_PER_ELEMENT, this.camera.matrixWorldInvert.elements);\n        }\n        if (this.needUpdateProjection) {\n            gl.bufferSubData(gl.UNIFORM_BUFFER, 48 * Float32Array.BYTES_PER_ELEMENT, this.camera.projection.elements);\n        }\n        if (mesh instanceof _objects__WEBPACK_IMPORTED_MODULE_0__[\"SkinnedMesh\"]) {\n            gl.bindBufferBase(gl.UNIFORM_BUFFER, 2, mesh.geometry.SKIN);\n            if (mesh.bones.some(bone => bone.reflow)) {\n                const jointMatrix = mesh.getJointMatrix();\n                const matrices = new Float32Array(jointMatrix.length * 16);\n                let i = 0;\n                for (const j of jointMatrix) {\n                    matrices.set(j.elements, 0 + 16 * i);\n                    i++;\n                }\n                gl.bufferSubData(gl.UNIFORM_BUFFER, 0, matrices);\n            }\n        }\n        if (mesh.material.UBO) {\n            gl.bindBufferBase(gl.UNIFORM_BUFFER, 1, mesh.material.UBO);\n            if (this.needUpdateView) {\n                gl.bufferSubData(gl.UNIFORM_BUFFER, 4 * Float32Array.BYTES_PER_ELEMENT, new Float32Array([this.camera.matrixWorld.elements[12], this.camera.matrixWorld.elements[13], this.camera.matrixWorld.elements[14]]));\n                gl.bufferSubData(gl.UNIFORM_BUFFER, 8 * Float32Array.BYTES_PER_ELEMENT, new Float32Array([this.camera.matrixWorld.elements[12], this.camera.matrixWorld.elements[13], this.camera.matrixWorld.elements[14]]));\n            }\n        }\n        if (mesh.material.pbrMetallicRoughness.baseColorTexture) {\n            gl.uniform1i(mesh.material.uniforms.baseColorTexture, mesh.material.pbrMetallicRoughness.baseColorTexture.count);\n        }\n        if (mesh.material.pbrMetallicRoughness.metallicRoughnessTexture) {\n            gl.uniform1i(mesh.material.uniforms.metallicRoughnessTexture, mesh.material.pbrMetallicRoughness.metallicRoughnessTexture.count);\n        }\n        if (mesh.material.normalTexture) {\n            gl.uniform1i(mesh.material.uniforms.normalTexture, mesh.material.normalTexture.count);\n        }\n        if (mesh.material.occlusionTexture) {\n            gl.uniform1i(mesh.material.uniforms.occlusionTexture, mesh.material.occlusionTexture.count);\n        }\n        if (mesh.material.emissiveTexture) {\n            gl.uniform1i(mesh.material.uniforms.emissiveTexture, mesh.material.emissiveTexture.count);\n        }\n        if (mesh.material.doubleSided) {\n            gl.disable(gl.CULL_FACE);\n        }\n        if (mesh.geometry.indicesBuffer) {\n            gl.drawElements(mesh.mode || gl.TRIANGLES, mesh.geometry.indicesBuffer.length, mesh.geometry.indicesBuffer.BYTES_PER_ELEMENT === 4 ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT, 0);\n        }\n        else {\n            gl.drawArrays(mesh.mode || gl.TRIANGLES, 0, mesh.geometry.attributes.POSITION.length / 3);\n        }\n        if (mesh.material.doubleSided) {\n            gl.enable(gl.CULL_FACE);\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcmVkY3ViZS50cy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGN1YmUvLi9zcmMvcmVkY3ViZS50cz83MDIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uL2luZGV4LmQudHMnLz5cbmltcG9ydCB7IFNjZW5lLCBNZXNoLCBTa2lubmVkTWVzaCwgQ2FtZXJhLCBCb25lIH0gZnJvbSAnLi9vYmplY3RzJztcbmltcG9ydCB7IE1hdHJpeDQsIFZlY3RvcjIsIFZlY3RvcjMsIFZlY3RvcjQgfSBmcm9tICcuL21hdHJpeCc7XG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuL2V2ZW50cyc7XG5pbXBvcnQgeyBFbnYgfSBmcm9tICcuL2Vudic7XG5pbXBvcnQgeyBGUFMgfSBmcm9tICcuL2Zwcyc7XG5pbXBvcnQgeyBQYXJzZSB9IGZyb20gJy4vcGFyc2UnO1xuaW1wb3J0IHsgc2V0R2wsIGdldEFuaW1hdGlvbkNvbXBvbmVudCwgaW50ZXJwb2xhdGlvbiwgd2Fsaywgc2NlbmVUb0FyY0JhbGwsIGNhbnZhc1RvV29ybGQsIGNhbGN1bGF0ZVByb2plY3Rpb24sIGdldEF0dHJpYnV0ZUluZGV4IH0gZnJvbSAnLi91dGlscyc7XG5sZXQgZ2w7XG5jbGFzcyBSZWRDdWJlIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIGNhbnZhcywgem5lYXIpIHtcbiAgICAgICAgdGhpcy5yZWZsb3cgPSB0cnVlO1xuICAgICAgICB0aGlzLnNjZW5lID0gbmV3IFNjZW5lO1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBuZXcgQ2FtZXJhO1xuICAgICAgICB0aGlzLmNhbWVyYS5zZXRQcm9wcyh7XG4gICAgICAgICAgICB0eXBlOiAncGVyc3BlY3RpdmUnLFxuICAgICAgICAgICAgaXNJbml0aWFsOiB0cnVlLFxuICAgICAgICAgICAgem9vbTogMSxcbiAgICAgICAgICAgIGFzcGVjdDogdGhpcy5jYW52YXMub2Zmc2V0V2lkdGggLyB0aGlzLmNhbnZhcy5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICBwZXJzcGVjdGl2ZToge1xuICAgICAgICAgICAgICAgIHlmb3Y6IDAuNixcbiAgICAgICAgICAgICAgICB6bmVhcjogMSxcbiAgICAgICAgICAgICAgICB6ZmFyOiAyZTZcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50cyh0aGlzLnJlZHJhdy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5mcHMgPSBuZXcgRlBTO1xuICAgICAgICB0aGlzLmVudiA9IG5ldyBFbnY7XG4gICAgICAgIHRoaXMuZW52LnNldENhbWVyYSh0aGlzLmNhbWVyYSk7XG4gICAgICAgIC8vIHRoaXMuUFAgPSBuZXcgUG9zdFByb2Nlc3Npbmc7XG4gICAgICAgIC8vIHRoaXMuUFAuc2V0Q2FudmFzKHRoaXMuY2FudmFzKTtcbiAgICAgICAgLy8gdGhpcy5QUC5zZXRDYW1lcmEodGhpcy5jYW1lcmEpO1xuICAgICAgICB0aGlzLnBhcnNlID0gbmV3IFBhcnNlKHVybCk7XG4gICAgICAgIHRoaXMucGFyc2Uuc2V0U2NlbmUodGhpcy5zY2VuZSk7XG4gICAgICAgIHRoaXMucGFyc2Uuc2V0Q2FtZXJhKHRoaXMuY2FtZXJhKTtcbiAgICAgICAgdGhpcy5wYXJzZS5zZXRVcGRhdGVDYW1lcmEodGhpcy51cGRhdGVDYW1lcmEuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMucGFyc2Uuc2V0Q2FudmFzKHRoaXMuY2FudmFzKTtcbiAgICAgICAgdGhpcy5wYXJzZS5zZXRSZXNpemUodGhpcy5yZXNpemUuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlLmdldEpzb24oKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5nbEluaXQuYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC50aGVuKHRoaXMucGFyc2UuaW5pdFRleHR1cmVzLmJpbmQodGhpcy5wYXJzZSkpXG4gICAgICAgICAgICAudGhlbih0aGlzLnBhcnNlLmdldEJ1ZmZlci5iaW5kKHRoaXMucGFyc2UpKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5wYXJzZS5idWlsZFNraW4uYmluZCh0aGlzLnBhcnNlKSlcbiAgICAgICAgICAgIC50aGVuKHRoaXMucGFyc2UuYnVpbGRNZXNoLmJpbmQodGhpcy5wYXJzZSkpXG4gICAgICAgICAgICAudGhlbih0aGlzLnBhcnNlLmJ1aWxkQW5pbWF0aW9uLmJpbmQodGhpcy5wYXJzZSkpXG4gICAgICAgICAgICAudGhlbih0aGlzLmVudi5jcmVhdGVFbnZpcm9ubWVudEJ1ZmZlci5iaW5kKHRoaXMuZW52KSlcbiAgICAgICAgICAgIC50aGVuKHRoaXMuZHJhdy5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgIH1cbiAgICB1cGRhdGVDYW1lcmEoY2FtZXJhKSB7XG4gICAgICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgICAgICB0aGlzLmVudi5zZXRDYW1lcmEodGhpcy5jYW1lcmEpO1xuICAgIH1cbiAgICByZWRyYXcodHlwZSwgY29vcmRzU3RhcnQsIGNvb3Jkc01vdmUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICd6b29tJykge1xuICAgICAgICAgICAgdGhpcy5jYW1lcmEucHJvcHMuem9vbSA9IGNvb3Jkc1N0YXJ0O1xuICAgICAgICAgICAgdGhpcy5jYW1lcmEuc2V0UHJvamVjdGlvbihjYWxjdWxhdGVQcm9qZWN0aW9uKHRoaXMuY2FtZXJhLnByb3BzKSk7XG4gICAgICAgICAgICB0aGlzLm5lZWRVcGRhdGVQcm9qZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3JvdGF0ZScpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvb3Jkc1N0YXJ0V29ybGQgPSBjYW52YXNUb1dvcmxkKGNvb3Jkc1N0YXJ0LCB0aGlzLmNhbWVyYS5wcm9qZWN0aW9uLCB0aGlzLmNhbnZhcy5vZmZzZXRXaWR0aCwgdGhpcy5jYW52YXMub2Zmc2V0SGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IGNvb3Jkc01vdmVXb3JsZCA9IGNhbnZhc1RvV29ybGQoY29vcmRzTW92ZSwgdGhpcy5jYW1lcmEucHJvamVjdGlvbiwgdGhpcy5jYW52YXMub2Zmc2V0V2lkdGgsIHRoaXMuY2FudmFzLm9mZnNldEhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCBwMCA9IG5ldyBWZWN0b3IzKHNjZW5lVG9BcmNCYWxsKGNvb3Jkc1N0YXJ0V29ybGQpKTtcbiAgICAgICAgICAgIGNvbnN0IHAxID0gbmV3IFZlY3RvcjMoc2NlbmVUb0FyY0JhbGwoY29vcmRzTW92ZVdvcmxkKSk7XG4gICAgICAgICAgICBjb25zdCBhbmdsZSA9IFZlY3RvcjMuYW5nbGUocDEsIHAwKSAqIDU7XG4gICAgICAgICAgICBpZiAoYW5nbGUgPCAxZS02IHx8IGlzTmFOKGFuZ2xlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAwLmFwcGx5TWF0cml4NCh0aGlzLmNhbWVyYS5tYXRyaXhXb3JsZCk7XG4gICAgICAgICAgICBwMS5hcHBseU1hdHJpeDQodGhpcy5jYW1lcmEubWF0cml4V29ybGQpO1xuICAgICAgICAgICAgY29uc3QgdiA9IFZlY3RvcjMuY3Jvc3MocDEsIHAwKS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgTWF0cml4NDtcbiAgICAgICAgICAgIG0ubWFrZVJvdGF0aW9uQXhpcyh2LCBhbmdsZSk7XG4gICAgICAgICAgICBtLm11bHRpcGx5KHRoaXMuY2FtZXJhLm1hdHJpeFdvcmxkKTtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLnNldE1hdHJpeFdvcmxkKG0uZWxlbWVudHMpO1xuICAgICAgICAgICAgdGhpcy5uZWVkVXBkYXRlVmlldyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdwYW4nKSB7XG4gICAgICAgICAgICBjb25zdCBjb29yZHNTdGFydFdvcmxkID0gY2FudmFzVG9Xb3JsZChjb29yZHNTdGFydCwgdGhpcy5jYW1lcmEucHJvamVjdGlvbiwgdGhpcy5jYW52YXMub2Zmc2V0V2lkdGgsIHRoaXMuY2FudmFzLm9mZnNldEhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCBjb29yZHNNb3ZlV29ybGQgPSBjYW52YXNUb1dvcmxkKGNvb3Jkc01vdmUsIHRoaXMuY2FtZXJhLnByb2plY3Rpb24sIHRoaXMuY2FudmFzLm9mZnNldFdpZHRoLCB0aGlzLmNhbnZhcy5vZmZzZXRIZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgcDAgPSBuZXcgVmVjdG9yMyhbLi4uY29vcmRzU3RhcnRXb3JsZCwgMF0pO1xuICAgICAgICAgICAgY29uc3QgcDEgPSBuZXcgVmVjdG9yMyhbLi4uY29vcmRzTW92ZVdvcmxkLCAwXSk7XG4gICAgICAgICAgICBjb25zdCBwYW4gPSB0aGlzLmNhbWVyYS5tb2RlbFNpemUgKiAxMDA7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IHAxLnN1YnRyYWN0KHAwKS5zY2FsZShwYW4pO1xuICAgICAgICAgICAgdGhpcy5jYW1lcmEubWF0cml4V29ybGQudHJhbnNsYXRlKGRlbHRhLmVsZW1lbnRzWzBdLCBkZWx0YS5lbGVtZW50c1sxXSwgMCk7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5zZXRNYXRyaXhXb3JsZCh0aGlzLmNhbWVyYS5tYXRyaXhXb3JsZC5lbGVtZW50cyk7XG4gICAgICAgICAgICB0aGlzLm5lZWRVcGRhdGVWaWV3ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgICAgICB0aGlzLm5lZWRVcGRhdGVQcm9qZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZmxvdyA9IHRydWU7XG4gICAgfVxuICAgIHJlc2l6ZSgpIHtcbiAgICAgICAgdGhpcy5jYW1lcmEucHJvcHMuYXNwZWN0ID0gdGhpcy5jYW52YXMub2Zmc2V0V2lkdGggLyB0aGlzLmNhbnZhcy5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXMub2Zmc2V0V2lkdGggKiBkZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy5vZmZzZXRIZWlnaHQgKiBkZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLmNhbnZhcy5vZmZzZXRXaWR0aCAqIGRldmljZVBpeGVsUmF0aW8sIHRoaXMuY2FudmFzLm9mZnNldEhlaWdodCAqIGRldmljZVBpeGVsUmF0aW8pO1xuICAgICAgICB0aGlzLmNhbWVyYS5zZXRQcm9qZWN0aW9uKGNhbGN1bGF0ZVByb2plY3Rpb24odGhpcy5jYW1lcmEucHJvcHMpKTtcbiAgICAgICAgaWYgKHRoaXMuY2FtZXJhLnByb3BzLmlzSW5pdGlhbCkge1xuICAgICAgICAgICAgY29uc3QgeiA9IDEgLyB0aGlzLmNhbnZhcy53aWR0aCAqIHRoaXMuY2FtZXJhLm1vZGVsU2l6ZSAqIDUwMDA7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5zZXRaKHopO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FtZXJhLm1vZGVsU2l6ZSA8IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbWVyYS5wcm9wcy5wZXJzcGVjdGl2ZS56bmVhciA9IDAuMDE7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmEuc2V0UHJvamVjdGlvbihjYWxjdWxhdGVQcm9qZWN0aW9uKHRoaXMuY2FtZXJhLnByb3BzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5lZWRVcGRhdGVWaWV3ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnbEluaXQoKSB7XG4gICAgICAgIGdsID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJyk7XG4gICAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViZ2wgMiBkb2VzbnQgc3VwcG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIHNldEdsKGdsKTtcbiAgICAgICAgdGhpcy5lbnYuc2V0R2woZ2wpO1xuICAgICAgICAvL3RoaXMuUFAuc2V0R2woZ2wpO1xuICAgICAgICB0aGlzLnBhcnNlLnNldEdsKGdsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFuaW1hdGUoc2VjKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiB0aGlzLnBhcnNlLnRyYWNrcykge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gaW50ZXJwb2xhdGlvbihzZWMsIHYua2V5cyk7XG4gICAgICAgICAgICBpZiAodmFsWzBdID09PSAtMSB8fCB2YWxbMV0gPT09IC0xIHx8IHYuc3RvcGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsWzBdID09PSB2LmtleXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHYuc3RvcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0RnJhbWUgPSB2LmtleXNbdmFsWzBdXTtcbiAgICAgICAgICAgIGNvbnN0IGVuZEZyYW1lID0gdi5rZXlzW3ZhbFsxXV07XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgIGNvbnN0IHQgPSB2YWxbMl07XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBnZXRBbmltYXRpb25Db21wb25lbnQodi50eXBlKTtcbiAgICAgICAgICAgIGxldCB2ZWN0b3JDO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHZlY3RvckMgPSBWZWN0b3IzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50ID09PSA0KSB7XG4gICAgICAgICAgICAgICAgdmVjdG9yQyA9IFZlY3RvcjQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb21wb25lbnQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICB2ZWN0b3JDID0gVmVjdG9yMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZlY3RvciA9IG5ldyB2ZWN0b3JDKHN0YXJ0RnJhbWUudmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgdmVjdG9yMiA9IG5ldyB2ZWN0b3JDKGVuZEZyYW1lLnZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2LnR5cGUgPT09ICdyb3RhdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXQgPSBuZXcgVmVjdG9yNDtcbiAgICAgICAgICAgICAgICBvdXQubGVycCh2ZWN0b3IuZWxlbWVudHMsIHZlY3RvcjIuZWxlbWVudHMsIHQpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWVzaCBvZiB2Lm1lc2hlcykge1xuICAgICAgICAgICAgICAgICAgICBtZXNoLm1hdHJpeC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihvdXQuZWxlbWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHYudHlwZSA9PT0gJ3NjYWxlJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dCA9IG5ldyBWZWN0b3IzO1xuICAgICAgICAgICAgICAgIG91dC5sZXJwKHZlY3Rvci5lbGVtZW50cywgdmVjdG9yMi5lbGVtZW50cywgdCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtZXNoIG9mIHYubWVzaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc2gubWF0cml4LnNjYWxlKG91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodi50eXBlID09PSAnd2VpZ2h0cycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXQgPSBuZXcgVmVjdG9yMjtcbiAgICAgICAgICAgICAgICBvdXQubGVycCh2ZWN0b3IuZWxlbWVudHMsIHZlY3RvcjIuZWxlbWVudHMsIHQpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWVzaCBvZiB2Lm1lc2hlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gbWVzaC5nZW9tZXRyeS50YXJnZXRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5W2tdID0gbmV3IEZsb2F0MzJBcnJheShtZXNoLmdlb21ldHJ5LmF0dHJpYnV0ZXNba10ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cnlba10ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoayA9PT0gJ1RBTkdFTlQnICYmIChpICsgMSkgJSA0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnlba11baV0gPSBtZXNoLmdlb21ldHJ5LmF0dHJpYnV0ZXNba11baV0gKyBvdXQuZWxlbWVudHNbMF0gKiBtZXNoLmdlb21ldHJ5LnRhcmdldHNbMF1ba11baSAtIG9mZnNldF0gKyBvdXQuZWxlbWVudHNbMV0gKiBtZXNoLmdlb21ldHJ5LnRhcmdldHNbMV1ba11baSAtIG9mZnNldF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ2wuYmluZFZlcnRleEFycmF5KG1lc2guZ2VvbWV0cnkuVkFPKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIGdlb21ldHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBWQk8gPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBWQk8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5W2tdLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEF0dHJpYnV0ZUluZGV4KGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXhbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihpbmRleFswXSwgaW5kZXhbMV0sIGluZGV4WzJdLCBmYWxzZSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ2wuYmluZFZlcnRleEFycmF5KG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHYudHlwZSA9PT0gJ3RyYW5zbGF0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dCA9IG5ldyBWZWN0b3IzO1xuICAgICAgICAgICAgICAgIG91dC5sZXJwKHZlY3Rvci5lbGVtZW50cywgdmVjdG9yMi5lbGVtZW50cywgdCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtZXNoIG9mIHYubWVzaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc2gubWF0cml4LnNldFRyYW5zbGF0ZShvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0VSUk9SJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1lc2ggb2Ygdi5tZXNoZXMpIHtcbiAgICAgICAgICAgICAgICB3YWxrKG1lc2gsIG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEJvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIENhbWVyYSAmJiBub2RlID09PSB0aGlzLmNhbWVyYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZWVkVXBkYXRlVmlldyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVmbG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmF3KCkge1xuICAgICAgICBnbC5jbGVhckNvbG9yKDAuOCwgMC44LCAwLjgsIDEuMCk7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIHJlbmRlcih0aW1lID0gMCkge1xuICAgICAgICBjb25zdCBzZWMgPSB0aW1lIC8gMTAwMDtcbiAgICAgICAgdGhpcy5hbmltYXRlKHNlYyk7XG4gICAgICAgIGlmICh0aGlzLnJlZmxvdykge1xuICAgICAgICAgICAgLy90aGlzLlBQLmJpbmRCdWZmZXIoKTtcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKTtcbiAgICAgICAgICAgIHRoaXMuZW52LmNyZWF0ZUVudmlyb25tZW50KCk7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUub3BhcXVlQ2hpbGRyZW4uZm9yRWFjaChtZXNoID0+IHRoaXMuX2RyYXcobWVzaCkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmUudHJhbnNwYXJlbnRDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgICAgIGdsLmRlcHRoTWFzayhmYWxzZSk7XG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuU1JDX0NPTE9SLCBnbC5EU1RfQ09MT1IsIGdsLk9ORSwgZ2wuWkVSTyk7XG4gICAgICAgICAgICAgICAgLy8gZ2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUudHJhbnNwYXJlbnRDaGlsZHJlbi5mb3JFYWNoKG1lc2ggPT4gdGhpcy5fZHJhdyhtZXNoKSk7XG4gICAgICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICAgICAgZ2wuZGVwdGhNYXNrKHRydWUpO1xuICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLk9ORSwgZ2wuWkVSTywgZ2wuT05FLCBnbC5aRVJPKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdhbGsodGhpcy5zY2VuZSwgbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBCb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVmbG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm5lZWRVcGRhdGVWaWV3ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm5lZWRVcGRhdGVQcm9qZWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAvL3RoaXMuUFAucG9zdFByb2Nlc3NpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZwcy50aWNrKHRpbWUpO1xuICAgICAgICB0aGlzLnJlZmxvdyA9IGZhbHNlO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXIuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIF9kcmF3KG1lc2gpIHtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShtZXNoLnByb2dyYW0pO1xuICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkobWVzaC5nZW9tZXRyeS5WQU8pO1xuICAgICAgICBnbC5iaW5kQnVmZmVyQmFzZShnbC5VTklGT1JNX0JVRkZFUiwgMCwgbWVzaC5nZW9tZXRyeS5VQk8pO1xuICAgICAgICBpZiAobWVzaC5yZWZsb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXg0KG1lc2gubWF0cml4V29ybGQpO1xuICAgICAgICAgICAgbm9ybWFsTWF0cml4LmludmVydCgpLnRyYW5zcG9zZSgpO1xuICAgICAgICAgICAgY29uc3QgbWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KDMyKTtcbiAgICAgICAgICAgIG1hdHJpY2VzLnNldChtZXNoLm1hdHJpeFdvcmxkLmVsZW1lbnRzKTtcbiAgICAgICAgICAgIG1hdHJpY2VzLnNldChub3JtYWxNYXRyaXguZWxlbWVudHMsIDE2KTtcbiAgICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuVU5JRk9STV9CVUZGRVIsIDAsIG1hdHJpY2VzKTtcbiAgICAgICAgICAgIG1lc2gucmVmbG93ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmVlZFVwZGF0ZVZpZXcpIHtcbiAgICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuVU5JRk9STV9CVUZGRVIsIDMyICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCB0aGlzLmNhbWVyYS5tYXRyaXhXb3JsZEludmVydC5lbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmVlZFVwZGF0ZVByb2plY3Rpb24pIHtcbiAgICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuVU5JRk9STV9CVUZGRVIsIDQ4ICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCB0aGlzLmNhbWVyYS5wcm9qZWN0aW9uLmVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzaCBpbnN0YW5jZW9mIFNraW5uZWRNZXNoKSB7XG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyQmFzZShnbC5VTklGT1JNX0JVRkZFUiwgMiwgbWVzaC5nZW9tZXRyeS5TS0lOKTtcbiAgICAgICAgICAgIGlmIChtZXNoLmJvbmVzLnNvbWUoYm9uZSA9PiBib25lLnJlZmxvdykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqb2ludE1hdHJpeCA9IG1lc2guZ2V0Sm9pbnRNYXRyaXgoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoam9pbnRNYXRyaXgubGVuZ3RoICogMTYpO1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGogb2Ygam9pbnRNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0cmljZXMuc2V0KGouZWxlbWVudHMsIDAgKyAxNiAqIGkpO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuVU5JRk9STV9CVUZGRVIsIDAsIG1hdHJpY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzaC5tYXRlcmlhbC5VQk8pIHtcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXJCYXNlKGdsLlVOSUZPUk1fQlVGRkVSLCAxLCBtZXNoLm1hdGVyaWFsLlVCTyk7XG4gICAgICAgICAgICBpZiAodGhpcy5uZWVkVXBkYXRlVmlldykge1xuICAgICAgICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuVU5JRk9STV9CVUZGRVIsIDQgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsIG5ldyBGbG9hdDMyQXJyYXkoW3RoaXMuY2FtZXJhLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzEyXSwgdGhpcy5jYW1lcmEubWF0cml4V29ybGQuZWxlbWVudHNbMTNdLCB0aGlzLmNhbWVyYS5tYXRyaXhXb3JsZC5lbGVtZW50c1sxNF1dKSk7XG4gICAgICAgICAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5VTklGT1JNX0JVRkZFUiwgOCAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgbmV3IEZsb2F0MzJBcnJheShbdGhpcy5jYW1lcmEubWF0cml4V29ybGQuZWxlbWVudHNbMTJdLCB0aGlzLmNhbWVyYS5tYXRyaXhXb3JsZC5lbGVtZW50c1sxM10sIHRoaXMuY2FtZXJhLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzE0XV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzaC5tYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlKSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWkobWVzaC5tYXRlcmlhbC51bmlmb3Jtcy5iYXNlQ29sb3JUZXh0dXJlLCBtZXNoLm1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUuY291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNoLm1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkge1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFpKG1lc2gubWF0ZXJpYWwudW5pZm9ybXMubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlLCBtZXNoLm1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZS5jb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc2gubWF0ZXJpYWwubm9ybWFsVGV4dHVyZSkge1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFpKG1lc2gubWF0ZXJpYWwudW5pZm9ybXMubm9ybWFsVGV4dHVyZSwgbWVzaC5tYXRlcmlhbC5ub3JtYWxUZXh0dXJlLmNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzaC5tYXRlcmlhbC5vY2NsdXNpb25UZXh0dXJlKSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWkobWVzaC5tYXRlcmlhbC51bmlmb3Jtcy5vY2NsdXNpb25UZXh0dXJlLCBtZXNoLm1hdGVyaWFsLm9jY2x1c2lvblRleHR1cmUuY291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNoLm1hdGVyaWFsLmVtaXNzaXZlVGV4dHVyZSkge1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFpKG1lc2gubWF0ZXJpYWwudW5pZm9ybXMuZW1pc3NpdmVUZXh0dXJlLCBtZXNoLm1hdGVyaWFsLmVtaXNzaXZlVGV4dHVyZS5jb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc2gubWF0ZXJpYWwuZG91YmxlU2lkZWQpIHtcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzaC5nZW9tZXRyeS5pbmRpY2VzQnVmZmVyKSB7XG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMobWVzaC5tb2RlIHx8IGdsLlRSSUFOR0xFUywgbWVzaC5nZW9tZXRyeS5pbmRpY2VzQnVmZmVyLmxlbmd0aCwgbWVzaC5nZW9tZXRyeS5pbmRpY2VzQnVmZmVyLkJZVEVTX1BFUl9FTEVNRU5UID09PSA0ID8gZ2wuVU5TSUdORURfSU5UIDogZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhtZXNoLm1vZGUgfHwgZ2wuVFJJQU5HTEVTLCAwLCBtZXNoLmdlb21ldHJ5LmF0dHJpYnV0ZXMuUE9TSVRJT04ubGVuZ3RoIC8gMyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc2gubWF0ZXJpYWwuZG91YmxlU2lkZWQpIHtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IHsgUmVkQ3ViZSB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/redcube.ts\n");

/***/ }),

/***/ "./src/shaders/blurEnv.glsl":
/*!**********************************!*\
  !*** ./src/shaders/blurEnv.glsl ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\nin vec2 outUV;\\r\\nout vec4 color;\\r\\n\\r\\nuniform sampler2D diffuse;\\r\\nuniform float level;\\r\\n\\r\\nvoid main() {\\r\\n    vec2 texelSize = 1.0 / vec2(textureSize(diffuse, 0));\\r\\n    vec3 result = vec3(0.0);\\r\\n    for (int x = -2; x < 2; ++x) \\r\\n    {\\r\\n        for (int y = -2; y < 2; ++y) \\r\\n        {\\r\\n            vec2 offset = vec2(float(x), float(y)) * texelSize;\\r\\n            result += textureLod(diffuse, outUV + offset, level).rgb;\\r\\n        }\\r\\n    }\\r\\n    color = vec4(result / 16.0, 1.0);\\r\\n}\\r\\n\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2hhZGVycy9ibHVyRW52Lmdsc2wuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWRjdWJlLy4vc3JjL3NoYWRlcnMvYmx1ckVudi5nbHNsP2I3MTkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDMwMCBlc1xcclxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXHJcXG5cXHJcXG5pbiB2ZWMyIG91dFVWO1xcclxcbm91dCB2ZWM0IGNvbG9yO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIGRpZmZ1c2U7XFxyXFxudW5pZm9ybSBmbG9hdCBsZXZlbDtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuICAgIHZlYzIgdGV4ZWxTaXplID0gMS4wIC8gdmVjMih0ZXh0dXJlU2l6ZShkaWZmdXNlLCAwKSk7XFxyXFxuICAgIHZlYzMgcmVzdWx0ID0gdmVjMygwLjApO1xcclxcbiAgICBmb3IgKGludCB4ID0gLTI7IHggPCAyOyArK3gpIFxcclxcbiAgICB7XFxyXFxuICAgICAgICBmb3IgKGludCB5ID0gLTI7IHkgPCAyOyArK3kpIFxcclxcbiAgICAgICAge1xcclxcbiAgICAgICAgICAgIHZlYzIgb2Zmc2V0ID0gdmVjMihmbG9hdCh4KSwgZmxvYXQoeSkpICogdGV4ZWxTaXplO1xcclxcbiAgICAgICAgICAgIHJlc3VsdCArPSB0ZXh0dXJlTG9kKGRpZmZ1c2UsIG91dFVWICsgb2Zmc2V0LCBsZXZlbCkucmdiO1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIGNvbG9yID0gdmVjNChyZXN1bHQgLyAxNi4wLCAxLjApO1xcclxcbn1cXHJcXG5cIiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/shaders/blurEnv.glsl\n");

/***/ }),

/***/ "./src/shaders/env.glsl":
/*!******************************!*\
  !*** ./src/shaders/env.glsl ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\nlayout (location = 0) in vec3 inPosition;\\r\\nlayout (location = 1) in vec2 inUV;\\r\\n\\r\\nuniform mat4 MVPMatrix;\\r\\n\\r\\nout vec2 outUV;\\r\\n\\r\\nvoid main() {\\r\\n\\toutUV = inUV;\\r\\n    gl_Position = MVPMatrix * vec4(inPosition, 1.0);\\r\\n}\\r\\n\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2hhZGVycy9lbnYuZ2xzbC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGN1YmUvLi9zcmMvc2hhZGVycy9lbnYuZ2xzbD80MjgzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAzMDAgZXNcXHJcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxyXFxuXFxyXFxubGF5b3V0IChsb2NhdGlvbiA9IDApIGluIHZlYzMgaW5Qb3NpdGlvbjtcXHJcXG5sYXlvdXQgKGxvY2F0aW9uID0gMSkgaW4gdmVjMiBpblVWO1xcclxcblxcclxcbnVuaWZvcm0gbWF0NCBNVlBNYXRyaXg7XFxyXFxuXFxyXFxub3V0IHZlYzIgb3V0VVY7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcdG91dFVWID0gaW5VVjtcXHJcXG4gICAgZ2xfUG9zaXRpb24gPSBNVlBNYXRyaXggKiB2ZWM0KGluUG9zaXRpb24sIDEuMCk7XFxyXFxufVxcclxcblwiIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/shaders/env.glsl\n");

/***/ }),

/***/ "./src/shaders/fragment.glsl":
/*!***********************************!*\
  !*** ./src/shaders/fragment.glsl ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\nin vec2 outUV;\\r\\nin vec3 outPosition;\\r\\n#ifdef TANGENT\\r\\n    in mat3 outTBN;\\r\\n#else\\r\\n    in vec3 outNormal;\\r\\n#endif\\r\\n\\r\\nout vec4 color;\\r\\n\\r\\nuniform Material {\\r\\n    vec4 baseColorFactor;\\r\\n    vec3 lightPos;\\r\\n    vec3 viewPos;\\r\\n};\\r\\nuniform sampler2D baseColorTexture;\\r\\nuniform sampler2D metallicRoughnessTexture;\\r\\nuniform sampler2D normalTexture;\\r\\nuniform sampler2D emissiveTexture;\\r\\nuniform sampler2D occlusionTexture;\\r\\n\\r\\nconst float PI = 3.14159265359;\\r\\nconst float ambientStrength = 0.1;\\r\\nconst float specularStrength = 0.5;\\r\\nconst float specularPower = 32.0;\\r\\nconst vec3 lightColor = vec3(1.0, 1.0, 1.0);\\r\\nconst vec3 emissiveFactor = vec3(1.0, 1.0, 1.0);\\r\\n\\r\\nvec3 srgbToLinear(vec4 srgbIn) {\\r\\n    return pow(srgbIn.rgb, vec3(2.2));\\r\\n}\\r\\n\\r\\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\\r\\n    float a = roughness*roughness;\\r\\n    float a2 = max(a*a, 0.0001);\\r\\n    float NdotH = max(dot(N, H), 0.0);\\r\\n    float NdotH2 = NdotH*NdotH;\\r\\n\\r\\n    float nom   = a2;\\r\\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\\r\\n    denom = PI * denom * denom;\\r\\n\\r\\n    return nom / max(denom, 0.0001);\\r\\n}\\r\\n\\r\\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\\r\\n    float r = (roughness + 1.0);\\r\\n    float k = (r*r) / 8.0;\\r\\n\\r\\n    float nom   = NdotV;\\r\\n    float denom = NdotV * (1.0 - k) + k;\\r\\n\\r\\n    return nom / denom;\\r\\n}\\r\\n\\r\\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\\r\\n    float NdotV = max(dot(N, V), 0.0);\\r\\n    float NdotL = max(dot(N, L), 0.0);\\r\\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\\r\\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\\r\\n\\r\\n    return ggx1 * ggx2;\\r\\n}\\r\\n\\r\\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\\r\\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    #ifdef BASECOLORTEXTURE\\r\\n        vec3 baseColor = srgbToLinear(texture(baseColorTexture, outUV));\\r\\n        float alpha = texture(baseColorTexture, outUV).a;\\r\\n    #else\\r\\n        vec3 baseColor = baseColorFactor.rgb;\\r\\n        float alpha = baseColorFactor.a;\\r\\n    #endif\\r\\n\\r\\n    #ifdef OCCLUSIONMAP\\r\\n        float ao = texture(occlusionTexture, outUV).r;\\r\\n    #endif\\r\\n\\r\\n    #ifdef METALROUGHNESSMAP\\r\\n        float roughness = texture(metallicRoughnessTexture, outUV).g;\\r\\n        float metallic = texture(metallicRoughnessTexture, outUV).b;\\r\\n    #endif\\r\\n\\r\\n    #ifdef TANGENT\\r\\n        #ifdef NORMALMAP\\r\\n            vec3 n = texture(normalTexture, outUV).rgb;\\r\\n            n = normalize(outTBN * (2.0 * n - 1.0));\\r\\n        #else\\r\\n            vec3 n = outTBN[2].xyz;\\r\\n        #endif\\r\\n    #else\\r\\n        vec3 n = outNormal;\\r\\n    #endif\\r\\n\\r\\n    vec3 viewDir = normalize(viewPos - outPosition);\\r\\n    vec3 lightDir = normalize(lightPos - outPosition);\\r\\n    vec3 H = normalize(viewDir + lightDir);\\r\\n    float distance = length(lightPos - outPosition);\\r\\n    float attenuation = 1.0 / (distance * distance);\\r\\n    vec3 radiance = lightColor * 2.0;\\r\\n\\r\\n    #ifdef USE_PBR\\r\\n        vec3 F0 = vec3(0.04); \\r\\n        F0 = mix(F0, baseColor, metallic);\\r\\n\\r\\n        vec3 light = vec3(0.0);\\r\\n\\r\\n        float NDF = DistributionGGX(n, H, roughness);        \\r\\n        float G = GeometrySmith(n, viewDir, lightDir, roughness);      \\r\\n        vec3 F = fresnelSchlick(max(dot(H, viewDir), 0.0), F0);       \\r\\n        \\r\\n        vec3 kS = F;\\r\\n        vec3 kD = vec3(1.0) - kS;\\r\\n        kD *= 1.0 - metallic;     \\r\\n        \\r\\n        vec3 nominator = NDF * G * F;\\r\\n        float denominator = 4.0 * max(dot(n, viewDir), 0.0) * max(dot(n, lightDir), 0.0);\\r\\n        vec3 specular = nominator / max(denominator, 0.001);  \\r\\n\\r\\n        float NdotL = max(dot(n, lightDir), 0.0);                \\r\\n        light += (kD * baseColor / PI + specular) * radiance * NdotL;\\r\\n\\r\\n        #ifdef OCCLUSIONMAP\\r\\n            vec3 ambient = vec3(0.03) * baseColor * ao;\\r\\n        #else\\r\\n            vec3 ambient = baseColor;\\r\\n        #endif\\r\\n        baseColor = ambient + light;\\r\\n\\r\\n        #ifdef EMISSIVEMAP\\r\\n            vec3 emissive = srgbToLinear(texture(emissiveTexture, outUV)) * emissiveFactor;\\r\\n            baseColor.rgb += emissive;\\r\\n        #endif\\r\\n\\r\\n        baseColor = baseColor / (baseColor + vec3(1.0));\\r\\n        baseColor = pow(baseColor, vec3(1.0 / 2.2));  \\r\\n   \\r\\n        color = vec4(baseColor, 1.0);\\r\\n    #else\\r\\n        vec3 ambient = ambientStrength * lightColor;\\r\\n\\r\\n        float diff = max(dot(n, lightDir), 0.0);\\r\\n        vec3 diffuse = diff * lightColor;\\r\\n\\r\\n        vec3 reflectDir = reflect(-lightDir, n);\\r\\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), specularPower);\\r\\n        vec3 specular = specularStrength * spec * lightColor;\\r\\n\\r\\n        color = vec4(baseColor.rgb * (ambient + diffuse + specular), alpha);\\r\\n    #endif\\r\\n}\\r\\n\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2hhZGVycy9mcmFnbWVudC5nbHNsLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkY3ViZS8uL3NyYy9zaGFkZXJzL2ZyYWdtZW50Lmdsc2w/OThmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMzAwIGVzXFxyXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcclxcblxcclxcbmluIHZlYzIgb3V0VVY7XFxyXFxuaW4gdmVjMyBvdXRQb3NpdGlvbjtcXHJcXG4jaWZkZWYgVEFOR0VOVFxcclxcbiAgICBpbiBtYXQzIG91dFRCTjtcXHJcXG4jZWxzZVxcclxcbiAgICBpbiB2ZWMzIG91dE5vcm1hbDtcXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG5vdXQgdmVjNCBjb2xvcjtcXHJcXG5cXHJcXG51bmlmb3JtIE1hdGVyaWFsIHtcXHJcXG4gICAgdmVjNCBiYXNlQ29sb3JGYWN0b3I7XFxyXFxuICAgIHZlYzMgbGlnaHRQb3M7XFxyXFxuICAgIHZlYzMgdmlld1BvcztcXHJcXG59O1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIGJhc2VDb2xvclRleHR1cmU7XFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlO1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIG5vcm1hbFRleHR1cmU7XFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVUZXh0dXJlO1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIG9jY2x1c2lvblRleHR1cmU7XFxyXFxuXFxyXFxuY29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5MjY1MzU5O1xcclxcbmNvbnN0IGZsb2F0IGFtYmllbnRTdHJlbmd0aCA9IDAuMTtcXHJcXG5jb25zdCBmbG9hdCBzcGVjdWxhclN0cmVuZ3RoID0gMC41O1xcclxcbmNvbnN0IGZsb2F0IHNwZWN1bGFyUG93ZXIgPSAzMi4wO1xcclxcbmNvbnN0IHZlYzMgbGlnaHRDb2xvciA9IHZlYzMoMS4wLCAxLjAsIDEuMCk7XFxyXFxuY29uc3QgdmVjMyBlbWlzc2l2ZUZhY3RvciA9IHZlYzMoMS4wLCAxLjAsIDEuMCk7XFxyXFxuXFxyXFxudmVjMyBzcmdiVG9MaW5lYXIodmVjNCBzcmdiSW4pIHtcXHJcXG4gICAgcmV0dXJuIHBvdyhzcmdiSW4ucmdiLCB2ZWMzKDIuMikpO1xcclxcbn1cXHJcXG5cXHJcXG5mbG9hdCBEaXN0cmlidXRpb25HR1godmVjMyBOLCB2ZWMzIEgsIGZsb2F0IHJvdWdobmVzcykge1xcclxcbiAgICBmbG9hdCBhID0gcm91Z2huZXNzKnJvdWdobmVzcztcXHJcXG4gICAgZmxvYXQgYTIgPSBtYXgoYSphLCAwLjAwMDEpO1xcclxcbiAgICBmbG9hdCBOZG90SCA9IG1heChkb3QoTiwgSCksIDAuMCk7XFxyXFxuICAgIGZsb2F0IE5kb3RIMiA9IE5kb3RIKk5kb3RIO1xcclxcblxcclxcbiAgICBmbG9hdCBub20gICA9IGEyO1xcclxcbiAgICBmbG9hdCBkZW5vbSA9IChOZG90SDIgKiAoYTIgLSAxLjApICsgMS4wKTtcXHJcXG4gICAgZGVub20gPSBQSSAqIGRlbm9tICogZGVub207XFxyXFxuXFxyXFxuICAgIHJldHVybiBub20gLyBtYXgoZGVub20sIDAuMDAwMSk7XFxyXFxufVxcclxcblxcclxcbmZsb2F0IEdlb21ldHJ5U2NobGlja0dHWChmbG9hdCBOZG90ViwgZmxvYXQgcm91Z2huZXNzKSB7XFxyXFxuICAgIGZsb2F0IHIgPSAocm91Z2huZXNzICsgMS4wKTtcXHJcXG4gICAgZmxvYXQgayA9IChyKnIpIC8gOC4wO1xcclxcblxcclxcbiAgICBmbG9hdCBub20gICA9IE5kb3RWO1xcclxcbiAgICBmbG9hdCBkZW5vbSA9IE5kb3RWICogKDEuMCAtIGspICsgaztcXHJcXG5cXHJcXG4gICAgcmV0dXJuIG5vbSAvIGRlbm9tO1xcclxcbn1cXHJcXG5cXHJcXG5mbG9hdCBHZW9tZXRyeVNtaXRoKHZlYzMgTiwgdmVjMyBWLCB2ZWMzIEwsIGZsb2F0IHJvdWdobmVzcykge1xcclxcbiAgICBmbG9hdCBOZG90ViA9IG1heChkb3QoTiwgViksIDAuMCk7XFxyXFxuICAgIGZsb2F0IE5kb3RMID0gbWF4KGRvdChOLCBMKSwgMC4wKTtcXHJcXG4gICAgZmxvYXQgZ2d4MiA9IEdlb21ldHJ5U2NobGlja0dHWChOZG90Viwgcm91Z2huZXNzKTtcXHJcXG4gICAgZmxvYXQgZ2d4MSA9IEdlb21ldHJ5U2NobGlja0dHWChOZG90TCwgcm91Z2huZXNzKTtcXHJcXG5cXHJcXG4gICAgcmV0dXJuIGdneDEgKiBnZ3gyO1xcclxcbn1cXHJcXG5cXHJcXG52ZWMzIGZyZXNuZWxTY2hsaWNrKGZsb2F0IGNvc1RoZXRhLCB2ZWMzIEYwKSB7XFxyXFxuICAgIHJldHVybiBGMCArICgxLjAgLSBGMCkgKiBwb3coMS4wIC0gY29zVGhldGEsIDUuMCk7XFxyXFxufVxcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG4gICAgI2lmZGVmIEJBU0VDT0xPUlRFWFRVUkVcXHJcXG4gICAgICAgIHZlYzMgYmFzZUNvbG9yID0gc3JnYlRvTGluZWFyKHRleHR1cmUoYmFzZUNvbG9yVGV4dHVyZSwgb3V0VVYpKTtcXHJcXG4gICAgICAgIGZsb2F0IGFscGhhID0gdGV4dHVyZShiYXNlQ29sb3JUZXh0dXJlLCBvdXRVVikuYTtcXHJcXG4gICAgI2Vsc2VcXHJcXG4gICAgICAgIHZlYzMgYmFzZUNvbG9yID0gYmFzZUNvbG9yRmFjdG9yLnJnYjtcXHJcXG4gICAgICAgIGZsb2F0IGFscGhhID0gYmFzZUNvbG9yRmFjdG9yLmE7XFxyXFxuICAgICNlbmRpZlxcclxcblxcclxcbiAgICAjaWZkZWYgT0NDTFVTSU9OTUFQXFxyXFxuICAgICAgICBmbG9hdCBhbyA9IHRleHR1cmUob2NjbHVzaW9uVGV4dHVyZSwgb3V0VVYpLnI7XFxyXFxuICAgICNlbmRpZlxcclxcblxcclxcbiAgICAjaWZkZWYgTUVUQUxST1VHSE5FU1NNQVBcXHJcXG4gICAgICAgIGZsb2F0IHJvdWdobmVzcyA9IHRleHR1cmUobWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlLCBvdXRVVikuZztcXHJcXG4gICAgICAgIGZsb2F0IG1ldGFsbGljID0gdGV4dHVyZShtZXRhbGxpY1JvdWdobmVzc1RleHR1cmUsIG91dFVWKS5iO1xcclxcbiAgICAjZW5kaWZcXHJcXG5cXHJcXG4gICAgI2lmZGVmIFRBTkdFTlRcXHJcXG4gICAgICAgICNpZmRlZiBOT1JNQUxNQVBcXHJcXG4gICAgICAgICAgICB2ZWMzIG4gPSB0ZXh0dXJlKG5vcm1hbFRleHR1cmUsIG91dFVWKS5yZ2I7XFxyXFxuICAgICAgICAgICAgbiA9IG5vcm1hbGl6ZShvdXRUQk4gKiAoMi4wICogbiAtIDEuMCkpO1xcclxcbiAgICAgICAgI2Vsc2VcXHJcXG4gICAgICAgICAgICB2ZWMzIG4gPSBvdXRUQk5bMl0ueHl6O1xcclxcbiAgICAgICAgI2VuZGlmXFxyXFxuICAgICNlbHNlXFxyXFxuICAgICAgICB2ZWMzIG4gPSBvdXROb3JtYWw7XFxyXFxuICAgICNlbmRpZlxcclxcblxcclxcbiAgICB2ZWMzIHZpZXdEaXIgPSBub3JtYWxpemUodmlld1BvcyAtIG91dFBvc2l0aW9uKTtcXHJcXG4gICAgdmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZShsaWdodFBvcyAtIG91dFBvc2l0aW9uKTtcXHJcXG4gICAgdmVjMyBIID0gbm9ybWFsaXplKHZpZXdEaXIgKyBsaWdodERpcik7XFxyXFxuICAgIGZsb2F0IGRpc3RhbmNlID0gbGVuZ3RoKGxpZ2h0UG9zIC0gb3V0UG9zaXRpb24pO1xcclxcbiAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IDEuMCAvIChkaXN0YW5jZSAqIGRpc3RhbmNlKTtcXHJcXG4gICAgdmVjMyByYWRpYW5jZSA9IGxpZ2h0Q29sb3IgKiAyLjA7XFxyXFxuXFxyXFxuICAgICNpZmRlZiBVU0VfUEJSXFxyXFxuICAgICAgICB2ZWMzIEYwID0gdmVjMygwLjA0KTsgXFxyXFxuICAgICAgICBGMCA9IG1peChGMCwgYmFzZUNvbG9yLCBtZXRhbGxpYyk7XFxyXFxuXFxyXFxuICAgICAgICB2ZWMzIGxpZ2h0ID0gdmVjMygwLjApO1xcclxcblxcclxcbiAgICAgICAgZmxvYXQgTkRGID0gRGlzdHJpYnV0aW9uR0dYKG4sIEgsIHJvdWdobmVzcyk7ICAgICAgICBcXHJcXG4gICAgICAgIGZsb2F0IEcgPSBHZW9tZXRyeVNtaXRoKG4sIHZpZXdEaXIsIGxpZ2h0RGlyLCByb3VnaG5lc3MpOyAgICAgIFxcclxcbiAgICAgICAgdmVjMyBGID0gZnJlc25lbFNjaGxpY2sobWF4KGRvdChILCB2aWV3RGlyKSwgMC4wKSwgRjApOyAgICAgICBcXHJcXG4gICAgICAgIFxcclxcbiAgICAgICAgdmVjMyBrUyA9IEY7XFxyXFxuICAgICAgICB2ZWMzIGtEID0gdmVjMygxLjApIC0ga1M7XFxyXFxuICAgICAgICBrRCAqPSAxLjAgLSBtZXRhbGxpYzsgICAgIFxcclxcbiAgICAgICAgXFxyXFxuICAgICAgICB2ZWMzIG5vbWluYXRvciA9IE5ERiAqIEcgKiBGO1xcclxcbiAgICAgICAgZmxvYXQgZGVub21pbmF0b3IgPSA0LjAgKiBtYXgoZG90KG4sIHZpZXdEaXIpLCAwLjApICogbWF4KGRvdChuLCBsaWdodERpciksIDAuMCk7XFxyXFxuICAgICAgICB2ZWMzIHNwZWN1bGFyID0gbm9taW5hdG9yIC8gbWF4KGRlbm9taW5hdG9yLCAwLjAwMSk7ICBcXHJcXG5cXHJcXG4gICAgICAgIGZsb2F0IE5kb3RMID0gbWF4KGRvdChuLCBsaWdodERpciksIDAuMCk7ICAgICAgICAgICAgICAgIFxcclxcbiAgICAgICAgbGlnaHQgKz0gKGtEICogYmFzZUNvbG9yIC8gUEkgKyBzcGVjdWxhcikgKiByYWRpYW5jZSAqIE5kb3RMO1xcclxcblxcclxcbiAgICAgICAgI2lmZGVmIE9DQ0xVU0lPTk1BUFxcclxcbiAgICAgICAgICAgIHZlYzMgYW1iaWVudCA9IHZlYzMoMC4wMykgKiBiYXNlQ29sb3IgKiBhbztcXHJcXG4gICAgICAgICNlbHNlXFxyXFxuICAgICAgICAgICAgdmVjMyBhbWJpZW50ID0gYmFzZUNvbG9yO1xcclxcbiAgICAgICAgI2VuZGlmXFxyXFxuICAgICAgICBiYXNlQ29sb3IgPSBhbWJpZW50ICsgbGlnaHQ7XFxyXFxuXFxyXFxuICAgICAgICAjaWZkZWYgRU1JU1NJVkVNQVBcXHJcXG4gICAgICAgICAgICB2ZWMzIGVtaXNzaXZlID0gc3JnYlRvTGluZWFyKHRleHR1cmUoZW1pc3NpdmVUZXh0dXJlLCBvdXRVVikpICogZW1pc3NpdmVGYWN0b3I7XFxyXFxuICAgICAgICAgICAgYmFzZUNvbG9yLnJnYiArPSBlbWlzc2l2ZTtcXHJcXG4gICAgICAgICNlbmRpZlxcclxcblxcclxcbiAgICAgICAgYmFzZUNvbG9yID0gYmFzZUNvbG9yIC8gKGJhc2VDb2xvciArIHZlYzMoMS4wKSk7XFxyXFxuICAgICAgICBiYXNlQ29sb3IgPSBwb3coYmFzZUNvbG9yLCB2ZWMzKDEuMCAvIDIuMikpOyAgXFxyXFxuICAgXFxyXFxuICAgICAgICBjb2xvciA9IHZlYzQoYmFzZUNvbG9yLCAxLjApO1xcclxcbiAgICAjZWxzZVxcclxcbiAgICAgICAgdmVjMyBhbWJpZW50ID0gYW1iaWVudFN0cmVuZ3RoICogbGlnaHRDb2xvcjtcXHJcXG5cXHJcXG4gICAgICAgIGZsb2F0IGRpZmYgPSBtYXgoZG90KG4sIGxpZ2h0RGlyKSwgMC4wKTtcXHJcXG4gICAgICAgIHZlYzMgZGlmZnVzZSA9IGRpZmYgKiBsaWdodENvbG9yO1xcclxcblxcclxcbiAgICAgICAgdmVjMyByZWZsZWN0RGlyID0gcmVmbGVjdCgtbGlnaHREaXIsIG4pO1xcclxcbiAgICAgICAgZmxvYXQgc3BlYyA9IHBvdyhtYXgoZG90KHZpZXdEaXIsIHJlZmxlY3REaXIpLCAwLjApLCBzcGVjdWxhclBvd2VyKTtcXHJcXG4gICAgICAgIHZlYzMgc3BlY3VsYXIgPSBzcGVjdWxhclN0cmVuZ3RoICogc3BlYyAqIGxpZ2h0Q29sb3I7XFxyXFxuXFxyXFxuICAgICAgICBjb2xvciA9IHZlYzQoYmFzZUNvbG9yLnJnYiAqIChhbWJpZW50ICsgZGlmZnVzZSArIHNwZWN1bGFyKSwgYWxwaGEpO1xcclxcbiAgICAjZW5kaWZcXHJcXG59XFxyXFxuXCIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/shaders/fragment.glsl\n");

/***/ }),

/***/ "./src/shaders/vertex.glsl":
/*!*********************************!*\
  !*** ./src/shaders/vertex.glsl ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\nlayout (location = 0) in vec3 inPosition;\\r\\nlayout (location = 1) in vec3 inNormal;\\r\\nlayout (location = 2) in vec2 inUV;\\r\\nlayout (location = 3) in vec4 inJoint;\\r\\nlayout (location = 4) in vec4 inWeight;\\r\\nlayout (location = 5) in vec4 inTangent;\\r\\n\\r\\nout vec2 outUV;\\r\\nout vec3 outPosition;\\r\\n#ifdef TANGENT\\r\\n    out mat3 outTBN;\\r\\n#else\\r\\n    out vec3 outNormal;\\r\\n#endif\\r\\n\\r\\nuniform Matrices {\\r\\n    mat4 model;\\r\\n    mat4 normalMatrix;\\r\\n    mat4 view;\\r\\n    mat4 projection;\\r\\n};\\r\\n\\r\\n#ifdef JOINTNUMBER\\r\\nuniform Skin {\\r\\n    mat4 joint[JOINTNUMBER];\\r\\n};\\r\\n#endif\\r\\n\\r\\nvoid main() {\\r\\n    #ifdef JOINTNUMBER\\r\\n        mat4 skin = inWeight.x * joint[int(inJoint.x)];\\r\\n        skin += inWeight.y * joint[int(inJoint.y)];\\r\\n        skin += inWeight.z * joint[int(inJoint.z)];\\r\\n        skin += inWeight.w * joint[int(inJoint.w)];\\r\\n    #else\\r\\n        mat4 skin = mat4(1.0);\\r\\n    #endif\\r\\n\\r\\n    outUV = inUV;\\r\\n    #ifdef TANGENT\\r\\n        vec3 normalW = normalize(vec3(model * vec4(inNormal.xyz, 0.0)));\\r\\n        vec3 tangentW = normalize(vec3(model * vec4(inTangent.xyz, 0.0)));\\r\\n        vec3 bitangentW = cross(normalW, tangentW) * inTangent.w;\\r\\n        outTBN = mat3(tangentW, bitangentW, normalW);\\r\\n    #else\\r\\n        outNormal = normalize(mat3(normalMatrix) * mat3(skin) * inNormal);\\r\\n    #endif\\r\\n    outPosition = vec3(model * skin * vec4(inPosition, 1.0));\\r\\n    gl_Position = projection * view * model * skin * vec4(inPosition, 1.0);\\r\\n}\\r\\n\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2hhZGVycy92ZXJ0ZXguZ2xzbC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGN1YmUvLi9zcmMvc2hhZGVycy92ZXJ0ZXguZ2xzbD8wY2UwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAzMDAgZXNcXHJcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxyXFxuXFxyXFxubGF5b3V0IChsb2NhdGlvbiA9IDApIGluIHZlYzMgaW5Qb3NpdGlvbjtcXHJcXG5sYXlvdXQgKGxvY2F0aW9uID0gMSkgaW4gdmVjMyBpbk5vcm1hbDtcXHJcXG5sYXlvdXQgKGxvY2F0aW9uID0gMikgaW4gdmVjMiBpblVWO1xcclxcbmxheW91dCAobG9jYXRpb24gPSAzKSBpbiB2ZWM0IGluSm9pbnQ7XFxyXFxubGF5b3V0IChsb2NhdGlvbiA9IDQpIGluIHZlYzQgaW5XZWlnaHQ7XFxyXFxubGF5b3V0IChsb2NhdGlvbiA9IDUpIGluIHZlYzQgaW5UYW5nZW50O1xcclxcblxcclxcbm91dCB2ZWMyIG91dFVWO1xcclxcbm91dCB2ZWMzIG91dFBvc2l0aW9uO1xcclxcbiNpZmRlZiBUQU5HRU5UXFxyXFxuICAgIG91dCBtYXQzIG91dFRCTjtcXHJcXG4jZWxzZVxcclxcbiAgICBvdXQgdmVjMyBvdXROb3JtYWw7XFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxudW5pZm9ybSBNYXRyaWNlcyB7XFxyXFxuICAgIG1hdDQgbW9kZWw7XFxyXFxuICAgIG1hdDQgbm9ybWFsTWF0cml4O1xcclxcbiAgICBtYXQ0IHZpZXc7XFxyXFxuICAgIG1hdDQgcHJvamVjdGlvbjtcXHJcXG59O1xcclxcblxcclxcbiNpZmRlZiBKT0lOVE5VTUJFUlxcclxcbnVuaWZvcm0gU2tpbiB7XFxyXFxuICAgIG1hdDQgam9pbnRbSk9JTlROVU1CRVJdO1xcclxcbn07XFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcbiAgICAjaWZkZWYgSk9JTlROVU1CRVJcXHJcXG4gICAgICAgIG1hdDQgc2tpbiA9IGluV2VpZ2h0LnggKiBqb2ludFtpbnQoaW5Kb2ludC54KV07XFxyXFxuICAgICAgICBza2luICs9IGluV2VpZ2h0LnkgKiBqb2ludFtpbnQoaW5Kb2ludC55KV07XFxyXFxuICAgICAgICBza2luICs9IGluV2VpZ2h0LnogKiBqb2ludFtpbnQoaW5Kb2ludC56KV07XFxyXFxuICAgICAgICBza2luICs9IGluV2VpZ2h0LncgKiBqb2ludFtpbnQoaW5Kb2ludC53KV07XFxyXFxuICAgICNlbHNlXFxyXFxuICAgICAgICBtYXQ0IHNraW4gPSBtYXQ0KDEuMCk7XFxyXFxuICAgICNlbmRpZlxcclxcblxcclxcbiAgICBvdXRVViA9IGluVVY7XFxyXFxuICAgICNpZmRlZiBUQU5HRU5UXFxyXFxuICAgICAgICB2ZWMzIG5vcm1hbFcgPSBub3JtYWxpemUodmVjMyhtb2RlbCAqIHZlYzQoaW5Ob3JtYWwueHl6LCAwLjApKSk7XFxyXFxuICAgICAgICB2ZWMzIHRhbmdlbnRXID0gbm9ybWFsaXplKHZlYzMobW9kZWwgKiB2ZWM0KGluVGFuZ2VudC54eXosIDAuMCkpKTtcXHJcXG4gICAgICAgIHZlYzMgYml0YW5nZW50VyA9IGNyb3NzKG5vcm1hbFcsIHRhbmdlbnRXKSAqIGluVGFuZ2VudC53O1xcclxcbiAgICAgICAgb3V0VEJOID0gbWF0Myh0YW5nZW50VywgYml0YW5nZW50Vywgbm9ybWFsVyk7XFxyXFxuICAgICNlbHNlXFxyXFxuICAgICAgICBvdXROb3JtYWwgPSBub3JtYWxpemUobWF0Myhub3JtYWxNYXRyaXgpICogbWF0Myhza2luKSAqIGluTm9ybWFsKTtcXHJcXG4gICAgI2VuZGlmXFxyXFxuICAgIG91dFBvc2l0aW9uID0gdmVjMyhtb2RlbCAqIHNraW4gKiB2ZWM0KGluUG9zaXRpb24sIDEuMCkpO1xcclxcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb24gKiB2aWV3ICogbW9kZWwgKiBza2luICogdmVjNChpblBvc2l0aW9uLCAxLjApO1xcclxcbn1cXHJcXG5cIiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/shaders/vertex.glsl\n");

/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/*! exports provided: setGl, isMatrix, random, getMatrixType, getDataType, getComponentType, getMethod, getAnimationComponent, range, interpolation, buildArray, compileShader, walk, sceneToArcBall, canvasToWorld, calculateProjection, calculateOffset, getAttributeIndex, calculateBinormals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setGl\", function() { return setGl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isMatrix\", function() { return isMatrix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMatrixType\", function() { return getMatrixType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDataType\", function() { return getDataType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getComponentType\", function() { return getComponentType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMethod\", function() { return getMethod; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAnimationComponent\", function() { return getAnimationComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"range\", function() { return range; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolation\", function() { return interpolation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildArray\", function() { return buildArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileShader\", function() { return compileShader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"walk\", function() { return walk; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sceneToArcBall\", function() { return sceneToArcBall; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"canvasToWorld\", function() { return canvasToWorld; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"calculateProjection\", function() { return calculateProjection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"calculateOffset\", function() { return calculateOffset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAttributeIndex\", function() { return getAttributeIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"calculateBinormals\", function() { return calculateBinormals; });\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matrix */ \"./src/matrix.ts\");\n\nconst glEnum = {};\nlet gl;\nfunction setGl(_gl) {\n    gl = _gl;\n    for (const k in gl) {\n        const v = gl[k];\n        if (typeof v === 'number') {\n            glEnum[v] = k;\n        }\n    }\n}\nfunction isMatrix(type) {\n    return glEnum[type] === 'FLOAT_MAT4' || glEnum[type] === 'FLOAT_MAT3' || glEnum[type] === 'FLOAT_MAT2';\n}\nfunction random(min, max) {\n    return Math.random() * (max - min) + min;\n}\nfunction getMatrixType(type) {\n    if (glEnum[type] === 'FLOAT_MAT4') {\n        return _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"];\n    }\n    if (glEnum[type] === 'FLOAT_MAT3') {\n        return _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Matrix3\"];\n    }\n    if (glEnum[type] === 'FLOAT_MAT2') {\n        return _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Matrix2\"];\n    }\n}\nfunction getDataType(type) {\n    let count;\n    switch (type) {\n        case 'MAT2':\n            count = 4;\n            break;\n        case 'MAT3':\n            count = 9;\n            break;\n        case 'MAT4':\n            count = 16;\n            break;\n        case 'VEC4':\n            count = 4;\n            break;\n        case 'VEC3':\n            count = 3;\n            break;\n        case 'VEC2':\n            count = 2;\n            break;\n        case 'SCALAR':\n            count = 1;\n            break;\n    }\n    return count;\n}\nfunction getComponentType(type) {\n    let count;\n    switch (glEnum[type]) {\n        case 'FLOAT_VEC4':\n            count = 4;\n            break;\n        case 'FLOAT_VEC3':\n            count = 3;\n            break;\n        case 'FLOAT_VEC2':\n            count = 2;\n            break;\n    }\n    return count;\n}\nfunction getMethod(type) {\n    let method;\n    switch (glEnum[type]) {\n        case 'FLOAT_VEC2':\n            method = 'uniform2f';\n            break;\n        case 'FLOAT_VEC4':\n            method = 'uniform4f';\n            break;\n        case 'FLOAT':\n            method = 'uniform1f';\n            break;\n        case 'FLOAT_VEC3':\n            method = 'uniform3f';\n            break;\n        case 'FLOAT_MAT4':\n            method = 'uniformMatrix4fv';\n            break;\n        case 'FLOAT_MAT3':\n            method = 'uniformMatrix3fv';\n            break;\n        case 'FLOAT_MAT2':\n            method = 'uniformMatrix2fv';\n            break;\n        case 'SAMPLER_2D':\n            method = 'uniform1i';\n            break;\n    }\n    return method;\n}\nfunction getAnimationComponent(type) {\n    if (type === 'rotation') {\n        return 4;\n    }\n    else if (type === 'weights') {\n        return 2;\n    }\n    else {\n        return 3;\n    }\n}\nfunction range(min, max, value) {\n    return (value - min) / (max - min);\n}\nfunction interpolation(time, frames) {\n    if (frames.length === 0) {\n        return [-1, -1, 0];\n    }\n    let prev = -1;\n    for (let i = frames.length - 1; i >= 0; i--) {\n        if (time >= frames[i].time) {\n            prev = i;\n            break;\n        }\n    }\n    if (prev === -1 || prev === frames.length - 1) {\n        if (prev < 0) {\n            prev = 0;\n        }\n        return [prev, prev, 0];\n    }\n    else {\n        const startFrame = frames[prev];\n        const endFrame = frames[prev + 1];\n        time = Math.max(startFrame.time, Math.min(time, endFrame.time));\n        const t = range(startFrame.time, endFrame.time, time);\n        return [prev, prev + 1, t];\n    }\n}\nfunction getCount(type) {\n    let arr;\n    switch (glEnum[type]) {\n        case 'BYTE':\n        case 'UNSIGNED_BYTE':\n            arr = 1;\n            break;\n        case 'SHORT':\n        case 'UNSIGNED_SHORT':\n            arr = 2;\n            break;\n        case 'UNSIGNED_INT':\n        case 'FLOAT':\n            arr = 4;\n            break;\n    }\n    return arr;\n}\nfunction buildArray(arrayBuffer, type, offset, length, stride, count) {\n    const l = length;\n    const c = length / count;\n    if (stride && stride !== getCount(type) * c) {\n        length = stride * count / getCount(type) - offset / getCount(type);\n    }\n    let arr;\n    switch (glEnum[type]) {\n        case 'BYTE':\n            arr = new Int8Array(arrayBuffer, offset, length);\n            break;\n        case 'UNSIGNED_BYTE':\n            arr = new Uint8Array(arrayBuffer, offset, length);\n            break;\n        case 'SHORT':\n            arr = new Int16Array(arrayBuffer, offset, length);\n            break;\n        case 'UNSIGNED_SHORT':\n            arr = new Uint16Array(arrayBuffer, offset, length);\n            break;\n        case 'UNSIGNED_INT':\n            arr = new Uint32Array(arrayBuffer, offset, length);\n            break;\n        case 'FLOAT':\n            arr = new Float32Array(arrayBuffer, offset, length);\n            break;\n    }\n    if (stride && stride !== getCount(type) * c) {\n        const stridedArr = new Float32Array(l);\n        let j = 0;\n        for (let i = 0; i < stridedArr.length; i = i + c) {\n            stridedArr[i] = arr[j];\n            stridedArr[i + 1] = arr[j + 1];\n            stridedArr[i + 2] = arr[j + 2];\n            j = j + c * (stride / getCount(type) / c);\n        }\n        return stridedArr;\n    }\n    return arr;\n}\nfunction compileShader(type, shaderSource, program) {\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, shaderSource);\n    gl.compileShader(shader);\n    gl.attachShader(program, shader);\n    const log = gl.getShaderInfoLog(shader);\n    if (log) {\n        console.error(log);\n    }\n}\nfunction walk(node, callback) {\n    function _walk(node) {\n        callback(node);\n        if (node.children) {\n            node.children.forEach(_walk);\n        }\n    }\n    _walk(node);\n}\nfunction sceneToArcBall(pos) {\n    let len = pos[0] * pos[0] + pos[1] * pos[1];\n    const sz = 0.04 * 0.04 - len;\n    if (sz > 0) {\n        return [pos[0], pos[1], Math.sqrt(sz)];\n    }\n    else {\n        len = Math.sqrt(len);\n        return [0.04 * pos[0] / len, 0.04 * pos[1] / len, 0];\n    }\n}\nfunction canvasToWorld(vec2, projection, width, height) {\n    const [x, y] = vec2;\n    const newM = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"];\n    newM.setTranslate(new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]([0, 0, 0.05]));\n    const m = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"](projection);\n    m.multiply(newM);\n    const mp = m.multiplyVector4(new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Vector4\"]([0, 0, 0, 1]));\n    mp.elements[0] = (2 * x / width - 1) * mp.elements[3];\n    mp.elements[1] = (-2 * y / height + 1) * mp.elements[3];\n    const v = m.invert().multiplyVector4(mp);\n    return [v.elements[0], v.elements[1]];\n}\nfunction calculateProjection(cam) {\n    const { aspect, zoom } = cam;\n    let proj;\n    if (cam.type === 'perspective' && cam.perspective) {\n        const { yfov } = cam.perspective;\n        const xfov = yfov * aspect;\n        proj = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"]().setPerspective(xfov * zoom * (180 / Math.PI), aspect, cam.perspective.znear || 1, cam.perspective.zfar || 2e6);\n    }\n    else if (cam.type === 'orthographic' && cam.orthographic) {\n        proj = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"]().setOrtho(cam.orthographic.xmag, cam.orthographic.ymag, cam.orthographic.znear, cam.orthographic.zfar);\n    }\n    return proj;\n}\nfunction calculateOffset(a = 0, b = 0) {\n    return a + b;\n}\nfunction getAttributeIndex(name) {\n    let index;\n    switch (name) {\n        case 'POSITION':\n            index = [0, 3, gl.FLOAT];\n            break;\n        case 'NORMAL':\n            index = [1, 3, gl.FLOAT];\n            break;\n        case 'TEXCOORD_0':\n            index = [2, 2, gl.FLOAT];\n            break;\n        case 'JOINTS_0':\n            index = [3, 4, gl.UNSIGNED_SHORT];\n            break;\n        case 'WEIGHTS_0':\n            index = [4, 4, gl.FLOAT];\n            break;\n        case 'TANGENT':\n            index = [5, 4, gl.FLOAT];\n            break;\n    }\n    return index;\n}\nfunction calculateBinormals(index, vertex, normal, uv) {\n    const tangent = new Float32Array(normal.length / 3 * 4);\n    for (let i = 0; i < index.length; i += 3) {\n        const faceIndexes = [index[i], index[i + 1], index[i + 2]];\n        const faceVertices = faceIndexes.map(ix => vectorFromArray(vertex, ix));\n        const faceUVs = faceIndexes.map(ix => vectorFromArray(uv, ix, 2));\n        const dv1 = faceVertices[1].subtract(faceVertices[0]);\n        const dv2 = faceVertices[2].subtract(faceVertices[0]);\n        const duv1 = faceUVs[1].subtract(faceUVs[0]);\n        const duv2 = faceUVs[2].subtract(faceUVs[0]);\n        let r = (duv1.elements[0] * duv2.elements[1] - duv1.elements[1] * duv2.elements[0]);\n        r = (r !== 0) ? 1.0 / r : 1.0;\n        const udir = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]([\n            (duv2.elements[1] * dv1.elements[0] - duv1.elements[1] * dv2.elements[0]) * r,\n            (duv2.elements[1] * dv1.elements[1] - duv1.elements[1] * dv2.elements[1]) * r,\n            (duv2.elements[1] * dv1.elements[2] - duv1.elements[1] * dv2.elements[2]) * r\n        ]);\n        udir.normalize();\n        faceIndexes.forEach(ix => {\n            accumulateVectorInArray(tangent, ix, udir);\n        });\n    }\n    return tangent;\n    function vectorFromArray(array, index, elements = 3) {\n        index = index * elements;\n        if (elements === 3) {\n            return new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]([array[index], array[index + 1], array[index + 2]]);\n        }\n        if (elements === 2) {\n            return new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]([array[index], array[index + 1]]);\n        }\n    }\n    function accumulateVectorInArray(array, index, vector, elements = 4, accumulator = (acc, x) => acc + x) {\n        index = index * elements;\n        for (let i = 0; i < elements; ++i) {\n            if (i === 3) {\n                array[index + i] = -1;\n            }\n            else {\n                array[index + i] = accumulator(array[index + i], vector.elements[i]);\n            }\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWRjdWJlLy4vc3JjL3V0aWxzLnRzPzhkYjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWF0cml4MiwgTWF0cml4MywgTWF0cml4NCwgVmVjdG9yMiwgVmVjdG9yMywgVmVjdG9yNCB9IGZyb20gJy4vbWF0cml4JztcbmNvbnN0IGdsRW51bSA9IHt9O1xubGV0IGdsO1xuZXhwb3J0IGZ1bmN0aW9uIHNldEdsKF9nbCkge1xuICAgIGdsID0gX2dsO1xuICAgIGZvciAoY29uc3QgayBpbiBnbCkge1xuICAgICAgICBjb25zdCB2ID0gZ2xba107XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGdsRW51bVt2XSA9IGs7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNNYXRyaXgodHlwZSkge1xuICAgIHJldHVybiBnbEVudW1bdHlwZV0gPT09ICdGTE9BVF9NQVQ0JyB8fCBnbEVudW1bdHlwZV0gPT09ICdGTE9BVF9NQVQzJyB8fCBnbEVudW1bdHlwZV0gPT09ICdGTE9BVF9NQVQyJztcbn1cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20obWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hdHJpeFR5cGUodHlwZSkge1xuICAgIGlmIChnbEVudW1bdHlwZV0gPT09ICdGTE9BVF9NQVQ0Jykge1xuICAgICAgICByZXR1cm4gTWF0cml4NDtcbiAgICB9XG4gICAgaWYgKGdsRW51bVt0eXBlXSA9PT0gJ0ZMT0FUX01BVDMnKSB7XG4gICAgICAgIHJldHVybiBNYXRyaXgzO1xuICAgIH1cbiAgICBpZiAoZ2xFbnVtW3R5cGVdID09PSAnRkxPQVRfTUFUMicpIHtcbiAgICAgICAgcmV0dXJuIE1hdHJpeDI7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGFUeXBlKHR5cGUpIHtcbiAgICBsZXQgY291bnQ7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ01BVDInOlxuICAgICAgICAgICAgY291bnQgPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01BVDMnOlxuICAgICAgICAgICAgY291bnQgPSA5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01BVDQnOlxuICAgICAgICAgICAgY291bnQgPSAxNjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdWRUM0JzpcbiAgICAgICAgICAgIGNvdW50ID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdWRUMzJzpcbiAgICAgICAgICAgIGNvdW50ID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdWRUMyJzpcbiAgICAgICAgICAgIGNvdW50ID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTQ0FMQVInOlxuICAgICAgICAgICAgY291bnQgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21wb25lbnRUeXBlKHR5cGUpIHtcbiAgICBsZXQgY291bnQ7XG4gICAgc3dpdGNoIChnbEVudW1bdHlwZV0pIHtcbiAgICAgICAgY2FzZSAnRkxPQVRfVkVDNCc6XG4gICAgICAgICAgICBjb3VudCA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRkxPQVRfVkVDMyc6XG4gICAgICAgICAgICBjb3VudCA9IDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRkxPQVRfVkVDMic6XG4gICAgICAgICAgICBjb3VudCA9IDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1ldGhvZCh0eXBlKSB7XG4gICAgbGV0IG1ldGhvZDtcbiAgICBzd2l0Y2ggKGdsRW51bVt0eXBlXSkge1xuICAgICAgICBjYXNlICdGTE9BVF9WRUMyJzpcbiAgICAgICAgICAgIG1ldGhvZCA9ICd1bmlmb3JtMmYnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0ZMT0FUX1ZFQzQnOlxuICAgICAgICAgICAgbWV0aG9kID0gJ3VuaWZvcm00Zic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRkxPQVQnOlxuICAgICAgICAgICAgbWV0aG9kID0gJ3VuaWZvcm0xZic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRkxPQVRfVkVDMyc6XG4gICAgICAgICAgICBtZXRob2QgPSAndW5pZm9ybTNmJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdGTE9BVF9NQVQ0JzpcbiAgICAgICAgICAgIG1ldGhvZCA9ICd1bmlmb3JtTWF0cml4NGZ2JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdGTE9BVF9NQVQzJzpcbiAgICAgICAgICAgIG1ldGhvZCA9ICd1bmlmb3JtTWF0cml4M2Z2JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdGTE9BVF9NQVQyJzpcbiAgICAgICAgICAgIG1ldGhvZCA9ICd1bmlmb3JtTWF0cml4MmZ2JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTQU1QTEVSXzJEJzpcbiAgICAgICAgICAgIG1ldGhvZCA9ICd1bmlmb3JtMWknO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBtZXRob2Q7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QW5pbWF0aW9uQ29tcG9uZW50KHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gJ3JvdGF0aW9uJykge1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ3dlaWdodHMnKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbik7XG59XG5leHBvcnQgZnVuY3Rpb24gaW50ZXJwb2xhdGlvbih0aW1lLCBmcmFtZXMpIHtcbiAgICBpZiAoZnJhbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gWy0xLCAtMSwgMF07XG4gICAgfVxuICAgIGxldCBwcmV2ID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IGZyYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbaV0udGltZSkge1xuICAgICAgICAgICAgcHJldiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldiA9PT0gLTEgfHwgcHJldiA9PT0gZnJhbWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKHByZXYgPCAwKSB7XG4gICAgICAgICAgICBwcmV2ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3ByZXYsIHByZXYsIDBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RhcnRGcmFtZSA9IGZyYW1lc1twcmV2XTtcbiAgICAgICAgY29uc3QgZW5kRnJhbWUgPSBmcmFtZXNbcHJldiArIDFdO1xuICAgICAgICB0aW1lID0gTWF0aC5tYXgoc3RhcnRGcmFtZS50aW1lLCBNYXRoLm1pbih0aW1lLCBlbmRGcmFtZS50aW1lKSk7XG4gICAgICAgIGNvbnN0IHQgPSByYW5nZShzdGFydEZyYW1lLnRpbWUsIGVuZEZyYW1lLnRpbWUsIHRpbWUpO1xuICAgICAgICByZXR1cm4gW3ByZXYsIHByZXYgKyAxLCB0XTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDb3VudCh0eXBlKSB7XG4gICAgbGV0IGFycjtcbiAgICBzd2l0Y2ggKGdsRW51bVt0eXBlXSkge1xuICAgICAgICBjYXNlICdCWVRFJzpcbiAgICAgICAgY2FzZSAnVU5TSUdORURfQllURSc6XG4gICAgICAgICAgICBhcnIgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1NIT1JUJzpcbiAgICAgICAgY2FzZSAnVU5TSUdORURfU0hPUlQnOlxuICAgICAgICAgICAgYXJyID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdVTlNJR05FRF9JTlQnOlxuICAgICAgICBjYXNlICdGTE9BVCc6XG4gICAgICAgICAgICBhcnIgPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRBcnJheShhcnJheUJ1ZmZlciwgdHlwZSwgb2Zmc2V0LCBsZW5ndGgsIHN0cmlkZSwgY291bnQpIHtcbiAgICBjb25zdCBsID0gbGVuZ3RoO1xuICAgIGNvbnN0IGMgPSBsZW5ndGggLyBjb3VudDtcbiAgICBpZiAoc3RyaWRlICYmIHN0cmlkZSAhPT0gZ2V0Q291bnQodHlwZSkgKiBjKSB7XG4gICAgICAgIGxlbmd0aCA9IHN0cmlkZSAqIGNvdW50IC8gZ2V0Q291bnQodHlwZSkgLSBvZmZzZXQgLyBnZXRDb3VudCh0eXBlKTtcbiAgICB9XG4gICAgbGV0IGFycjtcbiAgICBzd2l0Y2ggKGdsRW51bVt0eXBlXSkge1xuICAgICAgICBjYXNlICdCWVRFJzpcbiAgICAgICAgICAgIGFyciA9IG5ldyBJbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdVTlNJR05FRF9CWVRFJzpcbiAgICAgICAgICAgIGFyciA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnU0hPUlQnOlxuICAgICAgICAgICAgYXJyID0gbmV3IEludDE2QXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdVTlNJR05FRF9TSE9SVCc6XG4gICAgICAgICAgICBhcnIgPSBuZXcgVWludDE2QXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdVTlNJR05FRF9JTlQnOlxuICAgICAgICAgICAgYXJyID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRkxPQVQnOlxuICAgICAgICAgICAgYXJyID0gbmV3IEZsb2F0MzJBcnJheShhcnJheUJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChzdHJpZGUgJiYgc3RyaWRlICE9PSBnZXRDb3VudCh0eXBlKSAqIGMpIHtcbiAgICAgICAgY29uc3Qgc3RyaWRlZEFyciA9IG5ldyBGbG9hdDMyQXJyYXkobCk7XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpZGVkQXJyLmxlbmd0aDsgaSA9IGkgKyBjKSB7XG4gICAgICAgICAgICBzdHJpZGVkQXJyW2ldID0gYXJyW2pdO1xuICAgICAgICAgICAgc3RyaWRlZEFycltpICsgMV0gPSBhcnJbaiArIDFdO1xuICAgICAgICAgICAgc3RyaWRlZEFycltpICsgMl0gPSBhcnJbaiArIDJdO1xuICAgICAgICAgICAgaiA9IGogKyBjICogKHN0cmlkZSAvIGdldENvdW50KHR5cGUpIC8gYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmlkZWRBcnI7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZVNoYWRlcih0eXBlLCBzaGFkZXJTb3VyY2UsIHByb2dyYW0pIHtcbiAgICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcik7XG4gICAgY29uc3QgbG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICAgIGlmIChsb2cpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihsb2cpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB3YWxrKG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gX3dhbGsobm9kZSkge1xuICAgICAgICBjYWxsYmFjayhub2RlKTtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChfd2Fsayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3dhbGsobm9kZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2NlbmVUb0FyY0JhbGwocG9zKSB7XG4gICAgbGV0IGxlbiA9IHBvc1swXSAqIHBvc1swXSArIHBvc1sxXSAqIHBvc1sxXTtcbiAgICBjb25zdCBzeiA9IDAuMDQgKiAwLjA0IC0gbGVuO1xuICAgIGlmIChzeiA+IDApIHtcbiAgICAgICAgcmV0dXJuIFtwb3NbMF0sIHBvc1sxXSwgTWF0aC5zcXJ0KHN6KV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZW4gPSBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgcmV0dXJuIFswLjA0ICogcG9zWzBdIC8gbGVuLCAwLjA0ICogcG9zWzFdIC8gbGVuLCAwXTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY2FudmFzVG9Xb3JsZCh2ZWMyLCBwcm9qZWN0aW9uLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgW3gsIHldID0gdmVjMjtcbiAgICBjb25zdCBuZXdNID0gbmV3IE1hdHJpeDQ7XG4gICAgbmV3TS5zZXRUcmFuc2xhdGUobmV3IFZlY3RvcjMoWzAsIDAsIDAuMDVdKSk7XG4gICAgY29uc3QgbSA9IG5ldyBNYXRyaXg0KHByb2plY3Rpb24pO1xuICAgIG0ubXVsdGlwbHkobmV3TSk7XG4gICAgY29uc3QgbXAgPSBtLm11bHRpcGx5VmVjdG9yNChuZXcgVmVjdG9yNChbMCwgMCwgMCwgMV0pKTtcbiAgICBtcC5lbGVtZW50c1swXSA9ICgyICogeCAvIHdpZHRoIC0gMSkgKiBtcC5lbGVtZW50c1szXTtcbiAgICBtcC5lbGVtZW50c1sxXSA9ICgtMiAqIHkgLyBoZWlnaHQgKyAxKSAqIG1wLmVsZW1lbnRzWzNdO1xuICAgIGNvbnN0IHYgPSBtLmludmVydCgpLm11bHRpcGx5VmVjdG9yNChtcCk7XG4gICAgcmV0dXJuIFt2LmVsZW1lbnRzWzBdLCB2LmVsZW1lbnRzWzFdXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVQcm9qZWN0aW9uKGNhbSkge1xuICAgIGNvbnN0IHsgYXNwZWN0LCB6b29tIH0gPSBjYW07XG4gICAgbGV0IHByb2o7XG4gICAgaWYgKGNhbS50eXBlID09PSAncGVyc3BlY3RpdmUnICYmIGNhbS5wZXJzcGVjdGl2ZSkge1xuICAgICAgICBjb25zdCB7IHlmb3YgfSA9IGNhbS5wZXJzcGVjdGl2ZTtcbiAgICAgICAgY29uc3QgeGZvdiA9IHlmb3YgKiBhc3BlY3Q7XG4gICAgICAgIHByb2ogPSBuZXcgTWF0cml4NCgpLnNldFBlcnNwZWN0aXZlKHhmb3YgKiB6b29tICogKDE4MCAvIE1hdGguUEkpLCBhc3BlY3QsIGNhbS5wZXJzcGVjdGl2ZS56bmVhciB8fCAxLCBjYW0ucGVyc3BlY3RpdmUuemZhciB8fCAyZTYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjYW0udHlwZSA9PT0gJ29ydGhvZ3JhcGhpYycgJiYgY2FtLm9ydGhvZ3JhcGhpYykge1xuICAgICAgICBwcm9qID0gbmV3IE1hdHJpeDQoKS5zZXRPcnRobyhjYW0ub3J0aG9ncmFwaGljLnhtYWcsIGNhbS5vcnRob2dyYXBoaWMueW1hZywgY2FtLm9ydGhvZ3JhcGhpYy56bmVhciwgY2FtLm9ydGhvZ3JhcGhpYy56ZmFyKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2o7XG59XG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KGEgPSAwLCBiID0gMCkge1xuICAgIHJldHVybiBhICsgYjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVJbmRleChuYW1lKSB7XG4gICAgbGV0IGluZGV4O1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlICdQT1NJVElPTic6XG4gICAgICAgICAgICBpbmRleCA9IFswLCAzLCBnbC5GTE9BVF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTk9STUFMJzpcbiAgICAgICAgICAgIGluZGV4ID0gWzEsIDMsIGdsLkZMT0FUXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdURVhDT09SRF8wJzpcbiAgICAgICAgICAgIGluZGV4ID0gWzIsIDIsIGdsLkZMT0FUXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdKT0lOVFNfMCc6XG4gICAgICAgICAgICBpbmRleCA9IFszLCA0LCBnbC5VTlNJR05FRF9TSE9SVF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnV0VJR0hUU18wJzpcbiAgICAgICAgICAgIGluZGV4ID0gWzQsIDQsIGdsLkZMT0FUXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdUQU5HRU5UJzpcbiAgICAgICAgICAgIGluZGV4ID0gWzUsIDQsIGdsLkZMT0FUXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQmlub3JtYWxzKGluZGV4LCB2ZXJ0ZXgsIG5vcm1hbCwgdXYpIHtcbiAgICBjb25zdCB0YW5nZW50ID0gbmV3IEZsb2F0MzJBcnJheShub3JtYWwubGVuZ3RoIC8gMyAqIDQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXgubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY29uc3QgZmFjZUluZGV4ZXMgPSBbaW5kZXhbaV0sIGluZGV4W2kgKyAxXSwgaW5kZXhbaSArIDJdXTtcbiAgICAgICAgY29uc3QgZmFjZVZlcnRpY2VzID0gZmFjZUluZGV4ZXMubWFwKGl4ID0+IHZlY3RvckZyb21BcnJheSh2ZXJ0ZXgsIGl4KSk7XG4gICAgICAgIGNvbnN0IGZhY2VVVnMgPSBmYWNlSW5kZXhlcy5tYXAoaXggPT4gdmVjdG9yRnJvbUFycmF5KHV2LCBpeCwgMikpO1xuICAgICAgICBjb25zdCBkdjEgPSBmYWNlVmVydGljZXNbMV0uc3VidHJhY3QoZmFjZVZlcnRpY2VzWzBdKTtcbiAgICAgICAgY29uc3QgZHYyID0gZmFjZVZlcnRpY2VzWzJdLnN1YnRyYWN0KGZhY2VWZXJ0aWNlc1swXSk7XG4gICAgICAgIGNvbnN0IGR1djEgPSBmYWNlVVZzWzFdLnN1YnRyYWN0KGZhY2VVVnNbMF0pO1xuICAgICAgICBjb25zdCBkdXYyID0gZmFjZVVWc1syXS5zdWJ0cmFjdChmYWNlVVZzWzBdKTtcbiAgICAgICAgbGV0IHIgPSAoZHV2MS5lbGVtZW50c1swXSAqIGR1djIuZWxlbWVudHNbMV0gLSBkdXYxLmVsZW1lbnRzWzFdICogZHV2Mi5lbGVtZW50c1swXSk7XG4gICAgICAgIHIgPSAociAhPT0gMCkgPyAxLjAgLyByIDogMS4wO1xuICAgICAgICBjb25zdCB1ZGlyID0gbmV3IFZlY3RvcjMoW1xuICAgICAgICAgICAgKGR1djIuZWxlbWVudHNbMV0gKiBkdjEuZWxlbWVudHNbMF0gLSBkdXYxLmVsZW1lbnRzWzFdICogZHYyLmVsZW1lbnRzWzBdKSAqIHIsXG4gICAgICAgICAgICAoZHV2Mi5lbGVtZW50c1sxXSAqIGR2MS5lbGVtZW50c1sxXSAtIGR1djEuZWxlbWVudHNbMV0gKiBkdjIuZWxlbWVudHNbMV0pICogcixcbiAgICAgICAgICAgIChkdXYyLmVsZW1lbnRzWzFdICogZHYxLmVsZW1lbnRzWzJdIC0gZHV2MS5lbGVtZW50c1sxXSAqIGR2Mi5lbGVtZW50c1syXSkgKiByXG4gICAgICAgIF0pO1xuICAgICAgICB1ZGlyLm5vcm1hbGl6ZSgpO1xuICAgICAgICBmYWNlSW5kZXhlcy5mb3JFYWNoKGl4ID0+IHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVWZWN0b3JJbkFycmF5KHRhbmdlbnQsIGl4LCB1ZGlyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YW5nZW50O1xuICAgIGZ1bmN0aW9uIHZlY3RvckZyb21BcnJheShhcnJheSwgaW5kZXgsIGVsZW1lbnRzID0gMykge1xuICAgICAgICBpbmRleCA9IGluZGV4ICogZWxlbWVudHM7XG4gICAgICAgIGlmIChlbGVtZW50cyA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKFthcnJheVtpbmRleF0sIGFycmF5W2luZGV4ICsgMV0sIGFycmF5W2luZGV4ICsgMl1dKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudHMgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yMihbYXJyYXlbaW5kZXhdLCBhcnJheVtpbmRleCArIDFdXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWNjdW11bGF0ZVZlY3RvckluQXJyYXkoYXJyYXksIGluZGV4LCB2ZWN0b3IsIGVsZW1lbnRzID0gNCwgYWNjdW11bGF0b3IgPSAoYWNjLCB4KSA9PiBhY2MgKyB4KSB7XG4gICAgICAgIGluZGV4ID0gaW5kZXggKiBlbGVtZW50cztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50czsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMykge1xuICAgICAgICAgICAgICAgIGFycmF5W2luZGV4ICsgaV0gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2luZGV4ICsgaV0gPSBhY2N1bXVsYXRvcihhcnJheVtpbmRleCArIGldLCB2ZWN0b3IuZWxlbWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils.ts\n");

/***/ })

/******/ });
});