!function(g,I){"object"==typeof exports&&"object"==typeof module?module.exports=I():"function"==typeof define&&define.amd?define("redcube",[],I):"object"==typeof exports?exports.redcube=I():g.redcube=I()}(window,function(){return function(g){var I={};function C(A){if(I[A])return I[A].exports;var n=I[A]={i:A,l:!1,exports:{}};return g[A].call(n.exports,n,n.exports,C),n.l=!0,n.exports}return C.m=g,C.c=I,C.d=function(g,I,A){C.o(g,I)||Object.defineProperty(g,I,{configurable:!1,enumerable:!0,get:A})},C.r=function(g){Object.defineProperty(g,"__esModule",{value:!0})},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,"a",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p="",C(C.s=5)}([function(module,exports){eval('module.exports = "#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\nin vec2 outUV;\\r\\nin vec3 outPosition;\\r\\n#ifdef TANGENT\\r\\n    in mat3 outTBN;\\r\\n#else\\r\\n    in vec3 outNormal;\\r\\n#endif\\r\\n\\r\\nout vec4 color;\\r\\n\\r\\nuniform Material {\\r\\n    vec4 baseColorFactor;\\r\\n    vec3 lightPos;\\r\\n    vec3 viewPos;\\r\\n};\\r\\nuniform sampler2D baseColorTexture;\\r\\nuniform sampler2D metallicRoughnessTexture;\\r\\nuniform sampler2D normalTexture;\\r\\nuniform sampler2D emissiveTexture;\\r\\nuniform sampler2D occlusionTexture;\\r\\n\\r\\nconst float PI = 3.14159265359;\\r\\nconst float ambientStrength = 0.1;\\r\\nconst float specularStrength = 0.5;\\r\\nconst float specularPower = 32.0;\\r\\nconst vec3 lightColor = vec3(1.0, 1.0, 1.0);\\r\\nconst vec3 emissiveFactor = vec3(1.0, 1.0, 1.0);\\r\\n\\r\\nvec3 srgbToLinear(vec4 srgbIn) {\\r\\n    return pow(srgbIn.rgb, vec3(2.2));\\r\\n}\\r\\n\\r\\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\\r\\n    float a = roughness*roughness;\\r\\n    float a2 = max(a*a, 0.0001);\\r\\n    float NdotH = max(dot(N, H), 0.0);\\r\\n    float NdotH2 = NdotH*NdotH;\\r\\n\\r\\n    float nom   = a2;\\r\\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\\r\\n    denom = PI * denom * denom;\\r\\n\\r\\n    return nom / max(denom, 0.0001);\\r\\n}\\r\\n\\r\\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\\r\\n    float r = (roughness + 1.0);\\r\\n    float k = (r*r) / 8.0;\\r\\n\\r\\n    float nom   = NdotV;\\r\\n    float denom = NdotV * (1.0 - k) + k;\\r\\n\\r\\n    return nom / denom;\\r\\n}\\r\\n\\r\\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\\r\\n    float NdotV = max(dot(N, V), 0.0);\\r\\n    float NdotL = max(dot(N, L), 0.0);\\r\\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\\r\\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\\r\\n\\r\\n    return ggx1 * ggx2;\\r\\n}\\r\\n\\r\\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\\r\\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    #ifdef BASECOLORTEXTURE\\r\\n        vec3 baseColor = srgbToLinear(texture(baseColorTexture, outUV));\\r\\n        float alpha = texture(baseColorTexture, outUV).a;\\r\\n    #else\\r\\n        vec3 baseColor = baseColorFactor.rgb;\\r\\n        float alpha = baseColorFactor.a;\\r\\n    #endif\\r\\n\\r\\n    #ifdef OCCLUSIONMAP\\r\\n        float ao = texture(occlusionTexture, outUV).r;\\r\\n    #endif\\r\\n\\r\\n    #ifdef METALROUGHNESSMAP\\r\\n        float roughness = texture(metallicRoughnessTexture, outUV).g;\\r\\n        float metallic = texture(metallicRoughnessTexture, outUV).b;\\r\\n    #endif\\r\\n\\r\\n    #ifdef TANGENT\\r\\n        #ifdef NORMALMAP\\r\\n            vec3 n = texture(normalTexture, outUV).rgb;\\r\\n            n = normalize(outTBN * (2.0 * n - 1.0));\\r\\n        #else\\r\\n            vec3 n = outTBN[2].xyz;\\r\\n        #endif\\r\\n    #else\\r\\n        vec3 n = outNormal;\\r\\n    #endif\\r\\n\\r\\n    vec3 viewDir = normalize(viewPos - outPosition);\\r\\n    vec3 lightDir = normalize(lightPos - outPosition);\\r\\n    vec3 H = normalize(viewDir + lightDir);\\r\\n    float distance = length(lightPos - outPosition);\\r\\n    float attenuation = 1.0 / (distance * distance);\\r\\n    vec3 radiance = lightColor * 2.0;\\r\\n\\r\\n    #ifdef USE_PBR\\r\\n        vec3 F0 = vec3(0.04); \\r\\n        F0 = mix(F0, baseColor, metallic);\\r\\n\\r\\n        vec3 light = vec3(0.0);\\r\\n\\r\\n        float NDF = DistributionGGX(n, H, roughness);        \\r\\n        float G = GeometrySmith(n, viewDir, lightDir, roughness);      \\r\\n        vec3 F = fresnelSchlick(max(dot(H, viewDir), 0.0), F0);       \\r\\n        \\r\\n        vec3 kS = F;\\r\\n        vec3 kD = vec3(1.0) - kS;\\r\\n        kD *= 1.0 - metallic;     \\r\\n        \\r\\n        vec3 nominator = NDF * G * F;\\r\\n        float denominator = 4.0 * max(dot(n, viewDir), 0.0) * max(dot(n, lightDir), 0.0);\\r\\n        vec3 specular = nominator / max(denominator, 0.001);  \\r\\n\\r\\n        float NdotL = max(dot(n, lightDir), 0.0);                \\r\\n        light += (kD * baseColor / PI + specular) * radiance * NdotL;\\r\\n\\r\\n        #ifdef OCCLUSIONMAP\\r\\n            vec3 ambient = vec3(0.03) * baseColor * ao;\\r\\n        #else\\r\\n            vec3 ambient = baseColor;\\r\\n        #endif\\r\\n        baseColor = ambient + light;\\r\\n\\r\\n        #ifdef EMISSIVEMAP\\r\\n            vec3 emissive = srgbToLinear(texture(emissiveTexture, outUV)) * emissiveFactor;\\r\\n            baseColor.rgb += emissive;\\r\\n        #endif\\r\\n\\r\\n        baseColor = baseColor / (baseColor + vec3(1.0));\\r\\n        baseColor = pow(baseColor, vec3(1.0 / 2.2));  \\r\\n   \\r\\n        color = vec4(baseColor, 1.0);\\r\\n    #else\\r\\n        vec3 ambient = ambientStrength * lightColor;\\r\\n\\r\\n        float diff = max(dot(n, lightDir), 0.0);\\r\\n        vec3 diffuse = diff * lightColor;\\r\\n\\r\\n        vec3 reflectDir = reflect(-lightDir, n);\\r\\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), specularPower);\\r\\n        vec3 specular = specularStrength * spec * lightColor;\\r\\n\\r\\n        color = vec4(baseColor.rgb * (ambient + diffuse + specular), alpha);\\r\\n    #endif\\r\\n}\\r\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGN1YmUvLi9zcmMvc2hhZGVycy9mcmFnbWVudC5nbHNsPzk4ZjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDMwMCBlc1xcclxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXHJcXG5cXHJcXG5pbiB2ZWMyIG91dFVWO1xcclxcbmluIHZlYzMgb3V0UG9zaXRpb247XFxyXFxuI2lmZGVmIFRBTkdFTlRcXHJcXG4gICAgaW4gbWF0MyBvdXRUQk47XFxyXFxuI2Vsc2VcXHJcXG4gICAgaW4gdmVjMyBvdXROb3JtYWw7XFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxub3V0IHZlYzQgY29sb3I7XFxyXFxuXFxyXFxudW5pZm9ybSBNYXRlcmlhbCB7XFxyXFxuICAgIHZlYzQgYmFzZUNvbG9yRmFjdG9yO1xcclxcbiAgICB2ZWMzIGxpZ2h0UG9zO1xcclxcbiAgICB2ZWMzIHZpZXdQb3M7XFxyXFxufTtcXHJcXG51bmlmb3JtIHNhbXBsZXIyRCBiYXNlQ29sb3JUZXh0dXJlO1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZTtcXHJcXG51bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxUZXh0dXJlO1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIGVtaXNzaXZlVGV4dHVyZTtcXHJcXG51bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25UZXh0dXJlO1xcclxcblxcclxcbmNvbnN0IGZsb2F0IFBJID0gMy4xNDE1OTI2NTM1OTtcXHJcXG5jb25zdCBmbG9hdCBhbWJpZW50U3RyZW5ndGggPSAwLjE7XFxyXFxuY29uc3QgZmxvYXQgc3BlY3VsYXJTdHJlbmd0aCA9IDAuNTtcXHJcXG5jb25zdCBmbG9hdCBzcGVjdWxhclBvd2VyID0gMzIuMDtcXHJcXG5jb25zdCB2ZWMzIGxpZ2h0Q29sb3IgPSB2ZWMzKDEuMCwgMS4wLCAxLjApO1xcclxcbmNvbnN0IHZlYzMgZW1pc3NpdmVGYWN0b3IgPSB2ZWMzKDEuMCwgMS4wLCAxLjApO1xcclxcblxcclxcbnZlYzMgc3JnYlRvTGluZWFyKHZlYzQgc3JnYkluKSB7XFxyXFxuICAgIHJldHVybiBwb3coc3JnYkluLnJnYiwgdmVjMygyLjIpKTtcXHJcXG59XFxyXFxuXFxyXFxuZmxvYXQgRGlzdHJpYnV0aW9uR0dYKHZlYzMgTiwgdmVjMyBILCBmbG9hdCByb3VnaG5lc3MpIHtcXHJcXG4gICAgZmxvYXQgYSA9IHJvdWdobmVzcypyb3VnaG5lc3M7XFxyXFxuICAgIGZsb2F0IGEyID0gbWF4KGEqYSwgMC4wMDAxKTtcXHJcXG4gICAgZmxvYXQgTmRvdEggPSBtYXgoZG90KE4sIEgpLCAwLjApO1xcclxcbiAgICBmbG9hdCBOZG90SDIgPSBOZG90SCpOZG90SDtcXHJcXG5cXHJcXG4gICAgZmxvYXQgbm9tICAgPSBhMjtcXHJcXG4gICAgZmxvYXQgZGVub20gPSAoTmRvdEgyICogKGEyIC0gMS4wKSArIDEuMCk7XFxyXFxuICAgIGRlbm9tID0gUEkgKiBkZW5vbSAqIGRlbm9tO1xcclxcblxcclxcbiAgICByZXR1cm4gbm9tIC8gbWF4KGRlbm9tLCAwLjAwMDEpO1xcclxcbn1cXHJcXG5cXHJcXG5mbG9hdCBHZW9tZXRyeVNjaGxpY2tHR1goZmxvYXQgTmRvdFYsIGZsb2F0IHJvdWdobmVzcykge1xcclxcbiAgICBmbG9hdCByID0gKHJvdWdobmVzcyArIDEuMCk7XFxyXFxuICAgIGZsb2F0IGsgPSAocipyKSAvIDguMDtcXHJcXG5cXHJcXG4gICAgZmxvYXQgbm9tICAgPSBOZG90VjtcXHJcXG4gICAgZmxvYXQgZGVub20gPSBOZG90ViAqICgxLjAgLSBrKSArIGs7XFxyXFxuXFxyXFxuICAgIHJldHVybiBub20gLyBkZW5vbTtcXHJcXG59XFxyXFxuXFxyXFxuZmxvYXQgR2VvbWV0cnlTbWl0aCh2ZWMzIE4sIHZlYzMgViwgdmVjMyBMLCBmbG9hdCByb3VnaG5lc3MpIHtcXHJcXG4gICAgZmxvYXQgTmRvdFYgPSBtYXgoZG90KE4sIFYpLCAwLjApO1xcclxcbiAgICBmbG9hdCBOZG90TCA9IG1heChkb3QoTiwgTCksIDAuMCk7XFxyXFxuICAgIGZsb2F0IGdneDIgPSBHZW9tZXRyeVNjaGxpY2tHR1goTmRvdFYsIHJvdWdobmVzcyk7XFxyXFxuICAgIGZsb2F0IGdneDEgPSBHZW9tZXRyeVNjaGxpY2tHR1goTmRvdEwsIHJvdWdobmVzcyk7XFxyXFxuXFxyXFxuICAgIHJldHVybiBnZ3gxICogZ2d4MjtcXHJcXG59XFxyXFxuXFxyXFxudmVjMyBmcmVzbmVsU2NobGljayhmbG9hdCBjb3NUaGV0YSwgdmVjMyBGMCkge1xcclxcbiAgICByZXR1cm4gRjAgKyAoMS4wIC0gRjApICogcG93KDEuMCAtIGNvc1RoZXRhLCA1LjApO1xcclxcbn1cXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuICAgICNpZmRlZiBCQVNFQ09MT1JURVhUVVJFXFxyXFxuICAgICAgICB2ZWMzIGJhc2VDb2xvciA9IHNyZ2JUb0xpbmVhcih0ZXh0dXJlKGJhc2VDb2xvclRleHR1cmUsIG91dFVWKSk7XFxyXFxuICAgICAgICBmbG9hdCBhbHBoYSA9IHRleHR1cmUoYmFzZUNvbG9yVGV4dHVyZSwgb3V0VVYpLmE7XFxyXFxuICAgICNlbHNlXFxyXFxuICAgICAgICB2ZWMzIGJhc2VDb2xvciA9IGJhc2VDb2xvckZhY3Rvci5yZ2I7XFxyXFxuICAgICAgICBmbG9hdCBhbHBoYSA9IGJhc2VDb2xvckZhY3Rvci5hO1xcclxcbiAgICAjZW5kaWZcXHJcXG5cXHJcXG4gICAgI2lmZGVmIE9DQ0xVU0lPTk1BUFxcclxcbiAgICAgICAgZmxvYXQgYW8gPSB0ZXh0dXJlKG9jY2x1c2lvblRleHR1cmUsIG91dFVWKS5yO1xcclxcbiAgICAjZW5kaWZcXHJcXG5cXHJcXG4gICAgI2lmZGVmIE1FVEFMUk9VR0hORVNTTUFQXFxyXFxuICAgICAgICBmbG9hdCByb3VnaG5lc3MgPSB0ZXh0dXJlKG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSwgb3V0VVYpLmc7XFxyXFxuICAgICAgICBmbG9hdCBtZXRhbGxpYyA9IHRleHR1cmUobWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlLCBvdXRVVikuYjtcXHJcXG4gICAgI2VuZGlmXFxyXFxuXFxyXFxuICAgICNpZmRlZiBUQU5HRU5UXFxyXFxuICAgICAgICAjaWZkZWYgTk9STUFMTUFQXFxyXFxuICAgICAgICAgICAgdmVjMyBuID0gdGV4dHVyZShub3JtYWxUZXh0dXJlLCBvdXRVVikucmdiO1xcclxcbiAgICAgICAgICAgIG4gPSBub3JtYWxpemUob3V0VEJOICogKDIuMCAqIG4gLSAxLjApKTtcXHJcXG4gICAgICAgICNlbHNlXFxyXFxuICAgICAgICAgICAgdmVjMyBuID0gb3V0VEJOWzJdLnh5ejtcXHJcXG4gICAgICAgICNlbmRpZlxcclxcbiAgICAjZWxzZVxcclxcbiAgICAgICAgdmVjMyBuID0gb3V0Tm9ybWFsO1xcclxcbiAgICAjZW5kaWZcXHJcXG5cXHJcXG4gICAgdmVjMyB2aWV3RGlyID0gbm9ybWFsaXplKHZpZXdQb3MgLSBvdXRQb3NpdGlvbik7XFxyXFxuICAgIHZlYzMgbGlnaHREaXIgPSBub3JtYWxpemUobGlnaHRQb3MgLSBvdXRQb3NpdGlvbik7XFxyXFxuICAgIHZlYzMgSCA9IG5vcm1hbGl6ZSh2aWV3RGlyICsgbGlnaHREaXIpO1xcclxcbiAgICBmbG9hdCBkaXN0YW5jZSA9IGxlbmd0aChsaWdodFBvcyAtIG91dFBvc2l0aW9uKTtcXHJcXG4gICAgZmxvYXQgYXR0ZW51YXRpb24gPSAxLjAgLyAoZGlzdGFuY2UgKiBkaXN0YW5jZSk7XFxyXFxuICAgIHZlYzMgcmFkaWFuY2UgPSBsaWdodENvbG9yICogMi4wO1xcclxcblxcclxcbiAgICAjaWZkZWYgVVNFX1BCUlxcclxcbiAgICAgICAgdmVjMyBGMCA9IHZlYzMoMC4wNCk7IFxcclxcbiAgICAgICAgRjAgPSBtaXgoRjAsIGJhc2VDb2xvciwgbWV0YWxsaWMpO1xcclxcblxcclxcbiAgICAgICAgdmVjMyBsaWdodCA9IHZlYzMoMC4wKTtcXHJcXG5cXHJcXG4gICAgICAgIGZsb2F0IE5ERiA9IERpc3RyaWJ1dGlvbkdHWChuLCBILCByb3VnaG5lc3MpOyAgICAgICAgXFxyXFxuICAgICAgICBmbG9hdCBHID0gR2VvbWV0cnlTbWl0aChuLCB2aWV3RGlyLCBsaWdodERpciwgcm91Z2huZXNzKTsgICAgICBcXHJcXG4gICAgICAgIHZlYzMgRiA9IGZyZXNuZWxTY2hsaWNrKG1heChkb3QoSCwgdmlld0RpciksIDAuMCksIEYwKTsgICAgICAgXFxyXFxuICAgICAgICBcXHJcXG4gICAgICAgIHZlYzMga1MgPSBGO1xcclxcbiAgICAgICAgdmVjMyBrRCA9IHZlYzMoMS4wKSAtIGtTO1xcclxcbiAgICAgICAga0QgKj0gMS4wIC0gbWV0YWxsaWM7ICAgICBcXHJcXG4gICAgICAgIFxcclxcbiAgICAgICAgdmVjMyBub21pbmF0b3IgPSBOREYgKiBHICogRjtcXHJcXG4gICAgICAgIGZsb2F0IGRlbm9taW5hdG9yID0gNC4wICogbWF4KGRvdChuLCB2aWV3RGlyKSwgMC4wKSAqIG1heChkb3QobiwgbGlnaHREaXIpLCAwLjApO1xcclxcbiAgICAgICAgdmVjMyBzcGVjdWxhciA9IG5vbWluYXRvciAvIG1heChkZW5vbWluYXRvciwgMC4wMDEpOyAgXFxyXFxuXFxyXFxuICAgICAgICBmbG9hdCBOZG90TCA9IG1heChkb3QobiwgbGlnaHREaXIpLCAwLjApOyAgICAgICAgICAgICAgICBcXHJcXG4gICAgICAgIGxpZ2h0ICs9IChrRCAqIGJhc2VDb2xvciAvIFBJICsgc3BlY3VsYXIpICogcmFkaWFuY2UgKiBOZG90TDtcXHJcXG5cXHJcXG4gICAgICAgICNpZmRlZiBPQ0NMVVNJT05NQVBcXHJcXG4gICAgICAgICAgICB2ZWMzIGFtYmllbnQgPSB2ZWMzKDAuMDMpICogYmFzZUNvbG9yICogYW87XFxyXFxuICAgICAgICAjZWxzZVxcclxcbiAgICAgICAgICAgIHZlYzMgYW1iaWVudCA9IGJhc2VDb2xvcjtcXHJcXG4gICAgICAgICNlbmRpZlxcclxcbiAgICAgICAgYmFzZUNvbG9yID0gYW1iaWVudCArIGxpZ2h0O1xcclxcblxcclxcbiAgICAgICAgI2lmZGVmIEVNSVNTSVZFTUFQXFxyXFxuICAgICAgICAgICAgdmVjMyBlbWlzc2l2ZSA9IHNyZ2JUb0xpbmVhcih0ZXh0dXJlKGVtaXNzaXZlVGV4dHVyZSwgb3V0VVYpKSAqIGVtaXNzaXZlRmFjdG9yO1xcclxcbiAgICAgICAgICAgIGJhc2VDb2xvci5yZ2IgKz0gZW1pc3NpdmU7XFxyXFxuICAgICAgICAjZW5kaWZcXHJcXG5cXHJcXG4gICAgICAgIGJhc2VDb2xvciA9IGJhc2VDb2xvciAvIChiYXNlQ29sb3IgKyB2ZWMzKDEuMCkpO1xcclxcbiAgICAgICAgYmFzZUNvbG9yID0gcG93KGJhc2VDb2xvciwgdmVjMygxLjAgLyAyLjIpKTsgIFxcclxcbiAgIFxcclxcbiAgICAgICAgY29sb3IgPSB2ZWM0KGJhc2VDb2xvciwgMS4wKTtcXHJcXG4gICAgI2Vsc2VcXHJcXG4gICAgICAgIHZlYzMgYW1iaWVudCA9IGFtYmllbnRTdHJlbmd0aCAqIGxpZ2h0Q29sb3I7XFxyXFxuXFxyXFxuICAgICAgICBmbG9hdCBkaWZmID0gbWF4KGRvdChuLCBsaWdodERpciksIDAuMCk7XFxyXFxuICAgICAgICB2ZWMzIGRpZmZ1c2UgPSBkaWZmICogbGlnaHRDb2xvcjtcXHJcXG5cXHJcXG4gICAgICAgIHZlYzMgcmVmbGVjdERpciA9IHJlZmxlY3QoLWxpZ2h0RGlyLCBuKTtcXHJcXG4gICAgICAgIGZsb2F0IHNwZWMgPSBwb3cobWF4KGRvdCh2aWV3RGlyLCByZWZsZWN0RGlyKSwgMC4wKSwgc3BlY3VsYXJQb3dlcik7XFxyXFxuICAgICAgICB2ZWMzIHNwZWN1bGFyID0gc3BlY3VsYXJTdHJlbmd0aCAqIHNwZWMgKiBsaWdodENvbG9yO1xcclxcblxcclxcbiAgICAgICAgY29sb3IgPSB2ZWM0KGJhc2VDb2xvci5yZ2IgKiAoYW1iaWVudCArIGRpZmZ1c2UgKyBzcGVjdWxhciksIGFscGhhKTtcXHJcXG4gICAgI2VuZGlmXFxyXFxufVxcclxcblwiIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n')},function(module,exports){eval('module.exports = "#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\nlayout (location = 0) in vec3 inPosition;\\r\\nlayout (location = 1) in vec3 inNormal;\\r\\nlayout (location = 2) in vec2 inUV;\\r\\nlayout (location = 3) in vec4 inJoint;\\r\\nlayout (location = 4) in vec4 inWeight;\\r\\nlayout (location = 5) in vec4 inTangent;\\r\\n\\r\\nout vec2 outUV;\\r\\nout vec3 outPosition;\\r\\n#ifdef TANGENT\\r\\n    out mat3 outTBN;\\r\\n#else\\r\\n    out vec3 outNormal;\\r\\n#endif\\r\\n\\r\\nuniform Matrices {\\r\\n    mat4 model;\\r\\n    mat4 normalMatrix;\\r\\n    mat4 view;\\r\\n    mat4 projection;\\r\\n};\\r\\n\\r\\n#ifdef JOINTNUMBER\\r\\nuniform Skin {\\r\\n    mat4 joint[JOINTNUMBER];\\r\\n};\\r\\n#endif\\r\\n\\r\\nvoid main() {\\r\\n    #ifdef JOINTNUMBER\\r\\n        mat4 skin = inWeight.x * joint[int(inJoint.x)];\\r\\n        skin += inWeight.y * joint[int(inJoint.y)];\\r\\n        skin += inWeight.z * joint[int(inJoint.z)];\\r\\n        skin += inWeight.w * joint[int(inJoint.w)];\\r\\n    #else\\r\\n        mat4 skin = mat4(1.0);\\r\\n    #endif\\r\\n\\r\\n    outUV = inUV;\\r\\n    #ifdef TANGENT\\r\\n        vec3 normalW = normalize(vec3(model * vec4(inNormal.xyz, 0.0)));\\r\\n        vec3 tangentW = normalize(vec3(model * vec4(inTangent.xyz, 0.0)));\\r\\n        vec3 bitangentW = cross(normalW, tangentW) * inTangent.w;\\r\\n        outTBN = mat3(tangentW, bitangentW, normalW);\\r\\n    #else\\r\\n        outNormal = normalize(mat3(normalMatrix) * mat3(skin) * inNormal);\\r\\n    #endif\\r\\n    outPosition = vec3(model * skin * vec4(inPosition, 1.0));\\r\\n    gl_Position = projection * view * model * skin * vec4(inPosition, 1.0);\\r\\n}\\r\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGN1YmUvLi9zcmMvc2hhZGVycy92ZXJ0ZXguZ2xzbD8wY2UwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAzMDAgZXNcXHJcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxyXFxuXFxyXFxubGF5b3V0IChsb2NhdGlvbiA9IDApIGluIHZlYzMgaW5Qb3NpdGlvbjtcXHJcXG5sYXlvdXQgKGxvY2F0aW9uID0gMSkgaW4gdmVjMyBpbk5vcm1hbDtcXHJcXG5sYXlvdXQgKGxvY2F0aW9uID0gMikgaW4gdmVjMiBpblVWO1xcclxcbmxheW91dCAobG9jYXRpb24gPSAzKSBpbiB2ZWM0IGluSm9pbnQ7XFxyXFxubGF5b3V0IChsb2NhdGlvbiA9IDQpIGluIHZlYzQgaW5XZWlnaHQ7XFxyXFxubGF5b3V0IChsb2NhdGlvbiA9IDUpIGluIHZlYzQgaW5UYW5nZW50O1xcclxcblxcclxcbm91dCB2ZWMyIG91dFVWO1xcclxcbm91dCB2ZWMzIG91dFBvc2l0aW9uO1xcclxcbiNpZmRlZiBUQU5HRU5UXFxyXFxuICAgIG91dCBtYXQzIG91dFRCTjtcXHJcXG4jZWxzZVxcclxcbiAgICBvdXQgdmVjMyBvdXROb3JtYWw7XFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxudW5pZm9ybSBNYXRyaWNlcyB7XFxyXFxuICAgIG1hdDQgbW9kZWw7XFxyXFxuICAgIG1hdDQgbm9ybWFsTWF0cml4O1xcclxcbiAgICBtYXQ0IHZpZXc7XFxyXFxuICAgIG1hdDQgcHJvamVjdGlvbjtcXHJcXG59O1xcclxcblxcclxcbiNpZmRlZiBKT0lOVE5VTUJFUlxcclxcbnVuaWZvcm0gU2tpbiB7XFxyXFxuICAgIG1hdDQgam9pbnRbSk9JTlROVU1CRVJdO1xcclxcbn07XFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcbiAgICAjaWZkZWYgSk9JTlROVU1CRVJcXHJcXG4gICAgICAgIG1hdDQgc2tpbiA9IGluV2VpZ2h0LnggKiBqb2ludFtpbnQoaW5Kb2ludC54KV07XFxyXFxuICAgICAgICBza2luICs9IGluV2VpZ2h0LnkgKiBqb2ludFtpbnQoaW5Kb2ludC55KV07XFxyXFxuICAgICAgICBza2luICs9IGluV2VpZ2h0LnogKiBqb2ludFtpbnQoaW5Kb2ludC56KV07XFxyXFxuICAgICAgICBza2luICs9IGluV2VpZ2h0LncgKiBqb2ludFtpbnQoaW5Kb2ludC53KV07XFxyXFxuICAgICNlbHNlXFxyXFxuICAgICAgICBtYXQ0IHNraW4gPSBtYXQ0KDEuMCk7XFxyXFxuICAgICNlbmRpZlxcclxcblxcclxcbiAgICBvdXRVViA9IGluVVY7XFxyXFxuICAgICNpZmRlZiBUQU5HRU5UXFxyXFxuICAgICAgICB2ZWMzIG5vcm1hbFcgPSBub3JtYWxpemUodmVjMyhtb2RlbCAqIHZlYzQoaW5Ob3JtYWwueHl6LCAwLjApKSk7XFxyXFxuICAgICAgICB2ZWMzIHRhbmdlbnRXID0gbm9ybWFsaXplKHZlYzMobW9kZWwgKiB2ZWM0KGluVGFuZ2VudC54eXosIDAuMCkpKTtcXHJcXG4gICAgICAgIHZlYzMgYml0YW5nZW50VyA9IGNyb3NzKG5vcm1hbFcsIHRhbmdlbnRXKSAqIGluVGFuZ2VudC53O1xcclxcbiAgICAgICAgb3V0VEJOID0gbWF0Myh0YW5nZW50VywgYml0YW5nZW50Vywgbm9ybWFsVyk7XFxyXFxuICAgICNlbHNlXFxyXFxuICAgICAgICBvdXROb3JtYWwgPSBub3JtYWxpemUobWF0Myhub3JtYWxNYXRyaXgpICogbWF0Myhza2luKSAqIGluTm9ybWFsKTtcXHJcXG4gICAgI2VuZGlmXFxyXFxuICAgIG91dFBvc2l0aW9uID0gdmVjMyhtb2RlbCAqIHNraW4gKiB2ZWM0KGluUG9zaXRpb24sIDEuMCkpO1xcclxcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb24gKiB2aWV3ICogbW9kZWwgKiBza2luICogdmVjNChpblBvc2l0aW9uLCAxLjApO1xcclxcbn1cXHJcXG5cIiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')},function(module,exports){eval('module.exports = "#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\nin vec2 outUV;\\r\\nout vec4 color;\\r\\n\\r\\nuniform sampler2D diffuse;\\r\\nuniform float level;\\r\\n\\r\\nvoid main() {\\r\\n    vec2 texelSize = 1.0 / vec2(textureSize(diffuse, 0));\\r\\n    vec3 result = vec3(0.0);\\r\\n    for (int x = -2; x < 2; ++x) \\r\\n    {\\r\\n        for (int y = -2; y < 2; ++y) \\r\\n        {\\r\\n            vec2 offset = vec2(float(x), float(y)) * texelSize;\\r\\n            result += textureLod(diffuse, outUV + offset, level).rgb;\\r\\n        }\\r\\n    }\\r\\n    color = vec4(result / 16.0, 1.0);\\r\\n}\\r\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGN1YmUvLi9zcmMvc2hhZGVycy9ibHVyRW52Lmdsc2w/YjcxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMzAwIGVzXFxyXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcclxcblxcclxcbmluIHZlYzIgb3V0VVY7XFxyXFxub3V0IHZlYzQgY29sb3I7XFxyXFxuXFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgZGlmZnVzZTtcXHJcXG51bmlmb3JtIGZsb2F0IGxldmVsO1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG4gICAgdmVjMiB0ZXhlbFNpemUgPSAxLjAgLyB2ZWMyKHRleHR1cmVTaXplKGRpZmZ1c2UsIDApKTtcXHJcXG4gICAgdmVjMyByZXN1bHQgPSB2ZWMzKDAuMCk7XFxyXFxuICAgIGZvciAoaW50IHggPSAtMjsgeCA8IDI7ICsreCkgXFxyXFxuICAgIHtcXHJcXG4gICAgICAgIGZvciAoaW50IHkgPSAtMjsgeSA8IDI7ICsreSkgXFxyXFxuICAgICAgICB7XFxyXFxuICAgICAgICAgICAgdmVjMiBvZmZzZXQgPSB2ZWMyKGZsb2F0KHgpLCBmbG9hdCh5KSkgKiB0ZXhlbFNpemU7XFxyXFxuICAgICAgICAgICAgcmVzdWx0ICs9IHRleHR1cmVMb2QoZGlmZnVzZSwgb3V0VVYgKyBvZmZzZXQsIGxldmVsKS5yZ2I7XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgY29sb3IgPSB2ZWM0KHJlc3VsdCAvIDE2LjAsIDEuMCk7XFxyXFxufVxcclxcblwiIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n')},function(module,exports){eval('module.exports = "#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\nlayout (location = 0) in vec3 inPosition;\\r\\nlayout (location = 1) in vec2 inUV;\\r\\n\\r\\nuniform mat4 MVPMatrix;\\r\\n\\r\\nout vec2 outUV;\\r\\n\\r\\nvoid main() {\\r\\n\\toutUV = inUV;\\r\\n    gl_Position = MVPMatrix * vec4(inPosition, 1.0);\\r\\n}\\r\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGN1YmUvLi9zcmMvc2hhZGVycy9lbnYuZ2xzbD80MjgzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAzMDAgZXNcXHJcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxyXFxuXFxyXFxubGF5b3V0IChsb2NhdGlvbiA9IDApIGluIHZlYzMgaW5Qb3NpdGlvbjtcXHJcXG5sYXlvdXQgKGxvY2F0aW9uID0gMSkgaW4gdmVjMiBpblVWO1xcclxcblxcclxcbnVuaWZvcm0gbWF0NCBNVlBNYXRyaXg7XFxyXFxuXFxyXFxub3V0IHZlYzIgb3V0VVY7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcdG91dFVWID0gaW5VVjtcXHJcXG4gICAgZ2xfUG9zaXRpb24gPSBNVlBNYXRyaXggKiB2ZWM0KGluUG9zaXRpb24sIDEuMCk7XFxyXFxufVxcclxcblwiIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n')},function(module,exports){eval('module.exports = "data:image/jpeg;base64,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"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGN1YmUvLi9zcmMvaW1hZ2VzL2Vudi5qcGc/MGRjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFBQUFBQUQvNFFHbFJYaHBaZ0FBU1VrcUFBZ0FBQUFFQUJJQkF3QUJBQUFBQVFBQUFERUJBZ0NWQUFBQVBnQUFBRElCQWdBVUFBQUEwd0FBQUdtSEJBQUJBQUFBWndFQUFBQUFBQUJQY0dWdVNXMWhaMlZKVHlBeExqVXVNVFlnT2lCdmFXbHZkRzl2YkNBdmRHMXdMMjl5YVdkcGJtRnNYM0JoYm05eVlXMWhMblJwWmlBdExYSmxjMmw2WlNBeU5UWjRNVEk0SUMwdFkzQnZkeUF3TGpRMU5EVTBOVFExTERBdU5EVTBOVFExTkRVc01DNDBOVFExTkRVME5Td3hMakFnTFc4Z0wzUnRjQzlrWVhSaEwzUm9kVzFpYm1GcGJGOHlOVFl1YW5CbkFESXdNVGM2TURZNk1UUWdNVFE2TVRNNk1qUUFiMmxwYjNSdmIyd2dMM1J0Y0M5dmNtbG5hVzVoYkY5d1lXNXZjbUZ0WVM1MGFXWWdMUzF5WlhOcGVtVWdNalUyZURFeU9DQXRMV053YjNjZ01DNDBOVFExTkRVME5Td3dMalExTkRVME5UUTFMREF1TkRVME5UUTFORFVzTVM0d0lDMXZJQzkwYlhBdlpHRjBZUzkwYUhWdFltNWhhV3hmTWpVMkxtcHdad0FFQUFDUUJ3QUVBQUFBTURJeU1BR1JCd0FFQUFBQUFRSURBQk9TQWdDQUFBQUE1d0FBQUFDZ0J3QUVBQUFBTURFd01BQUFBQUQvN1FGSFVHaHZkRzl6YUc5d0lETXVNQUE0UWtsTkJBUUFBQUFBQVNzY0FrRUFqVTl3Wlc1SmJXRm5aVWxQSURFdU5TNHhOaUE2SUc5cGFXOTBiMjlzSUMxMklDOWtZWFJoTDJZME1XWmhNMlJoTWpWbFpUUTBObUpoTWpBek5qQm1OamszTm1Vek1ERTRMbVY0Y2lBdExXTnNZVzF3T20xaGVEMHhPQzQ0T1RBMk1qVWdMUzFqYkdGdGNEcHRhVzQ5TUNBdGJ5QXZkRzF3TDI5eWFXZHBibUZzWDNCaGJtOXlZVzFoTG5ScFpod0NRUUNVVDNCbGJrbHRZV2RsU1U4Z01TNDFMakUySURvZ2IybHBiM1J2YjJ3Z0wzUnRjQzl2Y21sbmFXNWhiRjl3WVc1dmNtRnRZUzUwYVdZZ0xTMXlaWE5wZW1VZ01qVTJlREV5T0NBdExXTndiM2NnTUM0ME5UUTFORFUwTlN3d0xqUTFORFUwTlRRMUxEQXVORFUwTlRRMU5EVXNNUzR3SUMxdklDOTBiWEF2WkdGMFlTOTBhSFZ0WW01aGFXeGZNalUyTG1wd1ovL2hBWjVvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2QUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1TlMxak1EQXlJREV1TVRRNE1ESXlMQ0F5TURFeUx6QTNMekUxTFRFNE9qQTJPalExSUNBZ0lDQWdJQ0FpUGlBOGNtUm1PbEpFUmlCNGJXeHVjenB5WkdZOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6RTVPVGt2TURJdk1qSXRjbVJtTFhONWJuUmhlQzF1Y3lNaVBpQThjbVJtT2tSbGMyTnlhWEIwYVc5dUlISmtaanBoWW05MWREMGlJaUI0Yld4dWN6cDRiWEE5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM4aUlIaHRjRHBEY21WaGRHVkVZWFJsUFNJeU1ERTNPakEyT2pFMElERTBPakV6T2pJMElpOCtJQ0E4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKM0lqOCsvOXNBUXdBQkFRRUJBUUVCQVFFQkFRRUJBUUVDQVFFQkFRRUNBUUVCQWdJQ0FnSUNBZ0lDQXdNRUF3TURBd01DQWdNRUF3TUVCQVFFQkFJREJRVUVCQVVFQkFRRS85c0FRd0VCQVFFQkFRRUNBUUVDQkFNQ0F3UUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFLzhBQUVRZ0FnQUVBQXdFaUFBSVJBUU1SQWYvRUFCOEFBQUVGQVFFQkFRRUJBQUFBQUFBQUFBQUJBZ01FQlFZSENBa0tDLy9FQUxVUUFBSUJBd01DQkFNRkJRUUVBQUFCZlFFQ0F3QUVFUVVTSVRGQkJoTlJZUWNpY1JReWdaR2hDQ05Dc2NFVlV0SHdKRE5pY29JSkNoWVhHQmthSlNZbktDa3FORFUyTnpnNU9rTkVSVVpIU0VsS1UxUlZWbGRZV1ZwalpHVm1aMmhwYW5OMGRYWjNlSGw2ZzRTRmhvZUlpWXFTazVTVmxwZVltWnFpbzZTbHBxZW9xYXF5czdTMXRyZTR1YnJDdzhURnhzZkl5Y3JTMDlUVjF0ZlkyZHJoNHVQazVlYm42T25xOGZMejlQWDI5L2o1K3YvRUFCOEJBQU1CQVFFQkFRRUJBUUVBQUFBQUFBQUJBZ01FQlFZSENBa0tDLy9FQUxVUkFBSUJBZ1FFQXdRSEJRUUVBQUVDZHdBQkFnTVJCQVVoTVFZU1FWRUhZWEVUSWpLQkNCUkNrYUd4d1Frak0xTHdGV0p5MFFvV0pEVGhKZkVYR0JrYUppY29LU28xTmpjNE9UcERSRVZHUjBoSlNsTlVWVlpYV0ZsYVkyUmxabWRvYVdwemRIVjJkM2g1ZW9LRGhJV0doNGlKaXBLVGxKV1dsNWlabXFLanBLV21wNmlwcXJLenRMVzJ0N2k1dXNMRHhNWEd4OGpKeXRMVDFOWFcxOWpaMnVMajVPWG01K2pwNnZMejlQWDI5L2o1K3YvYUFBd0RBUUFDRVFNUkFEOEEvdTMvQU9GbWVHeGdTalVZU2Vva3N3ZHYxd3gvVE5Yb1BpRDRObFhmSjRoMHl5WEdjNmpjZjJjRjltTW9VQStuUE5mTGw5ZDZnZ0tzZk5BNmhodi9BSjF5bHhlQnlkeUdGaDFlUEtIOHEvVTZmQStYWWlONHprdlJwL21qK1ljTDR3Y1YwcHAxNFVxa2VxY1duOG5HUy9KbjI1RDQwOEhYRCtYYitMUERVNy8zSWRkdFpYL0lQVzFhMzlqZW1RV1Y3YVhaaHg1d3RibExneGJzN2QyMG5HZHJZejZHdnp0dXJtVkFXRXpTeDV5Zm15eS9VVkZZK0w5VDBtYUs0MHpWOVQwdWVDWHpvMjA2L2UxalpncFVHV0xKaG1VYmlmTHVFa2p5QVNoSUdOYW5ocEdyVGJ3ZUlmTjA1bHBmenRaL2hwdnJzZTVoUEduR0t2SDY5Z1kreisxeVNmTmJ5NXRMK3JWOXJyZGZwRlhQWE54NHJTK0VkbnBIaDY1MDB5QU5kWFBpTzVzYjVFNHlSQXRqSWpIcng1aWpqcnp4OFd2KzBMOFFkTnNJcmUzMVRRTlF1SW9oR05UOFJlR20xQzZ1Q0Rsbm1qdExtemlMSGtmdTFqVVpIeUh2Y1A3VlhpZ1dTUUhSdkM0MUZaZDB1cEJMdHJPVk1uNUZzZk5ESVFNZk9ibDgvd0J3VjUxUHcwNG1nK2FGS25WVGR2aWtrbC9OOWgvSlhmZUo5TlY4VitGY1pUaXZiMThQSmE2VTZiYi9BTHJ1cXNmbm91MGo3a0FmSnl5RWZ3Z0lRUjllYWoyM084RXl3Yk82L1oyRG44ZC85SytQZEgvYWR2YmlLOGcxZlRkUFc2ZEZiVEx2U0lTSVluQkJLVHd5em5lcmNnbEpFWURJQXo4dzZqd3Q0eStJWHhMdlZHbGVOdkMvaGdXQmt0N3Uwc0xlMmx2WnlZMGVPNE9tM0VjOHMwVzUxVGZGZFc2LzZ3WlprSVBtWWpnWFBjREdkWE1PU2xUanZLVGJqYTE3cmxqSitXMTc5TmowcVhpVnczanF0TERaWkN0WHJTZWtJSlJkNzJzM1VxVTQ5bnJMbHM5NzNTK29hS3BDM3VuczRJSmIrVkx0RWpGeGZXa0VVVFR1dTN6Q0kzV1JWVnlEOHZKQWJoczROWE9jSG9EemorSWUxZkd1S1d6VCsvNzl1djM5MGo5RmhVbEw0b05hSjYyNjdyUnZWZGVtdWpldG8zTXdZQ09PSmx4eVhtTWJBK3dDbitkUTNWeWJXM003L1oxQ1kzbWFkbzQxeng5NElUK2xVdFgxZXowUFRadFYxVFV0SjB1eHRTa2R6ZTYxZUxvK25SdkpLa0tiN2h6dFRjN3FxZ2c3bWRRRHlEWENTZUtybHZDRUw2bmVlRnRjMTJkMmh1MDhKYXRNdWt1cGtmeTVJV3hKSnhINVRORzNHV1liaU1FK2hoTXZyNHFNYXNJWGh6cVBYVnZWNzZhSzEzZFd1dTU4N25mRU9DeWluV2pYcjhsUlVwVkZ6VzVWYXlqc25KdVVycEpLVGZMTHNyOWpINGwwMEQvU2JxMGpQWE50TTkwbyt2eUsyVDlDT090YUZuckdsNmc3UjJkL2EzRXNiYkpJVW1IbnhuYUh3eUg1Z2RwRFlJNkVIcFhpT2w2enA4S3lMcW5oZTh1bWM3dnROcnFXKzRYcmhVaWs4dEZBNE9kK1d5Y2poUlhvMmcrS2RCaHNkTzA3enI2MU1GbWtMeTZ0YlJ3U2IxVUFtNGtpSGtCMndYWm84UjVZNElQeTE2R1B5WjRlTW5ScHpiOG5GcTNmVG1kdlcyL3lQaStGK1A1NW5WaEhOTWJob1FhMmFuR3B6WFM1VzUremdtNzN2RlRXalhtZDFSVk9IVUxTNW5lM3Q1MG1saVFTU2JNc2dVamdoOGJUMUhBUEdhdVY4L0tFb08wMVpuNnRScjBNUkZ6dzgxS0tiVjAwMWRhTlhYVlBSOW1GRkZGU2FoUlJSUUFVVVVVQUZGUlBOR2piQ1dMOEVwR2pTdW9PN0JJVUVnSGEyQ2VPRFV0TnByY21NNFNiakZwdGIrUVVVVVVpZ29ySjFmN1g1Sy9aWGxRWi9lR0loV1BJQ2dITzdyMlVjOXoyUEIzTXQ3ODhjbHplc3I1V1NON3lWME9lQ0NwYkdQYnBYZmhjQzhUSG1VMHZ4UGs4OTRwamtsWjBaWWFVOU43MlR2MmRuNlB6dm9laGFscTJsYU5ibTcxZlU5UDBxMFg3MTFxVjdIWTI2OU9ydVFPNDc5NnpyYnhkNFV2RkQyZmlmdzlkS3piRmEyMXEyblVuR2NBcTU1eDJyekY3Wll5VEdpeGsvd0J3YlNmeXFqTEd4emtzZmNzVFhzMHNqd2tvV25PVGwzMFMrNnovQVBTdmtmbkdPOFZNNW8xWEtoZzZhaDJibEovK0JMbFh5NU5PN08rMXI0ZzJtbE9pMk9nNjk0a1ZseTh1aXZwME1jSnlRUTMydTdnSnhnSEtnakREQlBPS2xwOFRMS2NNYnJ3MzRtMHZBSkF2QnAwNWZIWWVSZVMvcml2UEpJai9BTFF6MXdhd3J5SzVUSmpta0F4a0RmWHIwTWl5eWROVVpROTcrYThydjhlWC93QWxQamNSNHM4WC9XSE9Fb1JUK3p5UmNWNlhYTjk4bVltclcwMFFiRVRZSnhrak9hODMxQlRKSXdaVHkyTURnL2hYMkRQNFVzWmJ1Q3cxTmJ0VGV4TzF2TFlXOGx6Ykt5WXlKSlJIdGo0WlNQTTJodVFDU0RqNWsrSVduRFFwYjJleDFLMHZySzExS1RTNVluZzhuV0ZrZ1NacDMrekFsakVwaFpCTHdIWmdGWEJCUDEzRG1jME1iWFdGaHBLMmpzN1BXMmp0YmRQN24yWjg3blBDdWFaSlFXSnhrRW9jemp1dVpOSlMxaGZtVjAwNzIyYTdxLzRqL3RVZjhGQWZHM3dXK09lcGVEL2gzSjhMdkYvZ2ZSZkQxc05YaDFlMHVMbS9oMVpqTjUwSzZyYTN1d1JzQkN1eDRRMGJoZ1djRWJmR2RQOEErQ3J1cFhQaTJ5Zld2aHg0T2o4RjZoYUpMZVdXaytKcm0wOFdhRTZxcTNUckxNR2d1WW8zWU1DWTRXS3ZnOGpKL0xmL0FJS1Izbnd0OFgvdEErSk5VK0QvQUlqMFBTdkJIaWV6Z3ZaUm90amQrSHJFYW5jUnUycXhYVUxSaDdOMXVpOGx3MnhBSGJvR1Z4WDU5M01Yanp5N3BkRThMK0hMcTZzN0pManhkNHMweExyWGRMMGUwdHJlZEk0WmZLUjlrRS8yY0o5b1pOa2trMEdXWEoyL3paVjhUdkViRmNVNCtqd3ZtWE5CVjZrYVVJS25WcFNqVGswbkNVcWQ1UWF0OE1yY3I1N0sxMSt1NERnL2hxcmsrSG5qY0xhYmhIbWN1YUVydEs5MG1yU3Y1WHZwcWYzSStFL2lCNFQrSm5oaXo4WGVBZkV1bGVLZkRXb3g3N1RWTkp2RnVZMVljUEZLbythT1JHeWp4eUJXVmxJSTRxUjU1dHpETERIdmpOZmhoL3dSRzhVK1A5YjhOK09ORzFuVC9IY3ZobzNrTnphVzd4YWRaZUcvQTRhMDNSdzZ2Wk9pWHNOMWRYQ1haVm8ya0NQSElraUpuYzM3MlM2UzRMazV5VG5sZUsvdXJnWGlLcG4vQUEzaGMxekNsN0t2T1B2UnMwdVpQbGJpbTVQa2sxelI5NXRKcE50cG40YnhIbGRMSnMzclpmU256eGk5SDFzMWRKN2FyWjZMdnNWZE4xYUsxVzdGeFpXMTgwMW8wRUJ1cm1lRDdJN01wRTBmbHNOenJnZ0NUS2ZNY3FlTWVxK0Z2anA0bCtGTnd1bWYyVG9tbnBOcmVuemEvSTNoNDY3SHFHbldyN2JwTE1RMzl1Z3ZKbzJsalMrTHpSSTVEdkJQdEtIeGg5TWxhUmdjL1FIaW81dEVVdy9ORmxRY0lvT0F2cnhYMDJOeXZKODBnOFBtVVZPbEsxNHU3MVZyV3U3SzFyMjVYZDJmVFh6OEZtV0t5NnRIRllHYmhWanRKT3pWMVo2clhWTzIremE2bjZOK0ZmMnIvZ2pld2FicGtjMnIrRDRFdHhhV2RocWZoMW9iSFRZNGNSd3dsck16UVJMc1ViQnVDS3FnRXFjS2QvWC9BTm92d2JicFovOEFDS1RmOEpOUEpLV3VrbHRyclI3Skk5aHdCY1NRNURsbVFqWkhLTUl3WUlXVmgrWDlsb3lSVHEvbHNkcHlCbk5la2FYYnlZVW9qZ0x4eU1ZcjgxekR3bzRQdytKK3RVSlZuSFZ1TXBweGJmbW9xZlgrYTk5Ym42REx4ZTRzbGczaFkreWpMUzA0d2FrclcyVGs0ZE9zR3JYVmo3UWsrS2x6NGhlTjd1YU8yZ1hPeTF0dDBjUXlWNjg1WS9LTUU4akp4akpGVGp4WHB3R1ZkaXdIQSs4VFh5OVlOZGdLb2RzZDhjNHJwNEpMaEFTOGhBQ0YzWmpnS3Fnc3grZ0FKSjdBRTlLOFd2d3BsdEQ5M1E5MksyU1BoTVpuT1B4Mklsak1iV2xPcTk1U2QzK1Bib2xheVBlRDRpZ25HVk9PZTV5YWxoMUF6TU5yNUJPQUJ5ZndyNWw4VmZHZjRXZkRMd3RlK05QSFBqclF0SThQYWNmTHVybUc2L3RTNEVtMWlJdkpnRHVyTVVLamVGQmRrWElMS0Q3VjRXK0lud3MxbTl1dE0wangzNFZ2dFNzcDdXMW10QnJkdWwyejNrVnBKYktrWmZjUy93QnR0VjI0M0I1Z2hBYml2QXh1RXcrQ2NxVVUzSmRPcXZvbjZPenQzczdiTzJNY0xqOFdsVmpDWEs3Kzg3MjB0Zlg1cS9xajZPOEU2cFlwYkd6dUxpMGd1Mm1LMjBUV3d0WlpBY1pBbTZTRW5rTDk0YlQxQUdQUmErWXZoMThWZmhQOFF0UThTNlg4UC9pSjRFOGI2ajRMdnY3TDhYV1hoWHhWWStJTGp3M2NBc3JRM3F3eU41VEJra1FodWp4U0ljTWpLUG5INHdmOEZZLytDYTM3TkdvYXI0VStJbjdXL3dBSVY4ZDZOZXBZNnY4QUNUNFY2bmMvSEQ0dDZiUE15U1lrOEZlR1lkUTFlSW43VWswai9ZMUFTUXl5RUtDNC9OYzN3aTl0UEVVMUxmVlcwVDF2cnBiWjc5bmZZL3Azdyt6VEcwOHRvNVBqb3cvZHgwZDVLVnRISDNYemN6ZDkwNHBLeWpHeCtsZEZmejkrTXY4QWc1Qi9ZZjBuVjRORStHM3dmL2JTK09ON2NYY2xwRzNoUDRCUS9DbTIvZFJOTEpKbnh4cWZoNTJWQUJ1RWFPNDNxU2dVN2hoVC93REJ4UjhLNEpyS052MkEvd0J2RkZ2NEo3bTJOelA4RkxhV2FPMWxraHVIUkQ4UXprUnZES3B5UnloRmVkU3dHTHJ5bkdoRG01VmVYSzAwbHUyMm0wcmRlM1UvUUsyWllUREtEcnVVZWUzTGVFMDNlMXRPVyt0MWJ2ZFdQNklhSy9uL0FCL3djSGZDY1dWcmZuOWdIL2dvZExiWGpTSmJ6V0drZkJMVW9wVEVrRWtnQlQ0bEUvS3R6QVRrRGlWYTk5K0h2L0JkWC9nblQ0dmswdTE4Y2ZFVDRsL3M2WFdvM3Y4QVo5MXFIN1Nmd0k4WC9DbjRhK0hKU3FsRHF2eEVsc0pQQmRwSEk3eHdSelRhMElwSjVvWVVkcFpZa2ZLcGhjUlNWNnNISFRtVjlMeDAxVjkxcXRWZEs2TjZlS3c5VnBVcFgxdHByWjZ1ei9sZWowZG4wUDJEb3J6YjRUZkdiNFAvQUI4OEUySHhLK0JYeFcrR3Z4cCtIT3EzVnhZNlg0LytFM2pyUy9pTjRKMUthMG1hM3U0YmZWZFBubXRaSGhsUjRwRVNRbEhSbFlBZ2l2U2F3T2dyejJsdmNORkpMSG1XQmc4TXlNWXA0c01qbFE2a01GWXhxR1hPMXdOckFna1V5enNvYkdONG9IdTNWNVRNeHZMK2ZVWkFTQUNBOHJzd1hnWVVFS09jRGsxYnBDY2RpZWNZRlg3U3B5ZXo1bnk5cjZmY2M3d21FK3NmWEhTajdWZmE1VnphcEo2MnZxa2x2MFExRktxb1oza1lLRkx2Z00rTzVBQUdmb0JUNktLaHUrcHZGS0tVVVpxU2FnNlNsTGRRQVQ5bU4xZENHZWJCWWZPcXhNRVU0Vmw2dGh2bUNrRmFyWEdtSTVIQkxQMU8zZXVUa25KeG50MU9PbzdtdHVpdGxYbENYTlRWdlE4MnBsZExFVTFUeFUzVS93QVZ0TzlySmI3ZGRsNTM0MjYwWFltOG1QMUNnNGI4alhNWE9uc3BQeTRIUUhzZnhyMHg5T3RaRGxrbEozTTdFWE1xbVFzYy9QaHZteDBVTm5hT0Z3T0twM21uV0VWbmN5TzBrQ1F4L2FIdUdrZTVhRll4dWJBWXNjRUtRd1hCSTc1d1I2ZUd6Sndhakp0dCtYL0JaOE5uUEJVY1RUblZweGhDTVUzOGI2SzczaWt2bTBrdFd6eWlheFlkQVIzQXJHdTdKaUQ4dk9POWVwMlVGcmV5WEFpYU5vNDl5QjVZMm1QRFlHRVVxZHhHVGp0amtHbHU5SFF1cVIyOHNyeUtDbmxXclJLd3hrNVkvS3ZjWWRnZVBjWjltbm0zc3FuSk5XYTNQemJFOEF6eGVHK3Q0U1NjVzdLenZkM3RvbHE3dlJXV3IwMzBPZXY3N3hIZFR4Sk5xVW1qTDUyVHVqVzNodDBCSVpwRHVWbWJBeUk5M3pLUVFSa0d2SHZpVGFhdytrZUpkYzBUVHo0bThUdm8xeGZhVHBPZzZRWjVkVW5qUWkzVnJZTzdJenllV0pDemZJV0JKNUFQUitKZkhQaGp3dmJYUGlUeDFydWplSGZEbG1UYzMycCtJOWZUUjlJdGlzWnpKSmQzVWdWUUFwSkROamF1UHVqRmZrdmYvd0RCZEw5aTdRL0dQeG0wbVh4M3FQaUd4OEIrTVg4UCtDSi8yYWZETjE4Wm0rS2VsRFE5S3ZKdFFYVzB0MzBLemVIVXBOWnNSRExleHRJdW5wSXJETENyclpuUTRhcHd4dUpsVHBSczdPVGhUaTJrNU5PVXY4TnJ2M2VheWJ2SkdlQnk2dHh4aUowbFVyVmFNYXNYS1g3MnJKTFNQTmF5cHhWcE4yMGx5dVR0YUZuL0FDUS90RzNPcStPUGk1cTFyNDR0L0czaHZ4QnF1cmFucTNqYTA4UitBbjhJK0xmRDJwSkJlVDZ0RU5MOHVLNnQ3b1hjaFdTQ1ZJWkluZ2xFaXhzY3I0QjhIL0R1b3hhNW9taTZ6cVdwMjJqek9YOFY2ckg0YzFuVmZEK254aEVNbzFXejBtMWU0ZU5vUXR2QksyMjNXV1dKNUpQTFhuNmkvYS8vQUd2L0FObnp4djQ2UHhGL1o0K0gvd0FWOWQrSkhqUHhwNGgxN3hUWWY4Rk1ZZkJQeFIwVFZMYldmREdxNk9kT3R0QzhOYXhKSkUxcGUzV2xhM3BldFM2b3VvMmVxNkZ1S3RCNWNNbkgvQkQ5dTd3ZmZlQUUvWmo4WWZDcjluLzltVHcvb3VuSHhONGIrT2Z3TCtDR28rSmZGdmp2eEJmejJrRjlxdmpSSlpyMFdyejJGalBCTnFOaDU5clBjM0UwcjJrRU54UGJRL2hIREdYWUtPYndsbWxlbEtLcVZLc2xLeWpVYjViS2M1dU1FbkpTOTVTU2NwT1Rub3JmdHVQd09Jd3VYVHAwdVpOSkpKUmZNa20wNVJpazNvbm9sZTZWcmQvN2hmaGQ0UStGdXErQS9CK3NmQjZQd2ZlZUNMWHc3Rm9IaHEvOEdSVzUwdTB0YlVMRkpZbzBReXZreXhPcnd5Zk5HNnNDQTJTZXltOElPQzJZK2d6akhGZkpmN0VmeFg4S2VBditDYjJuK0svQmZqUHdEOFp2QnZ3WDBXYncxNGQ4VWZBcit4ZFM4Q1dlbCtiQlBiL1pvZFBua3QxdDlHWFZIRnlrbUwwUTZiSjVzUmwyeDErVnZqRC9BSUxlNmxyWGdyNGU2YmVYM2gvd1Q0NDhPZnRXWG5oWDRvWEh3OXZYOGFXdmpYd0hwTFRYMFBpRFNEYm9zaHM3b1c4K21HU01Pc3MwRVZ4ZzI4NGhmK3M4ZHg1UXlLblRxNXpXaFJqSzZWNVhpclJoSnJuU1ZQUlRqWjh5VDFhdkZOcitVYXZDdWNZckgxcU9YM3FRaEpxOGsxTGRxN2kvZTNpMDlMMzBhVGRqOTdENFRrM0VORVF1N3NNZm5VZHg0V2Jjc1lqWUZSMEF5U1RYNG0vR1gvZ3VWNHU4UTNFbWpmc2kvczI2SnFUU3E4YzNqUDQ0ZU1WaE9sTVM2cmRXM2h6U3l5WHR2dTI3V2wxT3p5QmtnYmxCL09ueDMrMWovd0FGSC9qUVl2OEFoTmYydDlRK0hVVWswMGVzZURmZ2Q0VzA3NGErR1JDd2pNQVNlRkxuVjkrMlJnMjNWRjIrV0R1T1NCNGRYeDQ0V3BVdmJVYThxdHJxMEl1NmV1L080SzJtNmIrS0wxNmZlOEpmUi84QUVqaTJoSEcwbzBxRkI3U3FUYmJ0bzdScHhxTk82Mm55UFZQNGRWL1VINDc4VS9EdjRVSjRadWZpVDR1MEh3VmIrTVBHV20rQVBEYy9pUy9UU3JmVnRZMWVZUWFkWVJOSmdHV2VRcWlLU056TW9ISkdmb0d3OEl0R2dqOHBndzRZTXVOcEhCQi9HdjRRdkV1bDYxNGUxUHc1YitNZmpKOFkvaVhkUDRpR28ya1hqejRzK0t2R1MyMHJ4WFNtYTNnMVhWYnBOelBIQTVQeTcyaGp6OTBFZjJaLzhFei9BSXdlTXZqRit4LzRQOFcvRlh4T3ZpVHhwNFYxalcvQlhpenhSZjI4V24zZDVIbzE5TkhaWFYreWhZek0rbm14bGxtR0ErL2UyQ1dBcktmRnVueFhqcDRIQlVwUjVZT2NXL3RLTW9RbHAwZDZrT1ZLOTF6TnRXMTZQRWp3U3pQdzd5T2htMHNXcTc5cjdLcWxIbDVYT0RuVGNWZVdsb1ZGTnVXajVMTFYyK3ByWHdsT1h3c2Z5N2gyNHI0Sy9hUytLRGVGTmYxN3daNHo4VmVFTER3VHE5cTNoKzMwUzYxQ0t4MXZVTCs1Z3VCWTJrY3F6SzZ6VFNJRks0aWFTR1psTzBydmsrdnAvd0JxdjltVHhOb1YwZkEzN1UzN09tb2FsUHAvMjdTSmJINDErRzcyMHZzeEdXSDk1SGVNUkhJQ2pDUmR3eGc0ZGNxZndGL2FvL2JjK0IrdCtLdE1UNDQ2UjhPZkgzeHU4SmFLdmlMd2RwbWphMVA0eThQVzFvK3JXMDg5M2NOcHFUV2x0SWJXMldLQzB1R2lrdTBEU2NSdEswWDJHQXoybGhhRlhOTTBxMHFjSXBKT3EzR0tkMDA3MnM3cm01VW5lVFNpdDIxK2Y4TjhQWmxqY2NxZnNKemR2aGpHOGw1cFBvcmU4L3NyWDErY05DMVRWcmp3UjQrYjRxNmg0OXR0VXViUFVKVHBGdnI5c3VqM0duUVhzbGxvbDljQUJ2SnRZYnNMdUV6bzdMSGFmdUdXTjYrUVBHdnhWbjhTNjFjYWZwdDdmTEJjMzA5N3FNVVBpazZ4cFdyTkVIaGd0bHZUaVI0MGlMUWZLN0JsbEpLa01BZnQ3NGgvdEhmc3krSi9oSjhSdjdQOFNlQ1BHYlhYaHkwOFIydnd6ME9KdkIwMmlScEpGQlBvYytuM0RhZWlpQUxIZGhWYWJ5NDduTWNoZjk4MzVBL0ZyUmRVOEIrRS9Cbmk2M3NOVDBtUHg1OFFOVDBTUFJJb1lsc2JHN052ZGFwTHAwTnhidThTcmF4b3R2YmxTeGVLQ1ppOGhoTWpmaC9pTmdZWXZKSXd5SEdRcjBZUVVwMUUxSnlTcWNyNXB3aTE3M003cUxqZE9WMTd6djhBdjNEZlBIR05ZMmhLbFVjbW94a21sOEtscEdWbm9sdTAxb3JQVFQyaS93RENuZ3p4UDRiOE8rRzlVdk5jUGhYUXJadEgwbjRSNlpxemVIUGczbzFqcUFWZFYwdDlBczJodGJ5RzdNTUFrdHIxWm9TMXB1RVJPTWRzbmg3US9BUThHK0h0RjhFK0Z2aHJvVTFwZFRlRnROOE5hTlplR05IOGh4YlBJeTJrV3hYM3M4Y3FzQW9IMmh0b3d4eDhQMi94ZnVWdDEwTmJpZlNvOUxsanYyUlpSQ3duVUxscFhVaHpqWndxbmFQYkpCdStOZkdmZ3ZSL0E5dDRyMHJ4YjRvOFJmRWpVUEQ4dDVjR2V6dUxQVGZEVi9LbHA1VmxMZGJOK3dGNTBZcEl3WHlWNHdWVS9KY01adkN2Z3FtSGNyU3BVcFhzNDByMzErSnB5cTgyM0xvNWJYU3V6OU9oaDhYaVhUblBYbXF3VjNHZFQ1MlRVWUphdm1kMUhmVnV4OWMyZmluVnpmelFUMjhtbTZWYTNNNnk2anB1bHRiaTZ0MGljeFhNYnlSYndKbnlqSnRMcWhVa25kZ2R4ZWVJZkMxeERaeDIzeE4xUzdpYXhlZDU3encrMmlXOXJjbWFZUlFMTTFzQUVjK1dmTjNCZDA1eVd4ejhrZU1maTU4RzlTOEY2bDRXOEcvRDNXYmJXOVIwVmJYL0FJVFh4TzdYdXYyRjE5cU14bnQ1R3Y1WkFua2hJVEdzUTNZZjdxbmRXdHIzeHE4RGVLWHRyUFFmZ2w0UThLYVFQaEpQOE5MeTJodDdGWm4xZTVsdG5QaTB6cWdrL3RGRXR3Z0pKMmk2bU9RWEZlbkhHWWJDeW5EbXBWYngzVHF1emQ5RmJsOTViNjNqYTIrcDZjc3N4ZUlqVG55VmFmdjJ0eTBsb3JlODd0KzY5ZEZhV2oyMFByQ0R4QjRZdHJiUmJTMitLR3J3YWxkUE0ycFkwZTV0TEN4dUFzWmppU2RVRWNpeXR2VHpGNEhsRG5vQjJQZy9WUEhkaG9KdWRCK0xPaDZYSzF2cWJYZmhIKzBHc3JxYUdPSlk3aEVoWlNtNjVRSUZCS00rMDdUa1pId2xEOFd2aHpaZUR0SDhQNnA4Q0xMKzE3RFNKckMrOFdXRjdacmU2dE1iV0tDQzVlUmdoM0pKRExOeXo1TXg2NHlmQzlEOGZhMXBkakJCTlpYWnZJbzFSTlZnOFRhamFUNzBENGtNSmFTRmlIWk04TG5ZRnp6bXV1V1o0VERxbTZjbzYwMm55U3J4YWI1ZEpYVWsyKzBWN042M3M3R0VNbHgrSWRSVGpMU29yYzhhRWswcjZ4dEpOUlhtK2RhV3ZxZnNGUGEzZHA0RThJK09MLzhBWnMrSC9objRpV3ZrWHZnejl0djRMUjZwOEgvMnJOSXRGdDdqU3BiTS9FWHc5ZjIydEt0emJUWEduenI5cHQ1SkxlZVdDVHpJWGVOL3ZuOWtML2dveCsyVjRJK0svd0N6NzhEdkJQeDZ0LzJodmhMNDcrTlhnejRlK0lORC9iSThJdjR0K1BYZ2JRTlkxN1R0RjFHMTBQNGc2TGUyVTE1TloydDNQY1Izbml1eTEyOXVwNFlVdUw2TU84dGZ6ZytGL3dCb1B4VG9laG0yMGpYL0FCWmZYVEJUcUdrWHhnbThKNnF5a3JLNU52TEd3a1ZsVms4NkNWZ3cvd0JZQ00xN3Q0Si9iNzEvd0I0bytIL3h0OGIrRnJ5M3YvaGw4UU5COGNYR3ZKNEVmeGpaVzF6b21vVytxMmpYVmxZeldjMTRTMFlaYlVYTm5KZHJDOEMzRVpjU0xqU3hGREVMa2cyM2FPbGs5cjMxalpyNXA2ZGRFUEU0REZZTjg5U0s1YnkxVGE3VzkyVjcvSnJYcHVqL0FFeDY4SitMUDdVZjdNM3dEdU5Ncy9qcCswVjhDdmd2ZDYzZkxwbWkybnhYK0xlZ2ZEdTYxaTVlTVNwYldzZW9YY0xUU3NqSzRqakRNVklJR0RYOEIveHovd0NEazM5cUQ0dnBlNlo0QzhEZVROSnFFMTFhK0l2aVo0KzFyd2o0YTBxM21qYU82MDlmaHo0TzFDMHRidXptQVpJN2J4SjRuMXhvbGxQbVNURkdFbjVUYTcrM3orMnBxaTY3NFYwYjQrYWQ4RC9ETWVydkpkL0R6OW1QNGY4QWhQOEFaNDhEM2pUelNHNCt4ZjJScDUxSjIzbDVaWjU5UmtlUjNady96WUdVWFZxTnhoQzJtamI2M1d2S3J1Uzhyd2ZXL1IzN0dNWEdWU1YxZlZMdGJibWZ3dTluZmxtdWx0YnIvVEE4Wi84QUJUejlqendWcnA4UHllSmZqVjQ1dVBzaTMwZXJmQkg5a0Q0dy90RGVFTHFObTJqeU5lOEwrRjlTMDJadTVqaXVHY0w4eFVMODFlVDMvd0R3V2ovWUkwK3dtMU9meE4rMFBCWjJ1cTIrajN4MVg5aUg0MWVGcjYwbXVwNHJhREZscUhoVzN1WmthU1pGYVMyaWxXTUJpNVJWSkgrWVRxSGovV3ZGSGlheFR4LyswUDhBR3J4am84dGdseHFldGEvOFl2R1hpMmVLZDdhUjNpK3kzbXF5eHloSmZMaEprWEIzRndGd0FQSnZFUDhBd2c4dHVzMDAxcmNYOXZxMERXRnZOcDAyc0xiUmlBNzV4T1dMQnR4RVlWY1lWbUpyb3BSU2JkUlhYYmIrbVp1azNDS1VyUzZ0V2EvTFJQemI5ZGRQOVVMV2YrQzNYL0JPZncxTnBzWGliNG1mR1h3OHVzNjFCNGQwcTUxTDlqajR5bXp2YjI1WXJGQXNzZmhaMVhPQis4a0t4L045L2hzZlIvZ24vZ283K3diOFFMN1N0RzBIOXJYNEUyUGliWEJuU2ZCSGpYNGdXUHcxK0lkOTh5cmhQRHVydmFhbmtGbEJVMjRJTEFFY2l2OEFKaHM1ZkNhUm1YUkx1ZStqWFFJWmI5TG9QYnJvOTdJU1oxdFYzZklxa0pzblRFaEs4c2RveDIxaDhWdmpKNGZpR2w2QiswQjhWVjBJeGdham9tcGVOWnZIRnJkd3lNSTViZTVHcUxkTXFzbm1iVEF5TUEzVUVLUmY3aVV0WXRMeWFkdlc5aVhRcktLNUtpYjgwMTkxdjhqL0FHT0lKNExxQ0c1dHBvcmkydUlsbnQ3aUNRVFFUbzRESTZPT0dWZ1FRUndRYWxyL0FDVWYyZS8rQ2czN1QvN0pjWGhYUlBncDQ1MXo0ZStIdkRUdnFIaGF6K0ZQai9YUGhSQm93ZmRDbDFybWlRTmVlRC9FMGx1SEJnaThUYURkeEt2RWp1ZDhqLzBaL3NmL0FQQjA1NHE4UFIrRGZDdjdYUGhhejhmNlJQcU5qb0dyZkVLWFJiWDRXL0VEVExHSzFaZFI4UTZocTFnWnZCdXJUeVhBamN3eXhlQ29JWVpzaEpHanhKSHM0dFhqTDc5UGwyL0VIQ3JENG8vTmEvTzI2K2FQN2R6RENaVnVERkVaMVF4TE1Zd1pWVW5KVU4xeG5uRlBPY0hhQVd4d0NjQW4zTmZKZjdNdjdiWDdQdjdXOWswbndkOFdDKzFxMDBPMzhSYXo0UDF4WWRLOFY2UlozU3I1ZDB0dUpIanZMWGZKSEYvYUduU1hOaXpzQWwwNUlCOS84U2VKVXRvWnJPeFp6Y3NXaWt1RWs4djdLVmJhMk9DU2NxUjI2NUJyYWpoSytJcnhvUVYzcDFUU1hlNmUzWDhqd00xejdLc2t5K3JtR0tseXhUZW5LMUtja3RvcHBPVGVpNXJPSzZ1eVovbUwvdGkrUC9CZjdVSDdXL3hyOFphZjQ4OFJmRTc0VWVJL2lmcUhqdjRhL3dEQ2V6ZUpOVTBHMHQ3MWt1RWJUdkRPdFhUZjJSSkEwOXhhckJIRkRoTFVGWWhHNkt1RFphRm91aVJ3eDJkN3FJU1poUEdpeUpwMm5zMlFSSjltaVdLUGphZ0pZSGhCMXhYejNCNGZ1dFAwalMvRVVWak9UcWZoQ080V3d0N2lPMDFtMW5tdS9LZ2dNaEdJNTUxT1k1RlJnaGxHOEs0YU92cnY5bzM0WmZEVFFOVytFbWcvREN5MTdUb1BFOFZ4L3dBSlZidk5ydXRYaVNXY1VVc01zNlhFaVNYQnliaHBrdFdpV2J5VlZ5b1pjZm5XZDFKWmpqS3RYRXkxcU9UYXRwMWRrbTIrV043UlRiZGxadStwK3I1Wmk4RmxPV1liS09TTW9ScDhxY21tdVdFVXZlMlYybGVUU1M3Skt5WHlIOFZMeld0U211dExXMnR6clUvRU9vM0Y5SFloTFdPT1FDNGVRQUlYM3VxN1pDRjJuZGpkODU1WnRQOEFEajZEUHBsdjhROU92ckswdHlJb3JMWElOVDFuVFVFeUt4dEpXaWhreUdkZzdJekdVT1dCR01tUDQ0eWVHUERHclc4TnJwbXQ2ZTRnc05PTmxyVjFKcVdwSTAwU3BkT0pKQmxJMm1XVm9kN0Zva2tqUXMyMGsrTStERUdwYXBZemF2Ync2VEVHUytnbTFhNU5oL2FQbU1xcEdEcy9mVHpnTXFFcUErMDVaQmpkOHRTeXVvMUNOTjhzWXU2OTFXYjNXanYyU1Z0RnIzMCtVcllKVHpPR0dvV3ZMV05rbXUvbjd1MXJhZnA3ejRMMWo0dWZCUys4VWVLdmhEOFdmaVY4S05mOFZlSFc4SytPTlorSEhpT1R3anFQalhTWHRwYlZyRFdMVlNkTzFhSDdOTE1zRWVyVzg0dHpLWGhraWt4SVBPZEFoMVBWclRWTGwvRjJwYXg0YWZXRm0welhyUFVwOVBzdFNoV2RsdVlOUU15aFd1TE9TRkk1a1F5K1dnYVIyRWVNL1MzaTN4Yit6cDRZMFMxV0x4UjQ0ZnhkY0M5MGxOQ1hScjNWZEt1NTdHNGp0cFlyNExlUEZiVzF4SnZTUHo0OHZIbVJWVlFXSDV2RDRqZkQzeFk3ZkRUU2ZDMmxEUTcyL3VmRU9reCtMWTB2cm53L3F6VHh5MjRzcFRLakZwWnA1bFl1MGtxeHpHS0pBZ2VTdS9QL0FPMU1SUm80U3Z6dW5UOTVYVVpRakYvSEtLY3Q5RlpLeWE1dXFSejhUWWZMNmthZGZDVWYzeXNwempGV2FTV2t0bnpSK3lub2xlM1EvVTM0V2VOTmI4TStJN2EwUzgwM1g5RnZyNTAxdnhIWTMxa2wxWjJtMXZzVU1tQW02TUVsbVNONWR6U003YkNRdGZScWVOcDdEeERyOTdCWStKZkVFa2FXdHFORzhQYWJkK0lyKzhtZllvVzNzb1ZlUjNWVzNPWTFKVkZCYkNoaVB5eC9acTBhOWw4WjZONE5jbXc4UWVLOVp0TkZ1ZEo4TCtDN3Z3UDRXOE9vNGpLVFJQY2lkcnA0MzgwN29tampMU3lCajhtRCtzL2h6OWhHNHVQdCtxYTU4WlBpM3BNK21YVDZWTnFObjRsdXZDK3AzaXdSL3ZibUs2MHdRdXNKaUQvdmxaUVBtVmlFT0Q4N2hjUGhNQXB4cjFHbExaOGo5NWFOdFJXeTB0cG85TEgzdmg4OGZES0pld2hlQ25mbW5LTVZ0YlNPcldyVHMzWjdyZHMrZGZpNzhXYlcvd0JXMHF5VFNOYTBUWExTNWEwZzA3Vk5PZTQxVzd1TGZjaE1DQldFYXlQTUZqM2tuZEhrYmdSWDFUOENmK0NyZjdXdndOOEVYbnc2K0UxaiswTDRlMG01djV0VTFCZkEvd0FDUEQrdFdWenFFa1VGbk5xRHo2eHBGM0o1bmwyY0ViSUhhRUNIUGxxU2MvSy94YitEUHd0OExqdzdyV2dYM2pBWGx4NDV0dEt0Wi9FT3Mzb2kxWkdlTzRtYkU1RXBkMVV5WUdISVllcktmaFg0amVISGw4YitMTFBTZkZmeFlhY2VKcm5UdFAwKzIrSmZpRzIwd0pFRytXeTh1OVZFZ0JBQVlCUjBVcUNSbjdqS2E4YURpc0ZVbEJ0VzVselJldHROR3BLOXI3MjBUUE80cjloaWFjOFB4QlJqV3BTbkQzR295aTVKU3RMM296amVOcEs5cjZ0WFBvZlVuK0FkMWV6M2ZpZjlnN3hKcVd1NnBjTmY2dnJuL0NtTEc1bDFHNnU1SG11Yms3SU1SeVBLMHNwaU8xbzk0R3hSdEZjSjQ5OFZmQTd3ZHBWd3VuZkJMNGcrQVk1cDV6RmJhUDREZVJWdkpVWVMzREpaT3p4bGl1WGQwd3dLWk9jQStIL0VyNFgrSW9kSjhLYWw0YzFYeHVqM25oRWFycThuaDc0ajYzSmFxWFpQSmU1amp2RUN6N1JLWlNkNVk0eWZsNThoOFlhYnF3OEthWTAycmF2NGExUFR0YUZqY1NueGJxVjlxREw1Y2plWmVOOXA4eWRaTXhzeGtrT005Q0ZBcjE2bFd0aTQwNVZwcVNiMTAxVCs5djhBQm5oNGpEVUkxYW1HcFJzb0p0NjlGYTF0RmJmc3o2aDB2NGdlRWY3TmxzYmZWZkhHbS9iWW81NzE3a3NEc3dHZEpQT0Rvc1h5eG5hd0xiVUdkdk5mUnZ4RS9hUDAvd0FXZnNlL0R6d0Y0cCtLWGdmVWZpUjhPLzJ3YnY0b3hXZXJXZW5XWGovWFBEK3FlQVBFV2x6WC93Qm90b1V0MXNiQzhtdDdXUzJTSkZpa3ZMU1VCdDIxZnpQVFZmQ0hoRHd0TnFWeDR4dTlWdVM4ZW15YXZkM3h1cDcyYmZHakxhd1B2bmxpeXpQdFVnTEdrcnMrNVNUMDEzOFJ2QmpXR3VtODFKMHZ2RHR0SVd2azBWZFZYVG9uSVpzSUYzdDVaQjNLalA4QU13T01NQVBQd2VKeGVXeXIwc0lwZXlyUmNKeDF0Sk95dTFycW0xNXBhYk5wL00xTUpocTlXbE9jTDhrdVpkMXBaOUcxZFBYdlpka2V4YWo4WC9CV2pUUVhzR28yZXJLNnpYSDJiU2RTR3F5M1BsQ1dXNTh0bzBZcklHVnpzQUo2QkF4K1VjVnIvd0FjSU5YMGx0SDAvd0FMYXRkRFVvNE5QVy92bXV6TkpKRkU2dkltWkVpQmxEQ1NhSVJHTU5HcnFFSUFGMzRvL0RuVGZCVmw0UDhBRnRoTnJGNWU2bnFOcGFYMHQwdHUxdkhHdHJjU3pJdTJCU0Fxbmx1cStlZWhISG1Hc1hzMm5YR2xUUmFrOHR0TnAwaXVSdGE0dFhzdk1uTTBUWUFTU1Q5M0crQmhrWEdBV0pQYmwySGhnMHFjZnRiM3UrbTJxN2Qycm4xbUhwUWpoM09PNjg5dnZscjhvM3Z1ZS82YiswQjQ2dW9OTXNaUEJsN0ZvRThxNmhkSmI2TG90ck03U1J4c3prUlFyT3J1YmFGR1Y1VkM0eXlnYmcyN2EvRm40MnpXY24yUHc1bTFuWDdiZTJNbmlTQmZPZDRZTFdSNUZTRExNMGNFRVpPN0xMQkdPUUs0cXk4RGVJYmNXOG1vNmpxR2pSYWhvbGpyM2xMZEpiMjF0YlJabExnQmdRWkNoODFYSXlvd3pBY21uNHIrTEhnNzRaUEJvbW5hbHFmaWJ4Skpld2EzTmFoNWRXdVlra0t0TkJkTEhqN05FeVNPc01NaFE1anlJZG84dytwVHFZMlN2VXFTVmxiVnoydDhPc3R2TGJWOXdxL1VZdUxwUWpLNzVsWlU5NzI1cktHL252b3V4OUI2RCswSjhkOWQwbUR3bjRndC9GZWwrRzdHWCt5TFdLODF5d3U5QUVYbHlRTGFXa1U4Q3k0UkpwZHJZUmRreEFrM0VJT0ZrK09uZ1R3NU5jK0R0VXVyVFJ0YllHTFVkTHVmRDBQaVRWWXRrZDFIYk5kM05sYnpOYXlxSlkzV0dWa2wyU0Q1TndDanh1ZVg0by9FUHc5cUYxNFhpMVR3YjRNdnJLMjF5WHhMNGgxQ0ZQRjJzV21xeGVUYnoyVXFtZHJDMGFKWGg4emVieGtYSmx0bEhrbmg3YjRiMm1pVEpIQmJ5LzJscDJydFBkUTZhME11amlLS05sUll3Qjh5elNPMHJBYmN2ZzR5eHgzenFWNkVZMUhVazdLeWJjclcyNVkzZTNrdExMVk00cVNoaWFrcVBKR041WGFVWTN2YS9OSnBiK3V0MzBaNkY0dS9hWThXU1QyK2ovRGp3ZnBPazZib01wKzArSXRlc3BKYnpVTFpaWW8yV0RTNEpURmJnN0FVbGxrTXZ6c0h0a1lrTDV0NHErTS9qalVKdFdmVC9IT3BXV2hYOFVIL0FBa0hnSy84aE5CdjN0djlJdEcya2VlN1JzcFpaUzVZYmxYb0FLK1VmaWI4TU5VMEx4anE4eTNadDV0VjFLZldUSmFTR0dVQzZrYWNocEV3M0RTTUFDZUFvNHJ2ZkRObC9aM3c2OFJTYW5mWHQ3Y3k2Z2lXODE5Y3kza3NnTm5Lcklra2pGa1ZTWXp4eGs5cXFqVXFTbkdYTmJiYlR5KzYyajhqbXJLRUtiVTBta252ZCtmMzNWOXRQSTlMMGFkWlM4MTFKZmp6STJrazJNYmUzbHp5Nng0R0NBRDE1SkFQSjVyb0k3T0NGRGNYR2oyME52S3VJUzdoNWVtVkQ1SjJsZ08vNDQ2VndlazZwRHFVVnI1c1VNYkNGcGxpTGJqSC9EeTN0bmpqcDlLN0Y3MFgwa09uU0NTUlpZMm1sY3c1aGhNUy9kTFo2c0NDdkhJelhiQ29veHUzb1pVNXlxOHZzMXZzZW1RK0d0V3RkRGoxeVJkT3RSY3dDOXR0Sit3ckxKTkIxRWh1UTJGWUw4M2xnWjV3U0RWanduNFh1UEg0dVowMTNUdEIweUc2Rm9IZ3NZZFR1N21jRGNFMjcwQVg1bExQa2NNQUF4empNc1BHVnZZZUhIMGk1MEhUNUpYalN5ajFDNWdLNmhCdEw1WXNHQVlFU0tEa2ZjV1ArN1MrRS9IK2wrSElKb3pvbWw2aGJ3dk05MUZkVysxSjJrU0JFQmZjQm1NeEVyazhlWTM5NnVWMWVUbWRUWlhkOUZvZ2xWbXFMcXFTVnJmSXpOVnNialROVTFqU3RVaWdOM2F5RzB1V0VhUnRLd2M4c0JqaHM3c1lHT1FSa0VtOXFHbDZUYldpWFpzTFNLUlhpYUNXSDVaVk80NUxIMHhpdVUxTHhuby9qQysxTFdySFQ3TFF6NVVGbkpZV01Cc1VTV0p3amIxYklMSDV5V1U0SlVjNHpVYmFwUGVRM1VjeGhTQ1NaRnRuZGhHcUJXZU1rTm5hUmxCbkpHQ1R6WFBUcSsxaXB3MlBRcFZZU3BSbTllWkwrdFRvNzYwMG0zaHRwRnVkWGd1bnR2SmlGdGNOTmxUaDNPd3FRVVBjRUVISFBXdlBkWDErVHcrYnFEN2ZMcU5scU9uRm9sbGpXemxlV1FxR081TWhpRkNuajE5eFgwYjhDTkw4Q2F0cnVycjQ2aWhmVFl2RGJOYUpxbDNOYmd6RytNSmtnTWJncnRDcmdxY1lsR1J6WHozcldpYVByZnhSMUx3M3A4OE9vK0c0OVkxQzIwMk83RytDNGlTNGpFWVYvbTNScm55OStTemJDZm1KSnJ0bE5VTU5ERlRsbzc2WHUvZDh2TTRJNGlOZk1aWmJDTnArNnI3Sjh5V2wvbWF2d2gvYVorSW43TS9qelNQRWZ3UzhVMlBnbVN3dTR0WHZ2Q2wxcGNOOTRGdjd5TXliTlJrMDFab2ZLMUJGQWpqMUN4bXRMNUZLcXQwSXdZei9BR05mc0EvOEhQWHd6djhBUXJMd1orM0hvM2pEdzNmV2tFZHBhZkVMd1Y0UDFqNHJRM1hKVUZ2N05zbXZMaEVYeS9NKzBXa055bkpXVFVodm5UK0tmVVBDT29hUnJNTU5oYXZZYWZwdDdNN3A0ZG1PbjIwMEhNU0l5aU1Jc1NzNnNBcERjWXlSeFhxMmdlSHRNMTZDeHRBclBxVnhibWZ6TGkxV0x5dktWcHN1NnVWSmJkYkZRVU9RWDZBWUhWZzg1eEdGdE9tMDZiK3k3MmZuNVB6Vm5iUTh2UHVGTXJ6K25QQzVwUnZOYlNYeFI5SkxwMXRLNmVsMGZyTnJIN09kL2NYdmcxN2I0ZmVPZkRpV01jdDE0ODFUVUk5VDFpMjhWWHR0ckVGN29JdG8wWWl6aHRMZUQ3UFBIQ1Y4NXo1ekVFdnU5RDhmVCtQTlc4UmFCNGx2dkIybVhtcmVGYmE1ZzBTMjA3KzFOTHQwTjJvZ2xtdVJNakIvTFV1eVJiMTNzd3kzSEg3TFc4TVVTYnBQTU1CWXF2MlZtbGtCUFlyZ3I3OWZYMnEwK2lRM0lFazRQbHRHUXp6eUJjWU80WkpHM29jNC9LdnhDb3NUSGtwenFPU2lySzlsbzkvaHR2MSsvZlUvUnFlUlVhc28xSzlXVW1rMG0yMW8xYXpVWEZQVFJjeWJTU3RheVA1b2ZpQjhGZmlSOFlieUpkWDhENnExenFWaytvNnBjYVhaaTNpYVlPcGpnUkpNcjhnSVFsVkc0NzJEWXFDeC9aWitQZXNTZmF2RW1rYWRwQzZkYUtkSHRyUFNFczVMaFlYWXhXL21TM1NlVXg1Qmx3UU40K1U0SVA4QVJkcU9uNlhZSy9sVDJjczdSbWRFdUovc1Z2Q2d3cE82UGxoa0ExaHhhcG8wSXNuMUhUOUQzWExsWnB3MzJpMENGTWh2bVVIT0RqSHZuSnp6MlU4d3hWT1BMQkxsOU52VHRmcmJzZHp5ZkN6cXdyYzc1b3BKV3R0NmR2MFIrQW5oMy9nbkg4VlBFbXBycldxZUtiTFRiR1hYNWRjaDhPMytpemFvMENYRncwOHNNVjZsMFk0dk1iYTBoaFJkN0tDZDJjSEl2UDhBZ2kvOFFyN1VWMWR2aVpZV2todmZ0MW0raWFXMmszRm9WUmtDK2U3TWVCSm5kR1VkU1RoaHdWL3BPU096K3hsYmUyMHdidHNqUTI4RVRqcU1PL3R3Q01BazdlbFhvYnZTcElVaGhSZnRTSEVzaVhDcENTU0RueUZSZVJuK0k4SDFxcXVhWmpXYWw3U3pTdGRLTzMzV2Z6dVp5eVhBdVBKSzltNzd2ZlQ1ZmhZL0RYNFUvc0MvSEQ0RkxMTjRadU5ZK0lXdFhWd0NkUzFieEZweVQyYTdTUzFzczBoeTNLS0R3eWpuY1RYMUZxR2xmdGgyOFlYVXZEdmpHRzJCOHVTeWduczcrMHZJeXhZaVI3Ump6SXp2djNKa2dLR0JVQVYrbllzNXA3VkxreldrTnZFNFJYbnZIZFZJemdiRnkrT1RrWXdlMVV0TzFLM3VJN2g1UHRGbXNVakkwMS9wN2FUQklBU2dNUmJsMWJHUVNOMk1aQXpYQk9GWEVUOXJWcU56N3RKL0sxa3ZUUTZxVk9wZzZQc2NMVWxHUHFsMjFkbzYrcCtKdnhWK0EveEsrSmtkZ25pWDRlK01CTkhxTnByWXphUkZiaTZzWmpQWlplVlF1SUpqNXFsY091eEFveGtIeHk5L1pFK0wxbkpydmltZnczNHYwODNyTmRYVnhieHJhT3I3dG9rT1dBSk9mbElIR09jWjQvb2NzTlFVVE1iTFhtV0pEbHJTRzVTN25tSjRMQUVxQW96NmRSMU5Wcm1ZNm5lYWZwMTNmTk5iM2JOTWJpZVY0VWFTSTdsWHlBY09vT0QxNHdNZ25GYTBhZFdqUVZMMmw0cGEzU2Q5djhqbHhHRyt1dExGUzUzcHJLMnR0cjdkMzk3N3MvbTNiNFIvR1hSa2Q5SDBmeFhacGNML0FHZkpBdHU4Tnhlb205bE81WUNqZ0JqZ0xqalBMVjRickg3T1h4VXZyaFk3N3docUlNbTZlUFQ0OU91cm55bFVjekFDMzV4dUFPQitJNXovQUZlNnZveG1uVzBqdUlURXNablNlVm1qZFdVNVZTdVFNRW5nOVJnakJyZzlRMHpVTG95QzR0TGZNTXJLeld1bklmSU9jajVpU0ZPTzRJQkhJcjBNUFhuQ0tpcGY4RDA2STVaWmNxVW5OUFgwNmRqK1M2NS9ZNCtKaDFHeTFEVC9BQTlxVWFhZTdwRlpXK2lUcmMzVzlKVUt6RWxTQmlhVTg4SEk0NEFyVjAvOWxYNG9nYXJOUDRkdWNYVEI1OU51dEhlM2htM1JBRnk1Q00zS2xDQ09tRG5nWS9wMjF2d1JaNms3TnFNeVNXL2xncTBjWXRic0VuUDNvd3VWd0FPY25yeWE0NisrR3VoU3hpU2JUN0xWWTRvMlZSTXdNb3ovQUhwanprWUdTUmtmbm5yZGFWUnFWU2J2YTE5TnQraU9LZVUwWlM1NVhidGJlMzVXN3Mvbjk4ZitIL0h2aW0wdDlMOFFhTHFIaCsxc0k0bHNuc3JWNDdXRkZqZU9VTFB1ektzbVNDakFaeDA2VjVqcWZ3VXZOV3RZM3VQRWlUeGFla3J3WE4yYjZPMy9BSDQyeXlGaW9EUElDRmJ1ZU01eFg5R1Vud3U4R3kzRndMMnp0SUlMcU5DN1hUeUhUa1pjRDVWWG9UM1laN2V0RXY3T25nV2E2aTFTMWswK09TMzJ1a1ZoZkZvWkdISkRXN08yU2U1QTNZMjR4Vy90WmRha2w4LytBUlBLcVZTUExlV3F0by82dDVuNEtheG9IeFE4ZGFWbzJsUWVKbzdLL3N0TWgwZzZ4b21teTJtcVN3d1pWVVZYamRFbGNFZ3lsV0tqQmpFYllrcm1QQzM3Rkh4QzA1cHJ1enNoZnd6bVdVVGFucUtyZFhUeXR2YVNTWnNscEN6TTBrdldRc1dZN2lTZjZQRytGaHRJaEpiQzNNWVhNU1c4UlZoa2pJeGpJUDhBaFZLNStIOXpIRk8wOWlJNDRseTBrdHN6S1FPeWdoc2tZR08vU3RGWHFPWE5MRVRmcmIvNUU1YWVUUm8yVktVbGJiVmY1SDQwNkIremg4ZTR0R2ZRN3crR1lyR0hRTFhRZEpuTjAxekxaSmJSU1F4c3BTUmVVV1Y4SzJRR083dmdZaWZzYWZHSmQ2SjRpMFN4RThpVFBNZFBrOHAzU1V6SnVLejU0ZnB3UHhBcjk2OUowWFI3bTBpdlBzK2xPSmtIMnVDN25aWldsd29QeUJzS1RnZ3F5OXhXOWNhRDRidGxVRzAwazRRWlMxMCtLWjB6MFVsU3dCNDcxMXJNYXNsQlNkK1hSZVMrUnRETFZTNXVXVWs1YXZXMTNwMlA1NU5mL1lCOGFlSlozMURWdFcwdVRVTGlRL2FIMHV3bXQ3TURBWGNBWml3empKNjlEeFdCZi84QUJPbnhCUHBmOWt5ZUk3OTdKTHBicU9MVHJtQlpTNFVqYUJQR1R0STVLZ25rQTEvUTdkZURkRm1FYmFQRGMrYXpGaXN5cERZd2tnL013Mjdqbko0QXdLdTJ2aFMyYzV1N1Mzdk1ET0FUc0hRTUFYK285SzZGbTFhMXRGOHYxM01YbGRCeDVaWGE5V2Z6aDNIL0FBVCs4VzZYR2xwSGM2eGJReHhIN1A4QTJob1VzMGt1UVNwRnpGSUl4eWM1SzQ1R01DbXYreEQ0cGtSQTNpcUNWb2lHZTJrczduZks0WEFTVDk0U2NubGdCazEvUnV2Z2J3Vkc5MHR0cHNrYjNEaFp4RGR6Umc0dzJBd2ZZdUNTUUZ4MUh0VHJuNFkrQjVudDdtNTA1cmtXdVJDdHhmU1N4Y2dJTjhhdm1Rcmc0TGJzWkp6V1A5cFNXbDM4cFA4QXpHc253NlZrcEpMemYrWi9PTlAreEo0OVl0blZkTkp1QUZsTXBrdFRjWVB5dGhrTEhIT01Ib1Blc3E3L0FHRC9BQnJjNmRjMnNHcTZiSGIzUzVlRVhqZloxZktnTUMwZTdqYURqMUFyK2tTOStDM2c2K2JEYU9qRXdBUnoyTjdMQXNLa0hEWkxjZ1k0eGpBR2Zhdk50WCtDMWphVzhUYVd1clQzRXMyd1F6enpUQlJ3SXp5UU9TRDB4MDY5Y1pQTVpUdW5LWC9nVC96TkZrdUhjYlhkdlZuOCtsbit3UjhUTGZaYXRxWGhhZUtQNXZPU1o3VjhaWDVaZ1kyeVdPU1NlTThZNU5kQlovc00vRjlJcm1QKzBQQTBFQUpNSWkxQ1E3ZzVkakZzYVBqQmNuZHV3Yy9kQUhQN294L0MyOXQxL3dCSnM1cldXVjg3emJTaUc0SkE1UHpnNVBISnlNZDZodjhBd1ZhV3pDMjFTVzV0Tk5FTEdhVkx5YTBtVGNwLzFUUnlBbjZaSEI3bm1zMWpWRzNMS1N0NTk5d2hrTkpXVUp0VzIxWitKbW0vc1gvRlhUNWJhNXRQRWZoalNiK0tVUEdYMXRRWnlTUVl3L2xuNVJrOGJldU1IZ0drOE4vc0VlUGRNMXExOFV2NHQ4SjZSZVd6U1NNYmpVSTVMU1ozbVdRc0YyT0FRUUFBbVA4QWRITmZzNVkrQ3ZDZHVUZmFiZmE5cXNZdC9PbWVUVmJ2VWtoVTRBTWkzRTdybk9RQUFDUjBCeFhSNlo4T2REOFRSdGUyL2h0cDFXVFltb1htbVFHU0YxSUJNYnNwRDR6OTlDd0dSeU04VFBIeWxEMmZOTGw5WDFLWEQySGRUMjdrL2FQZDh6djA4ejhndE0vNEovYTlyRU9wdmNmR0tHMmkxVkpJeStsZUgwMUNXQXZKSEtKYmU0YVlLeFhhQXBaU3VDZmxQRmVvNkQrd2ZCNGN0VmtoMUg0aS9FSzhoZlAyYTAwMjEwRzNJWHl0eWhoR3BBYnk0emhDMjdhT2U5ZnJ6cFB3ZDBtMWlqODY1a2cyUDVodDRJMmdYQXdBRGhzQXNBTTRHQjdZcjBMUVBEbmh2U2pMSHBkb2tiWEUvbnpCM1JraWJvWDY1Sk9PU1NUd09lTVZ5WXZIWW12UlZHTW11aWEzVi9XNmZ6VE92K3hjSE5QbWNydnJmOGRkUHdQVDB2bzJYRVVFVFJuTEl5UmdvUWNqY3lLd0lIUTVIRmNCNDM4Y3JvczBWcERwV3VhaFp4VENLL3VMRng1VVdVQktQSHVERWdNaEhINDV3RHhUK0pybTJaMDM3QktubXlRRUdHQUZRQnREZ2h1Um5qa1pCNjFGTmRlSDlTdEx5ZlZMQ041cmkyTnZkWFR3Q2UzdkZBSTVpYmdzTVpYa0hwZ2tWNGpxVTNadlM1OU5Udzh1ZXoxc2RyZmVJZkN1bjZUQnFsOVBQTHBseGEvYWdiMnpTMG5kT01CWTJ4SW8zWTJodHA5UlhqZDE4YVBDY2tpMjF0cDA1dGhDZkttTnBDazBUa29xSnRCTFkrVTVQWWM4NUZUYXZybmdqVkxmN0RxbW5KY1F5V3FSM0Z4RkU4azB4aEEybzh3T1QzY2duQUl4a2JSV0pwZmh2NFFIekx0VnZibVdDTldrdGJpNGt1VGJFZ0RJaVFGaW95djd6RzFzWUJQTllxdlJscEdTL1U2bzRXcFRUZFNML1E5YzBQeE5hNnJhd3lXa2pGYjBneHZGSDViNDVISTRkZWd5R0FKUHJrWTJ2dE5scDdDR09CbHVjazNLWEtsV0o1eXBYcndjNHp3UnpuaXVDZ2dzZFJzZjdOOEx3YXlJRmlpMnRaV01sbFlRTkx5eXkzTXJZTzVXVnltQ3c1T0QyNnp3eDhIV25uazFYeEhkNnhybHBhUmpHbnJxSXNMSlF3eEhOSjh1MEE3bFpTNHcrTnU3SnhXL05Db3ZkMS9ydWM3aTZiOTdSL2o5eDJlaTZnelRXOGt6aUNPNWZ5U2JkREk4Undkb1lFSGFtQmtudDJ6MXE5ZlhNYTNaak1NOTh5NFd6VzNpVzN2dHpkY0JwQWpZQkpCNHpnRTQ0RlZvdkQycnlOWVMyVDZwWVg5ekM4ZGxwdXAyajZiYVF2YnBtNlpvbzh1WWdGd3MwakZSNXk0eXhVSGo5ZjhBRW8wZTUxS3kxVzB0b3I2MG1DVHZhM0xSU05pSkhHd3VtZHBEaGl6REh6SGpHTTJvd1dpam9ZUDNuZFMxL3JvYnI2WHBGaTdFL2FKYnRXYWVJNnBQOXF1clo1QUFXR0dPSlF2QUtuakJ4bXVTRjdwMmllUExIeFpxVjNxZHlsbG8wbGhiVzhzb21zeHZKTWp3eGtCdk5jaFEyT2dVRDBybXRRK0lydFp5UzJGb0d1WjUwaWdqVUsvMldKOENSbFVTQXlNb1BBQUFMRmVjSEZlZGVKZGY4VldPcXoyMnROSm8ybnpXWW50cFJBaHZ0Umh5Vm1NaGNGWU1ZWUVENWp3UVFNRWJPRUZUdDBKaHo4K3Uvd0R3eDlVcjR2ajEyRFQ1clMxMC9VV2tWVEliQ2NXNzJqTVNBOHNNamViRW96ZytZUVFXNzVwaldXdnpQY1gxMURwMm43VjJ0YXgzaHVZNUFwYkxOSUVCT1FWYjVnTUVIQk9hOGwrRjBhMk41L2JJVy92Yi93QVNtQkpmRUZvSDFqVEo0RkpaSVRBcWZ1V1pHQS9lT2RyWkE0d0sraTJ1Q1kwa1FUUHVrWlJBNTNGc0UvTnZZWkFHU09lM1lZeFhGQ2M0blZXaERwcWNsNFVnOFA2dXF2NGo4Ukphc3R0dmdzTGFKVGRha0FXVm1TZmFWa0JBUS91MVJnY2hsVTROYnVyZkN6VHIxWk5RMFo3ZTJSVkZ1R3M3MGFqYnp3akpRdHZ5UVJ1QVlaWHR6d01VYiszdHJwQjU4S0ZFWWxITXdEd09NZmRZREtrRWZlVThacTVwdmkzVi9EOFRRVDJ5YTlac3dLWEV4V0xXTE1mTGtCc0JadW1SdUliSjZtdXlFMjdPTE9LY0V0bG9jRGUvRG5XdExEUnpOWjZ1WlZNZ1czaDh1WXhaWTRWQ01FY0U4T1R4MHpYS05wSWhMTkpZVDJxd3grWEVYczVXU0FkTjJkdTNIcVY5dWE5OG04VGFkcjBFTnBEZEdGcFg4NllYRXZsUzJiTnVWa2FBNFpWSndTZWMrdFBhRFZmRFdtVEovYkIxVkxteDhtM3NkRjFqRTFtc3h3V2UzUlYrUWhNWXdUenlRSzZZU2ZmVTVwUlQyUjh0WHAwKzAzMmtOMUhCY1J3aTRlQ0djUlRLakVxemdMemdrRVpZRG5ISXF1WjdTM3RGblZicTRoZkRlWkxmT1pvbFBMRUtYMmcrNXlUNjlLOVRSM043TE5KYjIwL21XelJOY1hjU1BQR2Nra0ZtejhvL1BrbkJxZzBkbUJjUnphZHB2bXpGTTNNSUcxMTdiZHFsVDlXNTQ2VnQ3UWoyYTduRGVEZkVmaCtmKzFMTTNLRWFYTzBUUnJMNXZ5U2p6UzBpS0NUeTBtVDZBYzg0cm9MSHhSNFcxaTdpMC9SOVlqMXEvV1o3YzJWb3hTV0FMSDVxb1VjcUZjS0NTdkF3TSt0YU52cGxsNFV1OVFndExOclMzMVJ6cmtvdExkSVdhUm80MW5raFhibmgwREJUbm1UUFJzVnRYTjlwaUxIZDJpU0c0dVlmTy9lMm9ndmdwSE85TWJsT2VvUHJtbEdiNkV1bkcxMlpFbGhxbHpFMEQ2UmFXakNVWEZwTnFFaVhBVjQyQmlrOG1Ja0VnNElCYkdlbzdWeE9xMjNqZE5XV2RwTDZiVGtiZmZXazlsNW1tUHlBR3RSQ2VCZ0VsWlIxNTRyMEkrSTArVkpyaTBnTEptSVNUcXBmcnlPNXdCK2VlS2htMXhiWnBWbFAyWi9sOHlab3lwa1VEQzhyOTQ1SXdNOStuYWptZXhVWUxkSTFOSWthNHRUS1BLL2RmTUltZzhueTl3QkpVc1RnREorWDlPbFg3UzB1NzQrYkQ5bGI3SUdFa3NYK2h4WGU4ZytVckhQellBREVaeHdjRE9LeGJlMXVOUlUvMnRLOFZrem9WdERJWWJ1N09ReWxqa01xcU1EQitZOFp3QlhZTmY4QTJlM2lndExSby9Ld0kxV3pTNHRvZ0R6dUFJeDM1OXhVV3NhYU5ENXRKbWx0MHVOU3VaOU1saXUxUkJwdHpMZlJSUmhRem8rNzd5bGNjazVYakhBRlpSdDJtdUpoOWpuaWhpTzJLN3Y3aU9PS1VBZ2dCY2s4NEFJQjU5c25HdnFNVjVhUnh4WHRycUZpTHBvakd3dE1DNWI1SlFONms1NEtuZzRJSTU2Z2M5ZWFqSks2Q2ExbkllVjRoRjVRZUtNcjhvOHh1VjZqcXZyN1ZYTkphdDZrY3NIcFl4NEMwMGJ0R3Njc2l5bUtZS1VNU0daQkc2dUdWbXprRUFuNVFUeGc4ak12dkQ5NEpZZFNLNkRaQ3p0SENRNm0vd0Jva2FhUEpXQm0zcWtLazUvZTdYNUFVQWh1ZWJIaWExMHJ4RnF1aytiREZHODRndWJlU1JZMzJTb0pVM0RobEJFaDRValB2aW42cDRoMUZyb0MyanM3dC9KK3h5WDJvVzg5MmJaakhKbk5sRnVsblZENVdOaWpBa1k0NzFTOStYTGI4OWZuMCtabktNcWFjdjYvNFB5TGVrK01kSTFHTzl0N3pScnJTWmt1a3RMZ2FocEMybGdaVGhodG15WTVmN3hBeVZHQ3dVRUd1dWUzbmhHTGU1TUQ3bE53MFVCbWdNZVJ1SzdjRVpIOFErVWNZelhqbXJhbDRsYTEwS2RGOE5UK0VmRUY5RmFYT3BhenE4M2hyVFZhU0o0RmxpdDhTejI5d3hQa2hpY2toVllKa2taMHVrK1BiRHhUWmp3dDRxdFI0YUhreWFqYWEvb2todHJLT0xFVHk2WE03STByTUMyVllvd09XdzJjR0trT1dYTC9BRi9Yb2JVWHp3NWsvd0N1M2RmTmVSN3hGSkkwOGNLc0NvVXBISkpNSkl2WExxZUIyNVlIcjc1cXpIcTlpbDVHazdXVWx4RzRna2pqdW81eUJuYTUyRTcxR1F3NUcwRWRhemIyWi9zekhjTEs0TVhsTk1ZMlg3U0cyanpsYlBWZWhEcXZJQnllOUdCZEwwNHlTeGFYWVJYOGtXSDFWTEZKTlF2WkNvM21XWlYzRmp0WEpKT2NBNDZZem5KUWgxZmN1TVhLWHZhZGpOdTdhR1FXY09rK0dVa3Q1VkVjZG1OVGxOM0VGQVBtenRNZHBqTFpaaTJYTzlBQWNFMEw0Y1lhdGFiZjN1bWVmSkxxS0c3aU1zSHlxc1VVQytUamFEbHl4Y3VjN1ZQYXR6UzljMUx4WmQzMGwxbytyTHBUYWc4UGgzWDc5WWJPTFdsK1lTenhSeHNKR0paUGxhUkZHd0RBSkxBZW9lR3ZDaUpPTE9WSlp6RFk4elhzb0F1SGlNWnlIemd5RU0yQ1NBeFZ1QmxhNXB6b1U0YzhsdWRGUDI5U2ZJbjhLL3BiOUR4eSswYjdOUGRUNmJDRTgzeW9tZ2x0NDVwempjckVLUnRBR1ZCNkE0NjF3MTE0dzhNZURibVMzYlNKZkQrcUMzWWlTNjA4S0dHM2MwTE9xbFZXUmhrT1dHZHdIWWdmYU54NEpzemJYTnc0Z3VaYlNSNDViTzFiYkswWUhtK1dqQWt1QW9ad0Z4bmJqN3hBckwxcjRiYWZQYnBkNmRvZ0Y1RmJyTEV2OW56NnBEZnNUdkNPSkltVU13SU9Xd3E1T1dHR0ZjenhtSGpkVStwdkNoV2trNjIzOVc3L0FLbnpwNFEvYUQwalROQ3RMQzB1N0w3SFBmdGR5UnoyTDZkcWRwY3ZzaSswTE1oVlEwVVprMnJ1Q2t6U2NzV3lQb0h3NzQrdWZGOWd0eHBjbzF1SnJ3WDBhK0piZTMwS1MzbldOWlpycHJoSlpBbG9Td3dYaGFSamt0dFFjK0llRy9nam9OOWZYV24zT2lUM1VFYlBjWGx2S3NTYWpwelRCNDFnQ3hZRVVUbG5LdVdCK1VzRk9BOWRXZmdIOE9yUnJLTCt6ZkVseEhGSXNZa3ViNlc2U3gzQXZFeXNDUkZISHRLaGxRWkd6ZG5CTmNsUEd4aTJxbHZ2MjlldjNmNW5iVndWT1NUcE4zZmt2dy9TOWl0NDgrSUduYXJZM050cTNoeVB5dFMwMkhTN05EZXpMWVd6VHl5L2FiaVc1QldWbVFjV3dYYWtvSkpHMEtWK0d0VXV0WjBtNWhpdHBweHJtb3pmWVhtdk5aa251aGFMa01aM3lmTFVERE1TVHRWY0J1SyszUEYzd211THZTTGtlSGZGVTB0Mlp2TEY0YjlaYllCZ055Z29GK2I1UWM3UjkzQkZmTnVxL3M1YW5vdGxlWE91eDNWMXFsN0ZqVDVvTlRhMG5iZjk4UGJFQXlJVklCOHh0b09TZmxycGhVcDE1S1VGci9YV3h6eG93b1huVmV2cHFjYlplSTV0S04zYmF2cnZoblc3WFJHK3orYmFYc0hrU1QzSVNXVitRcEs0VURjQVN6RTUvaXJIMWZXcmkvV2ZWWWJDd2xoMVdmemJXQllvcFlZQTZwSEVza2hrQlZtSGJPMVhKNkNzUHgvOE52RnRwSHA5M1BZYVE2MjBNT213eHc2RGFhZTNEUHNTQ2Eyd2tvMkFZRWdCYmF4RzAvTFZXNTBLMzB1M2thYVdlYU9LeVM1dWlMVUpKYU9XSWJDNXdRR1JDemhtNE1uWEdLOUdTbkdsSnRhTFZXdC9Ya2M5T1ZHZGFEaS9lYnM5SDVlbnFmYS93YjhaNlkyZ2FmcFRTUmFKTTJ5M2doM0tiZU9RTWRzYW91VGtqN3pIMUJ5Y2duM1BVTlJzZGdhOWtLeFF4R2U1a0pJeWNaSllZQzRHQ0FlM29hK0cvZyttbHpUemJZZ2w1T3EzTnh1TWRwTERjZk41clRCby9NS0VqQVZzRGFWeUFRUlgweFlhbGVYdGt3bDBpNGt0NTNWakROYktZV0t2c1FpTUFMR3U0WjV6Z0FjZEs0S1ZwUlVtYjRoY2xScGJIZlJhcnBsNms4V25wSkVzc2E3cmdzZDZIYU5yS3BCd3dHU08zR2NWalBNd0NyZFNPOE1FVzd6TjZ2SkkzUTdqZ1o0NTVIcHoycm5KZkVaZ2tsU2UzbHQxak9NUnBIRVhiSEs4RDVnQ3VBR0hYdU9ha1RXYks1amt1SS9OZno5c3BsazVhSlR3UUV4MEFPQ3B6eCtCcm9VZGRORWNqWkpmejJhNGFUWktkcFA3NWhNNEJ5Tm9ERFBKUFkvcFdmYjYxZDJFN05aNnZxVmlJMFpQS2duWVJoR0F5QURsUmdGZW5mSHRXTGV6UEpNZkpETUZBaU0wWVJVQUs4WjVMQWRUbmtqSE5ZVVduWEVjbHd5aTNhWlVFVXJSWERTU0hPQ3I0T1NlWEI3ZGVhdHo1TlV3akNNOUdXNE5XU2E5YU1pUzQ4eTVhTWk2czVCOW9LbHpJZDZZMmpDZzdtSTVZWXpXdEZQcURTaExPMnNqQzdCemF6UEpMRW1PVXkyZHh3UU9wNzhpdU8vc08wQ1BheHcyOFJrbER5TmdwUDVwWU1XeURrRW5rcUNlZWV3cllzbzlRMDM3VDlsbWx1QktqdzIvbncrYkVaQnhnaHVlaE9leE9Sak9LY3E2ZWtmeUVxSzNrUitKOWQxR2JVTkRTNGtTSy9ta2tzdFBhMjh5VloyZEE4c1djc0ZiRVlZS2NENU9DTVlxN0ZCNG5uaGdhWHczZWlNUTdGdXJrSmFXK09tV2thUWZleUNNOG5QMXhnYTNvZDlxbG81ZUNLeWVBQXdYVUtSU0Mza0JEcE1pSElQSXlGd2NoZVR6WFQ2SDRqaE9rSnBUeHhxMm03V3Z0R2hoaXQ3U3dKSGtxcU5HcWhrSHp0RnZKT0hiSkdLdU0zWkpMVXlsQkxWYmZxWDE4SjNYbHZlNmhmNlhiUlJySHVqdHBEY1RnTWVRUVZDN2xQWEFicU9UM3NhVy9oY0FQYTNLWGwwa3JXMXhlUzNxM2N4YkkyYkRuQ0RnY0FEcjNxWjduVDU0Q2w2bHRKQUdLVFJ6Mmtrc21Cakp6dUJCNUJBQVBUajM0M1R2QlBoR3dsbnV0RHRwN0NmVkltaWt1TktVVzZTNzhQdjI3Y2JrSjNZWUhPNFo5MzdSTldhWWxCYlhQcEsvOEtXYWFkYldkcnB1cDNWL3FHbVJYTjVxT25YTFJwcEVnWXh5bExob3pFMmR3TWdBWXhzTWJ1NjFZUENUZVZjMjlwQkhkMmRtQ2xscThOMDF4TnI3S3lvSTdhRmo1ek9lRitkY051RFo1d09Mc3RUdWJPMlMydUw2N2pBQUVRVy9lM0Z6dFVLRG5jRkJ5Z1k1ejkwQUFqRlMzMTI0VDdZdW9YUlpJc1NwSGNDNUNrWVlxdTBsc0hnZ0ozUGFzb3ljWmFkZXY5ZjE4eTN6U2dveWVpdTdlYnRkL2hxYmZpZlZSYjJObDRkTnRxbGpIb0psdEFOY2pWdFRrdVcrL3ZFZUJHbzJSb0lVeVAzZTRrc1d4d1F1UkF0dkpQZHEwcVc3UjNBaFJyWkN3R1NFUm0zS0R5UWVlblU5YTVueEg0OHRvN2kyR3V1QTRmWmJYMTRqZ1F1aTcxRzV6empCUHpEZ0R0Vi9TTmEweldyaDNudmRPalYwZUNCWkM4TnpQTkh0TEZPUDlXQVNTNEJEWitVNEhPMTNCYUxRaFFUdGMrZWZpZjhBRFB3MzRyOFV3ZUpydGRWU2ErMDc3TjUxaktWdEE4RzR4czVPNDd0ajQrVEF3cDRHQWE3L0FNSFQzdWozSWdXVzB0dFAwblM0cmVMVUxqVVcwL1U0NDVGSW1SNUpGd1YvZHF5TUdZbllBd0pBWTJ2akw4S2ZHUGpMdytkWjBEVXpHbWl3QytPaHkyd1F6bHZsODYybVZsY3lScnVLcnRJWThIQkl4bS9EdndQZFdYaG5SNzN4SjRuU3h0WXBvakZyRjZCS0xlUXQ1Y2drdXBtK1ZuT05zVStmdmhWd0F1THAxRTUrNS9Xd1ZGRlVVNXRQcFk2Mnd1QkZxZC9Kb3VnZUhMNisxeHZ0SjFpZlRZdFcxQ2Z6STQwa0tUenBsZzZCVEl2ejlNZ0FacnVvN0MzMDZLM0dzUEhva2tGcVhsbHVwMjFLTytoVlFCNVNya3EvekRJQUxCU0FGWVlJNDI0dHRPaHZaSk5SMUMvMXExc3RSWHlOU05yTU5KdEhaakhDMGpJQkZDd3kzNzFuMkZjbFNQbVd2UllmaHUycms2blBmTEJaM0VhU1I2aHBzU2ExYXR5Y1BLUTRKWDVSZ1FrNTM5UmlpcTR1MHVmL0FETUlTU1RoeU5KOVh0L21jVHFNZW42bFlwcnVtV1Vla2FmREJEYk5lNmpleW02MXBtZmRHTGUwWWpMc295a2pxcjRWZ1J4em8rSE5TazhRMk0wMTdwMXJjYVJDL2sybDFlTXR2Tys3elkvbmhURXFGTmpCa0NsbWFSQ1EyT09pMHZ3N2I2VHJFMXhwdWx3WHZpZXd0NWJBNnpva2NPcWFkTEU4aXpRbWE5bUsvWjJLcWdaQXJNUTdZTFlOV3JtNmh0MHN0VThSMzkvb09vV3BsZXplNDhQeVcyaldEQlZabXQ1RHYybGQ1Qm1sK1k4Rk5xazFqN1M3czlqUk9MVmszL1g5ZjhBOU84T2FKNFRTNW5KK0orbVdMUEVyUnl5LzJWcThFU08zQ3g0WkVDZktoSnlCa0VIbW1lRnZGbmcrZlVMK0diV3ZEZDFxSzZ1TFFha2J5Q0k2akYvcWJXNVZBdUFKRWorUk01QzdlT2MxOEcvRVhUZGE4WlRXUnNmQ3ZnU3hzRjJtK2ExMXFPMnU3bE54OHdITm9ZMXlyTUFpeDUrYjc0eG11dzhPVFErSHJDMDBiVC9EaVdHbjJ0dXFLSUxpMnZneFJpeW1TWlI1a2paSitadWVlM1N1S1dXVnB5YnFWdjYvcjE4anRqajZFSUxrbzY5ZjZYL0FQMFpzZFc4UFJidFNPbzI2bzA0ZUNlSFVvMUxxUnN6RGdnZ0xuT1VJSko2akJycmREK0pud3d1YitXejFEeFZydmh6VjdSa2RyNjIwMTlUOEszMFRnZkpKTXNjaFdjbGNiQ3A2bkJIU3Z6Z2JXOWVnczBHaDMwVmhLTUZJbXRmM1VZQTVSWTFpWlZCeWNGY0hQWE5XWkxqVjd1R0pwOVhlM3ZwZ0JjL00xMUJjOFlZeVFzdlFEZ0RLOWZ3ckdlU0tvN3lxYS8xdVhITm5CS0twNkgzVDhWL2pWK3poNERXSzRnMWFEV3RSdjkwY3R4NGYwalV2RSt1czY3UW13UUxHb3lXTE1zNE8wYlJ3QWNmTlQvSG5STmYxR0p2RHVoK0tOTjAyelRmZFhQamJRNDlNbmxZbmE1dFZSMktid3pNSFpXeDNHM2tlTFgwSjFxN2luMVdmUnJtL3Q1dHRzNG1helN6alhBWHl5RUVpWndDVldUQlByMmtrdEw1SFJQN1N0eWluY0FkUW11dzRBd09XUW5qay9lemsxVkxJOEtwWHJ5dXZ4KzhtZWI0bTFxTWJlclZsOXlQVXRTK0pQaEFUelN3K0ZydTcxRDdPOXUrdE5weTZ5MGtjaDUybU5NNUh5bmlKY1p5RDNyekR4WDR2azFhT1N3dDBudUpMcUtOWXJGRXU3S3lkTm5sNS9lNVh6TU9mbFZjRTdzNHhpb2wwTzZtTDNFZXRXd2NSZ0dLYTllSWtmeEljeDdXeUR5Q2VvcVd5bW0wYThTNWdXeCsxS09Mb09zbm1qc0NJMEhJT09wOXMxNjFLbmg2RWVXaEd4NTAvYlY1YzFlVjJjSmUrSC9GYTI5b3VwV092VzhscHArMklYT2xPOXBaTTZFUEloV0lScnZRTDFCQ2dIQkhJcmtMNnh2WXJLN2U0czV0UVdLSlJLSk5QVzVoa1hDcXVRZ0I1eHR5T2c5c212ZG9OYTFiN1pIZXVza04yOGtxM0xIVUJGQk1qN3NxcWtFQU5rZjRlaGMzbW15eHhlZm9Ha1NYa2M0dUxmVTdpUWYydmJ5NURzNlNCQXEvTXFrQURhTUhqbm5WMUU0T05rL1VtTUpLYWJiWHAvd0FGcTU0SDhKL0ZWLzRlOFJhbHBVMXRkSFM5V1EzbG5vMm53L2JVc1pTZkxrbWtkMzh0U1BNYmV2ejRPMGdnNXo5UTZoSllKQmJ6MjA5K2tXeGcwenl5ckZJck1TM2xxdnk1VmlBRzNBZ2c5QWVQblRWZkNNMm82Nm10V3V0engzOE4wOTFNNHVackc1bTN1WGxRM2tJV1JrYzRIVUVaUEJIRmRCcHZpUHh4cFUxNVo2bERiYXhvaFA4QXhMSVhsYWE5c1BNKzlHTG1SUzgwWUk2U1ljN3psaU9CeGNqakcxcldQUW5Qbmx6cDMvQTdpLzFxMTBxNWhpMUczMXEvRWdjeDNvMDRTV2k0QUFpa2NNTmo4NTNOZ0VZT1RnMVZnOFo2VElkc2RqR2tVUktTU3czOFZ4SXZJVnhJZ2Y1VkdGSlU3aU04MWp2NHpsdUZObGQrRmRiaFRZeTNNTVQvQUdxMVpIeXJORU41NVVaMmh1eEhGWjl6ZStGSjN0MmJ3L3Fkb3h4OW5SL0RhM3pyOHpNd1pTQkdGSk9lU3VXNXhtdElxTzdNcE9XbGowYTB1NE5ka2tqdDVEZFRtUVNobHQ1MFJoenRWM0NsZVFNOFA3NHBaeFphZkdQTnZiT09VdWVicWRvRmZISTUyakJHVDhub000UGZ6cWZYNUlZN1p2dFhpcTNXMGtFVVZuRDRZa1l6UXRrbktyUEpFdkp5VlU5TzRIRlJUK0xJdFRtbi90VFFOZG1qdDhvcHUvREszRFNMc0JWNFcrWXI4eWdGU2NZQXFKVTR1VnlsT2FWajBaSi90VWpwQlBBTU9Wa1ZvNVZ0RVA4QXJPV2JIQkdUOG9JR0Q3VnEybHUwWmt2SXBMYVpwRTg4ckdSSEc3WlZkNysvWEk0NTRyenkzOGJhSkNsc2o2UjRqdEVoUmpDcVdnU0JPRnduazVBVUVyeGdFRDJycjA4YStEUXkzZ3VkVmlhY2p6ckszMHk2VUprREpsQ0tFSkhvdkh2Nnc0Skt5MkRtaytob3VqenNsdmR4R0thU1VMS2tEdGJCaUdVaEZ6Z0U4QS9MaktnNUhPYXpyN3doYXpYY2w1cDEzZTZWcURRQ0tHNFIwa2hLcXpNa2M4VEREUm5uNzN6WXpodWxadDU4VWZDTnVQbTFUVnJSMlpUOWpQaHFhZUdSa1lFU293VEtIR1FGWTk4NDZWT254UjhIMzBxbUNmVzVrZ1I4d0RRbWppT2NFRTcxWEpHT3pESlBRVlBOS0x1MlVvU2xvay82Kzh4VTFTODBpS0dIWDlQaWdLcjVVMm9XMGk2bHAwNHlka21jQWpnRnhsQmpQSnlyVjBkajRsMDhOZFcxenJWdmNYSW5WelozbDdCWVJXcWxRdmxKRGhKQTJTZzNTRjhrQTQ1QnJJYjR2K0NyZTRkMWt2WjVjbUFXVXZoNjY4eU5TTWduamJ1QkFHNEU1d0FlbFI2bjhUUGg5cU5uY3JjZUZyKzZFa1oyUnQ0V04vSWg0SytYNXFIYUEyV3puZzkrYTE5cExSdFhJZEpOMlNQUlJyR25mWjQzblFTRjVBeVFLeXlOS3JBamRHNUlWdllISFVlbEphYXRiM2l4UEhaUzJjWUg3MTdwWXJpWFlSbklqU1E3RHpqNWhuampJSU5mTWMrcmVDcnNQREJvSGplMGdWbWFhU0hTNG9STGx0Nk1zRFNyRTVEWk96RzBBNHprQ3VhZUhYN3EzdWRQMFNQWFlOTm5rODRYV294Q3l1SnBDcFVQSkdoZGlBQUFTV0hUR0NNVlRtaytZU290dTNYMFByNlZQRDZUcSt6ekZsWVJNN3FZVWtMZk1SamorNmM3dlNwYlVlRzVUSkxhV2x0YjNMTzdwTTRJdVFlQVYzcnp5VjZaQUlBcjVXMHExbTBsdFB2WkpmRU9uNnZGREpEck9zUmFuZjZyRnJKWndZNUZzNUxmeW9DcTVSc2J3MmR3MkVjOXZwZXQ2cmNSd0pQcXRwTDVaZDdlR1N4a1c1aUxaeUJ2T0c2NXl5cm4wQW9oNzdWLzYvQUtsUDJlaWY4QVhrZlFYbldrMFVVRWR3WFJCc1V3bFZaTThZT2VPdkFEWXlRTTgxblcrZ2Fmb2swdXRhSHJ1aTJtb3l3Yk5TMDN4UGEycFM4WHpOenhSeUlyQ01rZnhnZEhJUHQ1WGN6UGNMQWx2TzhtMDc1b3JrSXl0Z0VnaHVtYzV5Q08vV3ExMTltdlkzaFVyQTNraUdTVFVya05GTWNFL09xamQyeDBQUWRhMTluRnB4NkdEY2xyMVBSMitJZDVxd2t0OUtqc0xLS2VKcmVjRzRsMXUxQ3R1NVJ4SkZDd1hEZ0hrQUt1U09NK1pUK0dkUHZvcnRwdkdYaUhSN1V5TmUyeTZUNGdQaExSNEpUaDNFTnBiYlUrY2dGc2s3OXpaemxqVFk1NytKMG5PcVdGd1prS3pXMGMwMDl2am9FZEdkR0l6Mko1NDdDdWgwM3hMYzZkQzBUNlQ0ZWpuSnpieXRvOEZ3a1dXeUpGQzNEWVlFQXIwSTZkNnFNS01WYmxSazFWVDVvdC9nZEJvbmp6eE90dUxiUm9kVjE1N0c0Q3kzdHpwUzdJa3pscGpMYkJRVytVaFF5SEl5Y2V2cVYxY2FINGgwbVhUUEZYaksyMFdhN1paNyt5MC9VVDRkYThVdHVXR2VlNWo4NjRqVURKVWJJd1hZYkNNWThldC9IdmltQnRzbHdVdFNvRHhXMDZXVVNrakc2SmxKWk1ZSEJMZ0tjREhOYWkvRU8vTXR1clgxM2VSd3NaSklYOGJMUEpjZEQrODMyek1jTXE0VlNvQUI1N0hHdmgxVlZvU3Q2SXVqVmRHU2NxYWZ6L0FPR1AvOWs9XCIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/matrix.ts\n/* eslint-disable */\n/**\n * This is a class treating 4x4 matrix.\n * This class contains the function that is equivalent to OpenGL matrix stack.\n * The matrix after conversion is calculated by multiplying a conversion matrix from the right.\n * The matrix is replaced by the calculated result.\n */\nclass Matrix2 {\n    constructor(opt_src) {\n        let i;\n        let s;\n        let d;\n        if (opt_src && typeof opt_src === 'object' && opt_src.hasOwnProperty('elements')) {\n            s = opt_src.elements;\n            d = new Float32Array(4);\n            for (i = 0; i < 4; ++i) {\n                d[i] = s[i];\n            }\n            this.elements = d;\n        }\n        else {\n            this.elements = new Float32Array([1, 0, 0, 1]);\n        }\n    }\n    set(src) {\n        let i;\n        let s;\n        let d;\n        s = src;\n        d = this.elements;\n        if (s === d) {\n            return;\n        }\n        for (i = 0; i < 4; ++i) {\n            d[i] = s[i];\n        }\n        return this;\n    }\n}\n/**\n * Constructor of Matrix3\n * If opt_src is specified, new matrix is initialized by opt_src.\n * Otherwise, new matrix is initialized by identity matrix.\n * @param opt_src source matrix(option)\n */\nclass Matrix3 {\n    constructor(opt_src) {\n        let i;\n        let s;\n        let d;\n        if (opt_src && typeof opt_src === 'object' && opt_src.hasOwnProperty('elements')) {\n            s = opt_src.elements;\n            d = new Float32Array(9);\n            for (i = 0; i < 9; ++i) {\n                d[i] = s[i];\n            }\n            this.elements = d;\n        }\n        else {\n            this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);\n        }\n    }\n    set(src) {\n        let i;\n        let s;\n        let d;\n        s = src;\n        d = this.elements;\n        if (s === d) {\n            return;\n        }\n        for (i = 0; i < 9; ++i) {\n            d[i] = s[i];\n        }\n        return this;\n    }\n    normalFromMat4(a) {\n        const e = this.elements;\n        a = a.elements;\n        const a00 = a[0];\n        const a01 = a[1];\n        const a02 = a[2];\n        const a03 = a[3];\n        const a10 = a[4];\n        const a11 = a[5];\n        const a12 = a[6];\n        const a13 = a[7];\n        const a20 = a[8];\n        const a21 = a[9];\n        const a22 = a[10];\n        const a23 = a[11];\n        const a30 = a[12];\n        const a31 = a[13];\n        const a32 = a[14];\n        const a33 = a[15];\n        const b00 = a00 * a11 - a01 * a10;\n        const b01 = a00 * a12 - a02 * a10;\n        const b02 = a00 * a13 - a03 * a10;\n        const b03 = a01 * a12 - a02 * a11;\n        const b04 = a01 * a13 - a03 * a11;\n        const b05 = a02 * a13 - a03 * a12;\n        const b06 = a20 * a31 - a21 * a30;\n        const b07 = a20 * a32 - a22 * a30;\n        const b08 = a20 * a33 - a23 * a30;\n        const b09 = a21 * a32 - a22 * a31;\n        const b10 = a21 * a33 - a23 * a31;\n        const b11 = a22 * a33 - a23 * a32;\n        let // Calculate the determinant\n        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n        if (!det) {\n            return null;\n        }\n        det = 1.0 / det;\n        e[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n        e[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n        e[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n        e[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n        e[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n        e[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n        e[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n        e[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n        e[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n        return this;\n    }\n}\n/**\n * Constructor of Matrix4\n * If opt_src is specified, new matrix is initialized by opt_src.\n * Otherwise, new matrix is initialized by identity matrix.\n * @param opt_src source matrix(option)\n */\nclass Matrix4 {\n    constructor(opt_src) {\n        let i;\n        let s;\n        let d;\n        if (opt_src && typeof opt_src === 'object' && opt_src.hasOwnProperty('elements')) {\n            s = opt_src.elements;\n            d = new Float32Array(16);\n            for (i = 0; i < 16; ++i) {\n                d[i] = s[i];\n            }\n            this.elements = d;\n        }\n        else {\n            this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n        }\n    }\n    /**\n     * Copy matrix.\n     * @param src source matrix\n     * @return this\n     */\n    set(src) {\n        let i;\n        let s;\n        let d;\n        s = src;\n        d = this.elements;\n        if (s === d) {\n            return;\n        }\n        for (i = 0; i < 16; ++i) {\n            d[i] = s[i];\n        }\n        return this;\n    }\n    multiply(matrix) {\n        this.concat(matrix);\n        return this;\n    }\n    /**\n     * Multiply the matrix from the right.\n     * @param other The multiply matrix\n     * @return this\n     */\n    concat({ elements }) {\n        let i;\n        let e;\n        let a;\n        let b;\n        let ai0;\n        let ai1;\n        let ai2;\n        let ai3;\n        // Calculate e = a * b\n        e = this.elements;\n        a = this.elements;\n        b = elements;\n        // If e equals b, copy b to temporary matrix.\n        if (e === b) {\n            b = new Float32Array(16);\n            for (i = 0; i < 16; ++i) {\n                b[i] = e[i];\n            }\n        }\n        for (i = 0; i < 4; i++) {\n            ai0 = a[i];\n            ai1 = a[i + 4];\n            ai2 = a[i + 8];\n            ai3 = a[i + 12];\n            e[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];\n            e[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];\n            e[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];\n            e[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];\n        }\n        return this;\n    }\n    /**\n     * Calculate the inverse matrix of specified matrix, and set to this.\n     * @param other The source matrix\n     * @return this\n     */\n    setInverseOf({ elements }) {\n        let i;\n        let s;\n        let d;\n        let inv;\n        let det;\n        s = elements;\n        d = this.elements;\n        inv = new Float32Array(16);\n        inv[0] = s[5] * s[10] * s[15] - s[5] * s[11] * s[14] - s[9] * s[6] * s[15]\n            + s[9] * s[7] * s[14] + s[13] * s[6] * s[11] - s[13] * s[7] * s[10];\n        inv[4] = -s[4] * s[10] * s[15] + s[4] * s[11] * s[14] + s[8] * s[6] * s[15]\n            - s[8] * s[7] * s[14] - s[12] * s[6] * s[11] + s[12] * s[7] * s[10];\n        inv[8] = s[4] * s[9] * s[15] - s[4] * s[11] * s[13] - s[8] * s[5] * s[15]\n            + s[8] * s[7] * s[13] + s[12] * s[5] * s[11] - s[12] * s[7] * s[9];\n        inv[12] = -s[4] * s[9] * s[14] + s[4] * s[10] * s[13] + s[8] * s[5] * s[14]\n            - s[8] * s[6] * s[13] - s[12] * s[5] * s[10] + s[12] * s[6] * s[9];\n        inv[1] = -s[1] * s[10] * s[15] + s[1] * s[11] * s[14] + s[9] * s[2] * s[15]\n            - s[9] * s[3] * s[14] - s[13] * s[2] * s[11] + s[13] * s[3] * s[10];\n        inv[5] = s[0] * s[10] * s[15] - s[0] * s[11] * s[14] - s[8] * s[2] * s[15]\n            + s[8] * s[3] * s[14] + s[12] * s[2] * s[11] - s[12] * s[3] * s[10];\n        inv[9] = -s[0] * s[9] * s[15] + s[0] * s[11] * s[13] + s[8] * s[1] * s[15]\n            - s[8] * s[3] * s[13] - s[12] * s[1] * s[11] + s[12] * s[3] * s[9];\n        inv[13] = s[0] * s[9] * s[14] - s[0] * s[10] * s[13] - s[8] * s[1] * s[14]\n            + s[8] * s[2] * s[13] + s[12] * s[1] * s[10] - s[12] * s[2] * s[9];\n        inv[2] = s[1] * s[6] * s[15] - s[1] * s[7] * s[14] - s[5] * s[2] * s[15]\n            + s[5] * s[3] * s[14] + s[13] * s[2] * s[7] - s[13] * s[3] * s[6];\n        inv[6] = -s[0] * s[6] * s[15] + s[0] * s[7] * s[14] + s[4] * s[2] * s[15]\n            - s[4] * s[3] * s[14] - s[12] * s[2] * s[7] + s[12] * s[3] * s[6];\n        inv[10] = s[0] * s[5] * s[15] - s[0] * s[7] * s[13] - s[4] * s[1] * s[15]\n            + s[4] * s[3] * s[13] + s[12] * s[1] * s[7] - s[12] * s[3] * s[5];\n        inv[14] = -s[0] * s[5] * s[14] + s[0] * s[6] * s[13] + s[4] * s[1] * s[14]\n            - s[4] * s[2] * s[13] - s[12] * s[1] * s[6] + s[12] * s[2] * s[5];\n        inv[3] = -s[1] * s[6] * s[11] + s[1] * s[7] * s[10] + s[5] * s[2] * s[11]\n            - s[5] * s[3] * s[10] - s[9] * s[2] * s[7] + s[9] * s[3] * s[6];\n        inv[7] = s[0] * s[6] * s[11] - s[0] * s[7] * s[10] - s[4] * s[2] * s[11]\n            + s[4] * s[3] * s[10] + s[8] * s[2] * s[7] - s[8] * s[3] * s[6];\n        inv[11] = -s[0] * s[5] * s[11] + s[0] * s[7] * s[9] + s[4] * s[1] * s[11]\n            - s[4] * s[3] * s[9] - s[8] * s[1] * s[7] + s[8] * s[3] * s[5];\n        inv[15] = s[0] * s[5] * s[10] - s[0] * s[6] * s[9] - s[4] * s[1] * s[10]\n            + s[4] * s[2] * s[9] + s[8] * s[1] * s[6] - s[8] * s[2] * s[5];\n        det = s[0] * inv[0] + s[1] * inv[4] + s[2] * inv[8] + s[3] * inv[12];\n        if (det === 0) {\n            return this;\n        }\n        det = 1 / det;\n        for (i = 0; i < 16; i++) {\n            d[i] = inv[i] * det;\n        }\n        return this;\n    }\n    /**\n     * Calculate the inverse matrix of this, and set to this.\n     * @return this\n     */\n    invert() {\n        return this.setInverseOf(this);\n    }\n    /**\n     * Set the orthographic projection matrix.\n     * @param left The coordinate of the left of clipping plane.\n     * @param right The coordinate of the right of clipping plane.\n     * @param bottom The coordinate of the bottom of clipping plane.\n     * @param top The coordinate of the top top clipping plane.\n     * @param near The distances to the nearer depth clipping plane. This value is minus if the plane is to be behind the viewer.\n     * @param far The distances to the farther depth clipping plane. This value is minus if the plane is to be behind the viewer.\n     * @return this\n     */\n    setOrtho(r, t, near, far) {\n        let e;\n        let rw;\n        let rh;\n        let rd;\n        rw = 1 / r;\n        rh = 1 / t;\n        rd = 2 / (near - far);\n        e = this.elements;\n        e[0] = rw;\n        e[1] = 0;\n        e[2] = 0;\n        e[3] = 0;\n        e[4] = 0;\n        e[5] = rh;\n        e[6] = 0;\n        e[7] = 0;\n        e[8] = 0;\n        e[9] = 0;\n        e[10] = rd;\n        e[11] = (far + near) / (near - far);\n        e[12] = 0;\n        e[13] = 0;\n        e[14] = 0;\n        e[15] = 1;\n        return this;\n    }\n    /**\n     * Set the perspective projection matrix by fovy and aspect.\n     * @param fovy The angle between the upper and lower sides of the frustum.\n     * @param aspect The aspect ratio of the frustum. (width/height)\n     * @param near The distances to the nearer depth clipping plane. This value must be plus value.\n     * @param far The distances to the farther depth clipping plane. This value must be plus value.\n     * @return this\n     */\n    setPerspective(fovy, aspect, near, far) {\n        let e;\n        let rd;\n        let s;\n        let ct;\n        if (near === far || aspect === 0) {\n            throw 'null frustum';\n        }\n        if (near <= 0) {\n            throw 'near <= 0';\n        }\n        if (far <= 0) {\n            throw 'far <= 0';\n        }\n        fovy = Math.PI * fovy / 180 / 2;\n        s = Math.sin(fovy);\n        if (s === 0) {\n            throw 'null frustum';\n        }\n        rd = 1 / (far - near);\n        ct = Math.cos(fovy) / s;\n        e = this.elements;\n        e[0] = ct / aspect;\n        e[1] = 0;\n        e[2] = 0;\n        e[3] = 0;\n        e[4] = 0;\n        e[5] = ct;\n        e[6] = 0;\n        e[7] = 0;\n        e[8] = 0;\n        e[9] = 0;\n        e[10] = -(far + near) * rd;\n        e[11] = -1;\n        e[12] = 0;\n        e[13] = 0;\n        e[14] = -2 * near * far * rd;\n        e[15] = 0;\n        return this;\n    }\n    /**\n     * Multiply the perspective projection matrix from the right.\n     * @param fovy The angle between the upper and lower sides of the frustum.\n     * @param aspect The aspect ratio of the frustum. (width/height)\n     * @param near The distances to the nearer depth clipping plane. This value must be plus value.\n     * @param far The distances to the farther depth clipping plane. This value must be plus value.\n     * @return this\n     */\n    perspective(fovy, aspect, near, far) {\n        return this.concat(new Matrix4().setPerspective(fovy, aspect, near, far));\n    }\n    /**\n     * Multiply the four-dimensional vector.\n     * @param pos  The multiply vector\n     * @return The result of multiplication(Float32Array)\n     */\n    multiplyVector4({ elements }) {\n        const e = this.elements;\n        const p = elements;\n        const v = new Vector4();\n        const result = v.elements;\n        result[0] = p[0] * e[0] + p[1] * e[4] + p[2] * e[8] + p[3] * e[12];\n        result[1] = p[0] * e[1] + p[1] * e[5] + p[2] * e[9] + p[3] * e[13];\n        result[2] = p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + p[3] * e[14];\n        result[3] = p[0] * e[3] + p[1] * e[7] + p[2] * e[11] + p[3] * e[15];\n        return v;\n    }\n    scale(vec3) {\n        const x = vec3.elements[0];\n        const y = vec3.elements[1];\n        const z = vec3.elements[2];\n        const e = this.elements;\n        e[0] *= x;\n        e[4] *= y;\n        e[8] *= z;\n        e[1] *= x;\n        e[5] *= y;\n        e[9] *= z;\n        e[2] *= x;\n        e[6] *= y;\n        e[10] *= z;\n        e[3] *= x;\n        e[7] *= y;\n        e[11] *= z;\n        return this;\n    }\n    setTranslate(vec3) {\n        const e = this.elements;\n        const x = vec3.elements[0];\n        const y = vec3.elements[1];\n        const z = vec3.elements[2];\n        e[12] = x;\n        e[13] = y;\n        e[14] = z;\n        e[15] = 1;\n        return this;\n    }\n    /**\n     * Multiply the matrix for translation from the right.\n     * @param x The X value of a translation.\n     * @param y The Y value of a translation.\n     * @param z The Z value of a translation.\n     * @return this\n     */\n    translate(x, y, z) {\n        const e = this.elements;\n        e[12] += e[0] * x + e[4] * y + e[8] * z;\n        e[13] += e[1] * x + e[5] * y + e[9] * z;\n        e[14] += e[2] * x + e[6] * y + e[10] * z;\n        e[15] += e[3] * x + e[7] * y + e[11] * z;\n        return this;\n    }\n    getMaxScaleOnAxis() {\n        const te = this.elements;\n        const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n        const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n        const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n    }\n    makeRotationAxis(axis, angle) {\n        // Based on http://www.gamedev.net/reference/articles/article1199.asp\n        const te = this.elements;\n        const c = Math.cos(angle);\n        const s = Math.sin(angle);\n        const t = 1 - c;\n        const x = axis.elements[0], y = axis.elements[1], z = axis.elements[2];\n        const tx = t * x, ty = t * y;\n        te[0] = tx * x + c;\n        te[1] = tx * y - s * z;\n        te[2] = tx * z + s * y;\n        te[3] = 0;\n        te[4] = tx * y + s * z;\n        te[5] = ty * y + c;\n        te[6] = ty * z - s * x;\n        te[7] = 0;\n        te[8] = tx * z - s * y;\n        te[9] = ty * z + s * x;\n        te[10] = t * z * z + c;\n        te[11] = 0;\n        // te[12] = 0; \n        // te[13] = 0; \n        // te[14] = 0; \n        te[15] = 1;\n        return this;\n    }\n    makeRotationFromQuaternion(q) {\n        const te = this.elements;\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n        te[0] = 1 - (yy + zz);\n        te[4] = xy - wz;\n        te[8] = xz + wy;\n        te[1] = xy + wz;\n        te[5] = 1 - (xx + zz);\n        te[9] = yz - wx;\n        te[2] = xz - wy;\n        te[6] = yz + wx;\n        te[10] = 1 - (xx + yy);\n        return this;\n    }\n    transpose() {\n        let e;\n        let t;\n        e = this.elements;\n        t = e[1];\n        e[1] = e[4];\n        e[4] = t;\n        t = e[2];\n        e[2] = e[8];\n        e[8] = t;\n        t = e[3];\n        e[3] = e[12];\n        e[12] = t;\n        t = e[6];\n        e[6] = e[9];\n        e[9] = t;\n        t = e[7];\n        e[7] = e[13];\n        e[13] = t;\n        t = e[11];\n        e[11] = e[14];\n        e[14] = t;\n        return this;\n    }\n}\n/**\n * Constructor of Vector3\n * If opt_src is specified, new vector is initialized by opt_src.\n * @param opt_src source vector(option)\n */\nclass Vector3 {\n    constructor(opt_src) {\n        const v = new Float32Array(3);\n        if (opt_src && typeof opt_src === 'object') {\n            v[0] = opt_src[0];\n            v[1] = opt_src[1];\n            v[2] = opt_src[2];\n        }\n        this.elements = v;\n    }\n    applyQuaternion({ elements }) {\n        const x = this.elements[0];\n        const y = this.elements[1];\n        const z = this.elements[2];\n        const qx = elements[0];\n        const qy = elements[1];\n        const qz = elements[2];\n        const qw = elements[3];\n        // calculate quat * vector\n        const ix = qw * x + qy * z - qz * y;\n        const iy = qw * y + qz * x - qx * z;\n        const iz = qw * z + qx * y - qy * x;\n        const iw = -qx * x - qy * y - qz * z;\n        // calculate result * inverse quat\n        this.elements[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        this.elements[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        this.elements[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n        return this;\n    }\n    /**\n      * Normalize.\n      * @return this\n      */\n    normalize() {\n        const v = this.elements;\n        const c = v[0];\n        const d = v[1];\n        const e = v[2];\n        let g = Math.sqrt(c * c + d * d + e * e);\n        if (g) {\n            if (g == 1) {\n                return this;\n            }\n        }\n        else {\n            v[0] = 0;\n            v[1] = 0;\n            v[2] = 0;\n            return this;\n        }\n        g = 1 / g;\n        v[0] = c * g;\n        v[1] = d * g;\n        v[2] = e * g;\n        return this;\n    }\n    /**\n         * Scales a vec3 by a scalar number\n         *\n         * @param {vec3} out the receiving vector\n         * @param {vec3} a the vector to scale\n         * @param {Number} b amount to scale the vector by\n         * @returns {vec3} out\n         */\n    add(b) {\n        const a = this.elements;\n        b = b.elements;\n        a[0] = a[0] + b[0];\n        a[1] = a[1] + b[1];\n        a[2] = a[2] + b[2];\n        return this;\n    }\n    addS(b) {\n        const a = this.elements;\n        a[0] = a[0] + b;\n        a[1] = a[1] + b;\n        a[2] = a[2] + b;\n        return this;\n    }\n    scale(b) {\n        const a = this.elements;\n        a[0] = a[0] * b;\n        a[1] = a[1] * b;\n        a[2] = a[2] * b;\n        return this;\n    }\n    distanceToSquared(x, y, z) {\n        const dx = this.elements[0] - x;\n        const dy = this.elements[1] - y;\n        const dz = this.elements[2] - z;\n        return dx * dx + dy * dy + dz * dz;\n    }\n    subtract(b) {\n        const out = this.elements;\n        b = b.elements;\n        out[0] = out[0] - b[0];\n        out[1] = out[1] - b[1];\n        out[2] = out[2] - b[2];\n        return this;\n    }\n    divideScalar(scalar) {\n        return this.scale(1 / scalar);\n    }\n    applyMatrix4({ elements }) {\n        const x = this.elements[0];\n        const y = this.elements[1];\n        const z = this.elements[2];\n        const e = elements;\n        this.elements[0] = e[0] * x + e[4] * y + e[8] * z + e[12];\n        this.elements[1] = e[1] * x + e[5] * y + e[9] * z + e[13];\n        this.elements[2] = e[2] * x + e[6] * y + e[10] * z + e[14];\n        const w = e[3] * x + e[7] * y + e[11] * z + e[15];\n        return this.divideScalar(w);\n    }\n    lerp(a, b, t) {\n        const out = this.elements;\n        const ax = a[0];\n        const ay = a[1];\n        const az = a[2];\n        out[0] = ax + t * (b[0] - ax);\n        out[1] = ay + t * (b[1] - ay);\n        out[2] = az + t * (b[2] - az);\n        return this;\n    }\n    lengthSq() {\n        return this.elements[0] * this.elements[0] + this.elements[1] * this.elements[1] + this.elements[2] * this.elements[2];\n    }\n    multiply({ elements }) {\n        this.elements[0] *= elements[0];\n        this.elements[1] *= elements[1];\n        this.elements[2] *= elements[2];\n        return this;\n    }\n    static angle(a, b) {\n        const tempA = new Vector3(a.elements);\n        const tempB = new Vector3(b.elements);\n        tempA.normalize();\n        tempB.normalize();\n        const cosine = Vector3.dot(tempA, tempB);\n        if (cosine > 1.0) {\n            return 0;\n        }\n        else {\n            return Math.acos(cosine);\n        }\n    }\n    static cross(a, b) {\n        a = a.elements;\n        b = b.elements;\n        const ax = a[0];\n        const ay = a[1];\n        const az = a[2];\n        const bx = b[0];\n        const by = b[1];\n        const bz = b[2];\n        const out = new Vector3();\n        out.elements[0] = ay * bz - az * by;\n        out.elements[1] = az * bx - ax * bz;\n        out.elements[2] = ax * by - ay * bx;\n        return out;\n    }\n    static dot(a, b) {\n        a = a.elements;\n        b = b.elements;\n        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n    }\n}\n/**\n * Constructor of Vector4\n * If opt_src is specified, new vector is initialized by opt_src.\n * @param opt_src source vector(option)\n */\nclass Vector4 {\n    constructor(opt_src) {\n        const v = new Float32Array(4);\n        if (opt_src && typeof opt_src === 'object') {\n            v[0] = opt_src[0];\n            v[1] = opt_src[1];\n            v[2] = opt_src[2];\n            v[3] = opt_src[3];\n        }\n        this.elements = v;\n    }\n    set(e) {\n        const a = this.elements;\n        a[0] = e[0];\n        a[1] = e[1];\n        a[2] = e[2];\n        a[3] = e[3];\n        return this;\n    }\n    add(b) {\n        const a = this.elements;\n        b = b.elements;\n        a[0] = b[0];\n        a[1] = b[1];\n        a[2] = b[2];\n        a[3] = a[3] + b[3];\n        return this;\n    }\n    normalize() {\n        const x = this.elements[0];\n        const y = this.elements[1];\n        const z = this.elements[2];\n        const w = this.elements[3];\n        let len = x * x + y * y + z * z + w * w;\n        if (len > 0) {\n            len = 1 / Math.sqrt(len);\n            this.elements[0] = x * len;\n            this.elements[1] = y * len;\n            this.elements[2] = z * len;\n            this.elements[3] = w * len;\n        }\n        return this;\n    }\n    setFromRotationMatrix({ elements }) {\n        const te = elements;\n        const m11 = te[0];\n        const m12 = te[4];\n        const m13 = te[8];\n        const m21 = te[1];\n        const m22 = te[5];\n        const m23 = te[9];\n        const m31 = te[2];\n        const m32 = te[6];\n        const m33 = te[10];\n        const trace = m11 + m22 + m33;\n        let s;\n        if (trace > 0) {\n            s = 0.5 / Math.sqrt(trace + 1.0);\n            this.elements[3] = 0.25 / s;\n            this.elements[0] = (m32 - m23) * s;\n            this.elements[1] = (m13 - m31) * s;\n            this.elements[2] = (m21 - m12) * s;\n        }\n        else if (m11 > m22 && m11 > m33) {\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n            this.elements[3] = (m32 - m23) / s;\n            this.elements[0] = 0.25 * s;\n            this.elements[1] = (m12 + m21) / s;\n            this.elements[2] = (m13 + m31) / s;\n        }\n        else if (m22 > m33) {\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n            this.elements[3] = (m13 - m31) / s;\n            this.elements[0] = (m12 + m21) / s;\n            this.elements[1] = 0.25 * s;\n            this.elements[2] = (m23 + m32) / s;\n        }\n        else {\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n            this.elements[3] = (m21 - m12) / s;\n            this.elements[0] = (m13 + m31) / s;\n            this.elements[1] = (m23 + m32) / s;\n            this.elements[2] = 0.25 * s;\n        }\n        return this;\n    }\n    lerp(a, b, t) {\n        const out = this.elements;\n        const ax = a[0];\n        const ay = a[1];\n        const az = a[2];\n        const aw = a[3];\n        out[0] = ax + t * (b[0] - ax);\n        out[1] = ay + t * (b[1] - ay);\n        out[2] = az + t * (b[2] - az);\n        out[3] = aw + t * (b[3] - aw);\n        return this;\n    }\n}\nclass Vector2 {\n    constructor(opt_src) {\n        const v = new Float32Array(2);\n        if (opt_src && typeof opt_src === 'object') {\n            v[0] = opt_src[0];\n            v[1] = opt_src[1];\n        }\n        this.elements = v;\n    }\n    subtract(b) {\n        const out = this.elements;\n        b = b.elements;\n        out[0] = out[0] - b[0];\n        out[1] = out[1] - b[1];\n        return this;\n    }\n    lerp(a, b, t) {\n        const out = this.elements;\n        const ax = a[0];\n        const ay = a[1];\n        out[0] = ax + t * (b[0] - ax);\n        out[1] = ay + t * (b[1] - ay);\n        return this;\n    }\n}\n// { 0: right, 1: left, 2: bottom. 3: top, 4: far, 5: near }\nfunction Frustum(m) {\n    const planes = [new Vector4, new Vector4, new Vector4, new Vector4, new Vector4, new Vector4];\n    const me = m.elements;\n    let me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];\n    let me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];\n    let me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];\n    let me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];\n    planes[0].set([me3 - me0, me7 - me4, me11 - me8, me15 - me12]).normalize();\n    planes[1].set([me3 + me0, me7 + me4, me11 + me8, me15 + me12]).normalize();\n    planes[2].set([me3 + me1, me7 + me5, me11 + me9, me15 + me13]).normalize();\n    planes[3].set([me3 - me1, me7 - me5, me11 - me9, me15 - me13]).normalize();\n    planes[4].set([me3 - me2, me7 - me6, me11 - me10, me15 - me14]).normalize();\n    planes[5].set([me3 + me2, me7 + me6, me11 + me10, me15 + me14]).normalize();\n    return planes;\n}\n\n\n// CONCATENATED MODULE: ./src/objects.ts\n\nclass objects_Object3D {\n    constructor(name, parent) {\n        this.uuid = Math.floor(Date.now() * Math.random());\n        this.name = name;\n        this.children = [];\n        this.matrix = new Matrix4;\n        this.matrixWorld = new Matrix4;\n        this.parent = parent;\n    }\n    setPosition(translation, rotation, scale) {\n        if (rotation) {\n            this.matrix.makeRotationFromQuaternion(rotation);\n        }\n        if (scale) {\n            this.matrix.scale(new Vector3(scale));\n        }\n        if (translation) {\n            this.matrix.setTranslate(new Vector3(translation));\n        }\n    }\n    setMatrix(matrix) {\n        this.matrix.set(matrix);\n    }\n    setMatrixWorld(matrix) {\n        this.matrixWorld.set(matrix);\n    }\n    updateMatrix() {\n        const m = new Matrix4;\n        m.multiply(this.parent.matrixWorld);\n        m.multiply(this.matrix);\n        this.setMatrixWorld(m.elements);\n    }\n}\nclass objects_Mesh extends objects_Object3D {\n    constructor(name, parent) {\n        super(name, parent);\n        this.geometry = {\n            boundingSphere: {\n                center: new Vector3,\n                radius: null,\n                min: null,\n                max: null\n            },\n            UBO: null,\n            VAO: null,\n            indicesBuffer: null,\n            attributes: null,\n            targets: null,\n            blend: null,\n            uniforms: null,\n            SKIN: null\n        };\n        this.material = {\n            blend: null,\n            uniforms: null,\n            alphaMode: null,\n            UBO: null,\n            pbrMetallicRoughness: null\n        };\n        this.program = null;\n        this.defines = null;\n        this.mode = 4;\n    }\n    setBlend(value) {\n        this.material.blend = value;\n    }\n    setMaterial(material) {\n        this.material = material;\n        this.material.uniforms = {\n            baseColorTexture: null,\n            metallicRoughnessTexture: null,\n            normalTexture: null,\n            occlusionTexture: null,\n            emissiveTexture: null\n        };\n    }\n    calculateBounding() {\n        const vertices = this.geometry.attributes.POSITION;\n        let maxRadiusSq = 0;\n        this.geometry.boundingSphere.center\n            .add(this.geometry.boundingSphere.min)\n            .add(this.geometry.boundingSphere.max)\n            .scale(0.5);\n        for (let i = 0; i < vertices.length; i = i + 3) {\n            maxRadiusSq = Math.max(maxRadiusSq, this.geometry.boundingSphere.center.distanceToSquared(vertices[i], vertices[i + 1], vertices[i + 2]));\n        }\n        this.geometry.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n    }\n    setBoundingBox({ min, max }) {\n        this.geometry.boundingSphere.min = new Vector3(min);\n        this.geometry.boundingSphere.max = new Vector3(max);\n        this.calculateBounding();\n    }\n    setIndicesBuffer(value) {\n        this.geometry.indicesBuffer = value;\n    }\n    setAttributes(value) {\n        this.geometry.attributes = value;\n    }\n    setTargets(value) {\n        this.geometry.targets = value;\n    }\n    setProgram(value) {\n        this.program = value;\n    }\n    setMode(value) {\n        this.mode = value;\n    }\n    isVisible(planes) {\n        const c = new Vector3(this.geometry.boundingSphere.center.elements).applyMatrix4(this.matrixWorld);\n        const r = this.geometry.boundingSphere.radius * this.matrixWorld.getMaxScaleOnAxis();\n        let dist;\n        let visible = true;\n        for (const p of planes) {\n            dist = p.elements[0] * c.elements[0] + p.elements[1] * c.elements[1] + p.elements[2] * c.elements[2] + p.elements[3];\n            if (dist < -r) {\n                visible = false;\n                break;\n            }\n        }\n        this.distance = dist + r;\n        return visible;\n    }\n}\nclass objects_SkinnedMesh extends objects_Mesh {\n    constructor(name, parent) {\n        super(name, parent);\n    }\n    setSkin(value) {\n        this.skin = value;\n        return this;\n    }\n    getJointMatrix() {\n        const m = new Matrix4(this.matrixWorld).invert();\n        const resArray = [];\n        for (let mi = 0; mi < this.boneInverses.length; mi++) {\n            const res = new Matrix4()\n                .multiply(m)\n                .multiply(this.bones[mi].matrixWorld)\n                .multiply(this.boneInverses[mi]);\n            resArray.push(res);\n        }\n        return resArray;\n    }\n}\nclass Bone extends objects_Object3D {\n}\nclass objects_Camera extends objects_Object3D {\n    constructor(name, parent) {\n        super(name, parent);\n        this.matrixWorldInvert = new Matrix4;\n        this.projection = new Matrix4;\n    }\n    setProps(props) {\n        this.props = props;\n    }\n    setProjection(matrix) {\n        this.projection.set(matrix.elements);\n    }\n    setMatrixWorld(matrix) {\n        super.setMatrixWorld(matrix);\n        this.matrixWorldInvert.setInverseOf(this.matrixWorld);\n    }\n    setZ(z) {\n        this.matrix.elements[14] = z;\n        this.setMatrixWorld(this.matrix.elements);\n    }\n    getViewProjMatrix() {\n        const m = new Matrix4;\n        m.multiply(this.projection);\n        m.multiply(this.matrixWorldInvert);\n        return m;\n    }\n}\nclass objects_Scene {\n    constructor() {\n        this.opaqueChildren = [];\n        this.transparentChildren = [];\n        this.children = [];\n        this.bin = [];\n        this.matrixWorld = new Matrix4;\n    }\n}\n\n\n// CONCATENATED MODULE: ./src/events.ts\nclass Events {\n    constructor(redraw) {\n        this.redraw = redraw;\n        this.zoomValue = 0;\n        document.addEventListener('wheel', this);\n        document.addEventListener('mousedown', this);\n        document.addEventListener('mousemove', this);\n        document.addEventListener('mouseup', this);\n        document.addEventListener('keyup', this);\n        document.addEventListener('keydown', this);\n        addEventListener('resize', this);\n    }\n    handleEvent(e) {\n        switch (e.type) {\n            case 'wheel':\n                this.zoom(e);\n                break;\n            case 'mousedown':\n                this.onStart(e);\n                break;\n            case 'mousemove':\n                this.onMove(e);\n                break;\n            case 'mouseup':\n                this.onEnd();\n                break;\n            case 'keyup':\n                this.onKeyUp();\n                break;\n            case 'keydown':\n                this.onKeyDown(e);\n                break;\n            case 'resize':\n                this.onResize();\n                break;\n        }\n    }\n    onResize() {\n        this.redraw('resize');\n    }\n    onKeyDown(e) {\n        if (e.shiftKey || e.ctrlKey) {\n            this.isPan = true;\n        }\n    }\n    onKeyUp() {\n        this.isPan = false;\n    }\n    onStart(e) {\n        this.x = e.clientX;\n        this.y = e.clientY;\n        this.isDrag = true;\n    }\n    onMove(e) {\n        if (this.isDrag) {\n            if (this.isPan) {\n                this.redraw('pan', [this.x, this.y], [e.clientX, e.clientY]);\n            }\n            else {\n                this.redraw('rotate', [this.x, this.y], [e.clientX, e.clientY]);\n            }\n            this.x = e.clientX;\n            this.y = e.clientY;\n        }\n    }\n    onEnd() {\n        this.isDrag = false;\n    }\n    zoom(e) {\n        this.zoomValue = Math.min(this.zoomValue + e.deltaY, 1250);\n        this.redraw('zoom', Math.pow(1.001, this.zoomValue));\n    }\n}\n\n\n// CONCATENATED MODULE: ./src/utils.ts\n\nconst glEnum = {};\nlet gl;\nfunction setGl(_gl) {\n    gl = _gl;\n    for (const k in gl) {\n        const v = gl[k];\n        if (typeof v === 'number') {\n            glEnum[v] = k;\n        }\n    }\n}\nfunction isMatrix(type) {\n    return glEnum[type] === 'FLOAT_MAT4' || glEnum[type] === 'FLOAT_MAT3' || glEnum[type] === 'FLOAT_MAT2';\n}\nfunction random(min, max) {\n    return Math.random() * (max - min) + min;\n}\nfunction getMatrixType(type) {\n    if (glEnum[type] === 'FLOAT_MAT4') {\n        return Matrix4;\n    }\n    if (glEnum[type] === 'FLOAT_MAT3') {\n        return Matrix3;\n    }\n    if (glEnum[type] === 'FLOAT_MAT2') {\n        return Matrix2;\n    }\n}\nfunction getDataType(type) {\n    let count;\n    switch (type) {\n        case 'MAT2':\n            count = 4;\n            break;\n        case 'MAT3':\n            count = 9;\n            break;\n        case 'MAT4':\n            count = 16;\n            break;\n        case 'VEC4':\n            count = 4;\n            break;\n        case 'VEC3':\n            count = 3;\n            break;\n        case 'VEC2':\n            count = 2;\n            break;\n        case 'SCALAR':\n            count = 1;\n            break;\n    }\n    return count;\n}\nfunction getComponentType(type) {\n    let count;\n    switch (glEnum[type]) {\n        case 'FLOAT_VEC4':\n            count = 4;\n            break;\n        case 'FLOAT_VEC3':\n            count = 3;\n            break;\n        case 'FLOAT_VEC2':\n            count = 2;\n            break;\n    }\n    return count;\n}\nfunction getMethod(type) {\n    let method;\n    switch (glEnum[type]) {\n        case 'FLOAT_VEC2':\n            method = 'uniform2f';\n            break;\n        case 'FLOAT_VEC4':\n            method = 'uniform4f';\n            break;\n        case 'FLOAT':\n            method = 'uniform1f';\n            break;\n        case 'FLOAT_VEC3':\n            method = 'uniform3f';\n            break;\n        case 'FLOAT_MAT4':\n            method = 'uniformMatrix4fv';\n            break;\n        case 'FLOAT_MAT3':\n            method = 'uniformMatrix3fv';\n            break;\n        case 'FLOAT_MAT2':\n            method = 'uniformMatrix2fv';\n            break;\n        case 'SAMPLER_2D':\n            method = 'uniform1i';\n            break;\n    }\n    return method;\n}\nfunction getAnimationComponent(type) {\n    if (type === 'rotation') {\n        return 4;\n    }\n    else if (type === 'weights') {\n        return 2;\n    }\n    else {\n        return 3;\n    }\n}\nfunction range(min, max, value) {\n    return (value - min) / (max - min);\n}\nfunction interpolation(time, frames) {\n    if (frames.length === 0) {\n        return [-1, -1, 0];\n    }\n    let prev = -1;\n    for (let i = frames.length - 1; i >= 0; i--) {\n        if (time >= frames[i].time) {\n            prev = i;\n            break;\n        }\n    }\n    if (prev === -1 || prev === frames.length - 1) {\n        if (prev < 0) {\n            prev = 0;\n        }\n        return [prev, prev, 0];\n    }\n    else {\n        const startFrame = frames[prev];\n        const endFrame = frames[prev + 1];\n        time = Math.max(startFrame.time, Math.min(time, endFrame.time));\n        const t = range(startFrame.time, endFrame.time, time);\n        return [prev, prev + 1, t];\n    }\n}\nfunction getCount(type) {\n    let arr;\n    switch (glEnum[type]) {\n        case 'BYTE':\n        case 'UNSIGNED_BYTE':\n            arr = 1;\n            break;\n        case 'SHORT':\n        case 'UNSIGNED_SHORT':\n            arr = 2;\n            break;\n        case 'UNSIGNED_INT':\n        case 'FLOAT':\n            arr = 4;\n            break;\n    }\n    return arr;\n}\nfunction buildArray(arrayBuffer, type, offset, length, stride, count) {\n    const l = length;\n    const c = length / count;\n    if (stride && stride !== getCount(type) * c) {\n        length = stride * count / getCount(type) - offset / getCount(type);\n    }\n    let arr;\n    switch (glEnum[type]) {\n        case 'BYTE':\n            arr = new Int8Array(arrayBuffer, offset, length);\n            break;\n        case 'UNSIGNED_BYTE':\n            arr = new Uint8Array(arrayBuffer, offset, length);\n            break;\n        case 'SHORT':\n            arr = new Int16Array(arrayBuffer, offset, length);\n            break;\n        case 'UNSIGNED_SHORT':\n            arr = new Uint16Array(arrayBuffer, offset, length);\n            break;\n        case 'UNSIGNED_INT':\n            arr = new Uint32Array(arrayBuffer, offset, length);\n            break;\n        case 'FLOAT':\n            arr = new Float32Array(arrayBuffer, offset, length);\n            break;\n    }\n    if (stride && stride !== getCount(type) * c) {\n        const stridedArr = new Float32Array(l);\n        let j = 0;\n        for (let i = 0; i < stridedArr.length; i = i + c) {\n            stridedArr[i] = arr[j];\n            stridedArr[i + 1] = arr[j + 1];\n            stridedArr[i + 2] = arr[j + 2];\n            j = j + c * (stride / getCount(type) / c);\n        }\n        return stridedArr;\n    }\n    return arr;\n}\nfunction compileShader(type, shaderSource, program) {\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, shaderSource);\n    gl.compileShader(shader);\n    gl.attachShader(program, shader);\n    const log = gl.getShaderInfoLog(shader);\n    if (log) {\n        console.error(log);\n    }\n}\nfunction walk(node, callback) {\n    function _walk(node) {\n        callback(node);\n        if (node.children) {\n            node.children.forEach(_walk);\n        }\n    }\n    _walk(node);\n}\nfunction sceneToArcBall(pos) {\n    let len = pos[0] * pos[0] + pos[1] * pos[1];\n    const sz = 0.04 * 0.04 - len;\n    if (sz > 0) {\n        return [pos[0], pos[1], Math.sqrt(sz)];\n    }\n    else {\n        len = Math.sqrt(len);\n        return [0.04 * pos[0] / len, 0.04 * pos[1] / len, 0];\n    }\n}\nfunction canvasToWorld(vec2, projection, width, height) {\n    const [x, y] = vec2;\n    const newM = new Matrix4;\n    newM.setTranslate(new Vector3([0, 0, 0.05]));\n    const m = new Matrix4(projection);\n    m.multiply(newM);\n    const mp = m.multiplyVector4(new Vector4([0, 0, 0, 1]));\n    mp.elements[0] = (2 * x / width - 1) * mp.elements[3];\n    mp.elements[1] = (-2 * y / height + 1) * mp.elements[3];\n    const v = m.invert().multiplyVector4(mp);\n    return [v.elements[0], v.elements[1]];\n}\nfunction calculateProjection(cam) {\n    const { aspect, zoom } = cam;\n    let proj;\n    if (cam.type === 'perspective' && cam.perspective) {\n        const { yfov } = cam.perspective;\n        const xfov = yfov * aspect;\n        proj = new Matrix4().setPerspective(xfov * zoom * (180 / Math.PI), aspect, cam.perspective.znear || 1, cam.perspective.zfar || 2e6);\n    }\n    else if (cam.type === 'orthographic' && cam.orthographic) {\n        proj = new Matrix4().setOrtho(cam.orthographic.xmag, cam.orthographic.ymag, cam.orthographic.znear, cam.orthographic.zfar);\n    }\n    return proj;\n}\nfunction calculateOffset(a = 0, b = 0) {\n    return a + b;\n}\nfunction getAttributeIndex(name) {\n    let index;\n    switch (name) {\n        case 'POSITION':\n            index = [0, 3, gl.FLOAT];\n            break;\n        case 'NORMAL':\n            index = [1, 3, gl.FLOAT];\n            break;\n        case 'TEXCOORD_0':\n            index = [2, 2, gl.FLOAT];\n            break;\n        case 'JOINTS_0':\n            index = [3, 4, gl.UNSIGNED_SHORT];\n            break;\n        case 'WEIGHTS_0':\n            index = [4, 4, gl.FLOAT];\n            break;\n        case 'TANGENT':\n            index = [5, 4, gl.FLOAT];\n            break;\n    }\n    return index;\n}\nfunction calculateBinormals(index, vertex, normal, uv) {\n    const tangent = new Float32Array(normal.length / 3 * 4);\n    for (let i = 0; i < index.length; i += 3) {\n        const faceIndexes = [index[i], index[i + 1], index[i + 2]];\n        const faceVertices = faceIndexes.map(ix => vectorFromArray(vertex, ix));\n        const faceUVs = faceIndexes.map(ix => vectorFromArray(uv, ix, 2));\n        const dv1 = faceVertices[1].subtract(faceVertices[0]);\n        const dv2 = faceVertices[2].subtract(faceVertices[0]);\n        const duv1 = faceUVs[1].subtract(faceUVs[0]);\n        const duv2 = faceUVs[2].subtract(faceUVs[0]);\n        let r = (duv1.elements[0] * duv2.elements[1] - duv1.elements[1] * duv2.elements[0]);\n        r = (r !== 0) ? 1.0 / r : 1.0;\n        const udir = new Vector3([\n            (duv2.elements[1] * dv1.elements[0] - duv1.elements[1] * dv2.elements[0]) * r,\n            (duv2.elements[1] * dv1.elements[1] - duv1.elements[1] * dv2.elements[1]) * r,\n            (duv2.elements[1] * dv1.elements[2] - duv1.elements[1] * dv2.elements[2]) * r\n        ]);\n        udir.normalize();\n        faceIndexes.forEach(ix => {\n            accumulateVectorInArray(tangent, ix, udir);\n        });\n    }\n    return tangent;\n    function vectorFromArray(array, index, elements = 3) {\n        index = index * elements;\n        if (elements === 3) {\n            return new Vector3([array[index], array[index + 1], array[index + 2]]);\n        }\n        if (elements === 2) {\n            return new Vector2([array[index], array[index + 1]]);\n        }\n    }\n    function accumulateVectorInArray(array, index, vector, elements = 4, accumulator = (acc, x) => acc + x) {\n        index = index * elements;\n        for (let i = 0; i < elements; ++i) {\n            if (i === 3) {\n                array[index + i] = -1;\n            }\n            else {\n                array[index + i] = accumulator(array[index + i], vector.elements[i]);\n            }\n        }\n    }\n}\n\n// EXTERNAL MODULE: ./src/images/env.jpg\nvar env = __webpack_require__(4);\nvar env_default = /*#__PURE__*/__webpack_require__.n(env);\n\n// EXTERNAL MODULE: ./src/shaders/env.glsl\nvar shaders_env = __webpack_require__(3);\nvar shaders_env_default = /*#__PURE__*/__webpack_require__.n(shaders_env);\n\n// EXTERNAL MODULE: ./src/shaders/blurEnv.glsl\nvar blurEnv = __webpack_require__(2);\nvar blurEnv_default = /*#__PURE__*/__webpack_require__.n(blurEnv);\n\n// CONCATENATED MODULE: ./src/env.ts\n\n\n\n\n\nlet env_gl;\nclass env_Env {\n    constructor() {\n        this.envMatrix = new Matrix4;\n    }\n    setCamera(camera) {\n        this._camera = camera;\n    }\n    setGl(g) {\n        env_gl = g;\n    }\n    createEnvironment() {\n        env_gl.useProgram(this.program);\n        env_gl.bindVertexArray(this.VAO);\n        const m = new Matrix4;\n        m.multiply(this._camera.projection);\n        m.multiply(this._camera.matrixWorldInvert);\n        m.multiply(this.envMatrix);\n        env_gl.uniform1f(env_gl.getUniformLocation(this.program, 'level'), 3);\n        env_gl.uniform1i(env_gl.getUniformLocation(this.program, 'diffuse'), 0);\n        env_gl.uniformMatrix4fv(env_gl.getUniformLocation(this.program, 'MVPMatrix'), false, m.elements);\n        env_gl.drawElements(env_gl.TRIANGLES, this.IndexBufferLength, env_gl.UNSIGNED_SHORT, 0);\n    }\n    createEnvironmentBuffer() {\n        const latitudeBands = 30;\n        const longitudeBands = 30;\n        const radius = this._camera.modelSize * 10;\n        const vertexPositionData = [];\n        const normalData = [];\n        const textureCoordData = [];\n        for (let latNumber = 0; latNumber <= latitudeBands; latNumber++) {\n            const theta = latNumber * Math.PI / latitudeBands;\n            const sinTheta = Math.sin(theta);\n            const cosTheta = Math.cos(theta);\n            for (let longNumber = 0; longNumber <= longitudeBands; longNumber++) {\n                const phi = longNumber * 2 * Math.PI / longitudeBands;\n                const sinPhi = Math.sin(phi);\n                const cosPhi = Math.cos(phi);\n                const x = cosPhi * sinTheta;\n                const y = cosTheta;\n                const z = sinPhi * sinTheta;\n                const u = 1 - (longNumber / longitudeBands);\n                const v = 1 - (latNumber / latitudeBands);\n                normalData.push(x);\n                normalData.push(y);\n                normalData.push(z);\n                textureCoordData.push(u);\n                textureCoordData.push(v);\n                vertexPositionData.push(radius * x);\n                vertexPositionData.push(radius * y);\n                vertexPositionData.push(radius * z);\n            }\n        }\n        const indexData = [];\n        for (let latNumber = 0; latNumber < latitudeBands; latNumber++) {\n            for (let longNumber = 0; longNumber < longitudeBands; longNumber++) {\n                const first = (latNumber * (longitudeBands + 1)) + longNumber;\n                const second = first + longitudeBands + 1;\n                indexData.push(first);\n                indexData.push(second);\n                indexData.push(first + 1);\n                indexData.push(second);\n                indexData.push(second + 1);\n                indexData.push(first + 1);\n            }\n        }\n        this.VAO = env_gl.createVertexArray();\n        env_gl.bindVertexArray(this.VAO);\n        {\n            const VBO = env_gl.createBuffer();\n            env_gl.bindBuffer(env_gl.ARRAY_BUFFER, VBO);\n            env_gl.bufferData(env_gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), env_gl.STATIC_DRAW);\n            env_gl.enableVertexAttribArray(0);\n            env_gl.vertexAttribPointer(0, 3, env_gl.FLOAT, false, 0, 0);\n        }\n        {\n            const VBO = env_gl.createBuffer();\n            env_gl.bindBuffer(env_gl.ARRAY_BUFFER, VBO);\n            env_gl.bufferData(env_gl.ARRAY_BUFFER, new Float32Array(textureCoordData), env_gl.STATIC_DRAW);\n            env_gl.enableVertexAttribArray(1);\n            env_gl.vertexAttribPointer(1, 2, env_gl.FLOAT, false, 0, 0);\n        }\n        {\n            const VBO = env_gl.createBuffer();\n            env_gl.bindBuffer(env_gl.ELEMENT_ARRAY_BUFFER, VBO);\n            env_gl.bufferData(env_gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), env_gl.STATIC_DRAW);\n            this.IndexBufferLength = indexData.length;\n        }\n        env_gl.bindVertexArray(null);\n        this.program = env_gl.createProgram();\n        compileShader(env_gl.VERTEX_SHADER, shaders_env_default.a, this.program);\n        compileShader(env_gl.FRAGMENT_SHADER, blurEnv_default.a, this.program);\n        env_gl.linkProgram(this.program);\n        return new Promise((resolve, reject) => {\n            const texture = env_gl.createTexture();\n            const img = new Image;\n            img.crossOrigin = 'anonymous';\n            img.onload = () => {\n                env_gl.activeTexture(env_gl.TEXTURE0);\n                env_gl.bindTexture(env_gl.TEXTURE_2D, texture);\n                env_gl.pixelStorei(env_gl.UNPACK_FLIP_Y_WEBGL, true);\n                env_gl.texImage2D(env_gl.TEXTURE_2D, 0, env_gl.RGBA, env_gl.RGBA, env_gl.UNSIGNED_BYTE, img);\n                env_gl.texParameteri(env_gl.TEXTURE_2D, env_gl.TEXTURE_MAG_FILTER, env_gl.LINEAR);\n                env_gl.texParameteri(env_gl.TEXTURE_2D, env_gl.TEXTURE_MIN_FILTER, env_gl.LINEAR_MIPMAP_NEAREST);\n                env_gl.generateMipmap(env_gl.TEXTURE_2D);\n                resolve();\n            };\n            img.onerror = err => {\n                reject(err);\n            };\n            img.src = env_default.a;\n        });\n    }\n}\n\n// CONCATENATED MODULE: ./src/fps.ts\nclass FPS {\n    constructor() {\n        this.counterEl = document.createElement('div');\n        this.counterEl.setAttribute('style', 'position: absolute; top: 0; right: 0; color: #fff; font-size: 30px; background: #000;');\n        document.body.appendChild(this.counterEl);\n        this.fps = 0;\n        this.elapsedTime = 0;\n        this.lastTime = 0;\n    }\n    tick(time) {\n        this.fps++;\n        this.elapsedTime += (time - this.lastTime);\n        this.lastTime = time;\n        if (this.elapsedTime >= 1000) {\n            this.counterEl.innerHTML = String(this.fps);\n            this.fps = 0;\n            this.elapsedTime -= 1000;\n        }\n    }\n}\n\n// EXTERNAL MODULE: ./src/shaders/vertex.glsl\nvar shaders_vertex = __webpack_require__(1);\nvar vertex_default = /*#__PURE__*/__webpack_require__.n(shaders_vertex);\n\n// EXTERNAL MODULE: ./src/shaders/fragment.glsl\nvar fragment = __webpack_require__(0);\nvar fragment_default = /*#__PURE__*/__webpack_require__.n(fragment);\n\n// CONCATENATED MODULE: ./src/parse.ts\n\n\n\n\n\nlet parse_gl;\nlet sceneTextureCount = 1;\nclass parse_Parse {\n    constructor(url) {\n        this.url = url;\n        this.host = url.substr(0, url.lastIndexOf('/') + 1);\n        this.tracks = [];\n        this.skins = [];\n        this.textures = null;\n        this.samplers = null;\n        this.arrayBuffer = null;\n        this.cameras = [];\n        this.programs = {};\n    }\n    setScene(scene) {\n        this.scene = scene;\n    }\n    setGl(g) {\n        parse_gl = g;\n    }\n    setCamera(camera) {\n        this._camera = camera;\n    }\n    setCanvas(canvas) {\n        this.canvas = canvas;\n    }\n    setResize(resize) {\n        this.resize = resize;\n    }\n    setUpdateCamera(updateCamera) {\n        this.updateCamera = updateCamera;\n    }\n    get width() {\n        return this.canvas.offsetWidth;\n    }\n    getBuffer() {\n        return Promise.all(this.scene.bin.map(url => fetch(`${this.host}${url}`).then(res => res.arrayBuffer())))\n            .then(buffers => {\n            this.arrayBuffer = buffers;\n        });\n    }\n    compileShader(vertexShader, fragmentShader) {\n        const program = parse_gl.createProgram();\n        compileShader(parse_gl.VERTEX_SHADER, vertexShader, program);\n        compileShader(parse_gl.FRAGMENT_SHADER, fragmentShader, program);\n        parse_gl.linkProgram(program);\n        return program;\n    }\n    buildPrim(parent, name, skin, weights, p) {\n        const indicesAccessor = this.json.accessors[p.indices];\n        const vertexAccessor = new Map;\n        for (const a in p.attributes) {\n            vertexAccessor.set(a, this.json.accessors[p.attributes[a]]);\n        }\n        const targets = [];\n        if (p.targets) {\n            for (const target of p.targets) {\n                const vertexAcc = {};\n                for (const a in target) {\n                    vertexAcc[a] = this.json.accessors[target[a]];\n                    const accessor = vertexAcc[a];\n                    const bufferView = this.json.bufferViews[accessor.bufferView];\n                    vertexAcc[a] = buildArray(this.arrayBuffer[bufferView.buffer], accessor.componentType, calculateOffset(bufferView.byteOffset, accessor.byteOffset), getDataType(accessor.type) * accessor.count);\n                }\n                targets.push(vertexAcc);\n            }\n        }\n        const material = p.material !== undefined ? JSON.parse(JSON.stringify(this.json.materials[p.material])) : { pbrMetallicRoughness: { baseColorFactor: [0.8, 0.8, 0.8, 1.0] } };\n        const defines = [];\n        if (material.pbrMetallicRoughness.metallicRoughnessTexture) {\n            material.pbrMetallicRoughness.metallicRoughnessTexture = Object.assign({}, this.textures[material.pbrMetallicRoughness.metallicRoughnessTexture.index]);\n            defines.push({ name: 'USE_PBR' });\n            defines.push({ name: 'METALROUGHNESSMAP' });\n        }\n        if (material.normalTexture) {\n            material.normalTexture = Object.assign({}, this.textures[material.normalTexture.index]);\n            defines.push({ name: 'NORMALMAP' });\n        }\n        if (material.occlusionTexture) {\n            material.occlusionTexture = Object.assign({}, this.textures[material.occlusionTexture.index]);\n            defines.push({ name: 'OCCLUSIONMAP' });\n        }\n        if (material.pbrMetallicRoughness.baseColorTexture) {\n            material.pbrMetallicRoughness.baseColorTexture = Object.assign({}, this.textures[material.pbrMetallicRoughness.baseColorTexture.index]);\n            defines.push({ name: 'BASECOLORTEXTURE' });\n        }\n        if (material.emissiveTexture) {\n            material.emissiveTexture = Object.assign({}, this.textures[material.emissiveTexture.index]);\n            defines.push({ name: 'EMISSIVEMAP' });\n        }\n        if (skin !== undefined) {\n            defines.push({ name: 'JOINTNUMBER', value: this.skins[skin].jointNames.length });\n        }\n        if (p.attributes.TANGENT || material.normalTexture) {\n            defines.push({ name: 'TANGENT' });\n        }\n        let program;\n        if (this.programs[defines.map(define => define.name).join('')]) {\n            program = this.programs[defines.map(define => define.name).join('')];\n        }\n        else {\n            const defineStr = defines.map(define => `#define ${define.name} ${define.value || 1}` + '\\n').join('');\n            program = this.compileShader(vertex_default.a.replace(/\\n/, `\\n${defineStr}`), fragment_default.a.replace(/\\n/, `\\n${defineStr}`));\n            this.programs[defines.map(define => define.name).join('')] = program;\n        }\n        let indicesBuffer;\n        if (indicesAccessor) {\n            const bufferView = this.json.bufferViews[indicesAccessor.bufferView];\n            indicesBuffer = buildArray(this.arrayBuffer[bufferView.buffer], indicesAccessor.componentType, calculateOffset(bufferView.byteOffset, indicesAccessor.byteOffset), getDataType(indicesAccessor.type) * indicesAccessor.count);\n        }\n        const boundingBox = {\n            min: vertexAccessor.get('POSITION').min,\n            max: vertexAccessor.get('POSITION').max\n        };\n        const vertexBuffers = {};\n        for (const k of vertexAccessor.keys()) {\n            const accessor = vertexAccessor.get(k);\n            const bufferView = this.json.bufferViews[accessor.bufferView];\n            vertexBuffers[k] = buildArray(this.arrayBuffer[bufferView.buffer], accessor.componentType, calculateOffset(bufferView.byteOffset, accessor.byteOffset), getDataType(accessor.type) * accessor.count, bufferView.byteStride, accessor.count);\n            if (p.targets && k in p.targets[0]) {\n                let offset = 0;\n                const geometry = vertexBuffers[k];\n                vertexBuffers[k] = new Float32Array(geometry.length);\n                for (let i = 0; i < vertexBuffers[k].length; i++) {\n                    if (k === 'TANGENT' && (i + 1) % 4 === 0) {\n                        offset++;\n                        continue;\n                    }\n                    vertexBuffers[k][i] = geometry[i] + weights[0] * targets[0][k][i - offset] + weights[1] * targets[1][k][i - offset];\n                }\n            }\n        }\n        if (material.normalTexture && p.attributes.TANGENT === undefined) {\n            vertexBuffers.TANGENT = calculateBinormals(indicesBuffer, vertexBuffers.POSITION, vertexBuffers.NORMAL, vertexBuffers.TEXCOORD_0);\n        }\n        const mesh = skin !== undefined ? new objects_SkinnedMesh(name, parent).setSkin(skin) : new objects_Mesh(name, parent);\n        mesh.setProgram(program);\n        mesh.setMode(p.mode);\n        mesh.setMaterial(material);\n        mesh.setAttributes(vertexBuffers);\n        mesh.setIndicesBuffer(indicesBuffer);\n        mesh.setBoundingBox(boundingBox);\n        mesh.setTargets(targets);\n        mesh.updateMatrix();\n        const VAO = parse_gl.createVertexArray();\n        parse_gl.bindVertexArray(VAO);\n        for (const k in vertexBuffers) {\n            const VBO = parse_gl.createBuffer();\n            parse_gl.bindBuffer(parse_gl.ARRAY_BUFFER, VBO);\n            parse_gl.bufferData(parse_gl.ARRAY_BUFFER, vertexBuffers[k], parse_gl.STATIC_DRAW);\n            const index = getAttributeIndex(k);\n            parse_gl.enableVertexAttribArray(index[0]);\n            parse_gl.vertexAttribPointer(index[0], index[1], index[2], false, 0, 0);\n        }\n        if (indicesBuffer) {\n            const VBO = parse_gl.createBuffer();\n            parse_gl.bindBuffer(parse_gl.ELEMENT_ARRAY_BUFFER, VBO);\n            parse_gl.bufferData(parse_gl.ELEMENT_ARRAY_BUFFER, indicesBuffer, parse_gl.STATIC_DRAW);\n        }\n        mesh.geometry.VAO = VAO;\n        parse_gl.bindVertexArray(null);\n        if (material.pbrMetallicRoughness.baseColorTexture) {\n            mesh.material.uniforms.baseColorTexture = parse_gl.getUniformLocation(mesh.program, 'baseColorTexture');\n        }\n        if (material.pbrMetallicRoughness.metallicRoughnessTexture) {\n            mesh.material.uniforms.metallicRoughnessTexture = parse_gl.getUniformLocation(mesh.program, 'metallicRoughnessTexture');\n        }\n        if (material.normalTexture) {\n            mesh.material.uniforms.normalTexture = parse_gl.getUniformLocation(mesh.program, 'normalTexture');\n        }\n        if (material.occlusionTexture) {\n            mesh.material.uniforms.occlusionTexture = parse_gl.getUniformLocation(mesh.program, 'occlusionTexture');\n        }\n        if (material.emissiveTexture) {\n            mesh.material.uniforms.emissiveTexture = parse_gl.getUniformLocation(mesh.program, 'emissiveTexture');\n        }\n        return mesh;\n    }\n    walkByMesh(parent, name) {\n        const el = this.json.nodes[name];\n        let child;\n        if (el.camera !== undefined) {\n            const proj = calculateProjection(this.json.cameras[el.camera]);\n            child = new objects_Camera(name, parent);\n            child.setProps(Object.assign({\n                zoom: 1,\n                aspect: this.canvas.offsetWidth / this.canvas.offsetHeight\n            }, this.json.cameras[el.camera]));\n            child.setProjection(proj);\n            this._camera = child;\n            this.updateCamera(this._camera);\n            this.cameras.push(child);\n        }\n        else {\n            if (el.isBone !== undefined) {\n                child = new Bone(name, parent);\n            }\n            else {\n                child = new objects_Object3D(name, parent);\n            }\n        }\n        if (el.translation || el.rotation || el.scale) {\n            child.setPosition(el.translation, el.rotation, el.scale);\n        }\n        else if (el.matrix) {\n            child.setMatrix(el.matrix);\n        }\n        child.updateMatrix();\n        parent.children.push(child);\n        parent = child;\n        if (el.mesh !== undefined) {\n            if (el.skin !== undefined) {\n                for (const join of this.skins[el.skin].jointNames) {\n                    walk(this.scene, this.buildBones.bind(this, join, this.skins[el.skin]));\n                }\n            }\n            parent.children.push(...this.json.meshes[el.mesh].primitives.map(this.buildPrim.bind(this, parent, this.json.meshes[el.mesh].name, el.skin, this.json.meshes[el.mesh].weights)));\n        }\n        if (el.children && el.children.length) {\n            el.children.forEach(this.walkByMesh.bind(this, parent));\n        }\n    }\n    calculateFov() {\n        let biggestMesh;\n        walk(this.scene, node => {\n            if (node instanceof objects_Mesh) {\n                if (!biggestMesh) {\n                    biggestMesh = node;\n                }\n                if (node.geometry.boundingSphere.radius > biggestMesh.geometry.boundingSphere.radius) {\n                    biggestMesh = node;\n                }\n            }\n        });\n        const a = Math.abs;\n        const min = biggestMesh.geometry.boundingSphere.min.elements;\n        const max = biggestMesh.geometry.boundingSphere.max.elements;\n        this._camera.modelXSize = Math.max(a(min[0]), a(min[2]), a(max[0]), a(max[2]), Math.sqrt(min[0] * min[0] + min[2] * min[2]), Math.sqrt(max[0] * max[0] + max[2] * max[2]));\n        this._camera.modelYSize = Math.max(a(min[1]), a(min[2]), a(max[1]), a(max[2]));\n        this._camera.modelSize = Math.max(this._camera.modelYSize, this._camera.modelXSize);\n        this.resize();\n    }\n    buildMesh() {\n        this.json.scenes[this.json.scene !== undefined ? this.json.scene : 0].nodes.forEach(n => {\n            if (this.json.nodes[n].children && this.json.nodes[n].children.length) {\n                this.walkByMesh(this.scene, n);\n            }\n            if (this.json.nodes[n].mesh !== undefined) {\n                this.walkByMesh(this.scene, n);\n            }\n            if (this.json.nodes[n].camera !== undefined) {\n                this.walkByMesh(this.scene, n);\n            }\n        });\n        this.calculateFov();\n        const planes = Frustum(this._camera.getViewProjMatrix());\n        walk(this.scene, mesh => {\n            if (mesh instanceof objects_SkinnedMesh) {\n                mesh.bones = this.skins[mesh.skin].bones;\n                mesh.boneInverses = this.skins[mesh.skin].boneInverses;\n                const jointMatrix = mesh.getJointMatrix();\n                const matrices = new Float32Array(jointMatrix.length * 16);\n                let i = 0;\n                for (const j of jointMatrix) {\n                    matrices.set(j.elements, 0 + 16 * i);\n                    i++;\n                }\n                const uIndex = parse_gl.getUniformBlockIndex(mesh.program, 'Skin');\n                parse_gl.uniformBlockBinding(mesh.program, uIndex, 2);\n                const UBO = parse_gl.createBuffer();\n                parse_gl.bindBuffer(parse_gl.UNIFORM_BUFFER, UBO);\n                parse_gl.bufferData(parse_gl.UNIFORM_BUFFER, matrices, parse_gl.DYNAMIC_DRAW);\n                mesh.geometry.SKIN = UBO;\n                parse_gl.bindBuffer(parse_gl.UNIFORM_BUFFER, null);\n            }\n            if (mesh instanceof objects_Mesh) {\n                const materials = new Float32Array(12);\n                materials.set(mesh.material.pbrMetallicRoughness.baseColorFactor || [0.8, 0.8, 0.8, 1.0]);\n                materials.set([this._camera.matrixWorld.elements[12], this._camera.matrixWorld.elements[13], this._camera.matrixWorld.elements[14]], 4);\n                materials.set([this._camera.matrixWorld.elements[12], this._camera.matrixWorld.elements[13], this._camera.matrixWorld.elements[14]], 8);\n                const mIndex = parse_gl.getUniformBlockIndex(mesh.program, 'Material');\n                parse_gl.uniformBlockBinding(mesh.program, mIndex, 1);\n                const mUBO = parse_gl.createBuffer();\n                parse_gl.bindBuffer(parse_gl.UNIFORM_BUFFER, mUBO);\n                parse_gl.bufferData(parse_gl.UNIFORM_BUFFER, materials, parse_gl.STATIC_DRAW);\n                mesh.material.UBO = mUBO;\n                const normalMatrix = new Matrix4(mesh.matrixWorld);\n                normalMatrix.invert().transpose();\n                const matrices = new Float32Array(64);\n                matrices.set(mesh.matrixWorld.elements, 0);\n                matrices.set(normalMatrix.elements, 16);\n                matrices.set(this._camera.matrixWorldInvert.elements, 32);\n                matrices.set(this._camera.projection.elements, 48);\n                const uIndex = parse_gl.getUniformBlockIndex(mesh.program, 'Matrices');\n                parse_gl.uniformBlockBinding(mesh.program, uIndex, 0);\n                const UBO = parse_gl.createBuffer();\n                parse_gl.bindBuffer(parse_gl.UNIFORM_BUFFER, UBO);\n                parse_gl.bufferData(parse_gl.UNIFORM_BUFFER, matrices, parse_gl.DYNAMIC_DRAW);\n                mesh.geometry.UBO = UBO;\n                parse_gl.bindBuffer(parse_gl.UNIFORM_BUFFER, null);\n                if (mesh.isVisible(planes)) {\n                    if (mesh.material.alphaMode) {\n                        this.scene.transparentChildren.push(mesh);\n                    }\n                    else {\n                        this.scene.opaqueChildren.push(mesh);\n                    }\n                }\n            }\n        });\n        this.scene.transparentChildren.sort((a, b) => b.distance - a.distance);\n        return true;\n    }\n    buildAnimation() {\n        if (!this.json.animations) {\n            return true;\n        }\n        for (const animation of this.json.animations) {\n            for (const channel of animation.channels) {\n                const sampler = animation.samplers[channel.sampler];\n                if (sampler) {\n                    const { target } = channel;\n                    const name = target.node;\n                    const input = animation.parameters !== undefined ? animation.parameters[sampler.input] : sampler.input;\n                    const output = animation.parameters !== undefined ? animation.parameters[sampler.output] : sampler.output;\n                    const inputAccessor = this.json.accessors[input];\n                    const outputAccessor = this.json.accessors[output];\n                    const inputBuffer = this.json.bufferViews[inputAccessor.bufferView];\n                    const outputBuffer = this.json.bufferViews[outputAccessor.bufferView];\n                    const inputArray = buildArray(this.arrayBuffer[inputBuffer.buffer], inputAccessor.componentType, calculateOffset(inputBuffer.byteOffset, inputAccessor.byteOffset), getDataType(inputAccessor.type) * inputAccessor.count);\n                    const outputArray = buildArray(this.arrayBuffer[outputBuffer.buffer], outputAccessor.componentType, calculateOffset(outputBuffer.byteOffset, outputAccessor.byteOffset), getDataType(outputAccessor.type) * outputAccessor.count);\n                    const component = getAnimationComponent(target.path);\n                    const keys = [];\n                    for (let i = 0; i < inputArray.length; i++) {\n                        const firstT = inputArray[i];\n                        const firstV = outputArray.slice(i * component, (i + 1) * component);\n                        keys.push({\n                            time: firstT,\n                            value: firstV\n                        });\n                    }\n                    const meshes = [];\n                    walk(this.scene, node => {\n                        if (node.name === name) {\n                            if (target.path === 'weights' && node instanceof objects_Object3D) {\n                                // eslint-disable-next-line\n                                node = node.children[0];\n                            }\n                            meshes.push(node);\n                        }\n                    });\n                    if (meshes.length) {\n                        this.tracks.push({\n                            stoped: false,\n                            meshes: meshes,\n                            type: target.path,\n                            name: `${meshes[0].name}.${target.path}`,\n                            keys: keys,\n                            interpolation: sampler.interpolation\n                        });\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    buildSkin() {\n        if (!this.json.skins) {\n            return true;\n        }\n        for (const skin of this.json.skins) {\n            const acc = this.json.accessors[skin.inverseBindMatrices];\n            const buffer = this.json.bufferViews[acc.bufferView];\n            const array = buildArray(this.arrayBuffer[buffer.buffer], acc.componentType, calculateOffset(buffer.byteOffset, acc.byteOffset), getDataType(acc.type) * acc.count);\n            const v = {\n                jointNames: skin.joints,\n                inverseBindMatrices: array,\n                bones: [],\n                boneInverses: []\n            };\n            let i = 0;\n            for (const join of v.jointNames) {\n                //walk(this.scene, this.buildBones.bind(this, join, v));\n                this.json.nodes[join].isBone = true;\n                const m = v.inverseBindMatrices;\n                const mat = new Matrix4().set(m.slice(i * 16, (i + 1) * 16));\n                v.boneInverses.push(mat);\n                i++;\n            }\n            this.skins.push(v);\n        }\n        return true;\n    }\n    buildBones(join, v, node) {\n        if (node.name === join) {\n            v.bones.push(node);\n        }\n    }\n    getJson() {\n        return fetch(this.url)\n            .then(res => res.json())\n            .then(j => {\n            for (const key in j.buffers) {\n                this.scene.bin.push(j.buffers[key].uri);\n            }\n            this.json = j;\n            return true;\n        });\n    }\n    initTextures() {\n        if (!this.json.textures) {\n            return true;\n        }\n        const samplers = this.json.samplers || [{}];\n        this.samplers = samplers.map(s => {\n            const sampler = parse_gl.createSampler();\n            parse_gl.samplerParameteri(sampler, parse_gl.TEXTURE_MIN_FILTER, s.minFilter || 9986);\n            parse_gl.samplerParameteri(sampler, parse_gl.TEXTURE_MAG_FILTER, s.magFilter || 9729);\n            parse_gl.samplerParameteri(sampler, parse_gl.TEXTURE_WRAP_S, s.wrapS || 10497);\n            parse_gl.samplerParameteri(sampler, parse_gl.TEXTURE_WRAP_T, s.wrapT || 10497);\n            return sampler;\n        });\n        const promiseArr = this.json.textures.map(t => {\n            return new Promise((resolve, reject) => {\n                const sampler = this.samplers[t.sampler !== undefined ? t.sampler : 0];\n                const source = this.json.images[t.source];\n                const image = new Image();\n                image.onload = () => {\n                    resolve(this.handleTextureLoaded(sampler, image));\n                };\n                image.onerror = err => {\n                    reject(err);\n                };\n                image.crossOrigin = 'anonymous';\n                image.src = `${this.host}${source.uri}`;\n            });\n        });\n        return Promise.all(promiseArr)\n            .then(textures => {\n            this.textures = textures;\n            return true;\n        });\n    }\n    handleTextureLoaded(sampler, image) {\n        const t = {\n            image: image.src.substr(image.src.lastIndexOf('/')),\n            data: parse_gl.createTexture(),\n            count: sceneTextureCount\n        };\n        parse_gl.activeTexture(parse_gl[`TEXTURE${sceneTextureCount}`]);\n        parse_gl.bindTexture(parse_gl.TEXTURE_2D, t.data);\n        parse_gl.bindSampler(sceneTextureCount, sampler);\n        parse_gl.texImage2D(parse_gl.TEXTURE_2D, 0, parse_gl.RGBA, parse_gl.RGBA, parse_gl.UNSIGNED_BYTE, image);\n        parse_gl.generateMipmap(parse_gl.TEXTURE_2D);\n        sceneTextureCount++;\n        return t;\n    }\n}\n\n// CONCATENATED MODULE: ./src/redcube.ts\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RedCube\", function() { return redcube_RedCube; });\n/// <reference path='../index.d.ts'/>\n\n\n\n\n\n\n\nlet redcube_gl;\nclass redcube_RedCube {\n    constructor(url, canvas, znear) {\n        this.reflow = true;\n        this.scene = new objects_Scene;\n        this.canvas = canvas;\n        this.camera = new objects_Camera;\n        this.camera.setProps({\n            type: 'perspective',\n            isInitial: true,\n            zoom: 1,\n            aspect: this.canvas.offsetWidth / this.canvas.offsetHeight,\n            perspective: {\n                yfov: 0.6,\n                znear: znear || 1,\n                zfar: 2e6\n            }\n        });\n        this.events = new Events(this.redraw.bind(this));\n        this.fps = new FPS;\n        this.env = new env_Env;\n        this.env.setCamera(this.camera);\n        // this.PP = new PostProcessing;\n        // this.PP.setCanvas(this.canvas);\n        // this.PP.setCamera(this.camera);\n        this.parse = new parse_Parse(url);\n        this.parse.setScene(this.scene);\n        this.parse.setCamera(this.camera);\n        this.parse.setUpdateCamera(this.updateCamera.bind(this));\n        this.parse.setCanvas(this.canvas);\n        this.parse.setResize(this.resize.bind(this));\n    }\n    init() {\n        return this.parse.getJson()\n            .then(this.glInit.bind(this))\n            .then(this.parse.initTextures.bind(this.parse))\n            .then(this.parse.getBuffer.bind(this.parse))\n            .then(this.parse.buildSkin.bind(this.parse))\n            .then(this.parse.buildMesh.bind(this.parse))\n            .then(this.parse.buildAnimation.bind(this.parse))\n            .then(this.env.createEnvironmentBuffer.bind(this.env))\n            .then(this.draw.bind(this))\n            .catch(console.error);\n    }\n    updateCamera(camera) {\n        this.camera = camera;\n        this.env.setCamera(this.camera);\n    }\n    redraw(type, coordsStart, coordsMove) {\n        if (type === 'zoom') {\n            this.camera.props.zoom = coordsStart;\n            this.camera.setProjection(calculateProjection(this.camera.props));\n            this.needUpdateProjection = true;\n        }\n        if (type === 'rotate') {\n            const coordsStartWorld = canvasToWorld(coordsStart, this.camera.projection, this.canvas.offsetWidth, this.canvas.offsetHeight);\n            const coordsMoveWorld = canvasToWorld(coordsMove, this.camera.projection, this.canvas.offsetWidth, this.canvas.offsetHeight);\n            const p0 = new Vector3(sceneToArcBall(coordsStartWorld));\n            const p1 = new Vector3(sceneToArcBall(coordsMoveWorld));\n            const angle = Vector3.angle(p1, p0) * 5;\n            if (angle < 1e-6 || isNaN(angle)) {\n                return;\n            }\n            p0.applyMatrix4(this.camera.matrixWorld);\n            p1.applyMatrix4(this.camera.matrixWorld);\n            const v = Vector3.cross(p1, p0).normalize();\n            const m = new Matrix4;\n            m.makeRotationAxis(v, angle);\n            m.multiply(this.camera.matrixWorld);\n            this.camera.setMatrixWorld(m.elements);\n            this.needUpdateView = true;\n        }\n        if (type === 'pan') {\n            const coordsStartWorld = canvasToWorld(coordsStart, this.camera.projection, this.canvas.offsetWidth, this.canvas.offsetHeight);\n            const coordsMoveWorld = canvasToWorld(coordsMove, this.camera.projection, this.canvas.offsetWidth, this.canvas.offsetHeight);\n            const p0 = new Vector3([...coordsStartWorld, 0]);\n            const p1 = new Vector3([...coordsMoveWorld, 0]);\n            const pan = this.camera.modelSize * 100;\n            const delta = p1.subtract(p0).scale(pan);\n            this.camera.matrixWorld.translate(delta.elements[0], delta.elements[1], 0);\n            this.camera.setMatrixWorld(this.camera.matrixWorld.elements);\n            this.needUpdateView = true;\n        }\n        if (type === 'resize') {\n            this.resize();\n            this.needUpdateProjection = true;\n        }\n        this.reflow = true;\n    }\n    resize() {\n        this.camera.props.aspect = this.canvas.offsetWidth / this.canvas.offsetHeight;\n        this.canvas.width = this.canvas.offsetWidth * devicePixelRatio;\n        this.canvas.height = this.canvas.offsetHeight * devicePixelRatio;\n        redcube_gl.viewport(0, 0, this.canvas.offsetWidth * devicePixelRatio, this.canvas.offsetHeight * devicePixelRatio);\n        this.camera.setProjection(calculateProjection(this.camera.props));\n        if (this.camera.props.isInitial) {\n            const z = 1 / this.canvas.width * this.camera.modelSize * 5000;\n            this.camera.setZ(this.z || z);\n            this.needUpdateView = true;\n        }\n    }\n    glInit() {\n        redcube_gl = this.canvas.getContext('webgl2');\n        if (!redcube_gl) {\n            throw new Error('Webgl 2 doesnt support');\n        }\n        setGl(redcube_gl);\n        this.env.setGl(redcube_gl);\n        //this.PP.setGl(gl);\n        this.parse.setGl(redcube_gl);\n        return true;\n    }\n    animate(sec) {\n        for (const v of this.parse.tracks) {\n            const val = interpolation(sec, v.keys);\n            if (val[0] === -1 || val[1] === -1 || v.stoped) {\n                continue;\n            }\n            if (val[0] === v.keys.length - 1) {\n                v.stoped = true;\n            }\n            const startFrame = v.keys[val[0]];\n            const endFrame = v.keys[val[1]];\n            // eslint-disable-next-line\n            const t = val[2];\n            const component = getAnimationComponent(v.type);\n            let vectorC;\n            if (component === 3) {\n                vectorC = Vector3;\n            }\n            else if (component === 4) {\n                vectorC = Vector4;\n            }\n            else if (component === 2) {\n                vectorC = Vector2;\n            }\n            const vector = new vectorC(startFrame.value);\n            const vector2 = new vectorC(endFrame.value);\n            if (v.type === 'rotation') {\n                const out = new Vector4;\n                out.lerp(vector.elements, vector2.elements, t);\n                for (const mesh of v.meshes) {\n                    mesh.matrix.makeRotationFromQuaternion(out.elements);\n                }\n            }\n            else if (v.type === 'scale') {\n                const out = new Vector3;\n                out.lerp(vector.elements, vector2.elements, t);\n                for (const mesh of v.meshes) {\n                    mesh.matrix.scale(out);\n                }\n            }\n            else if (v.type === 'weights') {\n                const out = new Vector2;\n                out.lerp(vector.elements, vector2.elements, t);\n                for (const mesh of v.meshes) {\n                    const geometry = {};\n                    for (const k in mesh.geometry.targets[0]) {\n                        let offset = 0;\n                        geometry[k] = new Float32Array(mesh.geometry.attributes[k].length);\n                        for (let i = 0; i < geometry[k].length; i++) {\n                            if (k === 'TANGENT' && (i + 1) % 4 === 0) {\n                                offset++;\n                                continue;\n                            }\n                            geometry[k][i] = mesh.geometry.attributes[k][i] + out.elements[0] * mesh.geometry.targets[0][k][i - offset] + out.elements[1] * mesh.geometry.targets[1][k][i - offset];\n                        }\n                    }\n                    redcube_gl.bindVertexArray(mesh.geometry.VAO);\n                    for (const k in geometry) {\n                        const VBO = redcube_gl.createBuffer();\n                        redcube_gl.bindBuffer(redcube_gl.ARRAY_BUFFER, VBO);\n                        redcube_gl.bufferData(redcube_gl.ARRAY_BUFFER, geometry[k], redcube_gl.STATIC_DRAW);\n                        const index = getAttributeIndex(k);\n                        redcube_gl.enableVertexAttribArray(index[0]);\n                        redcube_gl.vertexAttribPointer(index[0], index[1], index[2], false, 0, 0);\n                    }\n                    redcube_gl.bindVertexArray(null);\n                }\n            }\n            else if (v.type === 'translation') {\n                const out = new Vector3;\n                out.lerp(vector.elements, vector2.elements, t);\n                for (const mesh of v.meshes) {\n                    mesh.matrix.setTranslate(out);\n                }\n            }\n            else {\n                console.error('ERROR');\n            }\n            for (const mesh of v.meshes) {\n                walk(mesh, node => {\n                    node.updateMatrix();\n                    if (node instanceof Bone) {\n                        node.reflow = true;\n                    }\n                    if (node instanceof objects_Mesh) {\n                        node.reflow = true;\n                    }\n                    if (node instanceof objects_Camera && node === this.camera) {\n                        this.needUpdateView = true;\n                    }\n                });\n            }\n            this.reflow = true;\n        }\n    }\n    draw() {\n        redcube_gl.clearColor(0.8, 0.8, 0.8, 1.0);\n        this.render();\n    }\n    render(time = 0) {\n        const sec = time / 1000;\n        this.animate(sec);\n        if (this.reflow) {\n            //this.PP.bindBuffer();\n            redcube_gl.clear(redcube_gl.COLOR_BUFFER_BIT | redcube_gl.DEPTH_BUFFER_BIT);\n            this.env.createEnvironment();\n            redcube_gl.enable(redcube_gl.DEPTH_TEST);\n            redcube_gl.enable(redcube_gl.CULL_FACE);\n            this.scene.opaqueChildren.forEach(mesh => this._draw(mesh));\n            if (this.scene.transparentChildren.length) {\n                redcube_gl.enable(redcube_gl.BLEND);\n                redcube_gl.depthMask(false);\n                redcube_gl.blendFuncSeparate(redcube_gl.SRC_COLOR, redcube_gl.DST_COLOR, redcube_gl.ONE, redcube_gl.ZERO);\n                // gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n                this.scene.transparentChildren.forEach(mesh => this._draw(mesh));\n                redcube_gl.disable(redcube_gl.BLEND);\n                redcube_gl.depthMask(true);\n                redcube_gl.blendFuncSeparate(redcube_gl.ONE, redcube_gl.ZERO, redcube_gl.ONE, redcube_gl.ZERO);\n            }\n            walk(this.scene, node => {\n                if (node instanceof Bone) {\n                    node.reflow = false;\n                }\n            });\n            this.needUpdateView = false;\n            this.needUpdateProjection = false;\n            //this.PP.postProcessing();\n        }\n        this.fps.tick(time);\n        this.reflow = false;\n        requestAnimationFrame(this.render.bind(this));\n    }\n    _draw(mesh) {\n        redcube_gl.useProgram(mesh.program);\n        redcube_gl.bindVertexArray(mesh.geometry.VAO);\n        redcube_gl.bindBufferBase(redcube_gl.UNIFORM_BUFFER, 0, mesh.geometry.UBO);\n        if (mesh.reflow) {\n            const normalMatrix = new Matrix4(mesh.matrixWorld);\n            normalMatrix.invert().transpose();\n            const matrices = new Float32Array(32);\n            matrices.set(mesh.matrixWorld.elements);\n            matrices.set(normalMatrix.elements, 16);\n            redcube_gl.bufferSubData(redcube_gl.UNIFORM_BUFFER, 0, matrices);\n            mesh.reflow = false;\n        }\n        if (this.needUpdateView) {\n            redcube_gl.bufferSubData(redcube_gl.UNIFORM_BUFFER, 32 * Float32Array.BYTES_PER_ELEMENT, this.camera.matrixWorldInvert.elements);\n        }\n        if (this.needUpdateProjection) {\n            redcube_gl.bufferSubData(redcube_gl.UNIFORM_BUFFER, 48 * Float32Array.BYTES_PER_ELEMENT, this.camera.projection.elements);\n        }\n        if (mesh instanceof objects_SkinnedMesh) {\n            redcube_gl.bindBufferBase(redcube_gl.UNIFORM_BUFFER, 2, mesh.geometry.SKIN);\n            if (mesh.bones.some(bone => bone.reflow)) {\n                const jointMatrix = mesh.getJointMatrix();\n                const matrices = new Float32Array(jointMatrix.length * 16);\n                let i = 0;\n                for (const j of jointMatrix) {\n                    matrices.set(j.elements, 0 + 16 * i);\n                    i++;\n                }\n                redcube_gl.bufferSubData(redcube_gl.UNIFORM_BUFFER, 0, matrices);\n            }\n        }\n        if (mesh.material.UBO) {\n            redcube_gl.bindBufferBase(redcube_gl.UNIFORM_BUFFER, 1, mesh.material.UBO);\n            if (this.needUpdateView) {\n                redcube_gl.bufferSubData(redcube_gl.UNIFORM_BUFFER, 4 * Float32Array.BYTES_PER_ELEMENT, new Float32Array([this.camera.matrixWorld.elements[12], this.camera.matrixWorld.elements[13], this.camera.matrixWorld.elements[14]]));\n                redcube_gl.bufferSubData(redcube_gl.UNIFORM_BUFFER, 8 * Float32Array.BYTES_PER_ELEMENT, new Float32Array([this.camera.matrixWorld.elements[12], this.camera.matrixWorld.elements[13], this.camera.matrixWorld.elements[14]]));\n            }\n        }\n        if (mesh.material.pbrMetallicRoughness.baseColorTexture) {\n            redcube_gl.uniform1i(mesh.material.uniforms.baseColorTexture, mesh.material.pbrMetallicRoughness.baseColorTexture.count);\n        }\n        if (mesh.material.pbrMetallicRoughness.metallicRoughnessTexture) {\n            redcube_gl.uniform1i(mesh.material.uniforms.metallicRoughnessTexture, mesh.material.pbrMetallicRoughness.metallicRoughnessTexture.count);\n        }\n        if (mesh.material.normalTexture) {\n            redcube_gl.uniform1i(mesh.material.uniforms.normalTexture, mesh.material.normalTexture.count);\n        }\n        if (mesh.material.occlusionTexture) {\n            redcube_gl.uniform1i(mesh.material.uniforms.occlusionTexture, mesh.material.occlusionTexture.count);\n        }\n        if (mesh.material.emissiveTexture) {\n            redcube_gl.uniform1i(mesh.material.uniforms.emissiveTexture, mesh.material.emissiveTexture.count);\n        }\n        if (mesh.material.doubleSided) {\n            redcube_gl.disable(redcube_gl.CULL_FACE);\n        }\n        if (mesh.geometry.indicesBuffer) {\n            redcube_gl.drawElements(mesh.mode || redcube_gl.TRIANGLES, mesh.geometry.indicesBuffer.length, mesh.geometry.indicesBuffer.BYTES_PER_ELEMENT === 4 ? redcube_gl.UNSIGNED_INT : redcube_gl.UNSIGNED_SHORT, 0);\n        }\n        else {\n            redcube_gl.drawArrays(mesh.mode || redcube_gl.TRIANGLES, 0, mesh.geometry.attributes.POSITION.length / 3);\n        }\n        if (mesh.material.doubleSided) {\n            redcube_gl.enable(redcube_gl.CULL_FACE);\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZGN1YmUvLi9zcmMvbWF0cml4LnRzPzQyNDIiLCJ3ZWJwYWNrOi8vcmVkY3ViZS8uL3NyYy9vYmplY3RzLnRzP2I4ZTQiLCJ3ZWJwYWNrOi8vcmVkY3ViZS8uL3NyYy9ldmVudHMudHM/YTYxYyIsIndlYnBhY2s6Ly9yZWRjdWJlLy4vc3JjL3V0aWxzLnRzPzhkYjkiLCJ3ZWJwYWNrOi8vcmVkY3ViZS8uL3NyYy9lbnYudHM/NzEwNSIsIndlYnBhY2s6Ly9yZWRjdWJlLy4vc3JjL2Zwcy50cz81NzRiIiwid2VicGFjazovL3JlZGN1YmUvLi9zcmMvcGFyc2UudHM/NTkwZiIsIndlYnBhY2s6Ly9yZWRjdWJlLy4vc3JjL3JlZGN1YmUudHM/NzAyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBUaGlzIGlzIGEgY2xhc3MgdHJlYXRpbmcgNHg0IG1hdHJpeC5cbiAqIFRoaXMgY2xhc3MgY29udGFpbnMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgZXF1aXZhbGVudCB0byBPcGVuR0wgbWF0cml4IHN0YWNrLlxuICogVGhlIG1hdHJpeCBhZnRlciBjb252ZXJzaW9uIGlzIGNhbGN1bGF0ZWQgYnkgbXVsdGlwbHlpbmcgYSBjb252ZXJzaW9uIG1hdHJpeCBmcm9tIHRoZSByaWdodC5cbiAqIFRoZSBtYXRyaXggaXMgcmVwbGFjZWQgYnkgdGhlIGNhbGN1bGF0ZWQgcmVzdWx0LlxuICovXG5jbGFzcyBNYXRyaXgyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRfc3JjKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgcztcbiAgICAgICAgbGV0IGQ7XG4gICAgICAgIGlmIChvcHRfc3JjICYmIHR5cGVvZiBvcHRfc3JjID09PSAnb2JqZWN0JyAmJiBvcHRfc3JjLmhhc093blByb3BlcnR5KCdlbGVtZW50cycpKSB7XG4gICAgICAgICAgICBzID0gb3B0X3NyYy5lbGVtZW50cztcbiAgICAgICAgICAgIGQgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgICAgICAgIGRbaV0gPSBzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cyA9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldChzcmMpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBzO1xuICAgICAgICBsZXQgZDtcbiAgICAgICAgcyA9IHNyYztcbiAgICAgICAgZCA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGlmIChzID09PSBkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgICAgZFtpXSA9IHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLyoqXG4gKiBDb25zdHJ1Y3RvciBvZiBNYXRyaXgzXG4gKiBJZiBvcHRfc3JjIGlzIHNwZWNpZmllZCwgbmV3IG1hdHJpeCBpcyBpbml0aWFsaXplZCBieSBvcHRfc3JjLlxuICogT3RoZXJ3aXNlLCBuZXcgbWF0cml4IGlzIGluaXRpYWxpemVkIGJ5IGlkZW50aXR5IG1hdHJpeC5cbiAqIEBwYXJhbSBvcHRfc3JjIHNvdXJjZSBtYXRyaXgob3B0aW9uKVxuICovXG5jbGFzcyBNYXRyaXgzIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRfc3JjKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgcztcbiAgICAgICAgbGV0IGQ7XG4gICAgICAgIGlmIChvcHRfc3JjICYmIHR5cGVvZiBvcHRfc3JjID09PSAnb2JqZWN0JyAmJiBvcHRfc3JjLmhhc093blByb3BlcnR5KCdlbGVtZW50cycpKSB7XG4gICAgICAgICAgICBzID0gb3B0X3NyYy5lbGVtZW50cztcbiAgICAgICAgICAgIGQgPSBuZXcgRmxvYXQzMkFycmF5KDkpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDk7ICsraSkge1xuICAgICAgICAgICAgICAgIGRbaV0gPSBzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cyA9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldChzcmMpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBzO1xuICAgICAgICBsZXQgZDtcbiAgICAgICAgcyA9IHNyYztcbiAgICAgICAgZCA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGlmIChzID09PSBkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDk7ICsraSkge1xuICAgICAgICAgICAgZFtpXSA9IHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG5vcm1hbEZyb21NYXQ0KGEpIHtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGEgPSBhLmVsZW1lbnRzO1xuICAgICAgICBjb25zdCBhMDAgPSBhWzBdO1xuICAgICAgICBjb25zdCBhMDEgPSBhWzFdO1xuICAgICAgICBjb25zdCBhMDIgPSBhWzJdO1xuICAgICAgICBjb25zdCBhMDMgPSBhWzNdO1xuICAgICAgICBjb25zdCBhMTAgPSBhWzRdO1xuICAgICAgICBjb25zdCBhMTEgPSBhWzVdO1xuICAgICAgICBjb25zdCBhMTIgPSBhWzZdO1xuICAgICAgICBjb25zdCBhMTMgPSBhWzddO1xuICAgICAgICBjb25zdCBhMjAgPSBhWzhdO1xuICAgICAgICBjb25zdCBhMjEgPSBhWzldO1xuICAgICAgICBjb25zdCBhMjIgPSBhWzEwXTtcbiAgICAgICAgY29uc3QgYTIzID0gYVsxMV07XG4gICAgICAgIGNvbnN0IGEzMCA9IGFbMTJdO1xuICAgICAgICBjb25zdCBhMzEgPSBhWzEzXTtcbiAgICAgICAgY29uc3QgYTMyID0gYVsxNF07XG4gICAgICAgIGNvbnN0IGEzMyA9IGFbMTVdO1xuICAgICAgICBjb25zdCBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gICAgICAgIGNvbnN0IGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgICAgICAgY29uc3QgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICAgICAgICBjb25zdCBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gICAgICAgIGNvbnN0IGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgICAgICAgY29uc3QgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICAgICAgICBjb25zdCBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gICAgICAgIGNvbnN0IGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgICAgICAgY29uc3QgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICAgICAgICBjb25zdCBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gICAgICAgIGNvbnN0IGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgICAgICAgY29uc3QgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuICAgICAgICBsZXQgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG4gICAgICAgIGlmICghZGV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgICAgIGVbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICAgICAgZVsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgICAgICBlWzJdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gICAgICAgIGVbM10gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICAgICAgZVs0XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgICAgICBlWzVdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gICAgICAgIGVbNl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICAgICAgZVs3XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgICAgICBlWzhdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbi8qKlxuICogQ29uc3RydWN0b3Igb2YgTWF0cml4NFxuICogSWYgb3B0X3NyYyBpcyBzcGVjaWZpZWQsIG5ldyBtYXRyaXggaXMgaW5pdGlhbGl6ZWQgYnkgb3B0X3NyYy5cbiAqIE90aGVyd2lzZSwgbmV3IG1hdHJpeCBpcyBpbml0aWFsaXplZCBieSBpZGVudGl0eSBtYXRyaXguXG4gKiBAcGFyYW0gb3B0X3NyYyBzb3VyY2UgbWF0cml4KG9wdGlvbilcbiAqL1xuY2xhc3MgTWF0cml4NCB7XG4gICAgY29uc3RydWN0b3Iob3B0X3NyYykge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IHM7XG4gICAgICAgIGxldCBkO1xuICAgICAgICBpZiAob3B0X3NyYyAmJiB0eXBlb2Ygb3B0X3NyYyA9PT0gJ29iamVjdCcgJiYgb3B0X3NyYy5oYXNPd25Qcm9wZXJ0eSgnZWxlbWVudHMnKSkge1xuICAgICAgICAgICAgcyA9IG9wdF9zcmMuZWxlbWVudHM7XG4gICAgICAgICAgICBkID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICAgICAgICAgIGRbaV0gPSBzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cyA9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcHkgbWF0cml4LlxuICAgICAqIEBwYXJhbSBzcmMgc291cmNlIG1hdHJpeFxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHNldChzcmMpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBzO1xuICAgICAgICBsZXQgZDtcbiAgICAgICAgcyA9IHNyYztcbiAgICAgICAgZCA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGlmIChzID09PSBkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgICAgICAgIGRbaV0gPSBzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtdWx0aXBseShtYXRyaXgpIHtcbiAgICAgICAgdGhpcy5jb25jYXQobWF0cml4KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IHRoZSBtYXRyaXggZnJvbSB0aGUgcmlnaHQuXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBtdWx0aXBseSBtYXRyaXhcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBjb25jYXQoeyBlbGVtZW50cyB9KSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgZTtcbiAgICAgICAgbGV0IGE7XG4gICAgICAgIGxldCBiO1xuICAgICAgICBsZXQgYWkwO1xuICAgICAgICBsZXQgYWkxO1xuICAgICAgICBsZXQgYWkyO1xuICAgICAgICBsZXQgYWkzO1xuICAgICAgICAvLyBDYWxjdWxhdGUgZSA9IGEgKiBiXG4gICAgICAgIGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICBhID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgYiA9IGVsZW1lbnRzO1xuICAgICAgICAvLyBJZiBlIGVxdWFscyBiLCBjb3B5IGIgdG8gdGVtcG9yYXJ5IG1hdHJpeC5cbiAgICAgICAgaWYgKGUgPT09IGIpIHtcbiAgICAgICAgICAgIGIgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgICAgICAgICAgYltpXSA9IGVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgYWkwID0gYVtpXTtcbiAgICAgICAgICAgIGFpMSA9IGFbaSArIDRdO1xuICAgICAgICAgICAgYWkyID0gYVtpICsgOF07XG4gICAgICAgICAgICBhaTMgPSBhW2kgKyAxMl07XG4gICAgICAgICAgICBlW2ldID0gYWkwICogYlswXSArIGFpMSAqIGJbMV0gKyBhaTIgKiBiWzJdICsgYWkzICogYlszXTtcbiAgICAgICAgICAgIGVbaSArIDRdID0gYWkwICogYls0XSArIGFpMSAqIGJbNV0gKyBhaTIgKiBiWzZdICsgYWkzICogYls3XTtcbiAgICAgICAgICAgIGVbaSArIDhdID0gYWkwICogYls4XSArIGFpMSAqIGJbOV0gKyBhaTIgKiBiWzEwXSArIGFpMyAqIGJbMTFdO1xuICAgICAgICAgICAgZVtpICsgMTJdID0gYWkwICogYlsxMl0gKyBhaTEgKiBiWzEzXSArIGFpMiAqIGJbMTRdICsgYWkzICogYlsxNV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgaW52ZXJzZSBtYXRyaXggb2Ygc3BlY2lmaWVkIG1hdHJpeCwgYW5kIHNldCB0byB0aGlzLlxuICAgICAqIEBwYXJhbSBvdGhlciBUaGUgc291cmNlIG1hdHJpeFxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHNldEludmVyc2VPZih7IGVsZW1lbnRzIH0pIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBzO1xuICAgICAgICBsZXQgZDtcbiAgICAgICAgbGV0IGludjtcbiAgICAgICAgbGV0IGRldDtcbiAgICAgICAgcyA9IGVsZW1lbnRzO1xuICAgICAgICBkID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgaW52ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgICAgIGludlswXSA9IHNbNV0gKiBzWzEwXSAqIHNbMTVdIC0gc1s1XSAqIHNbMTFdICogc1sxNF0gLSBzWzldICogc1s2XSAqIHNbMTVdXG4gICAgICAgICAgICArIHNbOV0gKiBzWzddICogc1sxNF0gKyBzWzEzXSAqIHNbNl0gKiBzWzExXSAtIHNbMTNdICogc1s3XSAqIHNbMTBdO1xuICAgICAgICBpbnZbNF0gPSAtc1s0XSAqIHNbMTBdICogc1sxNV0gKyBzWzRdICogc1sxMV0gKiBzWzE0XSArIHNbOF0gKiBzWzZdICogc1sxNV1cbiAgICAgICAgICAgIC0gc1s4XSAqIHNbN10gKiBzWzE0XSAtIHNbMTJdICogc1s2XSAqIHNbMTFdICsgc1sxMl0gKiBzWzddICogc1sxMF07XG4gICAgICAgIGludls4XSA9IHNbNF0gKiBzWzldICogc1sxNV0gLSBzWzRdICogc1sxMV0gKiBzWzEzXSAtIHNbOF0gKiBzWzVdICogc1sxNV1cbiAgICAgICAgICAgICsgc1s4XSAqIHNbN10gKiBzWzEzXSArIHNbMTJdICogc1s1XSAqIHNbMTFdIC0gc1sxMl0gKiBzWzddICogc1s5XTtcbiAgICAgICAgaW52WzEyXSA9IC1zWzRdICogc1s5XSAqIHNbMTRdICsgc1s0XSAqIHNbMTBdICogc1sxM10gKyBzWzhdICogc1s1XSAqIHNbMTRdXG4gICAgICAgICAgICAtIHNbOF0gKiBzWzZdICogc1sxM10gLSBzWzEyXSAqIHNbNV0gKiBzWzEwXSArIHNbMTJdICogc1s2XSAqIHNbOV07XG4gICAgICAgIGludlsxXSA9IC1zWzFdICogc1sxMF0gKiBzWzE1XSArIHNbMV0gKiBzWzExXSAqIHNbMTRdICsgc1s5XSAqIHNbMl0gKiBzWzE1XVxuICAgICAgICAgICAgLSBzWzldICogc1szXSAqIHNbMTRdIC0gc1sxM10gKiBzWzJdICogc1sxMV0gKyBzWzEzXSAqIHNbM10gKiBzWzEwXTtcbiAgICAgICAgaW52WzVdID0gc1swXSAqIHNbMTBdICogc1sxNV0gLSBzWzBdICogc1sxMV0gKiBzWzE0XSAtIHNbOF0gKiBzWzJdICogc1sxNV1cbiAgICAgICAgICAgICsgc1s4XSAqIHNbM10gKiBzWzE0XSArIHNbMTJdICogc1syXSAqIHNbMTFdIC0gc1sxMl0gKiBzWzNdICogc1sxMF07XG4gICAgICAgIGludls5XSA9IC1zWzBdICogc1s5XSAqIHNbMTVdICsgc1swXSAqIHNbMTFdICogc1sxM10gKyBzWzhdICogc1sxXSAqIHNbMTVdXG4gICAgICAgICAgICAtIHNbOF0gKiBzWzNdICogc1sxM10gLSBzWzEyXSAqIHNbMV0gKiBzWzExXSArIHNbMTJdICogc1szXSAqIHNbOV07XG4gICAgICAgIGludlsxM10gPSBzWzBdICogc1s5XSAqIHNbMTRdIC0gc1swXSAqIHNbMTBdICogc1sxM10gLSBzWzhdICogc1sxXSAqIHNbMTRdXG4gICAgICAgICAgICArIHNbOF0gKiBzWzJdICogc1sxM10gKyBzWzEyXSAqIHNbMV0gKiBzWzEwXSAtIHNbMTJdICogc1syXSAqIHNbOV07XG4gICAgICAgIGludlsyXSA9IHNbMV0gKiBzWzZdICogc1sxNV0gLSBzWzFdICogc1s3XSAqIHNbMTRdIC0gc1s1XSAqIHNbMl0gKiBzWzE1XVxuICAgICAgICAgICAgKyBzWzVdICogc1szXSAqIHNbMTRdICsgc1sxM10gKiBzWzJdICogc1s3XSAtIHNbMTNdICogc1szXSAqIHNbNl07XG4gICAgICAgIGludls2XSA9IC1zWzBdICogc1s2XSAqIHNbMTVdICsgc1swXSAqIHNbN10gKiBzWzE0XSArIHNbNF0gKiBzWzJdICogc1sxNV1cbiAgICAgICAgICAgIC0gc1s0XSAqIHNbM10gKiBzWzE0XSAtIHNbMTJdICogc1syXSAqIHNbN10gKyBzWzEyXSAqIHNbM10gKiBzWzZdO1xuICAgICAgICBpbnZbMTBdID0gc1swXSAqIHNbNV0gKiBzWzE1XSAtIHNbMF0gKiBzWzddICogc1sxM10gLSBzWzRdICogc1sxXSAqIHNbMTVdXG4gICAgICAgICAgICArIHNbNF0gKiBzWzNdICogc1sxM10gKyBzWzEyXSAqIHNbMV0gKiBzWzddIC0gc1sxMl0gKiBzWzNdICogc1s1XTtcbiAgICAgICAgaW52WzE0XSA9IC1zWzBdICogc1s1XSAqIHNbMTRdICsgc1swXSAqIHNbNl0gKiBzWzEzXSArIHNbNF0gKiBzWzFdICogc1sxNF1cbiAgICAgICAgICAgIC0gc1s0XSAqIHNbMl0gKiBzWzEzXSAtIHNbMTJdICogc1sxXSAqIHNbNl0gKyBzWzEyXSAqIHNbMl0gKiBzWzVdO1xuICAgICAgICBpbnZbM10gPSAtc1sxXSAqIHNbNl0gKiBzWzExXSArIHNbMV0gKiBzWzddICogc1sxMF0gKyBzWzVdICogc1syXSAqIHNbMTFdXG4gICAgICAgICAgICAtIHNbNV0gKiBzWzNdICogc1sxMF0gLSBzWzldICogc1syXSAqIHNbN10gKyBzWzldICogc1szXSAqIHNbNl07XG4gICAgICAgIGludls3XSA9IHNbMF0gKiBzWzZdICogc1sxMV0gLSBzWzBdICogc1s3XSAqIHNbMTBdIC0gc1s0XSAqIHNbMl0gKiBzWzExXVxuICAgICAgICAgICAgKyBzWzRdICogc1szXSAqIHNbMTBdICsgc1s4XSAqIHNbMl0gKiBzWzddIC0gc1s4XSAqIHNbM10gKiBzWzZdO1xuICAgICAgICBpbnZbMTFdID0gLXNbMF0gKiBzWzVdICogc1sxMV0gKyBzWzBdICogc1s3XSAqIHNbOV0gKyBzWzRdICogc1sxXSAqIHNbMTFdXG4gICAgICAgICAgICAtIHNbNF0gKiBzWzNdICogc1s5XSAtIHNbOF0gKiBzWzFdICogc1s3XSArIHNbOF0gKiBzWzNdICogc1s1XTtcbiAgICAgICAgaW52WzE1XSA9IHNbMF0gKiBzWzVdICogc1sxMF0gLSBzWzBdICogc1s2XSAqIHNbOV0gLSBzWzRdICogc1sxXSAqIHNbMTBdXG4gICAgICAgICAgICArIHNbNF0gKiBzWzJdICogc1s5XSArIHNbOF0gKiBzWzFdICogc1s2XSAtIHNbOF0gKiBzWzJdICogc1s1XTtcbiAgICAgICAgZGV0ID0gc1swXSAqIGludlswXSArIHNbMV0gKiBpbnZbNF0gKyBzWzJdICogaW52WzhdICsgc1szXSAqIGludlsxMl07XG4gICAgICAgIGlmIChkZXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGRldCA9IDEgLyBkZXQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICBkW2ldID0gaW52W2ldICogZGV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGludmVyc2UgbWF0cml4IG9mIHRoaXMsIGFuZCBzZXQgdG8gdGhpcy5cbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldEludmVyc2VPZih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXguXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgb2YgY2xpcHBpbmcgcGxhbmUuXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBvZiBjbGlwcGluZyBwbGFuZS5cbiAgICAgKiBAcGFyYW0gYm90dG9tIFRoZSBjb29yZGluYXRlIG9mIHRoZSBib3R0b20gb2YgY2xpcHBpbmcgcGxhbmUuXG4gICAgICogQHBhcmFtIHRvcCBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgdG9wIHRvcCBjbGlwcGluZyBwbGFuZS5cbiAgICAgKiBAcGFyYW0gbmVhciBUaGUgZGlzdGFuY2VzIHRvIHRoZSBuZWFyZXIgZGVwdGggY2xpcHBpbmcgcGxhbmUuIFRoaXMgdmFsdWUgaXMgbWludXMgaWYgdGhlIHBsYW5lIGlzIHRvIGJlIGJlaGluZCB0aGUgdmlld2VyLlxuICAgICAqIEBwYXJhbSBmYXIgVGhlIGRpc3RhbmNlcyB0byB0aGUgZmFydGhlciBkZXB0aCBjbGlwcGluZyBwbGFuZS4gVGhpcyB2YWx1ZSBpcyBtaW51cyBpZiB0aGUgcGxhbmUgaXMgdG8gYmUgYmVoaW5kIHRoZSB2aWV3ZXIuXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgc2V0T3J0aG8ociwgdCwgbmVhciwgZmFyKSB7XG4gICAgICAgIGxldCBlO1xuICAgICAgICBsZXQgcnc7XG4gICAgICAgIGxldCByaDtcbiAgICAgICAgbGV0IHJkO1xuICAgICAgICBydyA9IDEgLyByO1xuICAgICAgICByaCA9IDEgLyB0O1xuICAgICAgICByZCA9IDIgLyAobmVhciAtIGZhcik7XG4gICAgICAgIGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICBlWzBdID0gcnc7XG4gICAgICAgIGVbMV0gPSAwO1xuICAgICAgICBlWzJdID0gMDtcbiAgICAgICAgZVszXSA9IDA7XG4gICAgICAgIGVbNF0gPSAwO1xuICAgICAgICBlWzVdID0gcmg7XG4gICAgICAgIGVbNl0gPSAwO1xuICAgICAgICBlWzddID0gMDtcbiAgICAgICAgZVs4XSA9IDA7XG4gICAgICAgIGVbOV0gPSAwO1xuICAgICAgICBlWzEwXSA9IHJkO1xuICAgICAgICBlWzExXSA9IChmYXIgKyBuZWFyKSAvIChuZWFyIC0gZmFyKTtcbiAgICAgICAgZVsxMl0gPSAwO1xuICAgICAgICBlWzEzXSA9IDA7XG4gICAgICAgIGVbMTRdID0gMDtcbiAgICAgICAgZVsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCBieSBmb3Z5IGFuZCBhc3BlY3QuXG4gICAgICogQHBhcmFtIGZvdnkgVGhlIGFuZ2xlIGJldHdlZW4gdGhlIHVwcGVyIGFuZCBsb3dlciBzaWRlcyBvZiB0aGUgZnJ1c3R1bS5cbiAgICAgKiBAcGFyYW0gYXNwZWN0IFRoZSBhc3BlY3QgcmF0aW8gb2YgdGhlIGZydXN0dW0uICh3aWR0aC9oZWlnaHQpXG4gICAgICogQHBhcmFtIG5lYXIgVGhlIGRpc3RhbmNlcyB0byB0aGUgbmVhcmVyIGRlcHRoIGNsaXBwaW5nIHBsYW5lLiBUaGlzIHZhbHVlIG11c3QgYmUgcGx1cyB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gZmFyIFRoZSBkaXN0YW5jZXMgdG8gdGhlIGZhcnRoZXIgZGVwdGggY2xpcHBpbmcgcGxhbmUuIFRoaXMgdmFsdWUgbXVzdCBiZSBwbHVzIHZhbHVlLlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHNldFBlcnNwZWN0aXZlKGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gICAgICAgIGxldCBlO1xuICAgICAgICBsZXQgcmQ7XG4gICAgICAgIGxldCBzO1xuICAgICAgICBsZXQgY3Q7XG4gICAgICAgIGlmIChuZWFyID09PSBmYXIgfHwgYXNwZWN0ID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyAnbnVsbCBmcnVzdHVtJztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVhciA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyAnbmVhciA8PSAwJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmFyIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93ICdmYXIgPD0gMCc7XG4gICAgICAgIH1cbiAgICAgICAgZm92eSA9IE1hdGguUEkgKiBmb3Z5IC8gMTgwIC8gMjtcbiAgICAgICAgcyA9IE1hdGguc2luKGZvdnkpO1xuICAgICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgJ251bGwgZnJ1c3R1bSc7XG4gICAgICAgIH1cbiAgICAgICAgcmQgPSAxIC8gKGZhciAtIG5lYXIpO1xuICAgICAgICBjdCA9IE1hdGguY29zKGZvdnkpIC8gcztcbiAgICAgICAgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGVbMF0gPSBjdCAvIGFzcGVjdDtcbiAgICAgICAgZVsxXSA9IDA7XG4gICAgICAgIGVbMl0gPSAwO1xuICAgICAgICBlWzNdID0gMDtcbiAgICAgICAgZVs0XSA9IDA7XG4gICAgICAgIGVbNV0gPSBjdDtcbiAgICAgICAgZVs2XSA9IDA7XG4gICAgICAgIGVbN10gPSAwO1xuICAgICAgICBlWzhdID0gMDtcbiAgICAgICAgZVs5XSA9IDA7XG4gICAgICAgIGVbMTBdID0gLShmYXIgKyBuZWFyKSAqIHJkO1xuICAgICAgICBlWzExXSA9IC0xO1xuICAgICAgICBlWzEyXSA9IDA7XG4gICAgICAgIGVbMTNdID0gMDtcbiAgICAgICAgZVsxNF0gPSAtMiAqIG5lYXIgKiBmYXIgKiByZDtcbiAgICAgICAgZVsxNV0gPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgdGhlIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IGZyb20gdGhlIHJpZ2h0LlxuICAgICAqIEBwYXJhbSBmb3Z5IFRoZSBhbmdsZSBiZXR3ZWVuIHRoZSB1cHBlciBhbmQgbG93ZXIgc2lkZXMgb2YgdGhlIGZydXN0dW0uXG4gICAgICogQHBhcmFtIGFzcGVjdCBUaGUgYXNwZWN0IHJhdGlvIG9mIHRoZSBmcnVzdHVtLiAod2lkdGgvaGVpZ2h0KVxuICAgICAqIEBwYXJhbSBuZWFyIFRoZSBkaXN0YW5jZXMgdG8gdGhlIG5lYXJlciBkZXB0aCBjbGlwcGluZyBwbGFuZS4gVGhpcyB2YWx1ZSBtdXN0IGJlIHBsdXMgdmFsdWUuXG4gICAgICogQHBhcmFtIGZhciBUaGUgZGlzdGFuY2VzIHRvIHRoZSBmYXJ0aGVyIGRlcHRoIGNsaXBwaW5nIHBsYW5lLiBUaGlzIHZhbHVlIG11c3QgYmUgcGx1cyB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBwZXJzcGVjdGl2ZShmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25jYXQobmV3IE1hdHJpeDQoKS5zZXRQZXJzcGVjdGl2ZShmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSB0aGUgZm91ci1kaW1lbnNpb25hbCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHBvcyAgVGhlIG11bHRpcGx5IHZlY3RvclxuICAgICAqIEByZXR1cm4gVGhlIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvbihGbG9hdDMyQXJyYXkpXG4gICAgICovXG4gICAgbXVsdGlwbHlWZWN0b3I0KHsgZWxlbWVudHMgfSkge1xuICAgICAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgY29uc3QgcCA9IGVsZW1lbnRzO1xuICAgICAgICBjb25zdCB2ID0gbmV3IFZlY3RvcjQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdi5lbGVtZW50cztcbiAgICAgICAgcmVzdWx0WzBdID0gcFswXSAqIGVbMF0gKyBwWzFdICogZVs0XSArIHBbMl0gKiBlWzhdICsgcFszXSAqIGVbMTJdO1xuICAgICAgICByZXN1bHRbMV0gPSBwWzBdICogZVsxXSArIHBbMV0gKiBlWzVdICsgcFsyXSAqIGVbOV0gKyBwWzNdICogZVsxM107XG4gICAgICAgIHJlc3VsdFsyXSA9IHBbMF0gKiBlWzJdICsgcFsxXSAqIGVbNl0gKyBwWzJdICogZVsxMF0gKyBwWzNdICogZVsxNF07XG4gICAgICAgIHJlc3VsdFszXSA9IHBbMF0gKiBlWzNdICsgcFsxXSAqIGVbN10gKyBwWzJdICogZVsxMV0gKyBwWzNdICogZVsxNV07XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICBzY2FsZSh2ZWMzKSB7XG4gICAgICAgIGNvbnN0IHggPSB2ZWMzLmVsZW1lbnRzWzBdO1xuICAgICAgICBjb25zdCB5ID0gdmVjMy5lbGVtZW50c1sxXTtcbiAgICAgICAgY29uc3QgeiA9IHZlYzMuZWxlbWVudHNbMl07XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICBlWzBdICo9IHg7XG4gICAgICAgIGVbNF0gKj0geTtcbiAgICAgICAgZVs4XSAqPSB6O1xuICAgICAgICBlWzFdICo9IHg7XG4gICAgICAgIGVbNV0gKj0geTtcbiAgICAgICAgZVs5XSAqPSB6O1xuICAgICAgICBlWzJdICo9IHg7XG4gICAgICAgIGVbNl0gKj0geTtcbiAgICAgICAgZVsxMF0gKj0gejtcbiAgICAgICAgZVszXSAqPSB4O1xuICAgICAgICBlWzddICo9IHk7XG4gICAgICAgIGVbMTFdICo9IHo7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRUcmFuc2xhdGUodmVjMykge1xuICAgICAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgY29uc3QgeCA9IHZlYzMuZWxlbWVudHNbMF07XG4gICAgICAgIGNvbnN0IHkgPSB2ZWMzLmVsZW1lbnRzWzFdO1xuICAgICAgICBjb25zdCB6ID0gdmVjMy5lbGVtZW50c1syXTtcbiAgICAgICAgZVsxMl0gPSB4O1xuICAgICAgICBlWzEzXSA9IHk7XG4gICAgICAgIGVbMTRdID0gejtcbiAgICAgICAgZVsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgdGhlIG1hdHJpeCBmb3IgdHJhbnNsYXRpb24gZnJvbSB0aGUgcmlnaHQuXG4gICAgICogQHBhcmFtIHggVGhlIFggdmFsdWUgb2YgYSB0cmFuc2xhdGlvbi5cbiAgICAgKiBAcGFyYW0geSBUaGUgWSB2YWx1ZSBvZiBhIHRyYW5zbGF0aW9uLlxuICAgICAqIEBwYXJhbSB6IFRoZSBaIHZhbHVlIG9mIGEgdHJhbnNsYXRpb24uXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgdHJhbnNsYXRlKHgsIHksIHopIHtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGVbMTJdICs9IGVbMF0gKiB4ICsgZVs0XSAqIHkgKyBlWzhdICogejtcbiAgICAgICAgZVsxM10gKz0gZVsxXSAqIHggKyBlWzVdICogeSArIGVbOV0gKiB6O1xuICAgICAgICBlWzE0XSArPSBlWzJdICogeCArIGVbNl0gKiB5ICsgZVsxMF0gKiB6O1xuICAgICAgICBlWzE1XSArPSBlWzNdICogeCArIGVbN10gKiB5ICsgZVsxMV0gKiB6O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0TWF4U2NhbGVPbkF4aXMoKSB7XG4gICAgICAgIGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgY29uc3Qgc2NhbGVYU3EgPSB0ZVswXSAqIHRlWzBdICsgdGVbMV0gKiB0ZVsxXSArIHRlWzJdICogdGVbMl07XG4gICAgICAgIGNvbnN0IHNjYWxlWVNxID0gdGVbNF0gKiB0ZVs0XSArIHRlWzVdICogdGVbNV0gKyB0ZVs2XSAqIHRlWzZdO1xuICAgICAgICBjb25zdCBzY2FsZVpTcSA9IHRlWzhdICogdGVbOF0gKyB0ZVs5XSAqIHRlWzldICsgdGVbMTBdICogdGVbMTBdO1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgubWF4KHNjYWxlWFNxLCBzY2FsZVlTcSwgc2NhbGVaU3EpKTtcbiAgICB9XG4gICAgbWFrZVJvdGF0aW9uQXhpcyhheGlzLCBhbmdsZSkge1xuICAgICAgICAvLyBCYXNlZCBvbiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3JlZmVyZW5jZS9hcnRpY2xlcy9hcnRpY2xlMTE5OS5hc3BcbiAgICAgICAgY29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICBjb25zdCB0ID0gMSAtIGM7XG4gICAgICAgIGNvbnN0IHggPSBheGlzLmVsZW1lbnRzWzBdLCB5ID0gYXhpcy5lbGVtZW50c1sxXSwgeiA9IGF4aXMuZWxlbWVudHNbMl07XG4gICAgICAgIGNvbnN0IHR4ID0gdCAqIHgsIHR5ID0gdCAqIHk7XG4gICAgICAgIHRlWzBdID0gdHggKiB4ICsgYztcbiAgICAgICAgdGVbMV0gPSB0eCAqIHkgLSBzICogejtcbiAgICAgICAgdGVbMl0gPSB0eCAqIHogKyBzICogeTtcbiAgICAgICAgdGVbM10gPSAwO1xuICAgICAgICB0ZVs0XSA9IHR4ICogeSArIHMgKiB6O1xuICAgICAgICB0ZVs1XSA9IHR5ICogeSArIGM7XG4gICAgICAgIHRlWzZdID0gdHkgKiB6IC0gcyAqIHg7XG4gICAgICAgIHRlWzddID0gMDtcbiAgICAgICAgdGVbOF0gPSB0eCAqIHogLSBzICogeTtcbiAgICAgICAgdGVbOV0gPSB0eSAqIHogKyBzICogeDtcbiAgICAgICAgdGVbMTBdID0gdCAqIHogKiB6ICsgYztcbiAgICAgICAgdGVbMTFdID0gMDtcbiAgICAgICAgLy8gdGVbMTJdID0gMDsgXG4gICAgICAgIC8vIHRlWzEzXSA9IDA7IFxuICAgICAgICAvLyB0ZVsxNF0gPSAwOyBcbiAgICAgICAgdGVbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHEpIHtcbiAgICAgICAgY29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICBjb25zdCB4ID0gcVswXTtcbiAgICAgICAgY29uc3QgeSA9IHFbMV07XG4gICAgICAgIGNvbnN0IHogPSBxWzJdO1xuICAgICAgICBjb25zdCB3ID0gcVszXTtcbiAgICAgICAgY29uc3QgeDIgPSB4ICsgeDtcbiAgICAgICAgY29uc3QgeTIgPSB5ICsgeTtcbiAgICAgICAgY29uc3QgejIgPSB6ICsgejtcbiAgICAgICAgY29uc3QgeHggPSB4ICogeDI7XG4gICAgICAgIGNvbnN0IHh5ID0geCAqIHkyO1xuICAgICAgICBjb25zdCB4eiA9IHggKiB6MjtcbiAgICAgICAgY29uc3QgeXkgPSB5ICogeTI7XG4gICAgICAgIGNvbnN0IHl6ID0geSAqIHoyO1xuICAgICAgICBjb25zdCB6eiA9IHogKiB6MjtcbiAgICAgICAgY29uc3Qgd3ggPSB3ICogeDI7XG4gICAgICAgIGNvbnN0IHd5ID0gdyAqIHkyO1xuICAgICAgICBjb25zdCB3eiA9IHcgKiB6MjtcbiAgICAgICAgdGVbMF0gPSAxIC0gKHl5ICsgenopO1xuICAgICAgICB0ZVs0XSA9IHh5IC0gd3o7XG4gICAgICAgIHRlWzhdID0geHogKyB3eTtcbiAgICAgICAgdGVbMV0gPSB4eSArIHd6O1xuICAgICAgICB0ZVs1XSA9IDEgLSAoeHggKyB6eik7XG4gICAgICAgIHRlWzldID0geXogLSB3eDtcbiAgICAgICAgdGVbMl0gPSB4eiAtIHd5O1xuICAgICAgICB0ZVs2XSA9IHl6ICsgd3g7XG4gICAgICAgIHRlWzEwXSA9IDEgLSAoeHggKyB5eSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0cmFuc3Bvc2UoKSB7XG4gICAgICAgIGxldCBlO1xuICAgICAgICBsZXQgdDtcbiAgICAgICAgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIHQgPSBlWzFdO1xuICAgICAgICBlWzFdID0gZVs0XTtcbiAgICAgICAgZVs0XSA9IHQ7XG4gICAgICAgIHQgPSBlWzJdO1xuICAgICAgICBlWzJdID0gZVs4XTtcbiAgICAgICAgZVs4XSA9IHQ7XG4gICAgICAgIHQgPSBlWzNdO1xuICAgICAgICBlWzNdID0gZVsxMl07XG4gICAgICAgIGVbMTJdID0gdDtcbiAgICAgICAgdCA9IGVbNl07XG4gICAgICAgIGVbNl0gPSBlWzldO1xuICAgICAgICBlWzldID0gdDtcbiAgICAgICAgdCA9IGVbN107XG4gICAgICAgIGVbN10gPSBlWzEzXTtcbiAgICAgICAgZVsxM10gPSB0O1xuICAgICAgICB0ID0gZVsxMV07XG4gICAgICAgIGVbMTFdID0gZVsxNF07XG4gICAgICAgIGVbMTRdID0gdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLyoqXG4gKiBDb25zdHJ1Y3RvciBvZiBWZWN0b3IzXG4gKiBJZiBvcHRfc3JjIGlzIHNwZWNpZmllZCwgbmV3IHZlY3RvciBpcyBpbml0aWFsaXplZCBieSBvcHRfc3JjLlxuICogQHBhcmFtIG9wdF9zcmMgc291cmNlIHZlY3RvcihvcHRpb24pXG4gKi9cbmNsYXNzIFZlY3RvcjMge1xuICAgIGNvbnN0cnVjdG9yKG9wdF9zcmMpIHtcbiAgICAgICAgY29uc3QgdiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIGlmIChvcHRfc3JjICYmIHR5cGVvZiBvcHRfc3JjID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdlswXSA9IG9wdF9zcmNbMF07XG4gICAgICAgICAgICB2WzFdID0gb3B0X3NyY1sxXTtcbiAgICAgICAgICAgIHZbMl0gPSBvcHRfc3JjWzJdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSB2O1xuICAgIH1cbiAgICBhcHBseVF1YXRlcm5pb24oeyBlbGVtZW50cyB9KSB7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLmVsZW1lbnRzWzBdO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5lbGVtZW50c1sxXTtcbiAgICAgICAgY29uc3QgeiA9IHRoaXMuZWxlbWVudHNbMl07XG4gICAgICAgIGNvbnN0IHF4ID0gZWxlbWVudHNbMF07XG4gICAgICAgIGNvbnN0IHF5ID0gZWxlbWVudHNbMV07XG4gICAgICAgIGNvbnN0IHF6ID0gZWxlbWVudHNbMl07XG4gICAgICAgIGNvbnN0IHF3ID0gZWxlbWVudHNbM107XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjdG9yXG4gICAgICAgIGNvbnN0IGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuICAgICAgICBjb25zdCBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcbiAgICAgICAgY29uc3QgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG4gICAgICAgIGNvbnN0IGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgICAgICB0aGlzLmVsZW1lbnRzWzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgICAgICAgdGhpcy5lbGVtZW50c1sxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICAqIE5vcm1hbGl6ZS5cbiAgICAgICogQHJldHVybiB0aGlzXG4gICAgICAqL1xuICAgIG5vcm1hbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGNvbnN0IGMgPSB2WzBdO1xuICAgICAgICBjb25zdCBkID0gdlsxXTtcbiAgICAgICAgY29uc3QgZSA9IHZbMl07XG4gICAgICAgIGxldCBnID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQgKyBlICogZSk7XG4gICAgICAgIGlmIChnKSB7XG4gICAgICAgICAgICBpZiAoZyA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2WzBdID0gMDtcbiAgICAgICAgICAgIHZbMV0gPSAwO1xuICAgICAgICAgICAgdlsyXSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBnID0gMSAvIGc7XG4gICAgICAgIHZbMF0gPSBjICogZztcbiAgICAgICAgdlsxXSA9IGQgKiBnO1xuICAgICAgICB2WzJdID0gZSAqIGc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgICAgICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAgICAgICAgICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAgICAgICAgICogQHJldHVybnMge3ZlYzN9IG91dFxuICAgICAgICAgKi9cbiAgICBhZGQoYikge1xuICAgICAgICBjb25zdCBhID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgYiA9IGIuZWxlbWVudHM7XG4gICAgICAgIGFbMF0gPSBhWzBdICsgYlswXTtcbiAgICAgICAgYVsxXSA9IGFbMV0gKyBiWzFdO1xuICAgICAgICBhWzJdID0gYVsyXSArIGJbMl07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRTKGIpIHtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGFbMF0gPSBhWzBdICsgYjtcbiAgICAgICAgYVsxXSA9IGFbMV0gKyBiO1xuICAgICAgICBhWzJdID0gYVsyXSArIGI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzY2FsZShiKSB7XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICBhWzBdID0gYVswXSAqIGI7XG4gICAgICAgIGFbMV0gPSBhWzFdICogYjtcbiAgICAgICAgYVsyXSA9IGFbMl0gKiBiO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlzdGFuY2VUb1NxdWFyZWQoeCwgeSwgeikge1xuICAgICAgICBjb25zdCBkeCA9IHRoaXMuZWxlbWVudHNbMF0gLSB4O1xuICAgICAgICBjb25zdCBkeSA9IHRoaXMuZWxlbWVudHNbMV0gLSB5O1xuICAgICAgICBjb25zdCBkeiA9IHRoaXMuZWxlbWVudHNbMl0gLSB6O1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xuICAgIH1cbiAgICBzdWJ0cmFjdChiKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGIgPSBiLmVsZW1lbnRzO1xuICAgICAgICBvdXRbMF0gPSBvdXRbMF0gLSBiWzBdO1xuICAgICAgICBvdXRbMV0gPSBvdXRbMV0gLSBiWzFdO1xuICAgICAgICBvdXRbMl0gPSBvdXRbMl0gLSBiWzJdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGl2aWRlU2NhbGFyKHNjYWxhcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZSgxIC8gc2NhbGFyKTtcbiAgICB9XG4gICAgYXBwbHlNYXRyaXg0KHsgZWxlbWVudHMgfSkge1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5lbGVtZW50c1swXTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuZWxlbWVudHNbMV07XG4gICAgICAgIGNvbnN0IHogPSB0aGlzLmVsZW1lbnRzWzJdO1xuICAgICAgICBjb25zdCBlID0gZWxlbWVudHM7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbMF0gPSBlWzBdICogeCArIGVbNF0gKiB5ICsgZVs4XSAqIHogKyBlWzEyXTtcbiAgICAgICAgdGhpcy5lbGVtZW50c1sxXSA9IGVbMV0gKiB4ICsgZVs1XSAqIHkgKyBlWzldICogeiArIGVbMTNdO1xuICAgICAgICB0aGlzLmVsZW1lbnRzWzJdID0gZVsyXSAqIHggKyBlWzZdICogeSArIGVbMTBdICogeiArIGVbMTRdO1xuICAgICAgICBjb25zdCB3ID0gZVszXSAqIHggKyBlWzddICogeSArIGVbMTFdICogeiArIGVbMTVdO1xuICAgICAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodyk7XG4gICAgfVxuICAgIGxlcnAoYSwgYiwgdCkge1xuICAgICAgICBjb25zdCBvdXQgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICBjb25zdCBheCA9IGFbMF07XG4gICAgICAgIGNvbnN0IGF5ID0gYVsxXTtcbiAgICAgICAgY29uc3QgYXogPSBhWzJdO1xuICAgICAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICAgICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgICAgIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbGVuZ3RoU3EoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzWzBdICogdGhpcy5lbGVtZW50c1swXSArIHRoaXMuZWxlbWVudHNbMV0gKiB0aGlzLmVsZW1lbnRzWzFdICsgdGhpcy5lbGVtZW50c1syXSAqIHRoaXMuZWxlbWVudHNbMl07XG4gICAgfVxuICAgIG11bHRpcGx5KHsgZWxlbWVudHMgfSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzWzBdICo9IGVsZW1lbnRzWzBdO1xuICAgICAgICB0aGlzLmVsZW1lbnRzWzFdICo9IGVsZW1lbnRzWzFdO1xuICAgICAgICB0aGlzLmVsZW1lbnRzWzJdICo9IGVsZW1lbnRzWzJdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhdGljIGFuZ2xlKGEsIGIpIHtcbiAgICAgICAgY29uc3QgdGVtcEEgPSBuZXcgVmVjdG9yMyhhLmVsZW1lbnRzKTtcbiAgICAgICAgY29uc3QgdGVtcEIgPSBuZXcgVmVjdG9yMyhiLmVsZW1lbnRzKTtcbiAgICAgICAgdGVtcEEubm9ybWFsaXplKCk7XG4gICAgICAgIHRlbXBCLm5vcm1hbGl6ZSgpO1xuICAgICAgICBjb25zdCBjb3NpbmUgPSBWZWN0b3IzLmRvdCh0ZW1wQSwgdGVtcEIpO1xuICAgICAgICBpZiAoY29zaW5lID4gMS4wKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgY3Jvc3MoYSwgYikge1xuICAgICAgICBhID0gYS5lbGVtZW50cztcbiAgICAgICAgYiA9IGIuZWxlbWVudHM7XG4gICAgICAgIGNvbnN0IGF4ID0gYVswXTtcbiAgICAgICAgY29uc3QgYXkgPSBhWzFdO1xuICAgICAgICBjb25zdCBheiA9IGFbMl07XG4gICAgICAgIGNvbnN0IGJ4ID0gYlswXTtcbiAgICAgICAgY29uc3QgYnkgPSBiWzFdO1xuICAgICAgICBjb25zdCBieiA9IGJbMl07XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIG91dC5lbGVtZW50c1swXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICAgICAgICBvdXQuZWxlbWVudHNbMV0gPSBheiAqIGJ4IC0gYXggKiBiejtcbiAgICAgICAgb3V0LmVsZW1lbnRzWzJdID0gYXggKiBieSAtIGF5ICogYng7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHN0YXRpYyBkb3QoYSwgYikge1xuICAgICAgICBhID0gYS5lbGVtZW50cztcbiAgICAgICAgYiA9IGIuZWxlbWVudHM7XG4gICAgICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG4gICAgfVxufVxuLyoqXG4gKiBDb25zdHJ1Y3RvciBvZiBWZWN0b3I0XG4gKiBJZiBvcHRfc3JjIGlzIHNwZWNpZmllZCwgbmV3IHZlY3RvciBpcyBpbml0aWFsaXplZCBieSBvcHRfc3JjLlxuICogQHBhcmFtIG9wdF9zcmMgc291cmNlIHZlY3RvcihvcHRpb24pXG4gKi9cbmNsYXNzIFZlY3RvcjQge1xuICAgIGNvbnN0cnVjdG9yKG9wdF9zcmMpIHtcbiAgICAgICAgY29uc3QgdiA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgICAgIGlmIChvcHRfc3JjICYmIHR5cGVvZiBvcHRfc3JjID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdlswXSA9IG9wdF9zcmNbMF07XG4gICAgICAgICAgICB2WzFdID0gb3B0X3NyY1sxXTtcbiAgICAgICAgICAgIHZbMl0gPSBvcHRfc3JjWzJdO1xuICAgICAgICAgICAgdlszXSA9IG9wdF9zcmNbM107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IHY7XG4gICAgfVxuICAgIHNldChlKSB7XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICBhWzBdID0gZVswXTtcbiAgICAgICAgYVsxXSA9IGVbMV07XG4gICAgICAgIGFbMl0gPSBlWzJdO1xuICAgICAgICBhWzNdID0gZVszXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZChiKSB7XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICBiID0gYi5lbGVtZW50cztcbiAgICAgICAgYVswXSA9IGJbMF07XG4gICAgICAgIGFbMV0gPSBiWzFdO1xuICAgICAgICBhWzJdID0gYlsyXTtcbiAgICAgICAgYVszXSA9IGFbM10gKyBiWzNdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbm9ybWFsaXplKCkge1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5lbGVtZW50c1swXTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuZWxlbWVudHNbMV07XG4gICAgICAgIGNvbnN0IHogPSB0aGlzLmVsZW1lbnRzWzJdO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy5lbGVtZW50c1szXTtcbiAgICAgICAgbGV0IGxlbiA9IHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3O1xuICAgICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1swXSA9IHggKiBsZW47XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzWzFdID0geSAqIGxlbjtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbMl0gPSB6ICogbGVuO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1szXSA9IHcgKiBsZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldEZyb21Sb3RhdGlvbk1hdHJpeCh7IGVsZW1lbnRzIH0pIHtcbiAgICAgICAgY29uc3QgdGUgPSBlbGVtZW50cztcbiAgICAgICAgY29uc3QgbTExID0gdGVbMF07XG4gICAgICAgIGNvbnN0IG0xMiA9IHRlWzRdO1xuICAgICAgICBjb25zdCBtMTMgPSB0ZVs4XTtcbiAgICAgICAgY29uc3QgbTIxID0gdGVbMV07XG4gICAgICAgIGNvbnN0IG0yMiA9IHRlWzVdO1xuICAgICAgICBjb25zdCBtMjMgPSB0ZVs5XTtcbiAgICAgICAgY29uc3QgbTMxID0gdGVbMl07XG4gICAgICAgIGNvbnN0IG0zMiA9IHRlWzZdO1xuICAgICAgICBjb25zdCBtMzMgPSB0ZVsxMF07XG4gICAgICAgIGNvbnN0IHRyYWNlID0gbTExICsgbTIyICsgbTMzO1xuICAgICAgICBsZXQgcztcbiAgICAgICAgaWYgKHRyYWNlID4gMCkge1xuICAgICAgICAgICAgcyA9IDAuNSAvIE1hdGguc3FydCh0cmFjZSArIDEuMCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzWzNdID0gMC4yNSAvIHM7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzWzBdID0gKG0zMiAtIG0yMykgKiBzO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1sxXSA9IChtMTMgLSBtMzEpICogcztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbMl0gPSAobTIxIC0gbTEyKSAqIHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobTExID4gbTIyICYmIG0xMSA+IG0zMykge1xuICAgICAgICAgICAgcyA9IDIuMCAqIE1hdGguc3FydCgxLjAgKyBtMTEgLSBtMjIgLSBtMzMpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1szXSA9IChtMzIgLSBtMjMpIC8gcztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbMF0gPSAwLjI1ICogcztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbMV0gPSAobTEyICsgbTIxKSAvIHM7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzWzJdID0gKG0xMyArIG0zMSkgLyBzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0yMiA+IG0zMykge1xuICAgICAgICAgICAgcyA9IDIuMCAqIE1hdGguc3FydCgxLjAgKyBtMjIgLSBtMTEgLSBtMzMpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1szXSA9IChtMTMgLSBtMzEpIC8gcztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbMF0gPSAobTEyICsgbTIxKSAvIHM7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzWzFdID0gMC4yNSAqIHM7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzWzJdID0gKG0yMyArIG0zMikgLyBzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcyA9IDIuMCAqIE1hdGguc3FydCgxLjAgKyBtMzMgLSBtMTEgLSBtMjIpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1szXSA9IChtMjEgLSBtMTIpIC8gcztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbMF0gPSAobTEzICsgbTMxKSAvIHM7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzWzFdID0gKG0yMyArIG0zMikgLyBzO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1syXSA9IDAuMjUgKiBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBsZXJwKGEsIGIsIHQpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgY29uc3QgYXggPSBhWzBdO1xuICAgICAgICBjb25zdCBheSA9IGFbMV07XG4gICAgICAgIGNvbnN0IGF6ID0gYVsyXTtcbiAgICAgICAgY29uc3QgYXcgPSBhWzNdO1xuICAgICAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICAgICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgICAgIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICAgICAgICBvdXRbM10gPSBhdyArIHQgKiAoYlszXSAtIGF3KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuY2xhc3MgVmVjdG9yMiB7XG4gICAgY29uc3RydWN0b3Iob3B0X3NyYykge1xuICAgICAgICBjb25zdCB2ID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICAgICAgaWYgKG9wdF9zcmMgJiYgdHlwZW9mIG9wdF9zcmMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB2WzBdID0gb3B0X3NyY1swXTtcbiAgICAgICAgICAgIHZbMV0gPSBvcHRfc3JjWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSB2O1xuICAgIH1cbiAgICBzdWJ0cmFjdChiKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGIgPSBiLmVsZW1lbnRzO1xuICAgICAgICBvdXRbMF0gPSBvdXRbMF0gLSBiWzBdO1xuICAgICAgICBvdXRbMV0gPSBvdXRbMV0gLSBiWzFdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbGVycChhLCBiLCB0KSB7XG4gICAgICAgIGNvbnN0IG91dCA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIGNvbnN0IGF4ID0gYVswXTtcbiAgICAgICAgY29uc3QgYXkgPSBhWzFdO1xuICAgICAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICAgICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbi8vIHsgMDogcmlnaHQsIDE6IGxlZnQsIDI6IGJvdHRvbS4gMzogdG9wLCA0OiBmYXIsIDU6IG5lYXIgfVxuZnVuY3Rpb24gRnJ1c3R1bShtKSB7XG4gICAgY29uc3QgcGxhbmVzID0gW25ldyBWZWN0b3I0LCBuZXcgVmVjdG9yNCwgbmV3IFZlY3RvcjQsIG5ldyBWZWN0b3I0LCBuZXcgVmVjdG9yNCwgbmV3IFZlY3RvcjRdO1xuICAgIGNvbnN0IG1lID0gbS5lbGVtZW50cztcbiAgICBsZXQgbWUwID0gbWVbMF0sIG1lMSA9IG1lWzFdLCBtZTIgPSBtZVsyXSwgbWUzID0gbWVbM107XG4gICAgbGV0IG1lNCA9IG1lWzRdLCBtZTUgPSBtZVs1XSwgbWU2ID0gbWVbNl0sIG1lNyA9IG1lWzddO1xuICAgIGxldCBtZTggPSBtZVs4XSwgbWU5ID0gbWVbOV0sIG1lMTAgPSBtZVsxMF0sIG1lMTEgPSBtZVsxMV07XG4gICAgbGV0IG1lMTIgPSBtZVsxMl0sIG1lMTMgPSBtZVsxM10sIG1lMTQgPSBtZVsxNF0sIG1lMTUgPSBtZVsxNV07XG4gICAgcGxhbmVzWzBdLnNldChbbWUzIC0gbWUwLCBtZTcgLSBtZTQsIG1lMTEgLSBtZTgsIG1lMTUgLSBtZTEyXSkubm9ybWFsaXplKCk7XG4gICAgcGxhbmVzWzFdLnNldChbbWUzICsgbWUwLCBtZTcgKyBtZTQsIG1lMTEgKyBtZTgsIG1lMTUgKyBtZTEyXSkubm9ybWFsaXplKCk7XG4gICAgcGxhbmVzWzJdLnNldChbbWUzICsgbWUxLCBtZTcgKyBtZTUsIG1lMTEgKyBtZTksIG1lMTUgKyBtZTEzXSkubm9ybWFsaXplKCk7XG4gICAgcGxhbmVzWzNdLnNldChbbWUzIC0gbWUxLCBtZTcgLSBtZTUsIG1lMTEgLSBtZTksIG1lMTUgLSBtZTEzXSkubm9ybWFsaXplKCk7XG4gICAgcGxhbmVzWzRdLnNldChbbWUzIC0gbWUyLCBtZTcgLSBtZTYsIG1lMTEgLSBtZTEwLCBtZTE1IC0gbWUxNF0pLm5vcm1hbGl6ZSgpO1xuICAgIHBsYW5lc1s1XS5zZXQoW21lMyArIG1lMiwgbWU3ICsgbWU2LCBtZTExICsgbWUxMCwgbWUxNSArIG1lMTRdKS5ub3JtYWxpemUoKTtcbiAgICByZXR1cm4gcGxhbmVzO1xufVxuZXhwb3J0IHsgTWF0cml4MiwgTWF0cml4MywgTWF0cml4NCwgVmVjdG9yMiwgVmVjdG9yMywgVmVjdG9yNCwgRnJ1c3R1bSB9O1xuIiwiaW1wb3J0IHsgTWF0cml4NCwgVmVjdG9yMyB9IGZyb20gJy4vbWF0cml4JztcbmNsYXNzIE9iamVjdDNEIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwYXJlbnQpIHtcbiAgICAgICAgdGhpcy51dWlkID0gTWF0aC5mbG9vcihEYXRlLm5vdygpICogTWF0aC5yYW5kb20oKSk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5tYXRyaXggPSBuZXcgTWF0cml4NDtcbiAgICAgICAgdGhpcy5tYXRyaXhXb3JsZCA9IG5ldyBNYXRyaXg0O1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgc2V0UG9zaXRpb24odHJhbnNsYXRpb24sIHJvdGF0aW9uLCBzY2FsZSkge1xuICAgICAgICBpZiAocm90YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubWF0cml4Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHJvdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMubWF0cml4LnNjYWxlKG5ldyBWZWN0b3IzKHNjYWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1hdHJpeC5zZXRUcmFuc2xhdGUobmV3IFZlY3RvcjModHJhbnNsYXRpb24pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRNYXRyaXgobWF0cml4KSB7XG4gICAgICAgIHRoaXMubWF0cml4LnNldChtYXRyaXgpO1xuICAgIH1cbiAgICBzZXRNYXRyaXhXb3JsZChtYXRyaXgpIHtcbiAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5zZXQobWF0cml4KTtcbiAgICB9XG4gICAgdXBkYXRlTWF0cml4KCkge1xuICAgICAgICBjb25zdCBtID0gbmV3IE1hdHJpeDQ7XG4gICAgICAgIG0ubXVsdGlwbHkodGhpcy5wYXJlbnQubWF0cml4V29ybGQpO1xuICAgICAgICBtLm11bHRpcGx5KHRoaXMubWF0cml4KTtcbiAgICAgICAgdGhpcy5zZXRNYXRyaXhXb3JsZChtLmVsZW1lbnRzKTtcbiAgICB9XG59XG5jbGFzcyBNZXNoIGV4dGVuZHMgT2JqZWN0M0Qge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHBhcmVudCkge1xuICAgICAgICBzdXBlcihuYW1lLCBwYXJlbnQpO1xuICAgICAgICB0aGlzLmdlb21ldHJ5ID0ge1xuICAgICAgICAgICAgYm91bmRpbmdTcGhlcmU6IHtcbiAgICAgICAgICAgICAgICBjZW50ZXI6IG5ldyBWZWN0b3IzLFxuICAgICAgICAgICAgICAgIHJhZGl1czogbnVsbCxcbiAgICAgICAgICAgICAgICBtaW46IG51bGwsXG4gICAgICAgICAgICAgICAgbWF4OiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgVUJPOiBudWxsLFxuICAgICAgICAgICAgVkFPOiBudWxsLFxuICAgICAgICAgICAgaW5kaWNlc0J1ZmZlcjogbnVsbCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IG51bGwsXG4gICAgICAgICAgICB0YXJnZXRzOiBudWxsLFxuICAgICAgICAgICAgYmxlbmQ6IG51bGwsXG4gICAgICAgICAgICB1bmlmb3JtczogbnVsbCxcbiAgICAgICAgICAgIFNLSU46IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9IHtcbiAgICAgICAgICAgIGJsZW5kOiBudWxsLFxuICAgICAgICAgICAgdW5pZm9ybXM6IG51bGwsXG4gICAgICAgICAgICBhbHBoYU1vZGU6IG51bGwsXG4gICAgICAgICAgICBVQk86IG51bGwsXG4gICAgICAgICAgICBwYnJNZXRhbGxpY1JvdWdobmVzczogbnVsbFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLmRlZmluZXMgPSBudWxsO1xuICAgICAgICB0aGlzLm1vZGUgPSA0O1xuICAgIH1cbiAgICBzZXRCbGVuZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsLmJsZW5kID0gdmFsdWU7XG4gICAgfVxuICAgIHNldE1hdGVyaWFsKG1hdGVyaWFsKSB7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3JtcyA9IHtcbiAgICAgICAgICAgIGJhc2VDb2xvclRleHR1cmU6IG51bGwsXG4gICAgICAgICAgICBtZXRhbGxpY1JvdWdobmVzc1RleHR1cmU6IG51bGwsXG4gICAgICAgICAgICBub3JtYWxUZXh0dXJlOiBudWxsLFxuICAgICAgICAgICAgb2NjbHVzaW9uVGV4dHVyZTogbnVsbCxcbiAgICAgICAgICAgIGVtaXNzaXZlVGV4dHVyZTogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYWxjdWxhdGVCb3VuZGluZygpIHtcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMuUE9TSVRJT047XG4gICAgICAgIGxldCBtYXhSYWRpdXNTcSA9IDA7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2VudGVyXG4gICAgICAgICAgICAuYWRkKHRoaXMuZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUubWluKVxuICAgICAgICAgICAgLmFkZCh0aGlzLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLm1heClcbiAgICAgICAgICAgIC5zY2FsZSgwLjUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSA9IGkgKyAzKSB7XG4gICAgICAgICAgICBtYXhSYWRpdXNTcSA9IE1hdGgubWF4KG1heFJhZGl1c1NxLCB0aGlzLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCh2ZXJ0aWNlc1tpXSwgdmVydGljZXNbaSArIDFdLCB2ZXJ0aWNlc1tpICsgMl0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydChtYXhSYWRpdXNTcSk7XG4gICAgfVxuICAgIHNldEJvdW5kaW5nQm94KHsgbWluLCBtYXggfSkge1xuICAgICAgICB0aGlzLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLm1pbiA9IG5ldyBWZWN0b3IzKG1pbik7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUubWF4ID0gbmV3IFZlY3RvcjMobWF4KTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZGluZygpO1xuICAgIH1cbiAgICBzZXRJbmRpY2VzQnVmZmVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnkuaW5kaWNlc0J1ZmZlciA9IHZhbHVlO1xuICAgIH1cbiAgICBzZXRBdHRyaWJ1dGVzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcyA9IHZhbHVlO1xuICAgIH1cbiAgICBzZXRUYXJnZXRzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnkudGFyZ2V0cyA9IHZhbHVlO1xuICAgIH1cbiAgICBzZXRQcm9ncmFtKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHZhbHVlO1xuICAgIH1cbiAgICBzZXRNb2RlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubW9kZSA9IHZhbHVlO1xuICAgIH1cbiAgICBpc1Zpc2libGUocGxhbmVzKSB7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgVmVjdG9yMyh0aGlzLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNlbnRlci5lbGVtZW50cykuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpO1xuICAgICAgICBjb25zdCByID0gdGhpcy5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgKiB0aGlzLm1hdHJpeFdvcmxkLmdldE1heFNjYWxlT25BeGlzKCk7XG4gICAgICAgIGxldCBkaXN0O1xuICAgICAgICBsZXQgdmlzaWJsZSA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBwbGFuZXMpIHtcbiAgICAgICAgICAgIGRpc3QgPSBwLmVsZW1lbnRzWzBdICogYy5lbGVtZW50c1swXSArIHAuZWxlbWVudHNbMV0gKiBjLmVsZW1lbnRzWzFdICsgcC5lbGVtZW50c1syXSAqIGMuZWxlbWVudHNbMl0gKyBwLmVsZW1lbnRzWzNdO1xuICAgICAgICAgICAgaWYgKGRpc3QgPCAtcikge1xuICAgICAgICAgICAgICAgIHZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3RhbmNlID0gZGlzdCArIHI7XG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgIH1cbn1cbmNsYXNzIFNraW5uZWRNZXNoIGV4dGVuZHMgTWVzaCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgcGFyZW50KSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIHBhcmVudCk7XG4gICAgfVxuICAgIHNldFNraW4odmFsdWUpIHtcbiAgICAgICAgdGhpcy5za2luID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRKb2ludE1hdHJpeCgpIHtcbiAgICAgICAgY29uc3QgbSA9IG5ldyBNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpO1xuICAgICAgICBjb25zdCByZXNBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBtaSA9IDA7IG1pIDwgdGhpcy5ib25lSW52ZXJzZXMubGVuZ3RoOyBtaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBuZXcgTWF0cml4NCgpXG4gICAgICAgICAgICAgICAgLm11bHRpcGx5KG0pXG4gICAgICAgICAgICAgICAgLm11bHRpcGx5KHRoaXMuYm9uZXNbbWldLm1hdHJpeFdvcmxkKVxuICAgICAgICAgICAgICAgIC5tdWx0aXBseSh0aGlzLmJvbmVJbnZlcnNlc1ttaV0pO1xuICAgICAgICAgICAgcmVzQXJyYXkucHVzaChyZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNBcnJheTtcbiAgICB9XG59XG5jbGFzcyBCb25lIGV4dGVuZHMgT2JqZWN0M0Qge1xufVxuY2xhc3MgQ2FtZXJhIGV4dGVuZHMgT2JqZWN0M0Qge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHBhcmVudCkge1xuICAgICAgICBzdXBlcihuYW1lLCBwYXJlbnQpO1xuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkSW52ZXJ0ID0gbmV3IE1hdHJpeDQ7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbiA9IG5ldyBNYXRyaXg0O1xuICAgIH1cbiAgICBzZXRQcm9wcyhwcm9wcykge1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgfVxuICAgIHNldFByb2plY3Rpb24obWF0cml4KSB7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbi5zZXQobWF0cml4LmVsZW1lbnRzKTtcbiAgICB9XG4gICAgc2V0TWF0cml4V29ybGQobWF0cml4KSB7XG4gICAgICAgIHN1cGVyLnNldE1hdHJpeFdvcmxkKG1hdHJpeCk7XG4gICAgICAgIHRoaXMubWF0cml4V29ybGRJbnZlcnQuc2V0SW52ZXJzZU9mKHRoaXMubWF0cml4V29ybGQpO1xuICAgIH1cbiAgICBzZXRaKHopIHtcbiAgICAgICAgdGhpcy5tYXRyaXguZWxlbWVudHNbMTRdID0gejtcbiAgICAgICAgdGhpcy5zZXRNYXRyaXhXb3JsZCh0aGlzLm1hdHJpeC5lbGVtZW50cyk7XG4gICAgfVxuICAgIGdldFZpZXdQcm9qTWF0cml4KCkge1xuICAgICAgICBjb25zdCBtID0gbmV3IE1hdHJpeDQ7XG4gICAgICAgIG0ubXVsdGlwbHkodGhpcy5wcm9qZWN0aW9uKTtcbiAgICAgICAgbS5tdWx0aXBseSh0aGlzLm1hdHJpeFdvcmxkSW52ZXJ0KTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxufVxuY2xhc3MgU2NlbmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm9wYXF1ZUNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMudHJhbnNwYXJlbnRDaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMuYmluID0gW107XG4gICAgICAgIHRoaXMubWF0cml4V29ybGQgPSBuZXcgTWF0cml4NDtcbiAgICB9XG59XG5leHBvcnQgeyBTY2VuZSwgT2JqZWN0M0QsIE1lc2gsIFNraW5uZWRNZXNoLCBCb25lLCBDYW1lcmEgfTtcbiIsImNsYXNzIEV2ZW50cyB7XG4gICAgY29uc3RydWN0b3IocmVkcmF3KSB7XG4gICAgICAgIHRoaXMucmVkcmF3ID0gcmVkcmF3O1xuICAgICAgICB0aGlzLnpvb21WYWx1ZSA9IDA7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcyk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcyk7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMpO1xuICAgIH1cbiAgICBoYW5kbGVFdmVudChlKSB7XG4gICAgICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICd3aGVlbCc6XG4gICAgICAgICAgICAgICAgdGhpcy56b29tKGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uU3RhcnQoZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMub25Nb3ZlKGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVuZCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAna2V5dXAnOlxuICAgICAgICAgICAgICAgIHRoaXMub25LZXlVcCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAna2V5ZG93bic6XG4gICAgICAgICAgICAgICAgdGhpcy5vbktleURvd24oZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZXNpemUnOlxuICAgICAgICAgICAgICAgIHRoaXMub25SZXNpemUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblJlc2l6ZSgpIHtcbiAgICAgICAgdGhpcy5yZWRyYXcoJ3Jlc2l6ZScpO1xuICAgIH1cbiAgICBvbktleURvd24oZSkge1xuICAgICAgICBpZiAoZS5zaGlmdEtleSB8fCBlLmN0cmxLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuaXNQYW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uS2V5VXAoKSB7XG4gICAgICAgIHRoaXMuaXNQYW4gPSBmYWxzZTtcbiAgICB9XG4gICAgb25TdGFydChlKSB7XG4gICAgICAgIHRoaXMueCA9IGUuY2xpZW50WDtcbiAgICAgICAgdGhpcy55ID0gZS5jbGllbnRZO1xuICAgICAgICB0aGlzLmlzRHJhZyA9IHRydWU7XG4gICAgfVxuICAgIG9uTW92ZShlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNQYW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZHJhdygncGFuJywgW3RoaXMueCwgdGhpcy55XSwgW2UuY2xpZW50WCwgZS5jbGllbnRZXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZHJhdygncm90YXRlJywgW3RoaXMueCwgdGhpcy55XSwgW2UuY2xpZW50WCwgZS5jbGllbnRZXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnggPSBlLmNsaWVudFg7XG4gICAgICAgICAgICB0aGlzLnkgPSBlLmNsaWVudFk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25FbmQoKSB7XG4gICAgICAgIHRoaXMuaXNEcmFnID0gZmFsc2U7XG4gICAgfVxuICAgIHpvb20oZSkge1xuICAgICAgICB0aGlzLnpvb21WYWx1ZSA9IE1hdGgubWluKHRoaXMuem9vbVZhbHVlICsgZS5kZWx0YVksIDEyNTApO1xuICAgICAgICB0aGlzLnJlZHJhdygnem9vbScsIE1hdGgucG93KDEuMDAxLCB0aGlzLnpvb21WYWx1ZSkpO1xuICAgIH1cbn1cbmV4cG9ydCB7IEV2ZW50cyB9O1xuIiwiaW1wb3J0IHsgTWF0cml4MiwgTWF0cml4MywgTWF0cml4NCwgVmVjdG9yMiwgVmVjdG9yMywgVmVjdG9yNCB9IGZyb20gJy4vbWF0cml4JztcbmNvbnN0IGdsRW51bSA9IHt9O1xubGV0IGdsO1xuZXhwb3J0IGZ1bmN0aW9uIHNldEdsKF9nbCkge1xuICAgIGdsID0gX2dsO1xuICAgIGZvciAoY29uc3QgayBpbiBnbCkge1xuICAgICAgICBjb25zdCB2ID0gZ2xba107XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGdsRW51bVt2XSA9IGs7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNNYXRyaXgodHlwZSkge1xuICAgIHJldHVybiBnbEVudW1bdHlwZV0gPT09ICdGTE9BVF9NQVQ0JyB8fCBnbEVudW1bdHlwZV0gPT09ICdGTE9BVF9NQVQzJyB8fCBnbEVudW1bdHlwZV0gPT09ICdGTE9BVF9NQVQyJztcbn1cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20obWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hdHJpeFR5cGUodHlwZSkge1xuICAgIGlmIChnbEVudW1bdHlwZV0gPT09ICdGTE9BVF9NQVQ0Jykge1xuICAgICAgICByZXR1cm4gTWF0cml4NDtcbiAgICB9XG4gICAgaWYgKGdsRW51bVt0eXBlXSA9PT0gJ0ZMT0FUX01BVDMnKSB7XG4gICAgICAgIHJldHVybiBNYXRyaXgzO1xuICAgIH1cbiAgICBpZiAoZ2xFbnVtW3R5cGVdID09PSAnRkxPQVRfTUFUMicpIHtcbiAgICAgICAgcmV0dXJuIE1hdHJpeDI7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGFUeXBlKHR5cGUpIHtcbiAgICBsZXQgY291bnQ7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ01BVDInOlxuICAgICAgICAgICAgY291bnQgPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01BVDMnOlxuICAgICAgICAgICAgY291bnQgPSA5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01BVDQnOlxuICAgICAgICAgICAgY291bnQgPSAxNjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdWRUM0JzpcbiAgICAgICAgICAgIGNvdW50ID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdWRUMzJzpcbiAgICAgICAgICAgIGNvdW50ID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdWRUMyJzpcbiAgICAgICAgICAgIGNvdW50ID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTQ0FMQVInOlxuICAgICAgICAgICAgY291bnQgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21wb25lbnRUeXBlKHR5cGUpIHtcbiAgICBsZXQgY291bnQ7XG4gICAgc3dpdGNoIChnbEVudW1bdHlwZV0pIHtcbiAgICAgICAgY2FzZSAnRkxPQVRfVkVDNCc6XG4gICAgICAgICAgICBjb3VudCA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRkxPQVRfVkVDMyc6XG4gICAgICAgICAgICBjb3VudCA9IDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRkxPQVRfVkVDMic6XG4gICAgICAgICAgICBjb3VudCA9IDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1ldGhvZCh0eXBlKSB7XG4gICAgbGV0IG1ldGhvZDtcbiAgICBzd2l0Y2ggKGdsRW51bVt0eXBlXSkge1xuICAgICAgICBjYXNlICdGTE9BVF9WRUMyJzpcbiAgICAgICAgICAgIG1ldGhvZCA9ICd1bmlmb3JtMmYnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0ZMT0FUX1ZFQzQnOlxuICAgICAgICAgICAgbWV0aG9kID0gJ3VuaWZvcm00Zic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRkxPQVQnOlxuICAgICAgICAgICAgbWV0aG9kID0gJ3VuaWZvcm0xZic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRkxPQVRfVkVDMyc6XG4gICAgICAgICAgICBtZXRob2QgPSAndW5pZm9ybTNmJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdGTE9BVF9NQVQ0JzpcbiAgICAgICAgICAgIG1ldGhvZCA9ICd1bmlmb3JtTWF0cml4NGZ2JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdGTE9BVF9NQVQzJzpcbiAgICAgICAgICAgIG1ldGhvZCA9ICd1bmlmb3JtTWF0cml4M2Z2JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdGTE9BVF9NQVQyJzpcbiAgICAgICAgICAgIG1ldGhvZCA9ICd1bmlmb3JtTWF0cml4MmZ2JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTQU1QTEVSXzJEJzpcbiAgICAgICAgICAgIG1ldGhvZCA9ICd1bmlmb3JtMWknO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBtZXRob2Q7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QW5pbWF0aW9uQ29tcG9uZW50KHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gJ3JvdGF0aW9uJykge1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ3dlaWdodHMnKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbik7XG59XG5leHBvcnQgZnVuY3Rpb24gaW50ZXJwb2xhdGlvbih0aW1lLCBmcmFtZXMpIHtcbiAgICBpZiAoZnJhbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gWy0xLCAtMSwgMF07XG4gICAgfVxuICAgIGxldCBwcmV2ID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IGZyYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbaV0udGltZSkge1xuICAgICAgICAgICAgcHJldiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldiA9PT0gLTEgfHwgcHJldiA9PT0gZnJhbWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKHByZXYgPCAwKSB7XG4gICAgICAgICAgICBwcmV2ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3ByZXYsIHByZXYsIDBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RhcnRGcmFtZSA9IGZyYW1lc1twcmV2XTtcbiAgICAgICAgY29uc3QgZW5kRnJhbWUgPSBmcmFtZXNbcHJldiArIDFdO1xuICAgICAgICB0aW1lID0gTWF0aC5tYXgoc3RhcnRGcmFtZS50aW1lLCBNYXRoLm1pbih0aW1lLCBlbmRGcmFtZS50aW1lKSk7XG4gICAgICAgIGNvbnN0IHQgPSByYW5nZShzdGFydEZyYW1lLnRpbWUsIGVuZEZyYW1lLnRpbWUsIHRpbWUpO1xuICAgICAgICByZXR1cm4gW3ByZXYsIHByZXYgKyAxLCB0XTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDb3VudCh0eXBlKSB7XG4gICAgbGV0IGFycjtcbiAgICBzd2l0Y2ggKGdsRW51bVt0eXBlXSkge1xuICAgICAgICBjYXNlICdCWVRFJzpcbiAgICAgICAgY2FzZSAnVU5TSUdORURfQllURSc6XG4gICAgICAgICAgICBhcnIgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1NIT1JUJzpcbiAgICAgICAgY2FzZSAnVU5TSUdORURfU0hPUlQnOlxuICAgICAgICAgICAgYXJyID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdVTlNJR05FRF9JTlQnOlxuICAgICAgICBjYXNlICdGTE9BVCc6XG4gICAgICAgICAgICBhcnIgPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRBcnJheShhcnJheUJ1ZmZlciwgdHlwZSwgb2Zmc2V0LCBsZW5ndGgsIHN0cmlkZSwgY291bnQpIHtcbiAgICBjb25zdCBsID0gbGVuZ3RoO1xuICAgIGNvbnN0IGMgPSBsZW5ndGggLyBjb3VudDtcbiAgICBpZiAoc3RyaWRlICYmIHN0cmlkZSAhPT0gZ2V0Q291bnQodHlwZSkgKiBjKSB7XG4gICAgICAgIGxlbmd0aCA9IHN0cmlkZSAqIGNvdW50IC8gZ2V0Q291bnQodHlwZSkgLSBvZmZzZXQgLyBnZXRDb3VudCh0eXBlKTtcbiAgICB9XG4gICAgbGV0IGFycjtcbiAgICBzd2l0Y2ggKGdsRW51bVt0eXBlXSkge1xuICAgICAgICBjYXNlICdCWVRFJzpcbiAgICAgICAgICAgIGFyciA9IG5ldyBJbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdVTlNJR05FRF9CWVRFJzpcbiAgICAgICAgICAgIGFyciA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnU0hPUlQnOlxuICAgICAgICAgICAgYXJyID0gbmV3IEludDE2QXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdVTlNJR05FRF9TSE9SVCc6XG4gICAgICAgICAgICBhcnIgPSBuZXcgVWludDE2QXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdVTlNJR05FRF9JTlQnOlxuICAgICAgICAgICAgYXJyID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRkxPQVQnOlxuICAgICAgICAgICAgYXJyID0gbmV3IEZsb2F0MzJBcnJheShhcnJheUJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChzdHJpZGUgJiYgc3RyaWRlICE9PSBnZXRDb3VudCh0eXBlKSAqIGMpIHtcbiAgICAgICAgY29uc3Qgc3RyaWRlZEFyciA9IG5ldyBGbG9hdDMyQXJyYXkobCk7XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpZGVkQXJyLmxlbmd0aDsgaSA9IGkgKyBjKSB7XG4gICAgICAgICAgICBzdHJpZGVkQXJyW2ldID0gYXJyW2pdO1xuICAgICAgICAgICAgc3RyaWRlZEFycltpICsgMV0gPSBhcnJbaiArIDFdO1xuICAgICAgICAgICAgc3RyaWRlZEFycltpICsgMl0gPSBhcnJbaiArIDJdO1xuICAgICAgICAgICAgaiA9IGogKyBjICogKHN0cmlkZSAvIGdldENvdW50KHR5cGUpIC8gYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmlkZWRBcnI7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZVNoYWRlcih0eXBlLCBzaGFkZXJTb3VyY2UsIHByb2dyYW0pIHtcbiAgICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcik7XG4gICAgY29uc3QgbG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICAgIGlmIChsb2cpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihsb2cpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB3YWxrKG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gX3dhbGsobm9kZSkge1xuICAgICAgICBjYWxsYmFjayhub2RlKTtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChfd2Fsayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3dhbGsobm9kZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2NlbmVUb0FyY0JhbGwocG9zKSB7XG4gICAgbGV0IGxlbiA9IHBvc1swXSAqIHBvc1swXSArIHBvc1sxXSAqIHBvc1sxXTtcbiAgICBjb25zdCBzeiA9IDAuMDQgKiAwLjA0IC0gbGVuO1xuICAgIGlmIChzeiA+IDApIHtcbiAgICAgICAgcmV0dXJuIFtwb3NbMF0sIHBvc1sxXSwgTWF0aC5zcXJ0KHN6KV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZW4gPSBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgcmV0dXJuIFswLjA0ICogcG9zWzBdIC8gbGVuLCAwLjA0ICogcG9zWzFdIC8gbGVuLCAwXTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY2FudmFzVG9Xb3JsZCh2ZWMyLCBwcm9qZWN0aW9uLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgW3gsIHldID0gdmVjMjtcbiAgICBjb25zdCBuZXdNID0gbmV3IE1hdHJpeDQ7XG4gICAgbmV3TS5zZXRUcmFuc2xhdGUobmV3IFZlY3RvcjMoWzAsIDAsIDAuMDVdKSk7XG4gICAgY29uc3QgbSA9IG5ldyBNYXRyaXg0KHByb2plY3Rpb24pO1xuICAgIG0ubXVsdGlwbHkobmV3TSk7XG4gICAgY29uc3QgbXAgPSBtLm11bHRpcGx5VmVjdG9yNChuZXcgVmVjdG9yNChbMCwgMCwgMCwgMV0pKTtcbiAgICBtcC5lbGVtZW50c1swXSA9ICgyICogeCAvIHdpZHRoIC0gMSkgKiBtcC5lbGVtZW50c1szXTtcbiAgICBtcC5lbGVtZW50c1sxXSA9ICgtMiAqIHkgLyBoZWlnaHQgKyAxKSAqIG1wLmVsZW1lbnRzWzNdO1xuICAgIGNvbnN0IHYgPSBtLmludmVydCgpLm11bHRpcGx5VmVjdG9yNChtcCk7XG4gICAgcmV0dXJuIFt2LmVsZW1lbnRzWzBdLCB2LmVsZW1lbnRzWzFdXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVQcm9qZWN0aW9uKGNhbSkge1xuICAgIGNvbnN0IHsgYXNwZWN0LCB6b29tIH0gPSBjYW07XG4gICAgbGV0IHByb2o7XG4gICAgaWYgKGNhbS50eXBlID09PSAncGVyc3BlY3RpdmUnICYmIGNhbS5wZXJzcGVjdGl2ZSkge1xuICAgICAgICBjb25zdCB7IHlmb3YgfSA9IGNhbS5wZXJzcGVjdGl2ZTtcbiAgICAgICAgY29uc3QgeGZvdiA9IHlmb3YgKiBhc3BlY3Q7XG4gICAgICAgIHByb2ogPSBuZXcgTWF0cml4NCgpLnNldFBlcnNwZWN0aXZlKHhmb3YgKiB6b29tICogKDE4MCAvIE1hdGguUEkpLCBhc3BlY3QsIGNhbS5wZXJzcGVjdGl2ZS56bmVhciB8fCAxLCBjYW0ucGVyc3BlY3RpdmUuemZhciB8fCAyZTYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjYW0udHlwZSA9PT0gJ29ydGhvZ3JhcGhpYycgJiYgY2FtLm9ydGhvZ3JhcGhpYykge1xuICAgICAgICBwcm9qID0gbmV3IE1hdHJpeDQoKS5zZXRPcnRobyhjYW0ub3J0aG9ncmFwaGljLnhtYWcsIGNhbS5vcnRob2dyYXBoaWMueW1hZywgY2FtLm9ydGhvZ3JhcGhpYy56bmVhciwgY2FtLm9ydGhvZ3JhcGhpYy56ZmFyKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2o7XG59XG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KGEgPSAwLCBiID0gMCkge1xuICAgIHJldHVybiBhICsgYjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVJbmRleChuYW1lKSB7XG4gICAgbGV0IGluZGV4O1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlICdQT1NJVElPTic6XG4gICAgICAgICAgICBpbmRleCA9IFswLCAzLCBnbC5GTE9BVF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTk9STUFMJzpcbiAgICAgICAgICAgIGluZGV4ID0gWzEsIDMsIGdsLkZMT0FUXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdURVhDT09SRF8wJzpcbiAgICAgICAgICAgIGluZGV4ID0gWzIsIDIsIGdsLkZMT0FUXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdKT0lOVFNfMCc6XG4gICAgICAgICAgICBpbmRleCA9IFszLCA0LCBnbC5VTlNJR05FRF9TSE9SVF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnV0VJR0hUU18wJzpcbiAgICAgICAgICAgIGluZGV4ID0gWzQsIDQsIGdsLkZMT0FUXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdUQU5HRU5UJzpcbiAgICAgICAgICAgIGluZGV4ID0gWzUsIDQsIGdsLkZMT0FUXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQmlub3JtYWxzKGluZGV4LCB2ZXJ0ZXgsIG5vcm1hbCwgdXYpIHtcbiAgICBjb25zdCB0YW5nZW50ID0gbmV3IEZsb2F0MzJBcnJheShub3JtYWwubGVuZ3RoIC8gMyAqIDQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXgubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY29uc3QgZmFjZUluZGV4ZXMgPSBbaW5kZXhbaV0sIGluZGV4W2kgKyAxXSwgaW5kZXhbaSArIDJdXTtcbiAgICAgICAgY29uc3QgZmFjZVZlcnRpY2VzID0gZmFjZUluZGV4ZXMubWFwKGl4ID0+IHZlY3RvckZyb21BcnJheSh2ZXJ0ZXgsIGl4KSk7XG4gICAgICAgIGNvbnN0IGZhY2VVVnMgPSBmYWNlSW5kZXhlcy5tYXAoaXggPT4gdmVjdG9yRnJvbUFycmF5KHV2LCBpeCwgMikpO1xuICAgICAgICBjb25zdCBkdjEgPSBmYWNlVmVydGljZXNbMV0uc3VidHJhY3QoZmFjZVZlcnRpY2VzWzBdKTtcbiAgICAgICAgY29uc3QgZHYyID0gZmFjZVZlcnRpY2VzWzJdLnN1YnRyYWN0KGZhY2VWZXJ0aWNlc1swXSk7XG4gICAgICAgIGNvbnN0IGR1djEgPSBmYWNlVVZzWzFdLnN1YnRyYWN0KGZhY2VVVnNbMF0pO1xuICAgICAgICBjb25zdCBkdXYyID0gZmFjZVVWc1syXS5zdWJ0cmFjdChmYWNlVVZzWzBdKTtcbiAgICAgICAgbGV0IHIgPSAoZHV2MS5lbGVtZW50c1swXSAqIGR1djIuZWxlbWVudHNbMV0gLSBkdXYxLmVsZW1lbnRzWzFdICogZHV2Mi5lbGVtZW50c1swXSk7XG4gICAgICAgIHIgPSAociAhPT0gMCkgPyAxLjAgLyByIDogMS4wO1xuICAgICAgICBjb25zdCB1ZGlyID0gbmV3IFZlY3RvcjMoW1xuICAgICAgICAgICAgKGR1djIuZWxlbWVudHNbMV0gKiBkdjEuZWxlbWVudHNbMF0gLSBkdXYxLmVsZW1lbnRzWzFdICogZHYyLmVsZW1lbnRzWzBdKSAqIHIsXG4gICAgICAgICAgICAoZHV2Mi5lbGVtZW50c1sxXSAqIGR2MS5lbGVtZW50c1sxXSAtIGR1djEuZWxlbWVudHNbMV0gKiBkdjIuZWxlbWVudHNbMV0pICogcixcbiAgICAgICAgICAgIChkdXYyLmVsZW1lbnRzWzFdICogZHYxLmVsZW1lbnRzWzJdIC0gZHV2MS5lbGVtZW50c1sxXSAqIGR2Mi5lbGVtZW50c1syXSkgKiByXG4gICAgICAgIF0pO1xuICAgICAgICB1ZGlyLm5vcm1hbGl6ZSgpO1xuICAgICAgICBmYWNlSW5kZXhlcy5mb3JFYWNoKGl4ID0+IHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVWZWN0b3JJbkFycmF5KHRhbmdlbnQsIGl4LCB1ZGlyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YW5nZW50O1xuICAgIGZ1bmN0aW9uIHZlY3RvckZyb21BcnJheShhcnJheSwgaW5kZXgsIGVsZW1lbnRzID0gMykge1xuICAgICAgICBpbmRleCA9IGluZGV4ICogZWxlbWVudHM7XG4gICAgICAgIGlmIChlbGVtZW50cyA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKFthcnJheVtpbmRleF0sIGFycmF5W2luZGV4ICsgMV0sIGFycmF5W2luZGV4ICsgMl1dKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudHMgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yMihbYXJyYXlbaW5kZXhdLCBhcnJheVtpbmRleCArIDFdXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWNjdW11bGF0ZVZlY3RvckluQXJyYXkoYXJyYXksIGluZGV4LCB2ZWN0b3IsIGVsZW1lbnRzID0gNCwgYWNjdW11bGF0b3IgPSAoYWNjLCB4KSA9PiBhY2MgKyB4KSB7XG4gICAgICAgIGluZGV4ID0gaW5kZXggKiBlbGVtZW50cztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50czsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMykge1xuICAgICAgICAgICAgICAgIGFycmF5W2luZGV4ICsgaV0gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2luZGV4ICsgaV0gPSBhY2N1bXVsYXRvcihhcnJheVtpbmRleCArIGldLCB2ZWN0b3IuZWxlbWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgY29tcGlsZVNoYWRlciB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4vbWF0cml4JztcbmltcG9ydCBlbnZUZXh0dXJlIGZyb20gJy4vaW1hZ2VzL2Vudi5qcGcnO1xuaW1wb3J0IGVudlNoYWRlciBmcm9tICcuL3NoYWRlcnMvZW52Lmdsc2wnO1xuaW1wb3J0IGVudkJsdXJTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL2JsdXJFbnYuZ2xzbCc7XG5sZXQgZ2w7XG5leHBvcnQgY2xhc3MgRW52IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lbnZNYXRyaXggPSBuZXcgTWF0cml4NDtcbiAgICB9XG4gICAgc2V0Q2FtZXJhKGNhbWVyYSkge1xuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XG4gICAgfVxuICAgIHNldEdsKGcpIHtcbiAgICAgICAgZ2wgPSBnO1xuICAgIH1cbiAgICBjcmVhdGVFbnZpcm9ubWVudCgpIHtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkodGhpcy5WQU8pO1xuICAgICAgICBjb25zdCBtID0gbmV3IE1hdHJpeDQ7XG4gICAgICAgIG0ubXVsdGlwbHkodGhpcy5fY2FtZXJhLnByb2plY3Rpb24pO1xuICAgICAgICBtLm11bHRpcGx5KHRoaXMuX2NhbWVyYS5tYXRyaXhXb3JsZEludmVydCk7XG4gICAgICAgIG0ubXVsdGlwbHkodGhpcy5lbnZNYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtMWYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ2xldmVsJyksIDMpO1xuICAgICAgICBnbC51bmlmb3JtMWkoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ2RpZmZ1c2UnKSwgMCk7XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ01WUE1hdHJpeCcpLCBmYWxzZSwgbS5lbGVtZW50cyk7XG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIHRoaXMuSW5kZXhCdWZmZXJMZW5ndGgsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgICB9XG4gICAgY3JlYXRlRW52aXJvbm1lbnRCdWZmZXIoKSB7XG4gICAgICAgIGNvbnN0IGxhdGl0dWRlQmFuZHMgPSAzMDtcbiAgICAgICAgY29uc3QgbG9uZ2l0dWRlQmFuZHMgPSAzMDtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gdGhpcy5fY2FtZXJhLm1vZGVsU2l6ZSAqIDEwO1xuICAgICAgICBjb25zdCB2ZXJ0ZXhQb3NpdGlvbkRhdGEgPSBbXTtcbiAgICAgICAgY29uc3Qgbm9ybWFsRGF0YSA9IFtdO1xuICAgICAgICBjb25zdCB0ZXh0dXJlQ29vcmREYXRhID0gW107XG4gICAgICAgIGZvciAobGV0IGxhdE51bWJlciA9IDA7IGxhdE51bWJlciA8PSBsYXRpdHVkZUJhbmRzOyBsYXROdW1iZXIrKykge1xuICAgICAgICAgICAgY29uc3QgdGhldGEgPSBsYXROdW1iZXIgKiBNYXRoLlBJIC8gbGF0aXR1ZGVCYW5kcztcbiAgICAgICAgICAgIGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuICAgICAgICAgICAgY29uc3QgY29zVGhldGEgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAgICAgICBmb3IgKGxldCBsb25nTnVtYmVyID0gMDsgbG9uZ051bWJlciA8PSBsb25naXR1ZGVCYW5kczsgbG9uZ051bWJlcisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGhpID0gbG9uZ051bWJlciAqIDIgKiBNYXRoLlBJIC8gbG9uZ2l0dWRlQmFuZHM7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2luUGhpID0gTWF0aC5zaW4ocGhpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3NQaGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBjb3NQaGkgKiBzaW5UaGV0YTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gY29zVGhldGE7XG4gICAgICAgICAgICAgICAgY29uc3QgeiA9IHNpblBoaSAqIHNpblRoZXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IHUgPSAxIC0gKGxvbmdOdW1iZXIgLyBsb25naXR1ZGVCYW5kcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IDEgLSAobGF0TnVtYmVyIC8gbGF0aXR1ZGVCYW5kcyk7XG4gICAgICAgICAgICAgICAgbm9ybWFsRGF0YS5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIG5vcm1hbERhdGEucHVzaCh5KTtcbiAgICAgICAgICAgICAgICBub3JtYWxEYXRhLnB1c2goeik7XG4gICAgICAgICAgICAgICAgdGV4dHVyZUNvb3JkRGF0YS5wdXNoKHUpO1xuICAgICAgICAgICAgICAgIHRleHR1cmVDb29yZERhdGEucHVzaCh2KTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NpdGlvbkRhdGEucHVzaChyYWRpdXMgKiB4KTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NpdGlvbkRhdGEucHVzaChyYWRpdXMgKiB5KTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NpdGlvbkRhdGEucHVzaChyYWRpdXMgKiB6KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleERhdGEgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGF0TnVtYmVyID0gMDsgbGF0TnVtYmVyIDwgbGF0aXR1ZGVCYW5kczsgbGF0TnVtYmVyKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGxvbmdOdW1iZXIgPSAwOyBsb25nTnVtYmVyIDwgbG9uZ2l0dWRlQmFuZHM7IGxvbmdOdW1iZXIrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gKGxhdE51bWJlciAqIChsb25naXR1ZGVCYW5kcyArIDEpKSArIGxvbmdOdW1iZXI7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vjb25kID0gZmlyc3QgKyBsb25naXR1ZGVCYW5kcyArIDE7XG4gICAgICAgICAgICAgICAgaW5kZXhEYXRhLnB1c2goZmlyc3QpO1xuICAgICAgICAgICAgICAgIGluZGV4RGF0YS5wdXNoKHNlY29uZCk7XG4gICAgICAgICAgICAgICAgaW5kZXhEYXRhLnB1c2goZmlyc3QgKyAxKTtcbiAgICAgICAgICAgICAgICBpbmRleERhdGEucHVzaChzZWNvbmQpO1xuICAgICAgICAgICAgICAgIGluZGV4RGF0YS5wdXNoKHNlY29uZCArIDEpO1xuICAgICAgICAgICAgICAgIGluZGV4RGF0YS5wdXNoKGZpcnN0ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5WQU8gPSBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xuICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkodGhpcy5WQU8pO1xuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBWQk8gPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBWQk8pO1xuICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkodmVydGV4UG9zaXRpb25EYXRhKSwgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoMCk7XG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKDAsIDMsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgVkJPID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgVkJPKTtcbiAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHRleHR1cmVDb29yZERhdGEpLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSgxKTtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoMSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBWQk8gPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIFZCTyk7XG4gICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBuZXcgVWludDE2QXJyYXkoaW5kZXhEYXRhKSwgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICAgICAgdGhpcy5JbmRleEJ1ZmZlckxlbmd0aCA9IGluZGV4RGF0YS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZ2wuYmluZFZlcnRleEFycmF5KG51bGwpO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgICAgIGNvbXBpbGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUiwgZW52U2hhZGVyLCB0aGlzLnByb2dyYW0pO1xuICAgICAgICBjb21waWxlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUiwgZW52Qmx1clNoYWRlciwgdGhpcy5wcm9ncmFtKTtcbiAgICAgICAgZ2wubGlua1Byb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2U7XG4gICAgICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBpbWcpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1QpO1xuICAgICAgICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWcub25lcnJvciA9IGVyciA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1nLnNyYyA9IGVudlRleHR1cmU7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImV4cG9ydCBjbGFzcyBGUFMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvdW50ZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmNvdW50ZXJFbC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyByaWdodDogMDsgY29sb3I6ICNmZmY7IGZvbnQtc2l6ZTogMzBweDsgYmFja2dyb3VuZDogIzAwMDsnKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNvdW50ZXJFbCk7XG4gICAgICAgIHRoaXMuZnBzID0gMDtcbiAgICAgICAgdGhpcy5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSAwO1xuICAgIH1cbiAgICB0aWNrKHRpbWUpIHtcbiAgICAgICAgdGhpcy5mcHMrKztcbiAgICAgICAgdGhpcy5lbGFwc2VkVGltZSArPSAodGltZSAtIHRoaXMubGFzdFRpbWUpO1xuICAgICAgICB0aGlzLmxhc3RUaW1lID0gdGltZTtcbiAgICAgICAgaWYgKHRoaXMuZWxhcHNlZFRpbWUgPj0gMTAwMCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudGVyRWwuaW5uZXJIVE1MID0gU3RyaW5nKHRoaXMuZnBzKTtcbiAgICAgICAgICAgIHRoaXMuZnBzID0gMDtcbiAgICAgICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgLT0gMTAwMDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IGJ1aWxkQXJyYXksIGdldERhdGFUeXBlLCB3YWxrLCBnZXRBbmltYXRpb25Db21wb25lbnQsIGNhbGN1bGF0ZVByb2plY3Rpb24sIGNvbXBpbGVTaGFkZXIsIGNhbGN1bGF0ZU9mZnNldCwgZ2V0QXR0cmlidXRlSW5kZXgsIGNhbGN1bGF0ZUJpbm9ybWFscyB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgTWVzaCwgU2tpbm5lZE1lc2gsIEJvbmUsIENhbWVyYSwgT2JqZWN0M0QgfSBmcm9tICcuL29iamVjdHMnO1xuaW1wb3J0IHsgTWF0cml4NCwgRnJ1c3R1bSB9IGZyb20gJy4vbWF0cml4JztcbmltcG9ydCB2ZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL3ZlcnRleC5nbHNsJztcbmltcG9ydCBmcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlcnMvZnJhZ21lbnQuZ2xzbCc7XG5sZXQgZ2w7XG5sZXQgc2NlbmVUZXh0dXJlQ291bnQgPSAxO1xuZXhwb3J0IGNsYXNzIFBhcnNlIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuaG9zdCA9IHVybC5zdWJzdHIoMCwgdXJsLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICAgICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5za2lucyA9IFtdO1xuICAgICAgICB0aGlzLnRleHR1cmVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zYW1wbGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmNhbWVyYXMgPSBbXTtcbiAgICAgICAgdGhpcy5wcm9ncmFtcyA9IHt9O1xuICAgIH1cbiAgICBzZXRTY2VuZShzY2VuZSkge1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgfVxuICAgIHNldEdsKGcpIHtcbiAgICAgICAgZ2wgPSBnO1xuICAgIH1cbiAgICBzZXRDYW1lcmEoY2FtZXJhKSB7XG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcbiAgICB9XG4gICAgc2V0Q2FudmFzKGNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB9XG4gICAgc2V0UmVzaXplKHJlc2l6ZSkge1xuICAgICAgICB0aGlzLnJlc2l6ZSA9IHJlc2l6ZTtcbiAgICB9XG4gICAgc2V0VXBkYXRlQ2FtZXJhKHVwZGF0ZUNhbWVyYSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNhbWVyYSA9IHVwZGF0ZUNhbWVyYTtcbiAgICB9XG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgfVxuICAgIGdldEJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuc2NlbmUuYmluLm1hcCh1cmwgPT4gZmV0Y2goYCR7dGhpcy5ob3N0fSR7dXJsfWApLnRoZW4ocmVzID0+IHJlcy5hcnJheUJ1ZmZlcigpKSkpXG4gICAgICAgICAgICAudGhlbihidWZmZXJzID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBidWZmZXJzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKSB7XG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgICAgIGNvbXBpbGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4U2hhZGVyLCBwcm9ncmFtKTtcbiAgICAgICAgY29tcGlsZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50U2hhZGVyLCBwcm9ncmFtKTtcbiAgICAgICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cbiAgICBidWlsZFByaW0ocGFyZW50LCBuYW1lLCBza2luLCB3ZWlnaHRzLCBwKSB7XG4gICAgICAgIGNvbnN0IGluZGljZXNBY2Nlc3NvciA9IHRoaXMuanNvbi5hY2Nlc3NvcnNbcC5pbmRpY2VzXTtcbiAgICAgICAgY29uc3QgdmVydGV4QWNjZXNzb3IgPSBuZXcgTWFwO1xuICAgICAgICBmb3IgKGNvbnN0IGEgaW4gcC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICB2ZXJ0ZXhBY2Nlc3Nvci5zZXQoYSwgdGhpcy5qc29uLmFjY2Vzc29yc1twLmF0dHJpYnV0ZXNbYV1dKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRzID0gW107XG4gICAgICAgIGlmIChwLnRhcmdldHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHAudGFyZ2V0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRleEFjYyA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4QWNjW2FdID0gdGhpcy5qc29uLmFjY2Vzc29yc1t0YXJnZXRbYV1dO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY2Nlc3NvciA9IHZlcnRleEFjY1thXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyVmlldyA9IHRoaXMuanNvbi5idWZmZXJWaWV3c1thY2Nlc3Nvci5idWZmZXJWaWV3XTtcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4QWNjW2FdID0gYnVpbGRBcnJheSh0aGlzLmFycmF5QnVmZmVyW2J1ZmZlclZpZXcuYnVmZmVyXSwgYWNjZXNzb3IuY29tcG9uZW50VHlwZSwgY2FsY3VsYXRlT2Zmc2V0KGJ1ZmZlclZpZXcuYnl0ZU9mZnNldCwgYWNjZXNzb3IuYnl0ZU9mZnNldCksIGdldERhdGFUeXBlKGFjY2Vzc29yLnR5cGUpICogYWNjZXNzb3IuY291bnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXRzLnB1c2godmVydGV4QWNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IHAubWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5qc29uLm1hdGVyaWFsc1twLm1hdGVyaWFsXSkpIDogeyBwYnJNZXRhbGxpY1JvdWdobmVzczogeyBiYXNlQ29sb3JGYWN0b3I6IFswLjgsIDAuOCwgMC44LCAxLjBdIH0gfTtcbiAgICAgICAgY29uc3QgZGVmaW5lcyA9IFtdO1xuICAgICAgICBpZiAobWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlKSB7XG4gICAgICAgICAgICBtYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnRleHR1cmVzW21hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZS5pbmRleF0pO1xuICAgICAgICAgICAgZGVmaW5lcy5wdXNoKHsgbmFtZTogJ1VTRV9QQlInIH0pO1xuICAgICAgICAgICAgZGVmaW5lcy5wdXNoKHsgbmFtZTogJ01FVEFMUk9VR0hORVNTTUFQJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0ZXJpYWwubm9ybWFsVGV4dHVyZSkge1xuICAgICAgICAgICAgbWF0ZXJpYWwubm9ybWFsVGV4dHVyZSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMudGV4dHVyZXNbbWF0ZXJpYWwubm9ybWFsVGV4dHVyZS5pbmRleF0pO1xuICAgICAgICAgICAgZGVmaW5lcy5wdXNoKHsgbmFtZTogJ05PUk1BTE1BUCcgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGVyaWFsLm9jY2x1c2lvblRleHR1cmUpIHtcbiAgICAgICAgICAgIG1hdGVyaWFsLm9jY2x1c2lvblRleHR1cmUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnRleHR1cmVzW21hdGVyaWFsLm9jY2x1c2lvblRleHR1cmUuaW5kZXhdKTtcbiAgICAgICAgICAgIGRlZmluZXMucHVzaCh7IG5hbWU6ICdPQ0NMVVNJT05NQVAnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlKSB7XG4gICAgICAgICAgICBtYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy50ZXh0dXJlc1ttYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlLmluZGV4XSk7XG4gICAgICAgICAgICBkZWZpbmVzLnB1c2goeyBuYW1lOiAnQkFTRUNPTE9SVEVYVFVSRScgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGVyaWFsLmVtaXNzaXZlVGV4dHVyZSkge1xuICAgICAgICAgICAgbWF0ZXJpYWwuZW1pc3NpdmVUZXh0dXJlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy50ZXh0dXJlc1ttYXRlcmlhbC5lbWlzc2l2ZVRleHR1cmUuaW5kZXhdKTtcbiAgICAgICAgICAgIGRlZmluZXMucHVzaCh7IG5hbWU6ICdFTUlTU0lWRU1BUCcgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVmaW5lcy5wdXNoKHsgbmFtZTogJ0pPSU5UTlVNQkVSJywgdmFsdWU6IHRoaXMuc2tpbnNbc2tpbl0uam9pbnROYW1lcy5sZW5ndGggfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAuYXR0cmlidXRlcy5UQU5HRU5UIHx8IG1hdGVyaWFsLm5vcm1hbFRleHR1cmUpIHtcbiAgICAgICAgICAgIGRlZmluZXMucHVzaCh7IG5hbWU6ICdUQU5HRU5UJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJvZ3JhbTtcbiAgICAgICAgaWYgKHRoaXMucHJvZ3JhbXNbZGVmaW5lcy5tYXAoZGVmaW5lID0+IGRlZmluZS5uYW1lKS5qb2luKCcnKV0pIHtcbiAgICAgICAgICAgIHByb2dyYW0gPSB0aGlzLnByb2dyYW1zW2RlZmluZXMubWFwKGRlZmluZSA9PiBkZWZpbmUubmFtZSkuam9pbignJyldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGVmaW5lU3RyID0gZGVmaW5lcy5tYXAoZGVmaW5lID0+IGAjZGVmaW5lICR7ZGVmaW5lLm5hbWV9ICR7ZGVmaW5lLnZhbHVlIHx8IDF9YCArICdcXG4nKS5qb2luKCcnKTtcbiAgICAgICAgICAgIHByb2dyYW0gPSB0aGlzLmNvbXBpbGVTaGFkZXIodmVydGV4U2hhZGVyLnJlcGxhY2UoL1xcbi8sIGBcXG4ke2RlZmluZVN0cn1gKSwgZnJhZ21lbnRTaGFkZXIucmVwbGFjZSgvXFxuLywgYFxcbiR7ZGVmaW5lU3RyfWApKTtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbXNbZGVmaW5lcy5tYXAoZGVmaW5lID0+IGRlZmluZS5uYW1lKS5qb2luKCcnKV0gPSBwcm9ncmFtO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbmRpY2VzQnVmZmVyO1xuICAgICAgICBpZiAoaW5kaWNlc0FjY2Vzc29yKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJWaWV3ID0gdGhpcy5qc29uLmJ1ZmZlclZpZXdzW2luZGljZXNBY2Nlc3Nvci5idWZmZXJWaWV3XTtcbiAgICAgICAgICAgIGluZGljZXNCdWZmZXIgPSBidWlsZEFycmF5KHRoaXMuYXJyYXlCdWZmZXJbYnVmZmVyVmlldy5idWZmZXJdLCBpbmRpY2VzQWNjZXNzb3IuY29tcG9uZW50VHlwZSwgY2FsY3VsYXRlT2Zmc2V0KGJ1ZmZlclZpZXcuYnl0ZU9mZnNldCwgaW5kaWNlc0FjY2Vzc29yLmJ5dGVPZmZzZXQpLCBnZXREYXRhVHlwZShpbmRpY2VzQWNjZXNzb3IudHlwZSkgKiBpbmRpY2VzQWNjZXNzb3IuY291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvdW5kaW5nQm94ID0ge1xuICAgICAgICAgICAgbWluOiB2ZXJ0ZXhBY2Nlc3Nvci5nZXQoJ1BPU0lUSU9OJykubWluLFxuICAgICAgICAgICAgbWF4OiB2ZXJ0ZXhBY2Nlc3Nvci5nZXQoJ1BPU0lUSU9OJykubWF4XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHZlcnRleEJ1ZmZlcnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrIG9mIHZlcnRleEFjY2Vzc29yLmtleXMoKSkge1xuICAgICAgICAgICAgY29uc3QgYWNjZXNzb3IgPSB2ZXJ0ZXhBY2Nlc3Nvci5nZXQoayk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJWaWV3ID0gdGhpcy5qc29uLmJ1ZmZlclZpZXdzW2FjY2Vzc29yLmJ1ZmZlclZpZXddO1xuICAgICAgICAgICAgdmVydGV4QnVmZmVyc1trXSA9IGJ1aWxkQXJyYXkodGhpcy5hcnJheUJ1ZmZlcltidWZmZXJWaWV3LmJ1ZmZlcl0sIGFjY2Vzc29yLmNvbXBvbmVudFR5cGUsIGNhbGN1bGF0ZU9mZnNldChidWZmZXJWaWV3LmJ5dGVPZmZzZXQsIGFjY2Vzc29yLmJ5dGVPZmZzZXQpLCBnZXREYXRhVHlwZShhY2Nlc3Nvci50eXBlKSAqIGFjY2Vzc29yLmNvdW50LCBidWZmZXJWaWV3LmJ5dGVTdHJpZGUsIGFjY2Vzc29yLmNvdW50KTtcbiAgICAgICAgICAgIGlmIChwLnRhcmdldHMgJiYgayBpbiBwLnRhcmdldHNbMF0pIHtcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IHZlcnRleEJ1ZmZlcnNba107XG4gICAgICAgICAgICAgICAgdmVydGV4QnVmZmVyc1trXSA9IG5ldyBGbG9hdDMyQXJyYXkoZ2VvbWV0cnkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleEJ1ZmZlcnNba10ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgPT09ICdUQU5HRU5UJyAmJiAoaSArIDEpICUgNCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJzW2tdW2ldID0gZ2VvbWV0cnlbaV0gKyB3ZWlnaHRzWzBdICogdGFyZ2V0c1swXVtrXVtpIC0gb2Zmc2V0XSArIHdlaWdodHNbMV0gKiB0YXJnZXRzWzFdW2tdW2kgLSBvZmZzZXRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0ZXJpYWwubm9ybWFsVGV4dHVyZSAmJiBwLmF0dHJpYnV0ZXMuVEFOR0VOVCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJzLlRBTkdFTlQgPSBjYWxjdWxhdGVCaW5vcm1hbHMoaW5kaWNlc0J1ZmZlciwgdmVydGV4QnVmZmVycy5QT1NJVElPTiwgdmVydGV4QnVmZmVycy5OT1JNQUwsIHZlcnRleEJ1ZmZlcnMuVEVYQ09PUkRfMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzaCA9IHNraW4gIT09IHVuZGVmaW5lZCA/IG5ldyBTa2lubmVkTWVzaChuYW1lLCBwYXJlbnQpLnNldFNraW4oc2tpbikgOiBuZXcgTWVzaChuYW1lLCBwYXJlbnQpO1xuICAgICAgICBtZXNoLnNldFByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIG1lc2guc2V0TW9kZShwLm1vZGUpO1xuICAgICAgICBtZXNoLnNldE1hdGVyaWFsKG1hdGVyaWFsKTtcbiAgICAgICAgbWVzaC5zZXRBdHRyaWJ1dGVzKHZlcnRleEJ1ZmZlcnMpO1xuICAgICAgICBtZXNoLnNldEluZGljZXNCdWZmZXIoaW5kaWNlc0J1ZmZlcik7XG4gICAgICAgIG1lc2guc2V0Qm91bmRpbmdCb3goYm91bmRpbmdCb3gpO1xuICAgICAgICBtZXNoLnNldFRhcmdldHModGFyZ2V0cyk7XG4gICAgICAgIG1lc2gudXBkYXRlTWF0cml4KCk7XG4gICAgICAgIGNvbnN0IFZBTyA9IGdsLmNyZWF0ZVZlcnRleEFycmF5KCk7XG4gICAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheShWQU8pO1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gdmVydGV4QnVmZmVycykge1xuICAgICAgICAgICAgY29uc3QgVkJPID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgVkJPKTtcbiAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXJzW2tdLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEF0dHJpYnV0ZUluZGV4KGspO1xuICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXhbMF0pO1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihpbmRleFswXSwgaW5kZXhbMV0sIGluZGV4WzJdLCBmYWxzZSwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGljZXNCdWZmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IFZCTyA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgVkJPKTtcbiAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGljZXNCdWZmZXIsIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgfVxuICAgICAgICBtZXNoLmdlb21ldHJ5LlZBTyA9IFZBTztcbiAgICAgICAgZ2wuYmluZFZlcnRleEFycmF5KG51bGwpO1xuICAgICAgICBpZiAobWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSkge1xuICAgICAgICAgICAgbWVzaC5tYXRlcmlhbC51bmlmb3Jtcy5iYXNlQ29sb3JUZXh0dXJlID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKG1lc2gucHJvZ3JhbSwgJ2Jhc2VDb2xvclRleHR1cmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlKSB7XG4gICAgICAgICAgICBtZXNoLm1hdGVyaWFsLnVuaWZvcm1zLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihtZXNoLnByb2dyYW0sICdtZXRhbGxpY1JvdWdobmVzc1RleHR1cmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0ZXJpYWwubm9ybWFsVGV4dHVyZSkge1xuICAgICAgICAgICAgbWVzaC5tYXRlcmlhbC51bmlmb3Jtcy5ub3JtYWxUZXh0dXJlID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKG1lc2gucHJvZ3JhbSwgJ25vcm1hbFRleHR1cmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0ZXJpYWwub2NjbHVzaW9uVGV4dHVyZSkge1xuICAgICAgICAgICAgbWVzaC5tYXRlcmlhbC51bmlmb3Jtcy5vY2NsdXNpb25UZXh0dXJlID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKG1lc2gucHJvZ3JhbSwgJ29jY2x1c2lvblRleHR1cmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0ZXJpYWwuZW1pc3NpdmVUZXh0dXJlKSB7XG4gICAgICAgICAgICBtZXNoLm1hdGVyaWFsLnVuaWZvcm1zLmVtaXNzaXZlVGV4dHVyZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihtZXNoLnByb2dyYW0sICdlbWlzc2l2ZVRleHR1cmUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzaDtcbiAgICB9XG4gICAgd2Fsa0J5TWVzaChwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLmpzb24ubm9kZXNbbmFtZV07XG4gICAgICAgIGxldCBjaGlsZDtcbiAgICAgICAgaWYgKGVsLmNhbWVyYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9qID0gY2FsY3VsYXRlUHJvamVjdGlvbih0aGlzLmpzb24uY2FtZXJhc1tlbC5jYW1lcmFdKTtcbiAgICAgICAgICAgIGNoaWxkID0gbmV3IENhbWVyYShuYW1lLCBwYXJlbnQpO1xuICAgICAgICAgICAgY2hpbGQuc2V0UHJvcHMoT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgem9vbTogMSxcbiAgICAgICAgICAgICAgICBhc3BlY3Q6IHRoaXMuY2FudmFzLm9mZnNldFdpZHRoIC8gdGhpcy5jYW52YXMub2Zmc2V0SGVpZ2h0XG4gICAgICAgICAgICB9LCB0aGlzLmpzb24uY2FtZXJhc1tlbC5jYW1lcmFdKSk7XG4gICAgICAgICAgICBjaGlsZC5zZXRQcm9qZWN0aW9uKHByb2opO1xuICAgICAgICAgICAgdGhpcy5fY2FtZXJhID0gY2hpbGQ7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNhbWVyYSh0aGlzLl9jYW1lcmEpO1xuICAgICAgICAgICAgdGhpcy5jYW1lcmFzLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVsLmlzQm9uZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBuZXcgQm9uZShuYW1lLCBwYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBuZXcgT2JqZWN0M0QobmFtZSwgcGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwudHJhbnNsYXRpb24gfHwgZWwucm90YXRpb24gfHwgZWwuc2NhbGUpIHtcbiAgICAgICAgICAgIGNoaWxkLnNldFBvc2l0aW9uKGVsLnRyYW5zbGF0aW9uLCBlbC5yb3RhdGlvbiwgZWwuc2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsLm1hdHJpeCkge1xuICAgICAgICAgICAgY2hpbGQuc2V0TWF0cml4KGVsLm1hdHJpeCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQudXBkYXRlTWF0cml4KCk7XG4gICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgcGFyZW50ID0gY2hpbGQ7XG4gICAgICAgIGlmIChlbC5tZXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChlbC5za2luICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGpvaW4gb2YgdGhpcy5za2luc1tlbC5za2luXS5qb2ludE5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhbGsodGhpcy5zY2VuZSwgdGhpcy5idWlsZEJvbmVzLmJpbmQodGhpcywgam9pbiwgdGhpcy5za2luc1tlbC5za2luXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKC4uLnRoaXMuanNvbi5tZXNoZXNbZWwubWVzaF0ucHJpbWl0aXZlcy5tYXAodGhpcy5idWlsZFByaW0uYmluZCh0aGlzLCBwYXJlbnQsIHRoaXMuanNvbi5tZXNoZXNbZWwubWVzaF0ubmFtZSwgZWwuc2tpbiwgdGhpcy5qc29uLm1lc2hlc1tlbC5tZXNoXS53ZWlnaHRzKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbC5jaGlsZHJlbiAmJiBlbC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsLmNoaWxkcmVuLmZvckVhY2godGhpcy53YWxrQnlNZXNoLmJpbmQodGhpcywgcGFyZW50KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsY3VsYXRlRm92KCkge1xuICAgICAgICBsZXQgYmlnZ2VzdE1lc2g7XG4gICAgICAgIHdhbGsodGhpcy5zY2VuZSwgbm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJpZ2dlc3RNZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpZ2dlc3RNZXNoID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUucmFkaXVzID4gYmlnZ2VzdE1lc2guZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUucmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpZ2dlc3RNZXNoID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhID0gTWF0aC5hYnM7XG4gICAgICAgIGNvbnN0IG1pbiA9IGJpZ2dlc3RNZXNoLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLm1pbi5lbGVtZW50cztcbiAgICAgICAgY29uc3QgbWF4ID0gYmlnZ2VzdE1lc2guZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUubWF4LmVsZW1lbnRzO1xuICAgICAgICB0aGlzLl9jYW1lcmEubW9kZWxYU2l6ZSA9IE1hdGgubWF4KGEobWluWzBdKSwgYShtaW5bMl0pLCBhKG1heFswXSksIGEobWF4WzJdKSwgTWF0aC5zcXJ0KG1pblswXSAqIG1pblswXSArIG1pblsyXSAqIG1pblsyXSksIE1hdGguc3FydChtYXhbMF0gKiBtYXhbMF0gKyBtYXhbMl0gKiBtYXhbMl0pKTtcbiAgICAgICAgdGhpcy5fY2FtZXJhLm1vZGVsWVNpemUgPSBNYXRoLm1heChhKG1pblsxXSksIGEobWluWzJdKSwgYShtYXhbMV0pLCBhKG1heFsyXSkpO1xuICAgICAgICB0aGlzLl9jYW1lcmEubW9kZWxTaXplID0gTWF0aC5tYXgodGhpcy5fY2FtZXJhLm1vZGVsWVNpemUsIHRoaXMuX2NhbWVyYS5tb2RlbFhTaXplKTtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9XG4gICAgYnVpbGRNZXNoKCkge1xuICAgICAgICB0aGlzLmpzb24uc2NlbmVzW3RoaXMuanNvbi5zY2VuZSAhPT0gdW5kZWZpbmVkID8gdGhpcy5qc29uLnNjZW5lIDogMF0ubm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmpzb24ubm9kZXNbbl0uY2hpbGRyZW4gJiYgdGhpcy5qc29uLm5vZGVzW25dLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMud2Fsa0J5TWVzaCh0aGlzLnNjZW5lLCBuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmpzb24ubm9kZXNbbl0ubWVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrQnlNZXNoKHRoaXMuc2NlbmUsIG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuanNvbi5ub2Rlc1tuXS5jYW1lcmEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMud2Fsa0J5TWVzaCh0aGlzLnNjZW5lLCBuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlRm92KCk7XG4gICAgICAgIGNvbnN0IHBsYW5lcyA9IEZydXN0dW0odGhpcy5fY2FtZXJhLmdldFZpZXdQcm9qTWF0cml4KCkpO1xuICAgICAgICB3YWxrKHRoaXMuc2NlbmUsIG1lc2ggPT4ge1xuICAgICAgICAgICAgaWYgKG1lc2ggaW5zdGFuY2VvZiBTa2lubmVkTWVzaCkge1xuICAgICAgICAgICAgICAgIG1lc2guYm9uZXMgPSB0aGlzLnNraW5zW21lc2guc2tpbl0uYm9uZXM7XG4gICAgICAgICAgICAgICAgbWVzaC5ib25lSW52ZXJzZXMgPSB0aGlzLnNraW5zW21lc2guc2tpbl0uYm9uZUludmVyc2VzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGpvaW50TWF0cml4ID0gbWVzaC5nZXRKb2ludE1hdHJpeCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheShqb2ludE1hdHJpeC5sZW5ndGggKiAxNik7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaiBvZiBqb2ludE1hdHJpeCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaWNlcy5zZXQoai5lbGVtZW50cywgMCArIDE2ICogaSk7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdUluZGV4ID0gZ2wuZ2V0VW5pZm9ybUJsb2NrSW5kZXgobWVzaC5wcm9ncmFtLCAnU2tpbicpO1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1CbG9ja0JpbmRpbmcobWVzaC5wcm9ncmFtLCB1SW5kZXgsIDIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFVCTyA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuVU5JRk9STV9CVUZGRVIsIFVCTyk7XG4gICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5VTklGT1JNX0JVRkZFUiwgbWF0cmljZXMsIGdsLkRZTkFNSUNfRFJBVyk7XG4gICAgICAgICAgICAgICAgbWVzaC5nZW9tZXRyeS5TS0lOID0gVUJPO1xuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuVU5JRk9STV9CVUZGRVIsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc2ggaW5zdGFuY2VvZiBNZXNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWxzID0gbmV3IEZsb2F0MzJBcnJheSgxMik7XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxzLnNldChtZXNoLm1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvciB8fCBbMC44LCAwLjgsIDAuOCwgMS4wXSk7XG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxzLnNldChbdGhpcy5fY2FtZXJhLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzEyXSwgdGhpcy5fY2FtZXJhLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzEzXSwgdGhpcy5fY2FtZXJhLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzE0XV0sIDQpO1xuICAgICAgICAgICAgICAgIG1hdGVyaWFscy5zZXQoW3RoaXMuX2NhbWVyYS5tYXRyaXhXb3JsZC5lbGVtZW50c1sxMl0sIHRoaXMuX2NhbWVyYS5tYXRyaXhXb3JsZC5lbGVtZW50c1sxM10sIHRoaXMuX2NhbWVyYS5tYXRyaXhXb3JsZC5lbGVtZW50c1sxNF1dLCA4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBtSW5kZXggPSBnbC5nZXRVbmlmb3JtQmxvY2tJbmRleChtZXNoLnByb2dyYW0sICdNYXRlcmlhbCcpO1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1CbG9ja0JpbmRpbmcobWVzaC5wcm9ncmFtLCBtSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1VQk8gPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLlVOSUZPUk1fQlVGRkVSLCBtVUJPKTtcbiAgICAgICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLlVOSUZPUk1fQlVGRkVSLCBtYXRlcmlhbHMsIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgICAgICAgICBtZXNoLm1hdGVyaWFsLlVCTyA9IG1VQk87XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDQobWVzaC5tYXRyaXhXb3JsZCk7XG4gICAgICAgICAgICAgICAgbm9ybWFsTWF0cml4LmludmVydCgpLnRyYW5zcG9zZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSg2NCk7XG4gICAgICAgICAgICAgICAgbWF0cmljZXMuc2V0KG1lc2gubWF0cml4V29ybGQuZWxlbWVudHMsIDApO1xuICAgICAgICAgICAgICAgIG1hdHJpY2VzLnNldChub3JtYWxNYXRyaXguZWxlbWVudHMsIDE2KTtcbiAgICAgICAgICAgICAgICBtYXRyaWNlcy5zZXQodGhpcy5fY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJ0LmVsZW1lbnRzLCAzMik7XG4gICAgICAgICAgICAgICAgbWF0cmljZXMuc2V0KHRoaXMuX2NhbWVyYS5wcm9qZWN0aW9uLmVsZW1lbnRzLCA0OCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdUluZGV4ID0gZ2wuZ2V0VW5pZm9ybUJsb2NrSW5kZXgobWVzaC5wcm9ncmFtLCAnTWF0cmljZXMnKTtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtQmxvY2tCaW5kaW5nKG1lc2gucHJvZ3JhbSwgdUluZGV4LCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBVQk8gPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLlVOSUZPUk1fQlVGRkVSLCBVQk8pO1xuICAgICAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuVU5JRk9STV9CVUZGRVIsIG1hdHJpY2VzLCBnbC5EWU5BTUlDX0RSQVcpO1xuICAgICAgICAgICAgICAgIG1lc2guZ2VvbWV0cnkuVUJPID0gVUJPO1xuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuVU5JRk9STV9CVUZGRVIsIG51bGwpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNoLmlzVmlzaWJsZShwbGFuZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNoLm1hdGVyaWFsLmFscGhhTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS50cmFuc3BhcmVudENoaWxkcmVuLnB1c2gobWVzaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLm9wYXF1ZUNoaWxkcmVuLnB1c2gobWVzaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjZW5lLnRyYW5zcGFyZW50Q2hpbGRyZW4uc29ydCgoYSwgYikgPT4gYi5kaXN0YW5jZSAtIGEuZGlzdGFuY2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYnVpbGRBbmltYXRpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5qc29uLmFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgYW5pbWF0aW9uIG9mIHRoaXMuanNvbi5hbmltYXRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoYW5uZWwgb2YgYW5pbWF0aW9uLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2FtcGxlciA9IGFuaW1hdGlvbi5zYW1wbGVyc1tjaGFubmVsLnNhbXBsZXJdO1xuICAgICAgICAgICAgICAgIGlmIChzYW1wbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSBjaGFubmVsO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gdGFyZ2V0Lm5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gYW5pbWF0aW9uLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCA/IGFuaW1hdGlvbi5wYXJhbWV0ZXJzW3NhbXBsZXIuaW5wdXRdIDogc2FtcGxlci5pbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gYW5pbWF0aW9uLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCA/IGFuaW1hdGlvbi5wYXJhbWV0ZXJzW3NhbXBsZXIub3V0cHV0XSA6IHNhbXBsZXIub3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dEFjY2Vzc29yID0gdGhpcy5qc29uLmFjY2Vzc29yc1tpbnB1dF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dEFjY2Vzc29yID0gdGhpcy5qc29uLmFjY2Vzc29yc1tvdXRwdXRdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dEJ1ZmZlciA9IHRoaXMuanNvbi5idWZmZXJWaWV3c1tpbnB1dEFjY2Vzc29yLmJ1ZmZlclZpZXddO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRCdWZmZXIgPSB0aGlzLmpzb24uYnVmZmVyVmlld3Nbb3V0cHV0QWNjZXNzb3IuYnVmZmVyVmlld107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0QXJyYXkgPSBidWlsZEFycmF5KHRoaXMuYXJyYXlCdWZmZXJbaW5wdXRCdWZmZXIuYnVmZmVyXSwgaW5wdXRBY2Nlc3Nvci5jb21wb25lbnRUeXBlLCBjYWxjdWxhdGVPZmZzZXQoaW5wdXRCdWZmZXIuYnl0ZU9mZnNldCwgaW5wdXRBY2Nlc3Nvci5ieXRlT2Zmc2V0KSwgZ2V0RGF0YVR5cGUoaW5wdXRBY2Nlc3Nvci50eXBlKSAqIGlucHV0QWNjZXNzb3IuY291bnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRBcnJheSA9IGJ1aWxkQXJyYXkodGhpcy5hcnJheUJ1ZmZlcltvdXRwdXRCdWZmZXIuYnVmZmVyXSwgb3V0cHV0QWNjZXNzb3IuY29tcG9uZW50VHlwZSwgY2FsY3VsYXRlT2Zmc2V0KG91dHB1dEJ1ZmZlci5ieXRlT2Zmc2V0LCBvdXRwdXRBY2Nlc3Nvci5ieXRlT2Zmc2V0KSwgZ2V0RGF0YVR5cGUob3V0cHV0QWNjZXNzb3IudHlwZSkgKiBvdXRwdXRBY2Nlc3Nvci5jb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGdldEFuaW1hdGlvbkNvbXBvbmVudCh0YXJnZXQucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFQgPSBpbnB1dEFycmF5W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RWID0gb3V0cHV0QXJyYXkuc2xpY2UoaSAqIGNvbXBvbmVudCwgKGkgKyAxKSAqIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IGZpcnN0VCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmlyc3RWXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNoZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgd2Fsayh0aGlzLnNjZW5lLCBub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LnBhdGggPT09ICd3ZWlnaHRzJyAmJiBub2RlIGluc3RhbmNlb2YgT2JqZWN0M0QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNoZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc2hlczogbWVzaGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRhcmdldC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGAke21lc2hlc1swXS5uYW1lfS4ke3RhcmdldC5wYXRofWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czoga2V5cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiBzYW1wbGVyLmludGVycG9sYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBidWlsZFNraW4oKSB7XG4gICAgICAgIGlmICghdGhpcy5qc29uLnNraW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHNraW4gb2YgdGhpcy5qc29uLnNraW5zKSB7XG4gICAgICAgICAgICBjb25zdCBhY2MgPSB0aGlzLmpzb24uYWNjZXNzb3JzW3NraW4uaW52ZXJzZUJpbmRNYXRyaWNlc107XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmpzb24uYnVmZmVyVmlld3NbYWNjLmJ1ZmZlclZpZXddO1xuICAgICAgICAgICAgY29uc3QgYXJyYXkgPSBidWlsZEFycmF5KHRoaXMuYXJyYXlCdWZmZXJbYnVmZmVyLmJ1ZmZlcl0sIGFjYy5jb21wb25lbnRUeXBlLCBjYWxjdWxhdGVPZmZzZXQoYnVmZmVyLmJ5dGVPZmZzZXQsIGFjYy5ieXRlT2Zmc2V0KSwgZ2V0RGF0YVR5cGUoYWNjLnR5cGUpICogYWNjLmNvdW50KTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB7XG4gICAgICAgICAgICAgICAgam9pbnROYW1lczogc2tpbi5qb2ludHMsXG4gICAgICAgICAgICAgICAgaW52ZXJzZUJpbmRNYXRyaWNlczogYXJyYXksXG4gICAgICAgICAgICAgICAgYm9uZXM6IFtdLFxuICAgICAgICAgICAgICAgIGJvbmVJbnZlcnNlczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGpvaW4gb2Ygdi5qb2ludE5hbWVzKSB7XG4gICAgICAgICAgICAgICAgLy93YWxrKHRoaXMuc2NlbmUsIHRoaXMuYnVpbGRCb25lcy5iaW5kKHRoaXMsIGpvaW4sIHYpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmpzb24ubm9kZXNbam9pbl0uaXNCb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gdi5pbnZlcnNlQmluZE1hdHJpY2VzO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdCA9IG5ldyBNYXRyaXg0KCkuc2V0KG0uc2xpY2UoaSAqIDE2LCAoaSArIDEpICogMTYpKTtcbiAgICAgICAgICAgICAgICB2LmJvbmVJbnZlcnNlcy5wdXNoKG1hdCk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5za2lucy5wdXNoKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBidWlsZEJvbmVzKGpvaW4sIHYsIG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gam9pbikge1xuICAgICAgICAgICAgdi5ib25lcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEpzb24oKSB7XG4gICAgICAgIHJldHVybiBmZXRjaCh0aGlzLnVybClcbiAgICAgICAgICAgIC50aGVuKHJlcyA9PiByZXMuanNvbigpKVxuICAgICAgICAgICAgLnRoZW4oaiA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBqLmJ1ZmZlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmJpbi5wdXNoKGouYnVmZmVyc1trZXldLnVyaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmpzb24gPSBqO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0VGV4dHVyZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5qc29uLnRleHR1cmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzYW1wbGVycyA9IHRoaXMuanNvbi5zYW1wbGVycyB8fCBbe31dO1xuICAgICAgICB0aGlzLnNhbXBsZXJzID0gc2FtcGxlcnMubWFwKHMgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlciA9IGdsLmNyZWF0ZVNhbXBsZXIoKTtcbiAgICAgICAgICAgIGdsLnNhbXBsZXJQYXJhbWV0ZXJpKHNhbXBsZXIsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgcy5taW5GaWx0ZXIgfHwgOTk4Nik7XG4gICAgICAgICAgICBnbC5zYW1wbGVyUGFyYW1ldGVyaShzYW1wbGVyLCBnbC5URVhUVVJFX01BR19GSUxURVIsIHMubWFnRmlsdGVyIHx8IDk3MjkpO1xuICAgICAgICAgICAgZ2wuc2FtcGxlclBhcmFtZXRlcmkoc2FtcGxlciwgZ2wuVEVYVFVSRV9XUkFQX1MsIHMud3JhcFMgfHwgMTA0OTcpO1xuICAgICAgICAgICAgZ2wuc2FtcGxlclBhcmFtZXRlcmkoc2FtcGxlciwgZ2wuVEVYVFVSRV9XUkFQX1QsIHMud3JhcFQgfHwgMTA0OTcpO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZXI7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcm9taXNlQXJyID0gdGhpcy5qc29uLnRleHR1cmVzLm1hcCh0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2FtcGxlciA9IHRoaXMuc2FtcGxlcnNbdC5zYW1wbGVyICE9PSB1bmRlZmluZWQgPyB0LnNhbXBsZXIgOiAwXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmpzb24uaW1hZ2VzW3Quc291cmNlXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmhhbmRsZVRleHR1cmVMb2FkZWQoc2FtcGxlciwgaW1hZ2UpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGltYWdlLm9uZXJyb3IgPSBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gICAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gYCR7dGhpcy5ob3N0fSR7c291cmNlLnVyaX1gO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZUFycilcbiAgICAgICAgICAgIC50aGVuKHRleHR1cmVzID0+IHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZXMgPSB0ZXh0dXJlcztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlVGV4dHVyZUxvYWRlZChzYW1wbGVyLCBpbWFnZSkge1xuICAgICAgICBjb25zdCB0ID0ge1xuICAgICAgICAgICAgaW1hZ2U6IGltYWdlLnNyYy5zdWJzdHIoaW1hZ2Uuc3JjLmxhc3RJbmRleE9mKCcvJykpLFxuICAgICAgICAgICAgZGF0YTogZ2wuY3JlYXRlVGV4dHVyZSgpLFxuICAgICAgICAgICAgY291bnQ6IHNjZW5lVGV4dHVyZUNvdW50XG4gICAgICAgIH07XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2xbYFRFWFRVUkUke3NjZW5lVGV4dHVyZUNvdW50fWBdKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdC5kYXRhKTtcbiAgICAgICAgZ2wuYmluZFNhbXBsZXIoc2NlbmVUZXh0dXJlQ291bnQsIHNhbXBsZXIpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGltYWdlKTtcbiAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG4gICAgICAgIHNjZW5lVGV4dHVyZUNvdW50Kys7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cbn1cbiIsIi8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uL2luZGV4LmQudHMnLz5cbmltcG9ydCB7IFNjZW5lLCBNZXNoLCBTa2lubmVkTWVzaCwgQ2FtZXJhLCBCb25lIH0gZnJvbSAnLi9vYmplY3RzJztcbmltcG9ydCB7IE1hdHJpeDQsIFZlY3RvcjIsIFZlY3RvcjMsIFZlY3RvcjQgfSBmcm9tICcuL21hdHJpeCc7XG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuL2V2ZW50cyc7XG5pbXBvcnQgeyBFbnYgfSBmcm9tICcuL2Vudic7XG5pbXBvcnQgeyBGUFMgfSBmcm9tICcuL2Zwcyc7XG5pbXBvcnQgeyBQYXJzZSB9IGZyb20gJy4vcGFyc2UnO1xuaW1wb3J0IHsgc2V0R2wsIGdldEFuaW1hdGlvbkNvbXBvbmVudCwgaW50ZXJwb2xhdGlvbiwgd2Fsaywgc2NlbmVUb0FyY0JhbGwsIGNhbnZhc1RvV29ybGQsIGNhbGN1bGF0ZVByb2plY3Rpb24sIGdldEF0dHJpYnV0ZUluZGV4IH0gZnJvbSAnLi91dGlscyc7XG5sZXQgZ2w7XG5jbGFzcyBSZWRDdWJlIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIGNhbnZhcywgem5lYXIpIHtcbiAgICAgICAgdGhpcy5yZWZsb3cgPSB0cnVlO1xuICAgICAgICB0aGlzLnNjZW5lID0gbmV3IFNjZW5lO1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBuZXcgQ2FtZXJhO1xuICAgICAgICB0aGlzLmNhbWVyYS5zZXRQcm9wcyh7XG4gICAgICAgICAgICB0eXBlOiAncGVyc3BlY3RpdmUnLFxuICAgICAgICAgICAgaXNJbml0aWFsOiB0cnVlLFxuICAgICAgICAgICAgem9vbTogMSxcbiAgICAgICAgICAgIGFzcGVjdDogdGhpcy5jYW52YXMub2Zmc2V0V2lkdGggLyB0aGlzLmNhbnZhcy5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICBwZXJzcGVjdGl2ZToge1xuICAgICAgICAgICAgICAgIHlmb3Y6IDAuNixcbiAgICAgICAgICAgICAgICB6bmVhcjogem5lYXIgfHwgMSxcbiAgICAgICAgICAgICAgICB6ZmFyOiAyZTZcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50cyh0aGlzLnJlZHJhdy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5mcHMgPSBuZXcgRlBTO1xuICAgICAgICB0aGlzLmVudiA9IG5ldyBFbnY7XG4gICAgICAgIHRoaXMuZW52LnNldENhbWVyYSh0aGlzLmNhbWVyYSk7XG4gICAgICAgIC8vIHRoaXMuUFAgPSBuZXcgUG9zdFByb2Nlc3Npbmc7XG4gICAgICAgIC8vIHRoaXMuUFAuc2V0Q2FudmFzKHRoaXMuY2FudmFzKTtcbiAgICAgICAgLy8gdGhpcy5QUC5zZXRDYW1lcmEodGhpcy5jYW1lcmEpO1xuICAgICAgICB0aGlzLnBhcnNlID0gbmV3IFBhcnNlKHVybCk7XG4gICAgICAgIHRoaXMucGFyc2Uuc2V0U2NlbmUodGhpcy5zY2VuZSk7XG4gICAgICAgIHRoaXMucGFyc2Uuc2V0Q2FtZXJhKHRoaXMuY2FtZXJhKTtcbiAgICAgICAgdGhpcy5wYXJzZS5zZXRVcGRhdGVDYW1lcmEodGhpcy51cGRhdGVDYW1lcmEuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMucGFyc2Uuc2V0Q2FudmFzKHRoaXMuY2FudmFzKTtcbiAgICAgICAgdGhpcy5wYXJzZS5zZXRSZXNpemUodGhpcy5yZXNpemUuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlLmdldEpzb24oKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5nbEluaXQuYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC50aGVuKHRoaXMucGFyc2UuaW5pdFRleHR1cmVzLmJpbmQodGhpcy5wYXJzZSkpXG4gICAgICAgICAgICAudGhlbih0aGlzLnBhcnNlLmdldEJ1ZmZlci5iaW5kKHRoaXMucGFyc2UpKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5wYXJzZS5idWlsZFNraW4uYmluZCh0aGlzLnBhcnNlKSlcbiAgICAgICAgICAgIC50aGVuKHRoaXMucGFyc2UuYnVpbGRNZXNoLmJpbmQodGhpcy5wYXJzZSkpXG4gICAgICAgICAgICAudGhlbih0aGlzLnBhcnNlLmJ1aWxkQW5pbWF0aW9uLmJpbmQodGhpcy5wYXJzZSkpXG4gICAgICAgICAgICAudGhlbih0aGlzLmVudi5jcmVhdGVFbnZpcm9ubWVudEJ1ZmZlci5iaW5kKHRoaXMuZW52KSlcbiAgICAgICAgICAgIC50aGVuKHRoaXMuZHJhdy5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgIH1cbiAgICB1cGRhdGVDYW1lcmEoY2FtZXJhKSB7XG4gICAgICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgICAgICB0aGlzLmVudi5zZXRDYW1lcmEodGhpcy5jYW1lcmEpO1xuICAgIH1cbiAgICByZWRyYXcodHlwZSwgY29vcmRzU3RhcnQsIGNvb3Jkc01vdmUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICd6b29tJykge1xuICAgICAgICAgICAgdGhpcy5jYW1lcmEucHJvcHMuem9vbSA9IGNvb3Jkc1N0YXJ0O1xuICAgICAgICAgICAgdGhpcy5jYW1lcmEuc2V0UHJvamVjdGlvbihjYWxjdWxhdGVQcm9qZWN0aW9uKHRoaXMuY2FtZXJhLnByb3BzKSk7XG4gICAgICAgICAgICB0aGlzLm5lZWRVcGRhdGVQcm9qZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3JvdGF0ZScpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvb3Jkc1N0YXJ0V29ybGQgPSBjYW52YXNUb1dvcmxkKGNvb3Jkc1N0YXJ0LCB0aGlzLmNhbWVyYS5wcm9qZWN0aW9uLCB0aGlzLmNhbnZhcy5vZmZzZXRXaWR0aCwgdGhpcy5jYW52YXMub2Zmc2V0SGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IGNvb3Jkc01vdmVXb3JsZCA9IGNhbnZhc1RvV29ybGQoY29vcmRzTW92ZSwgdGhpcy5jYW1lcmEucHJvamVjdGlvbiwgdGhpcy5jYW52YXMub2Zmc2V0V2lkdGgsIHRoaXMuY2FudmFzLm9mZnNldEhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCBwMCA9IG5ldyBWZWN0b3IzKHNjZW5lVG9BcmNCYWxsKGNvb3Jkc1N0YXJ0V29ybGQpKTtcbiAgICAgICAgICAgIGNvbnN0IHAxID0gbmV3IFZlY3RvcjMoc2NlbmVUb0FyY0JhbGwoY29vcmRzTW92ZVdvcmxkKSk7XG4gICAgICAgICAgICBjb25zdCBhbmdsZSA9IFZlY3RvcjMuYW5nbGUocDEsIHAwKSAqIDU7XG4gICAgICAgICAgICBpZiAoYW5nbGUgPCAxZS02IHx8IGlzTmFOKGFuZ2xlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAwLmFwcGx5TWF0cml4NCh0aGlzLmNhbWVyYS5tYXRyaXhXb3JsZCk7XG4gICAgICAgICAgICBwMS5hcHBseU1hdHJpeDQodGhpcy5jYW1lcmEubWF0cml4V29ybGQpO1xuICAgICAgICAgICAgY29uc3QgdiA9IFZlY3RvcjMuY3Jvc3MocDEsIHAwKS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgTWF0cml4NDtcbiAgICAgICAgICAgIG0ubWFrZVJvdGF0aW9uQXhpcyh2LCBhbmdsZSk7XG4gICAgICAgICAgICBtLm11bHRpcGx5KHRoaXMuY2FtZXJhLm1hdHJpeFdvcmxkKTtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLnNldE1hdHJpeFdvcmxkKG0uZWxlbWVudHMpO1xuICAgICAgICAgICAgdGhpcy5uZWVkVXBkYXRlVmlldyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdwYW4nKSB7XG4gICAgICAgICAgICBjb25zdCBjb29yZHNTdGFydFdvcmxkID0gY2FudmFzVG9Xb3JsZChjb29yZHNTdGFydCwgdGhpcy5jYW1lcmEucHJvamVjdGlvbiwgdGhpcy5jYW52YXMub2Zmc2V0V2lkdGgsIHRoaXMuY2FudmFzLm9mZnNldEhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCBjb29yZHNNb3ZlV29ybGQgPSBjYW52YXNUb1dvcmxkKGNvb3Jkc01vdmUsIHRoaXMuY2FtZXJhLnByb2plY3Rpb24sIHRoaXMuY2FudmFzLm9mZnNldFdpZHRoLCB0aGlzLmNhbnZhcy5vZmZzZXRIZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgcDAgPSBuZXcgVmVjdG9yMyhbLi4uY29vcmRzU3RhcnRXb3JsZCwgMF0pO1xuICAgICAgICAgICAgY29uc3QgcDEgPSBuZXcgVmVjdG9yMyhbLi4uY29vcmRzTW92ZVdvcmxkLCAwXSk7XG4gICAgICAgICAgICBjb25zdCBwYW4gPSB0aGlzLmNhbWVyYS5tb2RlbFNpemUgKiAxMDA7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IHAxLnN1YnRyYWN0KHAwKS5zY2FsZShwYW4pO1xuICAgICAgICAgICAgdGhpcy5jYW1lcmEubWF0cml4V29ybGQudHJhbnNsYXRlKGRlbHRhLmVsZW1lbnRzWzBdLCBkZWx0YS5lbGVtZW50c1sxXSwgMCk7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5zZXRNYXRyaXhXb3JsZCh0aGlzLmNhbWVyYS5tYXRyaXhXb3JsZC5lbGVtZW50cyk7XG4gICAgICAgICAgICB0aGlzLm5lZWRVcGRhdGVWaWV3ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgICAgICB0aGlzLm5lZWRVcGRhdGVQcm9qZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZmxvdyA9IHRydWU7XG4gICAgfVxuICAgIHJlc2l6ZSgpIHtcbiAgICAgICAgdGhpcy5jYW1lcmEucHJvcHMuYXNwZWN0ID0gdGhpcy5jYW52YXMub2Zmc2V0V2lkdGggLyB0aGlzLmNhbnZhcy5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXMub2Zmc2V0V2lkdGggKiBkZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy5vZmZzZXRIZWlnaHQgKiBkZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLmNhbnZhcy5vZmZzZXRXaWR0aCAqIGRldmljZVBpeGVsUmF0aW8sIHRoaXMuY2FudmFzLm9mZnNldEhlaWdodCAqIGRldmljZVBpeGVsUmF0aW8pO1xuICAgICAgICB0aGlzLmNhbWVyYS5zZXRQcm9qZWN0aW9uKGNhbGN1bGF0ZVByb2plY3Rpb24odGhpcy5jYW1lcmEucHJvcHMpKTtcbiAgICAgICAgaWYgKHRoaXMuY2FtZXJhLnByb3BzLmlzSW5pdGlhbCkge1xuICAgICAgICAgICAgY29uc3QgeiA9IDEgLyB0aGlzLmNhbnZhcy53aWR0aCAqIHRoaXMuY2FtZXJhLm1vZGVsU2l6ZSAqIDUwMDA7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5zZXRaKHRoaXMueiB8fCB6KTtcbiAgICAgICAgICAgIHRoaXMubmVlZFVwZGF0ZVZpZXcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdsSW5pdCgpIHtcbiAgICAgICAgZ2wgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInKTtcbiAgICAgICAgaWYgKCFnbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJnbCAyIGRvZXNudCBzdXBwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0R2woZ2wpO1xuICAgICAgICB0aGlzLmVudi5zZXRHbChnbCk7XG4gICAgICAgIC8vdGhpcy5QUC5zZXRHbChnbCk7XG4gICAgICAgIHRoaXMucGFyc2Uuc2V0R2woZ2wpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYW5pbWF0ZShzZWMpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHRoaXMucGFyc2UudHJhY2tzKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBpbnRlcnBvbGF0aW9uKHNlYywgdi5rZXlzKTtcbiAgICAgICAgICAgIGlmICh2YWxbMF0gPT09IC0xIHx8IHZhbFsxXSA9PT0gLTEgfHwgdi5zdG9wZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWxbMF0gPT09IHYua2V5cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdi5zdG9wZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhcnRGcmFtZSA9IHYua2V5c1t2YWxbMF1dO1xuICAgICAgICAgICAgY29uc3QgZW5kRnJhbWUgPSB2LmtleXNbdmFsWzFdXTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgY29uc3QgdCA9IHZhbFsyXTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGdldEFuaW1hdGlvbkNvbXBvbmVudCh2LnR5cGUpO1xuICAgICAgICAgICAgbGV0IHZlY3RvckM7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50ID09PSAzKSB7XG4gICAgICAgICAgICAgICAgdmVjdG9yQyA9IFZlY3RvcjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb21wb25lbnQgPT09IDQpIHtcbiAgICAgICAgICAgICAgICB2ZWN0b3JDID0gVmVjdG9yNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHZlY3RvckMgPSBWZWN0b3IyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmVjdG9yID0gbmV3IHZlY3RvckMoc3RhcnRGcmFtZS52YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCB2ZWN0b3IyID0gbmV3IHZlY3RvckMoZW5kRnJhbWUudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHYudHlwZSA9PT0gJ3JvdGF0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dCA9IG5ldyBWZWN0b3I0O1xuICAgICAgICAgICAgICAgIG91dC5sZXJwKHZlY3Rvci5lbGVtZW50cywgdmVjdG9yMi5lbGVtZW50cywgdCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtZXNoIG9mIHYubWVzaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc2gubWF0cml4Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKG91dC5lbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodi50eXBlID09PSAnc2NhbGUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFZlY3RvcjM7XG4gICAgICAgICAgICAgICAgb3V0LmxlcnAodmVjdG9yLmVsZW1lbnRzLCB2ZWN0b3IyLmVsZW1lbnRzLCB0KTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1lc2ggb2Ygdi5tZXNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzaC5tYXRyaXguc2NhbGUob3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2LnR5cGUgPT09ICd3ZWlnaHRzJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dCA9IG5ldyBWZWN0b3IyO1xuICAgICAgICAgICAgICAgIG91dC5sZXJwKHZlY3Rvci5lbGVtZW50cywgdmVjdG9yMi5lbGVtZW50cywgdCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtZXNoIG9mIHYubWVzaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBtZXNoLmdlb21ldHJ5LnRhcmdldHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnlba10gPSBuZXcgRmxvYXQzMkFycmF5KG1lc2guZ2VvbWV0cnkuYXR0cmlidXRlc1trXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tZXRyeVtrXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrID09PSAnVEFOR0VOVCcgJiYgKGkgKyAxKSAlIDQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeVtrXVtpXSA9IG1lc2guZ2VvbWV0cnkuYXR0cmlidXRlc1trXVtpXSArIG91dC5lbGVtZW50c1swXSAqIG1lc2guZ2VvbWV0cnkudGFyZ2V0c1swXVtrXVtpIC0gb2Zmc2V0XSArIG91dC5lbGVtZW50c1sxXSAqIG1lc2guZ2VvbWV0cnkudGFyZ2V0c1sxXVtrXVtpIC0gb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkobWVzaC5nZW9tZXRyeS5WQU8pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFZCTyA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIFZCTyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlba10sIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0QXR0cmlidXRlSW5kZXgoayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleFswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGluZGV4WzBdLCBpbmRleFsxXSwgaW5kZXhbMl0sIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodi50eXBlID09PSAndHJhbnNsYXRpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFZlY3RvcjM7XG4gICAgICAgICAgICAgICAgb3V0LmxlcnAodmVjdG9yLmVsZW1lbnRzLCB2ZWN0b3IyLmVsZW1lbnRzLCB0KTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1lc2ggb2Ygdi5tZXNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzaC5tYXRyaXguc2V0VHJhbnNsYXRlKG91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRVJST1InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzaCBvZiB2Lm1lc2hlcykge1xuICAgICAgICAgICAgICAgIHdhbGsobWVzaCwgbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudXBkYXRlTWF0cml4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQm9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgTWVzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQ2FtZXJhICYmIG5vZGUgPT09IHRoaXMuY2FtZXJhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5lZWRVcGRhdGVWaWV3ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWZsb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYXcoKSB7XG4gICAgICAgIGdsLmNsZWFyQ29sb3IoMC44LCAwLjgsIDAuOCwgMS4wKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgcmVuZGVyKHRpbWUgPSAwKSB7XG4gICAgICAgIGNvbnN0IHNlYyA9IHRpbWUgLyAxMDAwO1xuICAgICAgICB0aGlzLmFuaW1hdGUoc2VjKTtcbiAgICAgICAgaWYgKHRoaXMucmVmbG93KSB7XG4gICAgICAgICAgICAvL3RoaXMuUFAuYmluZEJ1ZmZlcigpO1xuICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgdGhpcy5lbnYuY3JlYXRlRW52aXJvbm1lbnQoKTtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5vcGFxdWVDaGlsZHJlbi5mb3JFYWNoKG1lc2ggPT4gdGhpcy5fZHJhdyhtZXNoKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zY2VuZS50cmFuc3BhcmVudENoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICAgICAgZ2wuZGVwdGhNYXNrKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5TUkNfQ09MT1IsIGdsLkRTVF9DT0xPUiwgZ2wuT05FLCBnbC5aRVJPKTtcbiAgICAgICAgICAgICAgICAvLyBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS50cmFuc3BhcmVudENoaWxkcmVuLmZvckVhY2gobWVzaCA9PiB0aGlzLl9kcmF3KG1lc2gpKTtcbiAgICAgICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgICAgICBnbC5kZXB0aE1hc2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuT05FLCBnbC5aRVJPLCBnbC5PTkUsIGdsLlpFUk8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2Fsayh0aGlzLnNjZW5lLCBub2RlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEJvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWZsb3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubmVlZFVwZGF0ZVZpZXcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubmVlZFVwZGF0ZVByb2plY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIC8vdGhpcy5QUC5wb3N0UHJvY2Vzc2luZygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnBzLnRpY2sodGltZSk7XG4gICAgICAgIHRoaXMucmVmbG93ID0gZmFsc2U7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlci5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgX2RyYXcobWVzaCkge1xuICAgICAgICBnbC51c2VQcm9ncmFtKG1lc2gucHJvZ3JhbSk7XG4gICAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheShtZXNoLmdlb21ldHJ5LlZBTyk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXJCYXNlKGdsLlVOSUZPUk1fQlVGRkVSLCAwLCBtZXNoLmdlb21ldHJ5LlVCTyk7XG4gICAgICAgIGlmIChtZXNoLnJlZmxvdykge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDQobWVzaC5tYXRyaXhXb3JsZCk7XG4gICAgICAgICAgICBub3JtYWxNYXRyaXguaW52ZXJ0KCkudHJhbnNwb3NlKCk7XG4gICAgICAgICAgICBjb25zdCBtYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoMzIpO1xuICAgICAgICAgICAgbWF0cmljZXMuc2V0KG1lc2gubWF0cml4V29ybGQuZWxlbWVudHMpO1xuICAgICAgICAgICAgbWF0cmljZXMuc2V0KG5vcm1hbE1hdHJpeC5lbGVtZW50cywgMTYpO1xuICAgICAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5VTklGT1JNX0JVRkZFUiwgMCwgbWF0cmljZXMpO1xuICAgICAgICAgICAgbWVzaC5yZWZsb3cgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZWVkVXBkYXRlVmlldykge1xuICAgICAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5VTklGT1JNX0JVRkZFUiwgMzIgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsIHRoaXMuY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJ0LmVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZWVkVXBkYXRlUHJvamVjdGlvbikge1xuICAgICAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5VTklGT1JNX0JVRkZFUiwgNDggKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsIHRoaXMuY2FtZXJhLnByb2plY3Rpb24uZWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNoIGluc3RhbmNlb2YgU2tpbm5lZE1lc2gpIHtcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXJCYXNlKGdsLlVOSUZPUk1fQlVGRkVSLCAyLCBtZXNoLmdlb21ldHJ5LlNLSU4pO1xuICAgICAgICAgICAgaWYgKG1lc2guYm9uZXMuc29tZShib25lID0+IGJvbmUucmVmbG93KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGpvaW50TWF0cml4ID0gbWVzaC5nZXRKb2ludE1hdHJpeCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheShqb2ludE1hdHJpeC5sZW5ndGggKiAxNik7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaiBvZiBqb2ludE1hdHJpeCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaWNlcy5zZXQoai5lbGVtZW50cywgMCArIDE2ICogaSk7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5VTklGT1JNX0JVRkZFUiwgMCwgbWF0cmljZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNoLm1hdGVyaWFsLlVCTykge1xuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlckJhc2UoZ2wuVU5JRk9STV9CVUZGRVIsIDEsIG1lc2gubWF0ZXJpYWwuVUJPKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5lZWRVcGRhdGVWaWV3KSB7XG4gICAgICAgICAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5VTklGT1JNX0JVRkZFUiwgNCAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgbmV3IEZsb2F0MzJBcnJheShbdGhpcy5jYW1lcmEubWF0cml4V29ybGQuZWxlbWVudHNbMTJdLCB0aGlzLmNhbWVyYS5tYXRyaXhXb3JsZC5lbGVtZW50c1sxM10sIHRoaXMuY2FtZXJhLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzE0XV0pKTtcbiAgICAgICAgICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLlVOSUZPUk1fQlVGRkVSLCA4ICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCBuZXcgRmxvYXQzMkFycmF5KFt0aGlzLmNhbWVyYS5tYXRyaXhXb3JsZC5lbGVtZW50c1sxMl0sIHRoaXMuY2FtZXJhLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzEzXSwgdGhpcy5jYW1lcmEubWF0cml4V29ybGQuZWxlbWVudHNbMTRdXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNoLm1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUpIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaShtZXNoLm1hdGVyaWFsLnVuaWZvcm1zLmJhc2VDb2xvclRleHR1cmUsIG1lc2gubWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZS5jb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc2gubWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlKSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWkobWVzaC5tYXRlcmlhbC51bmlmb3Jtcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUsIG1lc2gubWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlLmNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzaC5tYXRlcmlhbC5ub3JtYWxUZXh0dXJlKSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWkobWVzaC5tYXRlcmlhbC51bmlmb3Jtcy5ub3JtYWxUZXh0dXJlLCBtZXNoLm1hdGVyaWFsLm5vcm1hbFRleHR1cmUuY291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNoLm1hdGVyaWFsLm9jY2x1c2lvblRleHR1cmUpIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaShtZXNoLm1hdGVyaWFsLnVuaWZvcm1zLm9jY2x1c2lvblRleHR1cmUsIG1lc2gubWF0ZXJpYWwub2NjbHVzaW9uVGV4dHVyZS5jb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc2gubWF0ZXJpYWwuZW1pc3NpdmVUZXh0dXJlKSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWkobWVzaC5tYXRlcmlhbC51bmlmb3Jtcy5lbWlzc2l2ZVRleHR1cmUsIG1lc2gubWF0ZXJpYWwuZW1pc3NpdmVUZXh0dXJlLmNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzaC5tYXRlcmlhbC5kb3VibGVTaWRlZCkge1xuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNoLmdlb21ldHJ5LmluZGljZXNCdWZmZXIpIHtcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhtZXNoLm1vZGUgfHwgZ2wuVFJJQU5HTEVTLCBtZXNoLmdlb21ldHJ5LmluZGljZXNCdWZmZXIubGVuZ3RoLCBtZXNoLmdlb21ldHJ5LmluZGljZXNCdWZmZXIuQllURVNfUEVSX0VMRU1FTlQgPT09IDQgPyBnbC5VTlNJR05FRF9JTlQgOiBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbC5kcmF3QXJyYXlzKG1lc2gubW9kZSB8fCBnbC5UUklBTkdMRVMsIDAsIG1lc2guZ2VvbWV0cnkuYXR0cmlidXRlcy5QT1NJVElPTi5sZW5ndGggLyAzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzaC5tYXRlcmlhbC5kb3VibGVTaWRlZCkge1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgeyBSZWRDdWJlIH07XG4iXSwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2gwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ25VQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzljQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n")}])});