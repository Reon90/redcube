!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("redcube",[],t):"object"==typeof exports?exports.redcube=t():e.redcube=t()}(window,function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=19)}([function(e,t){e.exports="#version 300 es\r\nlayout (location = 0) in vec2 pos;\r\n\r\nout vec2 uv;\r\n\r\nvoid main() {\r\n    uv = pos * 0.5 + 0.5;\r\n    gl_Position = vec4(pos, 0.0, 1.0); \r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\nout vec4 color;\r\n\r\nuniform vec2 denom;\r\nuniform sampler2D uTexture;\r\n\r\nconst float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\r\n\r\nvoid main() {             \r\n    vec2 offset = 1.0 / vec2(textureSize(uTexture, 0));\r\n    vec3 result = texture(uTexture, uv).rgb * weight[0];\r\n\r\n    for (int i = 1; i < 5; ++i) {\r\n        result += texture(uTexture, uv + denom * (offset * float(i))).rgb * weight[i];\r\n        result += texture(uTexture, uv - denom * (offset * float(i))).rgb * weight[i];\r\n    }\r\n\r\n    color = vec4(result, 1.0);\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 inPosition;\r\n\r\nuniform mat4 projection;\r\nuniform mat4 view;\r\n\r\nout vec3 outUV;\r\n\r\nvoid main() {\r\n\toutUV = inPosition;\r\n    mat4 rotView = mat4(mat3(view));\r\n    gl_Position = projection * rotView * vec4(inPosition, 1.0);\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\n// in vec4 tPos1;\r\n// in vec4 tPos2;\r\nin vec4 vPosLight1;\r\nin vec4 vPosLight2;\r\nout float color;\r\n\r\nuniform sampler2D lightTexture;\r\nuniform sampler2D cameraTexture;\r\n\r\nuniform mat4 proj;\r\nuniform mat4 light;\r\nuniform mat4 view;\r\n\r\nconst int samples = 80;\r\n\r\nvoid main() {\r\n    float stp = 1.0/float(samples);\r\n\tfloat k = 0.0;\r\n    float d = 0.0;\r\n\r\n    for (int i = 0; i < samples; i++) {\r\n\r\n        //vec4 vPos = mix(tPos1,tPos2,k);\r\n        vec4 vPosLight = mix(vPosLight1,vPosLight2,k);\r\n        k += stp;\r\n\r\n        vec3 ShadowTexC = (vPosLight.xyz/vPosLight.w) * 0.5 + 0.5;\r\n\r\n        float add = step(texture(lightTexture, ShadowTexC.xy).x, ShadowTexC.z);\r\n        d += add*stp;\r\n\t}\r\n\r\n    color = min((1.0 - d), 0.2);\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec2 pos;\r\n\r\nout vec2 uv;\r\nout vec4 vPosLight1;\r\nout vec4 vPosLight2;\r\n\r\nuniform mat4 proj;\r\nuniform mat4 light;\r\nuniform mat4 Iproj;\r\nuniform mat4 Iview;\r\n\r\nvoid main() {\r\n    vec4 p1 = Iview * Iproj * vec4(pos, -1.0/4.0, 1.0);\r\n    vec4 p2 = Iview * Iproj * vec4(pos, 1.0/4.0, 1.0);\r\n\r\n\tvPosLight1 = proj * light * p1;\r\n    vPosLight2 = proj * light * p2;\r\n\r\n\tuv = pos * 0.5 + 0.5;\r\n\tgl_Position = vec4(pos, 0.0, 1.0);\r\n}\r\n"},function(e,t){var r="#\\?RADIANCE",n="#.*",i="EXPOSURE=\\s*([0-9]*[.][0-9]*)",s="FORMAT=32-bit_rle_rgbe",o="-Y ([0-9]+) \\+X ([0-9]+)";e.exports=function(e){e instanceof ArrayBuffer&&(e=new Uint8Array(e));var t=0,a=e.length,l=10;function c(){var r="";do{var n=e[t];if(n==l){++t;break}r+=String.fromCharCode(n)}while(++t<a);return r}for(var h=0,u=0,f=1,m=!1,d=0;d<20;d++){var p,T=c();if(p=T.match(r));else if(p=T.match(s))m=!0;else if(p=T.match(i))f=Number(p[1]);else if(p=T.match(n));else if(p=T.match(o)){u=Number(p[1]),h=Number(p[2]);break}}if(!m)throw new Error("File is not run length encoded!");var E=new Uint8Array(h*u*4);!function(e,t,r,n,i,s){var o,a,l,c=new Array(4),h=null,u=new Array(2),f=e.length;function m(t){var r=0;do{t[r++]=e[n]}while(++n<f&&r<t.length);return r}function d(t,r,i){var s=0;do{t[r+s++]=e[n]}while(++n<f&&s<i);return s}function p(e,t,r,n){var i=4*n,s=d(t,r,i);if(s<i)throw new Error("Error reading raw pixels: got "+s+" bytes, expected "+i)}for(;s>0;){if(m(c)<c.length)throw new Error("Error reading bytes: expected "+c.length);if(2!=c[0]||2!=c[1]||0!=(128&c[2]))return t[r++]=c[0],t[r++]=c[1],t[r++]=c[2],t[r++]=c[3],void p(0,t,r,i*s-1);if(((255&c[2])<<8|255&c[3])!=i)throw new Error("Wrong scanline width "+((255&c[2])<<8|255&c[3])+", expected "+i);null==h&&(h=new Array(4*i)),o=0;for(var T=0;T<4;T++)for(a=(T+1)*i;o<a;){if(m(u)<u.length)throw new Error("Error reading 2-byte buffer");if((255&u[0])>128){if(0==(l=(255&u[0])-128)||l>a-o)throw new Error("Bad scanline data");for(;l-- >0;)h[o++]=u[1]}else{if(0==(l=255&u[0])||l>a-o)throw new Error("Bad scanline data");if(h[o++]=u[1],--l>0){if(d(h,o,l)<l)throw new Error("Error reading non-run data");o+=l}}}for(T=0;T<i;T++)t[r+0]=h[T],t[r+1]=h[T+i],t[r+2]=h[T+2*i],t[r+3]=h[T+3*i],r+=4;s--}}(e,E,0,t,h,u);for(var g=new Float32Array(h*u*4),v=0;v<E.length;v+=4){var R=E[v+0]/255,x=E[v+1]/255,b=E[v+2]/255,A=E[v+3],F=Math.pow(2,A-128);R*=F,x*=F,b*=F;var _=v;g[_+0]=R,g[_+1]=x,g[_+2]=b,g[_+3]=1}return{shape:[h,u],exposure:f,gamma:1,data:g}}},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nin vec3 outUV;\r\nlayout (location = 0) out vec4 color;\r\n\r\nuniform sampler2D diffuse;\r\n\r\nconst vec2 invAtan = vec2(0.1591, 0.3183);\r\nvec2 SampleSphericalMap(vec3 v) {\r\n    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\r\n    uv *= invAtan;\r\n    uv += 0.5;\r\n    return uv;\r\n}\r\n\r\nvoid main() {\t\t\r\n    vec2 uv = SampleSphericalMap(normalize(outUV));\r\n    vec3 c = texture(diffuse, uv).rgb;\r\n    \r\n    color = vec4(c, 1.0);\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nin vec3 outUV;\r\nlayout (location = 0) out vec4 color;\r\n\r\nuniform samplerCube environmentMap;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nvoid main() {\r\n    vec3 N = normalize(outUV);\r\n    vec3 irradiance = vec3(0.0);\r\n\r\n    vec3 up    = vec3(0.0, 1.0, 0.0);\r\n    vec3 right = cross(up, N);\r\n    up         = cross(N, right);\r\n\r\n    float sampleDelta = 0.025;\r\n    float nrSamples = 0.0; \r\n    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\r\n    {\r\n        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\r\n        {\r\n            // spherical to cartesian (in tangent space)\r\n            vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\r\n            // tangent space to world\r\n            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N; \r\n\r\n            irradiance += textureLod(environmentMap, sampleVec, 3.0).rgb * cos(theta) * sin(theta);\r\n            nrSamples++;\r\n        }\r\n    }\r\n    irradiance = PI * irradiance * (1.0 / float(nrSamples));\r\n    \r\n    color = vec4(irradiance, 1.0);\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nin vec3 outUV;\r\nlayout (location = 0) out vec4 color;\r\n\r\nuniform samplerCube environmentMap;\r\nuniform float roughness;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nfloat RadicalInverse_VdC(uint bits) {\r\n    bits = (bits << 16u) | (bits >> 16u);\r\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r\n}\r\n// ----------------------------------------------------------------------------\r\nvec2 Hammersley(uint i, uint N) {\r\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\r\n}  \r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness) {\r\n    float a = roughness*roughness;\r\n\t\r\n    float phi = 2.0 * PI * Xi.x;\r\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\r\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\r\n\t\r\n    // from spherical coordinates to cartesian coordinates\r\n    vec3 H;\r\n    H.x = cos(phi) * sinTheta;\r\n    H.y = sin(phi) * sinTheta;\r\n    H.z = cosTheta;\r\n\t\r\n    // from tangent-space vector to world-space sample vector\r\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r\n    vec3 tangent   = normalize(cross(up, N));\r\n    vec3 bitangent = cross(N, tangent);\r\n\t\r\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\r\n    return normalize(sampleVec);\r\n} \r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = max(a*a, 0.0001);\r\n    float NdotH = max(dot(N, H), 0.0);\r\n    float NdotH2 = NdotH*NdotH;\r\n\r\n    float nom   = a2;\r\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n\r\n    return nom / max(denom, 0.0001);\r\n}\r\n\r\nvoid main() {\t\t\r\n    vec3 N = normalize(outUV);    \r\n    vec3 R = N;\r\n    vec3 V = R;\r\n\r\n    const uint SAMPLE_COUNT = 1024u;\r\n    float totalWeight = 0.0;   \r\n    vec3 prefilteredColor = vec3(0.0);     \r\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i) {\r\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\r\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\r\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\r\n\r\n        float NdotL = max(dot(N, L), 0.0);\r\n        if (NdotL > 0.0) {\r\n            float D = DistributionGGX(N, H, roughness);\r\n            float pdf = (D * max(dot(N, H), 0.0) / (4.0 * max(dot(H, V), 0.0))) + 0.0001;\r\n             \r\n            float saTexel = 4.0 * PI / (6.0 * 512.0 * 512.0);\r\n            float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.00001);\r\n             \r\n            float mipLevel = roughness == 0.0 ? 0.0 :  0.5 * log2( saSample / saTexel )  ;\r\n                                 \r\n            prefilteredColor += textureLod( environmentMap, L, mipLevel ).rgb * NdotL;     \r\n            totalWeight += NdotL;\r\n        }\r\n    }\r\n    prefilteredColor = prefilteredColor / totalWeight;\r\n    \r\n    color = vec4(prefilteredColor, 1.0);\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\nlayout (location = 0) out vec2 color;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\r\n    float a = roughness;\r\n    float k = (a * a) / 2.0;\r\n\r\n    float nom   = NdotV;\r\n    float denom = NdotV * (1.0 - k) + k;\r\n\r\n    return nom / denom;\r\n}\r\n\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float NdotV = max(dot(N, V), 0.0);\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\r\n\r\n    return ggx1 * ggx2;\r\n} \r\n\r\nfloat RadicalInverse_VdC(uint bits) {\r\n    bits = (bits << 16u) | (bits >> 16u);\r\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r\n}\r\n\r\nvec2 Hammersley(uint i, uint N) {\r\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\r\n}  \r\n\r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness) {\r\n    float a = roughness*roughness;\r\n\t\r\n    float phi = 2.0 * PI * Xi.x;\r\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\r\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\r\n\t\r\n    // from spherical coordinates to cartesian coordinates\r\n    vec3 H;\r\n    H.x = cos(phi) * sinTheta;\r\n    H.y = sin(phi) * sinTheta;\r\n    H.z = cosTheta;\r\n\t\r\n    // from tangent-space vector to world-space sample vector\r\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r\n    vec3 tangent   = normalize(cross(up, N));\r\n    vec3 bitangent = cross(N, tangent);\r\n\t\r\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\r\n    return normalize(sampleVec);\r\n} \r\n\r\nvec2 IntegrateBRDF(float NdotV, float roughness) {\r\n    vec3 V;\r\n    V.x = sqrt(1.0 - NdotV*NdotV);\r\n    V.y = 0.0;\r\n    V.z = NdotV;\r\n\r\n    float A = 0.0;\r\n    float B = 0.0;\r\n\r\n    vec3 N = vec3(0.0, 0.0, 1.0);\r\n\r\n    const uint SAMPLE_COUNT = 1024u;\r\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i) {\r\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\r\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\r\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\r\n\r\n        float NdotL = max(L.z, 0.0);\r\n        float NdotH = max(H.z, 0.0);\r\n        float VdotH = max(dot(V, H), 0.0);\r\n\r\n        if(NdotL > 0.0) {\r\n            float G = GeometrySmith(N, V, L, roughness);\r\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\r\n            float Fc = pow(1.0 - VdotH, 5.0);\r\n\r\n            A += (1.0 - Fc) * G_Vis;\r\n            B += Fc * G_Vis;\r\n        }\r\n    }\r\n    A /= float(SAMPLE_COUNT);\r\n    B /= float(SAMPLE_COUNT);\r\n    return vec2(A, B);\r\n}\r\n\r\nvoid main() {\t\t\r\n    vec2 integratedBRDF = IntegrateBRDF(uv.x, uv.y);\r\n    color = integratedBRDF;\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 inPosition;\r\nlayout (location = 1) in vec3 inNormal;\r\nlayout (location = 2) in vec2 inUV;\r\nlayout (location = 3) in vec4 inJoint;\r\nlayout (location = 4) in vec4 inWeight;\r\nlayout (location = 5) in vec4 inTangent;\r\nlayout (location = 6) in vec4 inColor;\r\nlayout (location = 7) in vec2 inUV2;\r\n\r\nout vec4 vColor;\r\nout vec2 outUV;\r\nout vec2 outUV2;\r\nout vec3 outPosition;\r\nout vec4 outPositionView;\r\n#ifdef TANGENT\r\n    out mat3 outTBN;\r\n#else\r\n    out vec3 outNormal;\r\n#endif\r\n\r\nuniform Matrices {\r\n    mat4 model;\r\n    mat4 normalMatrix;\r\n    mat4 view;\r\n    mat4 projection;\r\n    mat4 light;\r\n    float isShadow;\r\n};\r\n\r\n#ifdef JOINTNUMBER\r\nuniform Skin {\r\n    mat4 joint[JOINTNUMBER];\r\n};\r\n#endif\r\n\r\nvoid main() {\r\n    #ifdef JOINTNUMBER\r\n        mat4 skin = inWeight.x * joint[int(inJoint.x)];\r\n        skin += inWeight.y * joint[int(inJoint.y)];\r\n        skin += inWeight.z * joint[int(inJoint.z)];\r\n        skin += inWeight.w * joint[int(inJoint.w)];\r\n    #else\r\n        mat4 skin = mat4(1.0);\r\n    #endif\r\n\r\n    vColor = inColor;\r\n    outUV = inUV;\r\n    outUV2 = inUV2;\r\n    #ifdef TANGENT\r\n        vec3 normalW = normalize(vec3(model * vec4(inNormal.xyz, 0.0)));\r\n        vec3 tangentW = normalize(vec3(model * vec4(inTangent.xyz, 0.0)));\r\n        vec3 bitangentW = cross(normalW, tangentW) * inTangent.w;\r\n        outTBN = mat3(tangentW, bitangentW, normalW);\r\n    #else\r\n        outNormal = normalize(mat3(normalMatrix) * mat3(skin) * inNormal);\r\n    #endif\r\n    outPosition = vec3(model * skin * vec4(inPosition, 1.0));\r\n    outPositionView = projection * light * model * skin * vec4(inPosition, 1.0);\r\n    if (isShadow == 1.0) {\r\n        gl_Position = projection * light * model * skin * vec4(inPosition, 1.0);\r\n    } else {\r\n        gl_Position = projection * view * model * skin * vec4(inPosition, 1.0);\r\n    }\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\n#define IBL 1\r\n\r\nin vec4 vColor;\r\nin vec2 outUV;\r\nin vec2 outUV2;\r\nin vec3 outPosition;\r\nin vec4 outPositionView;\r\n#ifdef TANGENT\r\n    in mat3 outTBN;\r\n#else\r\n    in vec3 outNormal;\r\n#endif\r\n\r\nlayout (location = 0) out vec4 color;\r\nlayout (location = 1) out vec3 normalColor;\r\n\r\nuniform Material {\r\n    vec4 baseColorFactor;\r\n    vec3 lightPos;\r\n    vec3 viewPos;\r\n    mat3 textureMatrix;\r\n    vec3 specularFactor;\r\n    float glossinessFactor;\r\n};\r\nuniform sampler2D baseColorTexture;\r\nuniform sampler2D metallicRoughnessTexture;\r\nuniform sampler2D normalTexture;\r\nuniform sampler2D emissiveTexture;\r\nuniform sampler2D occlusionTexture;\r\n\r\nuniform samplerCube prefilterMap;\r\nuniform sampler2D   brdfLUT;  \r\nuniform samplerCube irradianceMap;\r\nuniform sampler2D depthTexture;\r\n\r\nconst float RECIPROCAL_PI = 0.31830988618;\r\nconst float PI = 3.14159265359;\r\nconst float EPSILON = 1e-6;\r\nconst float ambientStrength = 0.1;\r\nconst float specularStrength = 2.5;\r\nconst float specularPower = 32.0;\r\n#ifdef USE_PBR\r\nconst vec3 lightColor = vec3(10.0, 10.0, 10.0);\r\n#else\r\nconst vec3 lightColor = vec3(1.0, 1.0, 1.0);\r\n#endif\r\nconst vec3 emissiveFactor = vec3(1.0, 1.0, 1.0);\r\nconst float gamma = 2.2;\r\n\r\nvec2 getUV(int index) {\r\n    if (index == 1) {\r\n        return outUV;\r\n    } else {\r\n        return outUV2;\r\n    }\r\n}\r\n\r\nfloat ShadowCalculation(vec4 fragPosLightSpace, float bias) {\r\n    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\r\n    projCoords = projCoords * 0.5 + 0.5;\r\n    float currentDepth = projCoords.z;\r\n\r\n    float shadow = 0.0;\r\n    vec2 texelSize = 1.0 / vec2(textureSize(depthTexture, 0));\r\n    for (int x = -2; x <= 2; ++x) {\r\n        for (int y = -2; y <= 2; ++y) {\r\n            float pcfDepth = texture(depthTexture, projCoords.xy + vec2(x, y) * texelSize).r;\r\n            shadow += currentDepth - bias > pcfDepth ? 0.5 : 0.0;\r\n        }\r\n    }\r\n    shadow /= 25.0;\r\n\r\n    return shadow;\r\n}\r\n\r\nvec3 srgbToLinear(vec4 srgbIn) {\r\n    return pow(srgbIn.rgb, vec3(2.2));\r\n}\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = max(a*a, 0.0001);\r\n    float NdotH = max(dot(N, H), 0.0);\r\n    float NdotH2 = NdotH*NdotH;\r\n\r\n    float nom   = a2;\r\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n\r\n    return nom / max(denom, 0.0001);\r\n}\r\n\r\nfloat GeometrySchlickGGX(float cosTheta, float roughness) {\r\n    float r = (roughness + 1.0);\r\n    float k = (r * r) / 8.0;\r\n\r\n    float nom   = cosTheta;\r\n    float denom = cosTheta * (1.0 - k) + k;\r\n\r\n    return nom / denom;\r\n}\r\n\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float NdotV = max(dot(N, V), 0.0);\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\r\n\r\n    return ggx1 * ggx2;\r\n}\r\n\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\r\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\r\n} \r\n\r\nvec3 IBLAmbient(vec3 specularMap, vec3 baseColor, float metallic, vec3 n, vec3 H, float roughness, vec3 viewDir, vec3 lightDir, float ao) {\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, baseColor, metallic);\r\n\r\n    #ifdef SPECULARGLOSSINESSMAP\r\n        F0 = specularMap;\r\n    #endif\r\n\r\n    vec3 F = fresnelSchlickRoughness(max(dot(n, viewDir), 0.0), F0, roughness);\r\n\r\n    vec3 kD = vec3(1.0) - F;\r\n    kD *= 1.0 - metallic;\r\n\r\n    vec3 R = reflect(-viewDir, n);   \r\n    const float MAX_REFLECTION_LOD = 4.0;\r\n    vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;\r\n    vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(n, viewDir), 0.0), roughness)).rg;\r\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\r\n\r\n    vec3 irradiance = texture(irradianceMap, n).rgb;\r\n    vec3 diffuse = baseColor * irradiance;\r\n\r\n    return (kD * diffuse + specular) * ao;\r\n}\r\n\r\nvec3 CookTorranceSpecular(vec3 specularMap, vec3 baseColor, float metallic, vec3 n, vec3 H, float roughness, vec3 viewDir, vec3 lightDir) {\r\n    vec3 F0 = vec3(0.04); \r\n    F0 = mix(F0, baseColor, metallic);\r\n\r\n    #ifdef SPECULARGLOSSINESSMAP\r\n        F0 = specularMap;\r\n    #endif\r\n\r\n    float D = DistributionGGX(n, H, roughness);\r\n    float G = GeometrySmith(n, viewDir, lightDir, roughness);      \r\n    vec3 F = fresnelSchlick(max(dot(H, viewDir), 0.0), F0); \r\n\r\n    vec3 nominator = D * G * F;\r\n    float denominator = 4.0 * max(dot(n, viewDir), 0.0) * max(dot(n, lightDir), 0.0);\r\n    return nominator / max(denominator, 0.001);\r\n}\r\n\r\nvec3 LambertDiffuse(vec3 baseColor, float metallic, vec3 n, vec3 H, float roughness, vec3 viewDir, vec3 lightDir) {\r\n    float NdotL = max(dot(n, lightDir), 0.0);\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, baseColor, metallic);\r\n\r\n    vec3 F = fresnelSchlick(max(dot(H, viewDir), 0.0), F0);    \r\n\r\n    vec3 kD = vec3(1.0) - F;\r\n    kD *= 1.0 - metallic;\r\n    return baseColor * kD / PI;\r\n}\r\n\r\nfloat saturate(float a) {\r\n\tif (a > 1.0f) return 1.0f;\r\n\tif (a < 0.0f) return 0.0f;\r\n\treturn a;\r\n}\r\nvec3 ImprovedOrenNayarDiffuse(vec3 baseColor, float metallic, vec3 N, vec3 H, float a, vec3 V, vec3 L) {\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, baseColor, metallic);\r\n    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);\r\n    vec3 kD = vec3(1.0) - F;\r\n    kD *= 1.0 - metallic;\r\n    vec3 diffuseColor = baseColor * kD;\r\n\t// calculate intermediary values\r\n\tfloat dotNL = saturate(dot(N, L));\r\n\tfloat dotNV = saturate(dot(N, V));\r\n\tfloat dotLV = saturate(dot(L, V));\r\n\tfloat dotLH = saturate(dot(L, H));\r\n\r\n\tfloat s = dotLV - dotNL * dotNV;\r\n\tfloat t = mix(1.0, max(dotNL, dotNV), step(0.0, s));\r\n\tfloat st = s * (1.0 / (t + EPSILON));\r\n\r\n\tfloat sigma2 = a;\r\n\tvec3 A = diffuseColor * (0.17 * sigma2 / (sigma2 + 0.13)) + vec3(1.0 - 0.5 * sigma2 / (sigma2 + 0.33));\r\n\tfloat B = 0.45 * sigma2 / (sigma2 + 0.09);\r\n\treturn (diffuseColor * max(0.0, dotNL)) * (A + vec3(B * s / t) / PI);\r\n}\r\n\r\nvoid main() {\r\n    #ifdef BASECOLORTEXTURE\r\n        vec2 uv = outUV;\r\n        #ifdef TEXTURE_TRANSFORM\r\n            uv = ( textureMatrix * vec3(uv.xy, 1.0) ).xy;\r\n        #endif\r\n        vec3 baseColor = srgbToLinear(texture(baseColorTexture, uv)) * baseColorFactor.rgb;\r\n        float alpha = min(texture(baseColorTexture, uv).a, baseColorFactor.a);\r\n    #else\r\n        vec3 baseColor = baseColorFactor.rgb;\r\n        float alpha = baseColorFactor.a;\r\n    #endif\r\n\r\n    #ifdef ALPHATEST\r\n    if ( alpha < ALPHATEST ) {\r\n        discard;\r\n    }\r\n    #endif\r\n\r\n    if ( length(vColor.rgb) != 0.0 ) {\r\n        baseColor.rgb *= vColor.rgb;\r\n    }\r\n\r\n    #ifdef OCCLUSIONMAP\r\n        float ao = texture(occlusionTexture, outUV).r;\r\n    #else\r\n        float ao = 0.2;\r\n    #endif\r\n\r\n    float roughness = 0.5;\r\n    float metallic = 0.5;\r\n    vec3 specularMap = vec3(0);\r\n    #ifdef SPECULARGLOSSINESSMAP\r\n        #ifdef METALROUGHNESSMAP\r\n            roughness = 1.0 - texture(metallicRoughnessTexture, outUV).a;\r\n            specularMap = srgbToLinear(texture(metallicRoughnessTexture, outUV));\r\n        #else\r\n            roughness = glossinessFactor;\r\n            specularMap = specularFactor;\r\n        #endif\r\n    #else\r\n        #ifdef METALROUGHNESSMAP\r\n            roughness = texture(metallicRoughnessTexture, outUV).g;\r\n            metallic = texture(metallicRoughnessTexture, outUV).b;\r\n        #endif\r\n    #endif\r\n\r\n    #ifdef TANGENT\r\n        #ifdef NORMALMAP\r\n            vec3 n = texture(normalTexture, outUV).rgb;\r\n            n = normalize(outTBN * (2.0 * n - 1.0));\r\n        #else\r\n            vec3 n = outTBN[2].xyz;\r\n        #endif\r\n    #else\r\n        vec3 n = outNormal;\r\n    #endif\r\n\r\n    vec3 viewDir = normalize(viewPos - outPosition);\r\n    vec3 lightDir = normalize(lightPos - outPosition);\r\n    float NdotL = max(dot(n, lightDir), 0.0);\r\n    vec3 H = normalize(viewDir + lightDir);\r\n    float distance = length(lightPos - outPosition);\r\n    float attenuation = 1.0 / (distance * distance);\r\n    vec3 radiance = lightColor; //* attenuation;\r\n\r\n    float shadow = 1.0;\r\n    #ifdef SHADOWMAP\r\n        float shadowBias = max(0.05 * (1.0 - dot(n, lightDir)), 0.005);\r\n        shadow = 1.0 - ShadowCalculation(outPositionView, shadowBias);\r\n    #endif\r\n\r\n    #ifdef USE_PBR\r\n        vec3 specular = CookTorranceSpecular(specularMap, baseColor, metallic, n, H, roughness, viewDir, lightDir);\r\n        vec3 diffuse = ImprovedOrenNayarDiffuse(baseColor, metallic, n, H, roughness, viewDir, lightDir);\r\n        #ifdef SPECULARGLOSSINESSMAP\r\n            diffuse = baseColor * (1.0 - max(max(specularMap.r, specularMap.g), specularMap.b));\r\n        #endif\r\n\r\n        vec3 ambient = vec3(0.0);\r\n        #ifdef IBL\r\n            ambient = IBLAmbient(specularMap, baseColor, metallic, n, H, roughness, viewDir, lightDir, ao);\r\n        #else\r\n            ambient = vec3(0.03) * baseColor * ao;\r\n        #endif\r\n\r\n        vec3 emissive = vec3(0.0);\r\n        #ifdef EMISSIVEMAP\r\n            emissive = srgbToLinear(texture(emissiveTexture, getUV(EMISSIVEMAP))) * emissiveFactor;\r\n        #endif\r\n\r\n        color = vec4(shadow * (emissive + ambient + (diffuse + specular) * radiance * NdotL), alpha);\r\n    #else\r\n        vec3 ambient = ambientStrength * lightColor;\r\n\r\n        float diff = max(dot(n, lightDir), 0.0);\r\n        vec3 diffuse = diff * lightColor;\r\n\r\n        vec3 reflectDir = reflect(-lightDir, n);\r\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), specularPower);\r\n        vec3 specular = specularStrength * spec * lightColor;\r\n\r\n        color = vec4(baseColor.rgb * (ambient + diffuse + specular) * shadow, alpha);\r\n    #endif\r\n\r\n    #ifdef TONE\r\n        color.rgb = color.rgb / (color.rgb + vec3(1.0));\r\n        color.rgb = pow(color.rgb, vec3(1.0 / gamma));\r\n    #endif\r\n\r\n    normalColor = n;\r\n}\r\n"},function(e,t){e.exports="#version 300 es\nprecision highp float;\n\nin vec2 uv;\nout float color;\n\nconst int kernelSize = 32;\nconst float radius = 1.0;\nconst float bias = 0.0;\nconst float power = 5.0;\n\nuniform sampler2D normBuff;\nuniform sampler2D depthBuff;\nuniform sampler2D noice;\nuniform vec2 noiseScale;\nuniform vec3 kernels[kernelSize];\nuniform mat4 proj;\nuniform mat4 projI;\nuniform mat4 view;\nuniform float zFar;\nuniform float zNear;\n\nvec3 getPositionFromDepth(float depth) {\n\tvec4 clipSpaceLocation = vec4(0.0);\n\tclipSpaceLocation.xy = uv * 2.0 - 1.0;\n\tclipSpaceLocation.z = depth * 2.0 - 1.0;;\n\tclipSpaceLocation.w = 1.0;\n\tvec4 homogenousLocation = projI * clipSpaceLocation;\n\thomogenousLocation.xyz = homogenousLocation.xyz / homogenousLocation.w;\n\treturn homogenousLocation.xyz;\n}\n\nvoid main() {\n\tfloat depth = texture(depthBuff, uv).x;\n\tif ((2.0 * zNear) / (zFar + zNear - depth * (zFar - zNear)) > 0.99) {\n\t\tdiscard;\n\t}\n\n\tvec3 pos = getPositionFromDepth(depth);\n\tvec3 normal = normalize(vec3(view * texture(normBuff, uv)));\n\tvec3 rvec = normalize(texture(noice, uv * noiseScale).xyz);\n\n\tvec3 tangent = normalize(rvec - normal * dot(rvec, normal));\n\tvec3 bitangent = cross(tangent, normal);\n\tmat3 rotate = mat3(tangent, bitangent, normal);\n\n\tfloat occlusion  = 0.0;\n\tfor (int i = 0; i < kernelSize; i++) {\n\t\tvec3 samplePos = rotate * kernels[i];\n\t\tsamplePos = pos + samplePos * radius;\n\n\t\tvec4 shift = proj * vec4(samplePos, 1.0);\n\t\tshift.xy /= shift.w;\n\t\tshift.xy = shift.xy * 0.5 + 0.5;\n\n\t\tfloat sampleDepth = getPositionFromDepth(texture(depthBuff, shift.xy).r).z;\n\n\t\tfloat distanceCheck = smoothstep(0.0, 1.0, radius / abs(pos.z - sampleDepth));\n\t\tocclusion  += (sampleDepth >= samplePos.z + bias ? 1.0 : 0.0) * distanceCheck;\n\t}\n\n\tocclusion = 1.0 - (occlusion / float(kernelSize));\n\tcolor = pow(occlusion, power);\n}\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\nout vec4 color;\r\n\r\nuniform sampler2D diff;\r\n\r\nconst vec3 hdrColor = vec3(0.2126, 0.7152, 0.0722);\r\nconst float brightnessThreshold = 0.8;\r\n\r\nvoid main() {\r\n    vec3 c = texture(diff, uv).rgb;\r\n    float brightness = dot(c, hdrColor);\r\n    if (brightness > brightnessThreshold) {\r\n        color = vec4(c, 1.0);\r\n    } else {\r\n        color = vec4(0.0, 0.0, 0.0, 1.0);\r\n    }\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\nout vec4 color;\r\n\r\nuniform sampler2D original;\r\nuniform sampler2D position;\r\nuniform sampler2D normal;\r\nuniform sampler2D ssao;\r\nuniform sampler2D bloom;\r\nuniform sampler2D depth;\r\nuniform sampler2D preDepth;\r\nuniform sampler2D light;\r\n\r\nconst float gamma = 2.2;\r\n\r\nvoid main() {\r\n    vec3 c = texture(original, uv).rgb;\r\n    #ifdef BLOOM\r\n        c += texture(bloom, uv).rgb;\r\n    #endif\r\n    #ifdef SSAO\r\n        c *= texture(ssao, uv).r;\r\n    #endif\r\n    #ifdef LIGHT\r\n        c += texture(light, uv).r;\r\n    #endif\r\n\r\n    c.rgb = c.rgb / (c.rgb + vec3(1.0));\r\n    c.rgb = pow(c.rgb, vec3(1.0 / gamma));\r\n\r\n    color = vec4(c, 1.0);\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\nprecision highp sampler3D;\r\n\r\nlayout (location = 0) in vec3 inPosition;\r\nout float depth;\r\n\r\nuniform sampler2D light;\r\nuniform mat4 MVPMatrix;\r\n\r\nvoid main() {\r\n    gl_PointSize = 1.0;\r\n    vec4 point = MVPMatrix * vec4(inPosition, 1.0);\r\n    vec2 uv = (point.xy / point.w) * 0.5 + 0.5;\r\n    depth = texture(light, uv).r;\r\n    gl_Position = point;\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) out vec4 color;\r\nin float depth;\r\n\r\nvoid main() {\r\n    //color = vec4(0.0, 0.0, 0.8, 1.0) * texture( image, gl_PointCoord );\r\n    if (depth < 0.05) {\r\n        discard;\r\n    }\r\n    color = vec4(1.0, 1.0, 1.0, 1.0);\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) out vec4 color;\r\n\r\nvoid main() {\r\n    color = vec4(1.0, 1.0, 1.0, 1.0);\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\nprecision highp sampler3D;\r\n\r\nlayout(location = 0) in vec3 a_position;\r\nlayout(location = 1) in vec3 a_velocity;\r\nlayout(location = 2) in float a_spawntime;\r\nlayout(location = 3) in float a_lifetime;\r\n\r\nout vec3 v_position;\r\nout vec3 v_velocity;\r\nout float v_spawntime;\r\nout float v_lifetime;\r\n\r\nuniform float u_time;\r\nuniform sampler3D noize;\r\nuniform float count;\r\n\r\nfloat rand(vec3 co) {\r\n    return texture(noize, co).r;\r\n}\r\n\r\nconst float lifetime = 15000.0;\r\nconst vec3 center = vec3(0.5, 0.5, 0.5);\r\nconst vec3 acceleration = vec3(0.0, 0.0, 0.0);\r\n\r\nvoid main() {\r\n    if (a_spawntime == 0.0 || (u_time - a_spawntime) > a_lifetime) {\r\n        float x = float(gl_InstanceID) / count;\r\n        float t = u_time/1000.0 * x;\r\n        v_position = vec3(\r\n            rand(vec3(x, x, t)),\r\n            rand(vec3(1.0 - x, 1.0 - x, t)),\r\n            rand(vec3(x, 0.5, t))\r\n        ) - center;\r\n        v_velocity = vec3(\r\n            rand(vec3(x, x, t)),\r\n            rand(vec3(1.0 - x, 1.0 - x, t)),\r\n            rand(vec3(x, 0.5, t))\r\n        ) - center;\r\n        v_spawntime = u_time;\r\n        v_lifetime = rand(vec3(x, 0.5, t)) * lifetime;\r\n    } else {\r\n        v_velocity = a_velocity + 0.01 * acceleration;\r\n        v_position = a_position + 0.01 * v_velocity;\r\n        v_spawntime = a_spawntime;\r\n        v_lifetime = a_lifetime;\r\n    }\r\n}\r\n"},function(e,t,r){"use strict";r.r(t);class n{constructor(){this._services=new Map,this._singletons=new Map,this.update=this.update.bind(this)}register(e,t,r=[],...n){this._services.set(e,{definition:t,dependencies:r,args:n}),this._isClass(t)?t.__update=this.update:this._updateDep(e,t)}get(e){const t=this._services.get(e);if(!t)return null;if(this._isClass(t.definition)){const r=this._singletons.get(e);if(r)return r;{const r=this._createInstance(t);return this._singletons.set(e,r),r}}return t.definition}update(e,...t){this._services.get(e).args=t,this._singletons.delete(e);const r=this.get(e);this._updateDep(e,r)}_updateDep(e,t){for(const[r,n]of this._singletons)this._services.get(r).dependencies.some(t=>t===e)&&n[`set${e.charAt(0).toUpperCase()+e.slice(1)}`].call(n,t);this._singletons.set(e,t)}_getResolvedDependencies(e){let t=[];return e.dependencies&&(t=e.dependencies.map(e=>[e,this.get(e)])),t}_createInstance(e){const t=new e.definition(...e.args);return this._getResolvedDependencies(e).forEach(([e,r])=>{t[`set${e.charAt(0).toUpperCase()+e.slice(1)}`].call(t,r)}),t}_isClass(e){return"function"==typeof e&&/^class\s/.test(Function.prototype.toString.call(e))}}class i{constructor(e){let t,r,n;if(e&&"object"==typeof e&&e.hasOwnProperty("elements")){for(r=e.elements,n=new Float32Array(9),t=0;t<9;++t)n[t]=r[t];this.elements=n}else this.elements=new Float32Array([1,0,0,0,1,0,0,0,1])}set(e){let t,r,n;if((r=e)!==(n=this.elements)){for(t=0;t<9;++t)n[t]=r[t];return this}}normalFromMat4(e){const t=this.elements,r=(e=e.elements)[0],n=e[1],i=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],h=e[8],u=e[9],f=e[10],m=e[11],d=e[12],p=e[13],T=e[14],E=e[15],g=r*a-n*o,v=r*l-i*o,R=r*c-s*o,x=n*l-i*a,b=n*c-s*a,A=i*c-s*l,F=h*p-u*d,_=h*T-f*d,U=h*E-m*d,M=u*T-f*p,P=u*E-m*p,w=f*E-m*T;let B=g*w-v*P+R*M+x*U-b*_+A*F;return B?(B=1/B,t[0]=(a*w-l*P+c*M)*B,t[1]=(l*U-o*w-c*_)*B,t[2]=(o*P-a*U+c*F)*B,t[3]=(i*P-n*w-s*M)*B,t[4]=(r*w-i*U+s*_)*B,t[5]=(n*U-r*P-s*F)*B,t[6]=(p*A-T*b+E*x)*B,t[7]=(T*R-d*A-E*v)*B,t[8]=(d*b-p*R+E*g)*B,this):null}multiply(e){const t=this.elements,r=e.elements,n=this.elements,i=t[0],s=t[3],o=t[6],a=t[1],l=t[4],c=t[7],h=t[2],u=t[5],f=t[8],m=r[0],d=r[3],p=r[6],T=r[1],E=r[4],g=r[7],v=r[2],R=r[5],x=r[8];return n[0]=i*m+s*T+o*v,n[3]=i*d+s*E+o*R,n[6]=i*p+s*g+o*x,n[1]=a*m+l*T+c*v,n[4]=a*d+l*E+c*R,n[7]=a*p+l*g+c*x,n[2]=h*m+u*T+f*v,n[5]=h*d+u*E+f*R,n[8]=h*p+u*g+f*x,this}}class s{constructor(e){let t,r,n;if(e&&"object"==typeof e&&e.hasOwnProperty("elements")){for(r=e.elements,n=new Float32Array(16),t=0;t<16;++t)n[t]=r[t];this.elements=n}else this.elements=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}getScaleZ(){const e=this.elements,t=e[8],r=e[9],n=e[10];return Math.sqrt(t*t+r*r+n*n)}set(e){let t,r,n;if((r=e)!==(n=this.elements)){for(t=0;t<16;++t)n[t]=r[t];return this}}multiply(e){return this.concat(e),this}concat({elements:e}){let t,r,n,i,s,o,a,l;if(r=this.elements,n=this.elements,r===(i=e))for(i=new Float32Array(16),t=0;t<16;++t)i[t]=r[t];for(t=0;t<4;t++)s=n[t],o=n[t+4],a=n[t+8],l=n[t+12],r[t]=s*i[0]+o*i[1]+a*i[2]+l*i[3],r[t+4]=s*i[4]+o*i[5]+a*i[6]+l*i[7],r[t+8]=s*i[8]+o*i[9]+a*i[10]+l*i[11],r[t+12]=s*i[12]+o*i[13]+a*i[14]+l*i[15];return this}setInverseOf({elements:e}){let t,r,n,i,s;if(r=e,n=this.elements,(i=new Float32Array(16))[0]=r[5]*r[10]*r[15]-r[5]*r[11]*r[14]-r[9]*r[6]*r[15]+r[9]*r[7]*r[14]+r[13]*r[6]*r[11]-r[13]*r[7]*r[10],i[4]=-r[4]*r[10]*r[15]+r[4]*r[11]*r[14]+r[8]*r[6]*r[15]-r[8]*r[7]*r[14]-r[12]*r[6]*r[11]+r[12]*r[7]*r[10],i[8]=r[4]*r[9]*r[15]-r[4]*r[11]*r[13]-r[8]*r[5]*r[15]+r[8]*r[7]*r[13]+r[12]*r[5]*r[11]-r[12]*r[7]*r[9],i[12]=-r[4]*r[9]*r[14]+r[4]*r[10]*r[13]+r[8]*r[5]*r[14]-r[8]*r[6]*r[13]-r[12]*r[5]*r[10]+r[12]*r[6]*r[9],i[1]=-r[1]*r[10]*r[15]+r[1]*r[11]*r[14]+r[9]*r[2]*r[15]-r[9]*r[3]*r[14]-r[13]*r[2]*r[11]+r[13]*r[3]*r[10],i[5]=r[0]*r[10]*r[15]-r[0]*r[11]*r[14]-r[8]*r[2]*r[15]+r[8]*r[3]*r[14]+r[12]*r[2]*r[11]-r[12]*r[3]*r[10],i[9]=-r[0]*r[9]*r[15]+r[0]*r[11]*r[13]+r[8]*r[1]*r[15]-r[8]*r[3]*r[13]-r[12]*r[1]*r[11]+r[12]*r[3]*r[9],i[13]=r[0]*r[9]*r[14]-r[0]*r[10]*r[13]-r[8]*r[1]*r[14]+r[8]*r[2]*r[13]+r[12]*r[1]*r[10]-r[12]*r[2]*r[9],i[2]=r[1]*r[6]*r[15]-r[1]*r[7]*r[14]-r[5]*r[2]*r[15]+r[5]*r[3]*r[14]+r[13]*r[2]*r[7]-r[13]*r[3]*r[6],i[6]=-r[0]*r[6]*r[15]+r[0]*r[7]*r[14]+r[4]*r[2]*r[15]-r[4]*r[3]*r[14]-r[12]*r[2]*r[7]+r[12]*r[3]*r[6],i[10]=r[0]*r[5]*r[15]-r[0]*r[7]*r[13]-r[4]*r[1]*r[15]+r[4]*r[3]*r[13]+r[12]*r[1]*r[7]-r[12]*r[3]*r[5],i[14]=-r[0]*r[5]*r[14]+r[0]*r[6]*r[13]+r[4]*r[1]*r[14]-r[4]*r[2]*r[13]-r[12]*r[1]*r[6]+r[12]*r[2]*r[5],i[3]=-r[1]*r[6]*r[11]+r[1]*r[7]*r[10]+r[5]*r[2]*r[11]-r[5]*r[3]*r[10]-r[9]*r[2]*r[7]+r[9]*r[3]*r[6],i[7]=r[0]*r[6]*r[11]-r[0]*r[7]*r[10]-r[4]*r[2]*r[11]+r[4]*r[3]*r[10]+r[8]*r[2]*r[7]-r[8]*r[3]*r[6],i[11]=-r[0]*r[5]*r[11]+r[0]*r[7]*r[9]+r[4]*r[1]*r[11]-r[4]*r[3]*r[9]-r[8]*r[1]*r[7]+r[8]*r[3]*r[5],i[15]=r[0]*r[5]*r[10]-r[0]*r[6]*r[9]-r[4]*r[1]*r[10]+r[4]*r[2]*r[9]+r[8]*r[1]*r[6]-r[8]*r[2]*r[5],0===(s=r[0]*i[0]+r[1]*i[4]+r[2]*i[8]+r[3]*i[12]))return this;for(s=1/s,t=0;t<16;t++)n[t]=i[t]*s;return this}invert(){return this.setInverseOf(this)}makeOrthographic(e,t,r,n,i,s){var o=this.elements,a=1/(t-e),l=1/(r-n),c=1/(s-i),h=(t+e)*a,u=(r+n)*l,f=(s+i)*c;return o[0]=2*a,o[4]=0,o[8]=0,o[12]=-h,o[1]=0,o[5]=2*l,o[9]=0,o[13]=-u,o[2]=0,o[6]=0,o[10]=-2*c,o[14]=-f,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}setOrtho(e,t,r,n){let i,s,o,a;return s=1/e,o=1/t,a=2/(r-n),(i=this.elements)[0]=s,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=o,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=a,i[11]=(n+r)/(r-n),i[12]=0,i[13]=0,i[14]=0,i[15]=1,this}setPerspective(e,t,r,n){let i,s,o,a;if(r===n||0===t)throw"null frustum";if(r<=0)throw"near <= 0";if(n<=0)throw"far <= 0";if(e/=2,0===(o=Math.sin(e)))throw"null frustum";return s=1/(n-r),a=Math.cos(e)/o,(i=this.elements)[0]=a/t,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=a,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=-(n+r)*s,i[11]=-1,i[12]=0,i[13]=0,i[14]=-2*r*n*s,i[15]=0,this}perspective(e,t,r,n){return this.concat((new s).setPerspective(e,t,r,n))}multiplyVector4({elements:e}){const t=this.elements,r=e,n=new l,i=n.elements;return i[0]=r[0]*t[0]+r[1]*t[4]+r[2]*t[8]+r[3]*t[12],i[1]=r[0]*t[1]+r[1]*t[5]+r[2]*t[9]+r[3]*t[13],i[2]=r[0]*t[2]+r[1]*t[6]+r[2]*t[10]+r[3]*t[14],i[3]=r[0]*t[3]+r[1]*t[7]+r[2]*t[11]+r[3]*t[15],n}scale(e){const t=e.elements[0],r=e.elements[1],n=e.elements[2],i=this.elements;return i[0]*=t,i[4]*=r,i[8]*=n,i[1]*=t,i[5]*=r,i[9]*=n,i[2]*=t,i[6]*=r,i[10]*=n,i[3]*=t,i[7]*=r,i[11]*=n,this}setTranslate(e){const t=this.elements,r=e.elements[0],n=e.elements[1],i=e.elements[2];return t[12]=r,t[13]=n,t[14]=i,t[15]=1,this}translate(e,t,r){const n=this.elements;return n[12]+=n[0]*e+n[4]*t+n[8]*r,n[13]+=n[1]*e+n[5]*t+n[9]*r,n[14]+=n[2]*e+n[6]*t+n[10]*r,n[15]+=n[3]*e+n[7]*t+n[11]*r,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],r=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],n=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,r,n))}makeRotationAxis(e,t){const r=this.elements,n=Math.cos(t),i=Math.sin(t),s=1-n,o=e.elements[0],a=e.elements[1],l=e.elements[2],c=s*o,h=s*a;return r[0]=c*o+n,r[1]=c*a-i*l,r[2]=c*l+i*a,r[3]=0,r[4]=c*a+i*l,r[5]=h*a+n,r[6]=h*l-i*o,r[7]=0,r[8]=c*l-i*a,r[9]=h*l+i*o,r[10]=s*l*l+n,r[11]=0,r[15]=1,this}makeRotationFromQuaternion(e){const t=this.elements,r=e[0],n=e[1],i=e[2],s=e[3],o=r+r,a=n+n,l=i+i,c=r*o,h=r*a,u=r*l,f=n*a,m=n*l,d=i*l,p=s*o,T=s*a,E=s*l;return t[0]=1-(f+d),t[4]=h-E,t[8]=u+T,t[1]=h+E,t[5]=1-(c+d),t[9]=m-p,t[2]=u-T,t[6]=m+p,t[10]=1-(c+f),this}transpose(){let e,t;return t=(e=this.elements)[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}}class o{constructor(e){this.elements=e.slice()}lerp(e,t,r){const n=this.elements;for(let i=0;i<n.length;i++)n[i]=e[i]+r*(t[i]-e[i]);return this}}class a{constructor(e){const t=new Float32Array(3);e&&"object"==typeof e&&(t[0]=e[0],t[1]=e[1],t[2]=e[2]),this.elements=t}applyQuaternion({elements:e}){const t=this.elements[0],r=this.elements[1],n=this.elements[2],i=e[0],s=e[1],o=e[2],a=e[3],l=a*t+s*n-o*r,c=a*r+o*t-i*n,h=a*n+i*r-s*t,u=-i*t-s*r-o*n;return this.elements[0]=l*a+u*-i+c*-o-h*-s,this.elements[1]=c*a+u*-s+h*-i-l*-o,this.elements[2]=h*a+u*-o+l*-s-c*-i,this}normalize(){const e=this.elements,t=e[0],r=e[1],n=e[2];let i=Math.sqrt(t*t+r*r+n*n);return i?1==i?this:(i=1/i,e[0]=t*i,e[1]=r*i,e[2]=n*i,this):(e[0]=0,e[1]=0,e[2]=0,this)}add(e){const t=this.elements;return e=e.elements,t[0]=t[0]+e[0],t[1]=t[1]+e[1],t[2]=t[2]+e[2],this}addS(e){const t=this.elements;return t[0]=t[0]+e,t[1]=t[1]+e,t[2]=t[2]+e,this}scale(e){const t=this.elements;return t[0]=t[0]*e,t[1]=t[1]*e,t[2]=t[2]*e,this}distanceToSquared(e,t,r){const n=this.elements[0]-e,i=this.elements[1]-t,s=this.elements[2]-r;return n*n+i*i+s*s}subtract(e){const t=this.elements;return e=e.elements,t[0]=t[0]-e[0],t[1]=t[1]-e[1],t[2]=t[2]-e[2],this}divideScalar(e){return this.scale(1/e)}applyMatrix4({elements:e}){const t=this.elements[0],r=this.elements[1],n=this.elements[2],i=e;this.elements[0]=i[0]*t+i[4]*r+i[8]*n+i[12],this.elements[1]=i[1]*t+i[5]*r+i[9]*n+i[13],this.elements[2]=i[2]*t+i[6]*r+i[10]*n+i[14];const s=i[3]*t+i[7]*r+i[11]*n+i[15];return this.divideScalar(s)}lerp(e,t,r){const n=this.elements,i=e[0],s=e[1],o=e[2];return n[0]=i+r*(t[0]-i),n[1]=s+r*(t[1]-s),n[2]=o+r*(t[2]-o),this}lengthSq(){return this.elements[0]*this.elements[0]+this.elements[1]*this.elements[1]+this.elements[2]*this.elements[2]}multiply({elements:e}){return this.elements[0]*=e[0],this.elements[1]*=e[1],this.elements[2]*=e[2],this}static angle(e,t){const r=new a(e.elements),n=new a(t.elements);r.normalize(),n.normalize();const i=a.dot(r,n);return i>1?0:Math.acos(i)}static cross(e,t){e=e.elements,t=t.elements;const r=e[0],n=e[1],i=e[2],s=t[0],o=t[1],l=t[2],c=new a;return c.elements[0]=n*l-i*o,c.elements[1]=i*s-r*l,c.elements[2]=r*o-n*s,c}static dot(e,t){return e=e.elements,t=t.elements,e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}}class l{constructor(e){const t=new Float32Array(4);e&&"object"==typeof e&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3]),this.elements=t}set(e){const t=this.elements;return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],this}add(e){const t=this.elements;return e=e.elements,t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=t[3]+e[3],this}normalize(){const e=this.elements[0],t=this.elements[1],r=this.elements[2],n=this.elements[3];let i=e*e+t*t+r*r+n*n;return i>0&&(i=1/Math.sqrt(i),this.elements[0]=e*i,this.elements[1]=t*i,this.elements[2]=r*i,this.elements[3]=n*i),this}setFromRotationMatrix({elements:e}){const t=e,r=t[0],n=t[4],i=t[8],s=t[1],o=t[5],a=t[9],l=t[2],c=t[6],h=t[10],u=r+o+h;let f;return u>0?(f=.5/Math.sqrt(u+1),this.elements[3]=.25/f,this.elements[0]=(c-a)*f,this.elements[1]=(i-l)*f,this.elements[2]=(s-n)*f):r>o&&r>h?(f=2*Math.sqrt(1+r-o-h),this.elements[3]=(c-a)/f,this.elements[0]=.25*f,this.elements[1]=(n+s)/f,this.elements[2]=(i+l)/f):o>h?(f=2*Math.sqrt(1+o-r-h),this.elements[3]=(i-l)/f,this.elements[0]=(n+s)/f,this.elements[1]=.25*f,this.elements[2]=(a+c)/f):(f=2*Math.sqrt(1+h-r-o),this.elements[3]=(s-n)/f,this.elements[0]=(i+l)/f,this.elements[1]=(a+c)/f,this.elements[2]=.25*f),this}lerp(e,t,r){const n=this.elements;if(0===r)return this;if(1===r)return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],this;const i=e[0],s=e[1],o=e[2],a=e[3];let l=a*t[3]+i*t[0]+s*t[1]+o*t[2];if(l<0?(n[3]=-t[3],n[0]=-t[0],n[1]=-t[1],n[2]=-t[2],l=-l):(n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3]),l>=1)return n[3]=a,n[0]=i,n[1]=s,n[2]=o,this;const c=1-l*l;if(c<=Number.EPSILON){var h=1-r;return n[3]=h*a+r*n[3],n[0]=h*i+r*n[0],n[1]=h*s+r*n[1],n[2]=h*o+r*n[2],this.normalize()}const u=Math.sqrt(c),f=Math.atan2(u,l),m=Math.sin((1-r)*f)/u,d=Math.sin(r*f)/u;return n[3]=a*m+n[3]*d,n[0]=i*m+n[0]*d,n[1]=s*m+n[1]*d,n[2]=o*m+n[2]*d,this}}class c{constructor(e){const t=new Float32Array(2);e&&"object"==typeof e&&(t[0]=e[0],t[1]=e[1]),this.elements=t}subtract(e){const t=this.elements;return e=e.elements,t[0]=t[0]-e[0],t[1]=t[1]-e[1],this}lerp(e,t,r){const n=this.elements,i=e[0],s=e[1];return n[0]=i+r*(t[0]-i),n[1]=s+r*(t[1]-s),this}}function h(e){const t=[new l,new l,new l,new l,new l,new l],r=e.elements;let n=r[0],i=r[1],s=r[2],o=r[3],a=r[4],c=r[5],h=r[6],u=r[7],f=r[8],m=r[9],d=r[10],p=r[11],T=r[12],E=r[13],g=r[14],v=r[15];return t[0].set([o-n,u-a,p-f,v-T]).normalize(),t[1].set([o+n,u+a,p+f,v+T]).normalize(),t[2].set([o+i,u+c,p+m,v+E]).normalize(),t[3].set([o-i,u-c,p-m,v-E]).normalize(),t[4].set([o-s,u-h,p-d,v-g]).normalize(),t[5].set([o+s,u+h,p+d,v+g]).normalize(),t}class u{constructor(){this.opaqueChildren=[],this.transparentChildren=[],this.meshes=[],this.children=[],this.bin=[],this.matrixWorld=new s}}class f{constructor(e,t){this.uuid=Math.floor(Date.now()*Math.random()),this.name=e,this.children=[],this.matrix=new s,this.matrixWorld=new s,this.parent=t}getPosition(){return new Float32Array([this.matrixWorld.elements[12],this.matrixWorld.elements[13],this.matrixWorld.elements[14]])}setPosition(e,t,r){t&&this.matrix.makeRotationFromQuaternion(t),r&&this.matrix.scale(new a(r)),e&&this.matrix.setTranslate(new a(e))}setMatrix(e){this.matrix.set(e)}setMatrixWorld(e){this.matrixWorld.set(e)}updateMatrix(){const e=new s;e.multiply(this.parent.matrixWorld),e.multiply(this.matrix),this.setMatrixWorld(e.elements)}}class m extends f{constructor(e,t){super(e,t),this.material={blend:null,uniforms:null,alphaMode:null,UBO:null,pbrMetallicRoughness:null},this.program=null,this.defines=null,this.mode=4}setDefines(e){this.defines=e}setBlend(e){this.material.blend=e}setMaterial(e){this.material=e,this.material.uniforms={baseColorTexture:null,metallicRoughnessTexture:null,normalTexture:null,occlusionTexture:null,emissiveTexture:null}}draw(e,{camera:t,light:r,preDepthTexture:n,fakeDepth:i,needUpdateView:o,needUpdateProjection:a,irradiancemap:l,prefilterMap:c,brdfLUT:h},u,f){if(e.useProgram(this.program),e.bindVertexArray(this.geometry.VAO),e.bindBufferBase(e.UNIFORM_BUFFER,0,this.geometry.UBO),this.reflow){const t=new s(this.matrixWorld);t.invert().transpose(),this.geometry.uniformBuffer.update(e,"model",this.matrixWorld.elements),this.geometry.uniformBuffer.update(e,"normalMatrix",t.elements)}if(o&&(this.geometry.uniformBuffer.update(e,"view",t.matrixWorldInvert.elements),this.geometry.uniformBuffer.update(e,"light",r.matrixWorldInvert.elements)),a&&this.geometry.uniformBuffer.update(e,"projection",t.projection.elements),this.geometry.uniformBuffer.update(e,"isShadow",new Float32Array([f?1:0])),this instanceof d&&(e.bindBufferBase(e.UNIFORM_BUFFER,2,this.geometry.SKIN),this.bones.some(e=>e.reflow))){const t=this.getJointMatrix(),r=new Float32Array(16*t.length);let n=0;for(const e of t)r.set(e.elements,0+16*n),n++;e.bufferSubData(e.UNIFORM_BUFFER,0,r)}this.material.UBO&&(e.bindBufferBase(e.UNIFORM_BUFFER,1,this.material.UBO),o&&(this.material.uniformBuffer.update(e,"lightPos",r.getPosition()),this.material.uniformBuffer.update(e,"viewPos",t.getPosition()))),e.uniform1i(e.getUniformLocation(this.program,"prefilterMap"),c.index),e.uniform1i(e.getUniformLocation(this.program,"brdfLUT"),h.index),e.uniform1i(e.getUniformLocation(this.program,"irradianceMap"),l.index),e.uniform1i(e.getUniformLocation(this.program,"depthTexture"),u?i.index:n.index);let m=31;this.material.pbrMetallicRoughness.baseColorTexture&&(e.activeTexture(e[`TEXTURE${m}`]),e.bindTexture(e.TEXTURE_2D,this.material.pbrMetallicRoughness.baseColorTexture),e.bindSampler(m,this.material.pbrMetallicRoughness.baseColorTexture.sampler),e.uniform1i(this.material.uniforms.baseColorTexture,m),m--),this.material.pbrMetallicRoughness.metallicRoughnessTexture&&(e.activeTexture(e[`TEXTURE${m}`]),e.bindTexture(e.TEXTURE_2D,this.material.pbrMetallicRoughness.metallicRoughnessTexture),e.bindSampler(m,this.material.pbrMetallicRoughness.metallicRoughnessTexture.sampler),e.uniform1i(this.material.uniforms.metallicRoughnessTexture,m),m--),this.material.normalTexture&&(e.activeTexture(e[`TEXTURE${m}`]),e.bindTexture(e.TEXTURE_2D,this.material.normalTexture),e.bindSampler(m,this.material.normalTexture.sampler),e.uniform1i(this.material.uniforms.normalTexture,m),m--),this.material.occlusionTexture&&(e.activeTexture(e[`TEXTURE${m}`]),e.bindTexture(e.TEXTURE_2D,this.material.occlusionTexture),e.bindSampler(m,this.material.occlusionTexture.sampler),e.uniform1i(this.material.uniforms.occlusionTexture,m),m--),this.material.emissiveTexture&&(e.activeTexture(e[`TEXTURE${m}`]),e.bindTexture(e.TEXTURE_2D,this.material.emissiveTexture),e.bindSampler(m,this.material.emissiveTexture.sampler),e.uniform1i(this.material.uniforms.emissiveTexture,m),m--),this.material.doubleSided&&e.disable(e.CULL_FACE),this.geometry.indicesBuffer?e.drawElements(this.mode,this.geometry.indicesBuffer.length,e[this.geometry.indicesBuffer.type],0):e.drawArrays(this.mode,0,this.geometry.attributes.POSITION.length/3),this.material.doubleSided&&e.enable(e.CULL_FACE)}setGeometry(e){this.geometry=e}setProgram(e){this.program=e}setMode(e=4){this.mode=e}isVisible(e){const t=new a(this.geometry.boundingSphere.center.elements).applyMatrix4(this.matrixWorld),r=this.geometry.boundingSphere.radius*this.matrixWorld.getMaxScaleOnAxis();let n,i=!0;for(const s of e)if((n=s.elements[0]*t.elements[0]+s.elements[1]*t.elements[1]+s.elements[2]*t.elements[2]+s.elements[3])<-r){i=!1;break}return this.distance=n+r,i}}class d extends m{constructor(e,t){super(e,t)}setSkin(e){return this.skin=e,this}getJointMatrix(){const e=new s(this.matrixWorld).invert(),t=[];for(let r=0;r<this.boneInverses.length;r++){const n=(new s).multiply(e).multiply(this.bones[r].matrixWorld).multiply(this.boneInverses[r]);t.push(n)}return t}}class p extends f{}const T={};let E,g=-1;const v=[0,0,0,1];function R(e,t){return Math.random()*(t-e)+e}function x(e,t,r){return e+r*(t-e)}function b(e){let t;switch(e){case"MAT2":t=4;break;case"MAT3":t=9;break;case"MAT4":t=16;break;case"VEC4":t=4;break;case"VEC3":t=3;break;case"VEC2":t=2;break;case"SCALAR":t=1}return t}function A(e){return"rotation"===e?4:"translation"===e||"scale"===e?3:void 0}function F(e,t){if(0===t.length)return[-1,-1,0];let r=-1;for(let n=t.length-1;n>=0;n--)if(e>=t[n].time){r=n;break}if(-1===r||r===t.length-1)return r<0&&(r=0),[r,r,0];{const n=t[r],i=t[r+1];return e=Math.max(n.time,Math.min(e,i.time)),[r,r+1,function(e,t,r){return(r-e)/(t-e)}(n.time,i.time,e)]}}function _(e){let t;switch(T[e]){case"BYTE":case"UNSIGNED_BYTE":t=1;break;case"SHORT":case"UNSIGNED_SHORT":t=2;break;case"UNSIGNED_INT":case"FLOAT":t=4}return t}function U(e,t,r,n,i,s){const o=n,a=n/s;let l;switch(i&&i!==_(t)*a&&(n=i*s/_(t)-r/_(t)),T[t]){case"BYTE":(l=new Int8Array(e,r,n)).type="BYTE";break;case"UNSIGNED_BYTE":(l=new Uint8Array(e,r,n)).type="UNSIGNED_BYTE";break;case"SHORT":(l=new Int16Array(e,r,n)).type="SHORT";break;case"UNSIGNED_SHORT":(l=new Uint16Array(e,r,n)).type="UNSIGNED_SHORT";break;case"UNSIGNED_INT":(l=new Uint32Array(e,r,n)).type="UNSIGNED_INT";break;case"FLOAT":(l=new Float32Array(e,r,n)).type="FLOAT"}if(i&&i!==_(t)*a){const e=new Float32Array(o);let r=0;for(let n=0;n<e.length;n+=a)e[n]=l[r],e[n+1]=l[r+1],e[n+2]=l[r+2],r+=a*(i/_(t)/a);return e.type=l.type,e}return l}function M(e,t,r){const n=E.createShader(e);E.shaderSource(n,t),E.compileShader(n),E.attachShader(r,n);const i=E.getShaderInfoLog(n);if(i)throw new Error(i)}function P(e,t){const r=E.createProgram();if(M(E.VERTEX_SHADER,e,r),M(E.FRAGMENT_SHADER,t,r),E.linkProgram(r),E.validateProgram(r),!E.getProgramParameter(r,E.LINK_STATUS)){const e=E.getProgramInfoLog(r);throw new Error(`Could not compile WebGL program. ${e}`)}return r}function w(e=E.TEXTURE_2D){const t=++g,r=E.createTexture();return E.activeTexture(E[`TEXTURE${t}`]),E.bindTexture(e,r),r.index=t,r}function B(e,t){!function e(r){t(r),r.children&&r.children.forEach(e)}(e)}function y(e){let t=e[0]*e[0]+e[1]*e[1];const r=.0016-t;return r>0?[e[0],e[1],Math.sqrt(r)]:(t=Math.sqrt(t),[.04*e[0]/t,.04*e[1]/t,0])}function L(e,t,r,n){const[i,o]=e,c=new s;c.setTranslate(new a([0,0,.05]));const h=new s(t);h.multiply(c);const u=h.multiplyVector4(new l([0,0,0,1]));u.elements[0]=(2*i/r-1)*u.elements[3],u.elements[1]=(-2*o/n+1)*u.elements[3];const f=h.invert().multiplyVector4(u);return[f.elements[0],f.elements[1]]}function S(e){const{aspect:t,zoom:r}=e;let n;if("perspective"===e.type&&e.perspective){const{yfov:i}=e.perspective,o=i*t;n=(new s).setPerspective(o*r,t,e.perspective.znear||1,e.perspective.zfar||2e6)}else"orthographic"===e.type&&e.orthographic&&(n=(new s).setOrtho(e.orthographic.xmag*r,e.orthographic.ymag*r,e.orthographic.znear,e.orthographic.zfar));return n}function N(e=0,t=0){return e+t}function D(e){let t;switch(e){case"POSITION":t=[0,3,E.FLOAT];break;case"NORMAL":t=[1,3,E.FLOAT];break;case"TEXCOORD_0":t=[2,2,E.FLOAT];break;case"JOINTS_0":t=[3,4,E.UNSIGNED_SHORT];break;case"WEIGHTS_0":t=[4,4,E.FLOAT];break;case"TANGENT":t=[5,4,E.FLOAT];break;case"COLOR_0":t=[6,4,E.FLOAT];break;case"TEXCOORD_1":t=[7,2,E.FLOAT]}return t}class C extends f{constructor(e,t,r){super(t,r),this.matrixWorldInvert=new s,this.projection=new s,this.props=e}setProjection(e){this.projection.set(e.elements)}setMatrixWorld(e){super.setMatrixWorld(e),this.matrixWorldInvert.setInverseOf(this.matrixWorld)}setZ(e){this.matrix.elements[14]=e,this.setMatrixWorld(this.matrix.elements)}getViewProjMatrix(){const e=new s;return e.multiply(this.projection),e.multiply(this.matrixWorldInvert),e}pan(e,t,r,n){const i=L(e,this.projection,r,n),s=L(t,this.projection,r,n),o=new a([...i,0]),l=new a([...s,0]),c=100*this.modelSize,h=l.subtract(o).scale(c);this.matrixWorld.translate(h.elements[0],h.elements[1],0),this.setMatrixWorld(this.matrixWorld.elements)}rotate(e,t,r,n){const i=L(e,this.projection,r,n),o=L(t,this.projection,r,n),l=new a(y(i)),c=new a(y(o)),h=30*a.angle(c,l)/this.props.aspect;if(h<1e-6||isNaN(h))return;const u=new a(l.elements).applyMatrix4(this.matrixWorld),f=new a(c.elements).applyMatrix4(this.matrixWorld),m=a.cross(f,u).normalize(),d=new s;d.makeRotationAxis(m,h),d.multiply(this.matrixWorld),this.setMatrixWorld(d.elements)}zoom(e){this.props.zoom=e,this.updateNF(),this.setProjection(S(this.props))}updateNF(){const e=Math.abs(this.matrixWorldInvert.elements[14]),t=this.props.perspective||this.props.orthographic;e>this.modelSize?(t.znear=e-this.modelSize,t.zfar=e+this.modelSize):(t.znear=1,t.zfar=1e4),this.setProjection(S(this.props))}}class O extends f{constructor(e,t){super(e,t),this.matrixWorldInvert=new s}setMatrixWorld(e){super.setMatrixWorld(e),this.matrixWorldInvert.setInverseOf(this.matrixWorld)}setZ(e){this.matrix.elements[14]=e,this.setMatrixWorld(this.matrix.elements)}update(e){const t=new s;t.makeRotationAxis(new a([0,1,0]),e),t.multiply(this.matrix),this.setMatrixWorld(t.elements)}}class I{constructor(){this.map=new Map,this.tempStore={},this.offset=0}getBuffer(e){const t=e.length;return t<=4?e:9===t?new Float32Array([e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0]):e}add(e,t){this.map.set(e,this.offset);const r=this.getBuffer(t);this.tempStore[e]=r,this.offset+=Math.max(r.length,4)}update(e,t,r){const n=this.map.get(t);this.store.set(r,n),e.bufferSubData(e.UNIFORM_BUFFER,n*Float32Array.BYTES_PER_ELEMENT,r)}done(){this.store=new Float32Array(this.offset);for(const[e,t]of this.map)this.store.set(this.tempStore[e],t);this.tempStore=null}}class V{constructor(){this.counterEl=document.createElement("div"),this.counterEl.setAttribute("style","position: absolute; top: 0; right: 0; color: #fff; font-size: 30px; background: #000;"),document.body.appendChild(this.counterEl),this.fps=0,this.elapsedTime=0,this.lastTime=0}tick(e){this.fps++,this.elapsedTime+=e-this.lastTime,this.lastTime=e,this.elapsedTime>=1e3&&(this.counterEl.innerHTML=String(this.fps),this.fps=0,this.elapsedTime-=1e3)}}class X{setCanvas(e){this.canvas=e}setCamera(e){this.camera=e}setLight(e){this.light=e}get width(){return this.canvas.offsetWidth*devicePixelRatio}get height(){return this.canvas.offsetHeight*devicePixelRatio}}var G=r(3),k=r.n(G),H=r(4),z=r.n(H);let j,W,Y;class q extends X{constructor(){super(),this.scale=2}setGL(e){j=e}preProcessing(e){j.clear(j.COLOR_BUFFER_BIT|j.DEPTH_BUFFER_BIT),e.renderScene(!0,!0),j.bindFramebuffer(j.FRAMEBUFFER,this.framebuffer),j.framebufferTexture2D(j.FRAMEBUFFER,j.COLOR_ATTACHMENT0,j.TEXTURE_2D,this.texture,0),j.useProgram(this.program),j.viewport(0,0,this.width/this.scale,this.height/this.scale),j.bindVertexArray(this.quadVAO);const t=S(Object.assign({},this.camera.props,{zoom:1}));j.uniformMatrix4fv(j.getUniformLocation(this.program,"Iproj"),!1,(new s).setInverseOf(t).elements),j.uniformMatrix4fv(j.getUniformLocation(this.program,"proj"),!1,t.elements),j.uniformMatrix4fv(j.getUniformLocation(this.program,"Iview"),!1,this.camera.matrixWorld.elements),j.uniformMatrix4fv(j.getUniformLocation(this.program,"light"),!1,this.light.matrixWorldInvert.elements),j.uniform1i(j.getUniformLocation(this.program,"lightTexture"),e.preDepthTexture.index),j.uniform1i(j.getUniformLocation(this.program,"cameraTexture"),e.depthTexture.index),j.drawArrays(j.TRIANGLES,0,6),j.bindFramebuffer(j.FRAMEBUFFER,null),j.viewport(0,0,this.width,this.height)}buildScreenBuffer(e){this.framebuffer=j.createFramebuffer(),j.bindFramebuffer(j.FRAMEBUFFER,this.framebuffer),this.texture=e.createOneChannelTexture(this.scale),j.framebufferTexture2D(j.FRAMEBUFFER,j.COLOR_ATTACHMENT0,j.TEXTURE_2D,this.texture,0),this.program=P(z.a,k.a);this.quadVAO=j.createVertexArray(),j.bindVertexArray(this.quadVAO);const t=j.createBuffer();return j.bindBuffer(j.ARRAY_BUFFER,t),j.bufferData(j.ARRAY_BUFFER,new Float32Array([1,1,-1,1,-1,-1,-1,-1,1,-1,1,1]),j.STATIC_DRAW),j.enableVertexAttribArray(0),j.vertexAttribPointer(0,2,j.FLOAT,!1,0,0),j.bindVertexArray(null),j.bindFramebuffer(j.FRAMEBUFFER,null),{name:"LIGHT"}}attachUniform(e){j.uniform1i(j.getUniformLocation(e,"light"),this.texture.index)}postProcessing(){}}class $ extends X{setGL(e){W=e}preProcessing(e){W.clear(W.COLOR_BUFFER_BIT|W.DEPTH_BUFFER_BIT),e.renderScene(!0,!0)}buildScreenBuffer(){return{name:"SHADOW"}}attachUniform(){}postProcessing(){}}class K{constructor(e){this.reflow=!0,this.fps=new V,this.getState=e}setEnv(e){this.env=e}setCamera(e){this.camera=e}setParticles(e){this.Particles=e}setScene(e){this.scene=e}setPp(e){this.PP=e}setGl(e){Y=e}setParser(e){this.parse=e}animate(e){e-=Math.floor(e/this.parse.duration)*this.parse.duration;for(const t of this.parse.tracks){const r=F(e,t.keys);if(-1===r[0]||-1===r[1]||t.stoped)continue;const n=t.keys[r[0]],i=t.keys[r[1]],s=r[2],c=A(t.type);let h;const u=new(h=3===c?a:4===c?l:o)(n.value),f=new h(i.value);if("rotation"===t.type){const e=new l;e.lerp(u.elements,f.elements,s);for(const r of t.meshes)r.matrix.makeRotationFromQuaternion(e.elements)}else if("scale"===t.type){const e=new a;e.lerp(u.elements,f.elements,s);for(const r of t.meshes)r.matrix.scale(e)}else if("weights"===t.type){const e=new o(u.elements);e.lerp(u.elements,f.elements,s);for(const r of t.meshes){const t={};for(const n in r.geometry.targets[0])if("POSITION"===n){t[n]=r.geometry.attributes[n].slice();for(let i=0;i<e.elements.length;i++){if(0===e.elements[i])continue;let s=0;for(let o=0;o<t[n].length;o++)t[n][o]+=e.elements[i]*r.geometry.targets[i][n][o-s]}}Y.bindVertexArray(r.geometry.VAO);for(const e in t){const r=Y.createBuffer();Y.bindBuffer(Y.ARRAY_BUFFER,r),Y.bufferData(Y.ARRAY_BUFFER,t[e],Y.STATIC_DRAW);const n=D(e);Y.enableVertexAttribArray(n[0]),Y.vertexAttribPointer(n[0],n[1],n[2],!1,0,0)}Y.bindVertexArray(null)}}else if("translation"===t.type){const e=new a;e.lerp(u.elements,f.elements,s);for(const r of t.meshes)r.matrix.setTranslate(e)}else console.error("ERROR");for(const e of t.meshes)B(e,e=>{e.updateMatrix(),e instanceof p&&(e.reflow=!0),e instanceof m&&(e.reflow=!0),e instanceof C&&e===this.camera&&(this.needUpdateView=!0)});this.reflow=!0}}render(e=0){const t=e/1e3;this.animate(t),this.reflow&&(this.PP.postprocessors.length>0&&(this.PP.bindPrePass(),this.PP.preProcessing(),this.PP.bindPostPass()),Y.clear(Y.COLOR_BUFFER_BIT|Y.DEPTH_BUFFER_BIT),this.renderScene(!this.PP.postprocessors.some(e=>e instanceof $),!1),this.clean(),this.PP.postprocessors.some(e=>e instanceof q)&&(this.Particles.draw(e),this.reflow=!0),this.PP.postprocessors.length>0&&this.PP.postProcessing()),this.fps.tick(e),requestAnimationFrame(this.render.bind(this))}renderScene(e,t){if(Y.enable(Y.DEPTH_TEST),Y.enable(Y.CULL_FACE),this.needUpdateView){const e=h(this.camera.getViewProjMatrix());this.scene.meshes.forEach(t=>{t.visible=t.isVisible(e)})}this.scene.opaqueChildren.forEach(r=>{r.visible&&r.draw(Y,this.getState(),e,t)}),this.scene.transparentChildren.length&&(Y.enable(Y.BLEND),Y.blendFunc(Y.SRC_ALPHA,Y.ONE_MINUS_SRC_ALPHA),this.scene.transparentChildren.forEach(r=>{r.visible&&r.draw(Y,this.getState(),e,t)}),Y.disable(Y.BLEND),Y.blendFunc(Y.ONE,Y.ZERO))}clean(){B(this.scene,e=>{e.reflow=!1}),this.needUpdateView=!1,this.needUpdateProjection=!1,this.reflow=!1}}class J{constructor(e){const t=document.querySelector("#canvas");this.redraw=e,this.zoomValue=0,document.addEventListener("wheel",this),t.addEventListener("mousedown",this),t.addEventListener("mousemove",this),t.addEventListener("mouseup",this),document.addEventListener("keyup",this),document.addEventListener("keydown",this),addEventListener("resize",this)}handleEvent(e){switch(e.type){case"wheel":this.zoom(e);break;case"mousedown":this.onStart(e);break;case"mousemove":this.onMove(e);break;case"mouseup":this.onEnd();break;case"keyup":this.onKeyUp();break;case"keydown":this.onKeyDown(e);break;case"resize":this.onResize()}}onResize(){this.redraw("resize")}onKeyDown(e){(e.shiftKey||e.ctrlKey)&&(this.isPan=!0)}onKeyUp(){this.isPan=!1}onStart(e){this.x=e.clientX,this.y=e.clientY,this.isDrag=!0}onMove(e){this.isDrag&&(this.isPan?this.redraw("pan",[this.x,this.y],[e.clientX,e.clientY]):this.redraw("rotate",[this.x,this.y],[e.clientX,e.clientY]),this.x=e.clientX,this.y=e.clientY)}onEnd(){this.isDrag=!1}zoom(e){e.preventDefault(),this.zoomValue=Math.min(this.zoomValue+e.deltaY,1250),this.redraw("zoom",Math.pow(1.001,this.zoomValue))}}var Z=r(5),Q=r.n(Z),ee=r(2),te=r.n(ee),re=r(6),ne=r.n(re),ie=r(7),se=r.n(ie),oe=r(8),ae=r.n(oe),le=r(9),ce=r.n(le),he=r(0),ue=r.n(he);let fe;class me{constructor(e){this.url=e,this.envMatrix=new s}setCamera(e){this._camera=e}setGl(e){fe=e}setCanvas(e){this.canvas=e}get width(){return this.canvas.offsetWidth*devicePixelRatio}get height(){return this.canvas.offsetHeight*devicePixelRatio}draw(){const e=new s,t=Object.assign({},this._camera.props,{perspective:{yfov:.3,znear:.01,zfar:1e4}});e.multiply(S(t)),fe.enable(fe.CULL_FACE);const r=fe.createProgram();M(fe.VERTEX_SHADER,"#version 300 es\n        precision highp float;\n        \n        layout (location = 0) in vec3 inPosition;\n        \n        out vec3 outUV;\n\n        uniform mat4 projection;\n        uniform mat4 view;\n        \n        void main() {\n            outUV = inPosition;\n            gl_Position = projection * view * vec4(inPosition, 1.0);\n        }\n        ",r),M(fe.FRAGMENT_SHADER,"#version 300 es\n        precision highp float;\n        \n        in vec3 outUV;\n        layout (location = 0) out vec4 color;\n\n        uniform samplerCube environmentMap;\n        \n        void main() {\n            vec3 c = textureLod(environmentMap, outUV, 0.0).rgb;\n            \n            color = vec4(c, 1.0);\n        }\n        ",r),fe.linkProgram(r),fe.useProgram(r),fe.bindVertexArray(this.VAO),fe.uniformMatrix4fv(fe.getUniformLocation(r,"projection"),!1,e.elements),fe.uniform1i(fe.getUniformLocation(r,"environmentMap"),this.map.index),fe.uniformMatrix4fv(fe.getUniformLocation(r,"view"),!1,this._camera.matrixWorldInvert.elements),fe.drawArrays(fe.TRIANGLES,0,36)}createEnvironment(){fe.enable(fe.CULL_FACE);const e=new s,t=Object.assign({},this._camera.props,{aspect:1,perspective:{yfov:Math.PI/2,znear:.01,zfar:1e4}});e.multiply(S(t));{fe.bindFramebuffer(fe.FRAMEBUFFER,this.framebuffer),fe.useProgram(this.cubeprogram),fe.bindVertexArray(this.VAO),fe.viewport(0,0,this.framebuffer.size,this.framebuffer.size),fe.uniformMatrix4fv(fe.getUniformLocation(this.cubeprogram,"projection"),!1,e.elements),fe.uniform1i(fe.getUniformLocation(this.cubeprogram,"diffuse"),this.texture.index);const t=5;for(let e=0;e<t;++e){const t=this.framebuffer.size*Math.pow(.5,e),r=this.framebuffer.size*Math.pow(.5,e);fe.viewport(0,0,t,r);for(let t=0;t<6;t++)fe.framebufferTexture2D(fe.FRAMEBUFFER,fe.COLOR_ATTACHMENT0,fe.TEXTURE_CUBE_MAP_POSITIVE_X+t,this.map,e),fe.uniformMatrix4fv(fe.getUniformLocation(this.cubeprogram,"view"),!1,this.views[t].elements),fe.clear(fe.COLOR_BUFFER_BIT|fe.DEPTH_BUFFER_BIT),fe.drawArrays(fe.TRIANGLES,0,36)}fe.bindVertexArray(null),fe.bindFramebuffer(fe.FRAMEBUFFER,null)}fe.bindFramebuffer(fe.FRAMEBUFFER,this.irradiancebuffer),fe.useProgram(this.irradianceprogram),fe.bindVertexArray(this.VAO),fe.viewport(0,0,this.irradiancebuffer.size,this.irradiancebuffer.size),fe.uniformMatrix4fv(fe.getUniformLocation(this.irradianceprogram,"projection"),!1,e.elements),fe.uniform1i(fe.getUniformLocation(this.irradianceprogram,"environmentMap"),this.map.index);for(let e=0;e<6;e++)fe.framebufferTexture2D(fe.FRAMEBUFFER,fe.COLOR_ATTACHMENT0,fe.TEXTURE_CUBE_MAP_POSITIVE_X+e,this.irradiancemap,0),fe.uniformMatrix4fv(fe.getUniformLocation(this.irradianceprogram,"view"),!1,this.views[e].elements),fe.clear(fe.COLOR_BUFFER_BIT|fe.DEPTH_BUFFER_BIT),fe.drawArrays(fe.TRIANGLES,0,36);fe.bindVertexArray(null),fe.bindFramebuffer(fe.FRAMEBUFFER,null);{fe.bindFramebuffer(fe.FRAMEBUFFER,this.prefilterbuffer),fe.useProgram(this.mipmapcubeprogram),fe.bindVertexArray(this.VAO),fe.uniformMatrix4fv(fe.getUniformLocation(this.mipmapcubeprogram,"projection"),!1,e.elements),fe.uniform1i(fe.getUniformLocation(this.mipmapcubeprogram,"environmentMap"),this.map.index);const t=5;for(let e=0;e<t;++e){const r=this.prefilterbuffer.size*Math.pow(.5,e),n=this.prefilterbuffer.size*Math.pow(.5,e);fe.viewport(0,0,r,n);const i=e/(t-1);fe.uniform1f(fe.getUniformLocation(this.mipmapcubeprogram,"roughness"),i);for(let t=0;t<6;t++)fe.framebufferTexture2D(fe.FRAMEBUFFER,fe.COLOR_ATTACHMENT0,fe.TEXTURE_CUBE_MAP_POSITIVE_X+t,this.prefilterMap,e),fe.uniformMatrix4fv(fe.getUniformLocation(this.mipmapcubeprogram,"view"),!1,this.views[t].elements),fe.clear(fe.COLOR_BUFFER_BIT|fe.DEPTH_BUFFER_BIT),fe.drawArrays(fe.TRIANGLES,0,36)}fe.bindVertexArray(null),fe.bindFramebuffer(fe.FRAMEBUFFER,null)}fe.bindFramebuffer(fe.FRAMEBUFFER,this.brdfbuffer),fe.useProgram(this.bdrfprogram),fe.bindVertexArray(this.quadVAO),fe.viewport(0,0,this.brdfbuffer.size,this.brdfbuffer.size),fe.framebufferTexture2D(fe.FRAMEBUFFER,fe.COLOR_ATTACHMENT0,fe.TEXTURE_2D,this.brdfLUTTexture,0),fe.clear(fe.COLOR_BUFFER_BIT|fe.DEPTH_BUFFER_BIT),fe.drawArrays(fe.TRIANGLE_STRIP,0,4),fe.bindVertexArray(null),fe.bindFramebuffer(fe.FRAMEBUFFER,null),fe.disable(fe.CULL_FACE),fe.viewport(0,0,this.width,this.height)}createEnvironmentBuffer(){{const e=32,t=fe.createFramebuffer();this.irradiancebuffer=t,this.irradiancebuffer.size=e,fe.bindFramebuffer(fe.FRAMEBUFFER,t);const r=w(fe.TEXTURE_CUBE_MAP);for(let t=0;t<6;t++)fe.texImage2D(fe.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,fe.RGBA16F,e,e,0,fe.RGBA,fe.FLOAT,null),fe.framebufferTexture2D(fe.FRAMEBUFFER,fe.COLOR_ATTACHMENT0,fe.TEXTURE_CUBE_MAP_POSITIVE_X+t,r,0);fe.texParameteri(fe.TEXTURE_CUBE_MAP,fe.TEXTURE_WRAP_S,fe.CLAMP_TO_EDGE),fe.texParameteri(fe.TEXTURE_CUBE_MAP,fe.TEXTURE_WRAP_T,fe.CLAMP_TO_EDGE),fe.texParameteri(fe.TEXTURE_CUBE_MAP,fe.TEXTURE_WRAP_R,fe.CLAMP_TO_EDGE),fe.texParameteri(fe.TEXTURE_CUBE_MAP,fe.TEXTURE_MIN_FILTER,fe.LINEAR),fe.texParameteri(fe.TEXTURE_CUBE_MAP,fe.TEXTURE_MAG_FILTER,fe.LINEAR),this.irradiancemap=r}{const e=512,t=fe.createFramebuffer();this.framebuffer=t,this.framebuffer.size=e,fe.bindFramebuffer(fe.FRAMEBUFFER,t);const r=w(fe.TEXTURE_CUBE_MAP);for(let t=0;t<6;t++)fe.texImage2D(fe.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,fe.RGBA16F,e,e,0,fe.RGBA,fe.FLOAT,null),fe.framebufferTexture2D(fe.FRAMEBUFFER,fe.COLOR_ATTACHMENT0,fe.TEXTURE_CUBE_MAP_POSITIVE_X+t,r,0);fe.texParameteri(fe.TEXTURE_CUBE_MAP,fe.TEXTURE_WRAP_S,fe.CLAMP_TO_EDGE),fe.texParameteri(fe.TEXTURE_CUBE_MAP,fe.TEXTURE_WRAP_T,fe.CLAMP_TO_EDGE),fe.texParameteri(fe.TEXTURE_CUBE_MAP,fe.TEXTURE_WRAP_R,fe.CLAMP_TO_EDGE),fe.texParameteri(fe.TEXTURE_CUBE_MAP,fe.TEXTURE_MIN_FILTER,fe.LINEAR_MIPMAP_LINEAR),fe.texParameteri(fe.TEXTURE_CUBE_MAP,fe.TEXTURE_MAG_FILTER,fe.LINEAR),fe.generateMipmap(fe.TEXTURE_CUBE_MAP),this.map=r}{const e=128,t=fe.createFramebuffer();this.prefilterbuffer=t,this.prefilterbuffer.size=e,fe.bindFramebuffer(fe.FRAMEBUFFER,t);const r=w(fe.TEXTURE_CUBE_MAP);for(let t=0;t<6;t++)fe.texImage2D(fe.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,fe.RGBA16F,e,e,0,fe.RGBA,fe.FLOAT,null),fe.framebufferTexture2D(fe.FRAMEBUFFER,fe.COLOR_ATTACHMENT0,fe.TEXTURE_CUBE_MAP_POSITIVE_X+t,r,t);fe.texParameteri(fe.TEXTURE_CUBE_MAP,fe.TEXTURE_WRAP_S,fe.CLAMP_TO_EDGE),fe.texParameteri(fe.TEXTURE_CUBE_MAP,fe.TEXTURE_WRAP_T,fe.CLAMP_TO_EDGE),fe.texParameteri(fe.TEXTURE_CUBE_MAP,fe.TEXTURE_WRAP_R,fe.CLAMP_TO_EDGE),fe.texParameteri(fe.TEXTURE_CUBE_MAP,fe.TEXTURE_MIN_FILTER,fe.LINEAR_MIPMAP_LINEAR),fe.texParameteri(fe.TEXTURE_CUBE_MAP,fe.TEXTURE_MAG_FILTER,fe.LINEAR),fe.generateMipmap(fe.TEXTURE_CUBE_MAP),this.prefilterMap=r}{const e=512,t=fe.createFramebuffer();this.brdfbuffer=t,this.brdfbuffer.size=e,fe.bindFramebuffer(fe.FRAMEBUFFER,t);const r=w();fe.texImage2D(fe.TEXTURE_2D,0,fe.RG16F,e,e,0,fe.RG,fe.FLOAT,null),fe.texParameteri(fe.TEXTURE_2D,fe.TEXTURE_WRAP_S,fe.CLAMP_TO_EDGE),fe.texParameteri(fe.TEXTURE_2D,fe.TEXTURE_WRAP_T,fe.CLAMP_TO_EDGE),fe.texParameteri(fe.TEXTURE_2D,fe.TEXTURE_MIN_FILTER,fe.LINEAR),fe.texParameteri(fe.TEXTURE_2D,fe.TEXTURE_MAG_FILTER,fe.LINEAR),this.brdfLUTTexture=r;const n=[-1,1,-1,-1,1,1,1,-1];this.quadVAO=fe.createVertexArray(),fe.bindVertexArray(this.quadVAO);const i=fe.createBuffer();fe.bindBuffer(fe.ARRAY_BUFFER,i),fe.bufferData(fe.ARRAY_BUFFER,new Float32Array(n),fe.STATIC_DRAW),fe.enableVertexAttribArray(0),fe.vertexAttribPointer(0,2,fe.FLOAT,!1,0,0),fe.bindVertexArray(null)}const e=[[new a([0,1,0]),Math.PI/2],[new a([0,1,0]),-Math.PI/2],[new a([1,0,0]),-Math.PI/2],[new a([1,0,0]),Math.PI/2],[new a([0,1,0]),Math.PI],[new a([0,1,0]),0]];this.views=e.map((e,t)=>{const r=new s;if(r.makeRotationAxis(e[0],e[1]),2!==t&&3!==t){const e=new s;e.makeRotationAxis(new a([0,0,1]),Math.PI),r.multiply(e)}return r.multiply(this._camera.matrix),(new s).setInverseOf(r)});const t=[-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1];this.VAO=fe.createVertexArray(),fe.bindVertexArray(this.VAO);{const e=fe.createBuffer();fe.bindBuffer(fe.ARRAY_BUFFER,e),fe.bufferData(fe.ARRAY_BUFFER,new Float32Array(t),fe.STATIC_DRAW),fe.enableVertexAttribArray(0),fe.vertexAttribPointer(0,3,fe.FLOAT,!1,0,0)}return fe.bindVertexArray(null),this.cubeprogram=P(te.a,ne.a),this.irradianceprogram=P(te.a,se.a),this.mipmapcubeprogram=P(te.a,ae.a),this.bdrfprogram=P(ue.a,ce.a),fetch(`src/images/${this.url}.hdr`).then(e=>e.arrayBuffer()).then(e=>{const{data:t}=Q()(e);return this.texture=w(),fe.pixelStorei(fe.UNPACK_FLIP_Y_WEBGL,!0),fe.texParameteri(fe.TEXTURE_2D,fe.TEXTURE_MAG_FILTER,fe.LINEAR),fe.texParameteri(fe.TEXTURE_2D,fe.TEXTURE_MIN_FILTER,fe.LINEAR),fe.texParameteri(fe.TEXTURE_2D,fe.TEXTURE_WRAP_S,fe.CLAMP_TO_EDGE),fe.texParameteri(fe.TEXTURE_2D,fe.TEXTURE_WRAP_T,fe.CLAMP_TO_EDGE),fe.texImage2D(fe.TEXTURE_2D,0,fe.RGBA16F,1024,512,0,fe.RGBA,fe.FLOAT,t),this.createEnvironment(),!0})}}var de=r(10),pe=r.n(de),Te=r(11),Ee=r.n(Te);class ge{constructor(e,t,r,n,i,s){this.boundingSphere={center:new a,radius:null,min:null,max:null},this.uniformBuffer=null,this.UBO=null,this.VAO=null,this.indicesBuffer=null,this.attributes=null,this.targets=null,this.blend=null,this.uniforms=null,this.SKIN=null,this.targets=[];const o=t.accessors[i.indices],l=new Map;for(const e in i.attributes)l.set(e,t.accessors[i.attributes[e]]);if(i.targets)for(const e of i.targets){const n={};for(const i in e){n[i]=t.accessors[e[i]];const s=n[i],o=t.bufferViews[s.bufferView];n[i]=U(r[o.buffer],s.componentType,N(o.byteOffset,s.byteOffset),b(s.type)*s.count)}this.targets.push(n)}let h;if(o){const e=t.bufferViews[o.bufferView];h=U(r[e.buffer],o.componentType,N(e.byteOffset,o.byteOffset),b(o.type)*o.count)}const u={min:l.get("POSITION").min,max:l.get("POSITION").max},f={};for(const e of l.keys()){const s=l.get(e),o=t.bufferViews[s.bufferView];if(f[e]=U(r[o.buffer],s.componentType,N(o.byteOffset,s.byteOffset),b(s.type)*s.count,o.byteStride,s.count),i.targets&&e in i.targets[0]){let t=0;const r=f[e];f[e]=new Float32Array(r.length);for(let i=0;i<f[e].length;i++)"TANGENT"!==e||(i+1)%4!=0?f[e][i]=r[i]+n.reduce((r,s,o)=>r+n[o]*this.targets[o][e][i-t],0):t++}}s&&void 0===i.attributes.TANGENT&&(f.TANGENT=function(e,t,r,n){const i=new Float32Array(r.length/3*4);for(let r=0;r<e.length;r+=3){const l=[e[r],e[r+1],e[r+2]],c=l.map(e=>s(t,e)),h=l.map(e=>s(n,e,2)),u=c[1].subtract(c[0]),f=c[2].subtract(c[0]),m=h[1].subtract(h[0]),d=h[2].subtract(h[0]);let p=m.elements[0]*d.elements[1]-m.elements[1]*d.elements[0];p=0!==p?1/p:1;const T=new a([(d.elements[1]*u.elements[0]-m.elements[1]*f.elements[0])*p,(d.elements[1]*u.elements[1]-m.elements[1]*f.elements[1])*p,(d.elements[1]*u.elements[2]-m.elements[1]*f.elements[2])*p]);T.normalize(),l.forEach(e=>{o(i,e,T)})}return i;function s(e,t,r=3){return t*=r,3===r?new a([e[t],e[t+1],e[t+2]]):2===r?new c([e[t],e[t+1]]):void 0}function o(e,t,r,n=4,i=((e,t)=>e+t)){t*=n;for(let s=0;s<n;++s)e[t+s]=3===s?-1:i(e[t+s],r.elements[s])}}(h,f.POSITION,f.NORMAL,f.TEXCOORD_0));const m=e.createVertexArray();e.bindVertexArray(m);for(const t in f){const r=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,r),e.bufferData(e.ARRAY_BUFFER,f[t],e.STATIC_DRAW);const n=D(t);e.enableVertexAttribArray(n[0]),e.vertexAttribPointer(n[0],n[1],n[2],!1,0,0)}if(h){const t=e.createBuffer();e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t),e.bufferData(e.ELEMENT_ARRAY_BUFFER,h,e.STATIC_DRAW)}this.VAO=m,this.attributes=f,this.indicesBuffer=h;const{min:d,max:p}=u;this.boundingSphere.min=new a(d),this.boundingSphere.max=new a(p),this.calculateBounding(),e.bindVertexArray(null)}calculateBounding(){const e=this.attributes.POSITION;let t=0;this.boundingSphere.center.add(this.boundingSphere.min).add(this.boundingSphere.max).scale(.5);for(let r=0;r<e.length;r+=3)t=Math.max(t,this.boundingSphere.center.distanceToSquared(e[r],e[r+1],e[r+2]));this.boundingSphere.radius=Math.sqrt(t)}}let ve;class Re{constructor(e,t,r){this.url=e,this.host=e.substr(0,e.lastIndexOf("/")+1),this.tracks=[],this.duration=0,this.skins=[],this.textures=null,this.samplers=null,this.arrayBuffer=null,this.cameras=[],this.programs={},this.defines=t,this.resize=r}setScene(e){this.scene=e}setGl(e){ve=e}setCamera(e){this._camera=e}setLight(e){this.light=e}setCanvas(e){this.canvas=e}getBuffer(){return Promise.all(this.scene.bin.map(e=>fetch(`${this.host}${e}`).then(e=>e.arrayBuffer()))).then(e=>{this.arrayBuffer=e})}buildPrim(e,t,r,n,s){const o=void 0!==s.material?JSON.parse(JSON.stringify(this.json.materials[s.material])):{pbrMetallicRoughness:{baseColorFactor:[.8,.8,.8,1]}},a=[...this.defines];if(!o.pbrMetallicRoughness&&o.extensions&&o.extensions.KHR_materials_pbrSpecularGlossiness){const e=o.extensions.KHR_materials_pbrSpecularGlossiness;o.pbrMetallicRoughness={},o.pbrMetallicRoughness.baseColorTexture=e.diffuseTexture,o.pbrMetallicRoughness.metallicRoughnessTexture=e.specularGlossinessTexture,o.pbrMetallicRoughness.baseColorFactor=e.diffuseFactor,o.pbrMetallicRoughness.specularFactor=e.specularFactor,o.pbrMetallicRoughness.glossinessFactor=e.glossinessFactor,a.push({name:"SPECULARGLOSSINESSMAP"})}if(o.pbrMetallicRoughness.metallicRoughnessTexture&&(o.pbrMetallicRoughness.metallicRoughnessTexture=this.textures[o.pbrMetallicRoughness.metallicRoughnessTexture.index],a.push({name:"METALROUGHNESSMAP"})),o.normalTexture&&(o.normalTexture=this.textures[o.normalTexture.index],a.push({name:"NORMALMAP"})),o.occlusionTexture&&(o.occlusionTexture=this.textures[o.occlusionTexture.index],a.push({name:"OCCLUSIONMAP"})),o.pbrMetallicRoughness.baseColorTexture){const e=o.pbrMetallicRoughness.baseColorTexture.extensions;if(o.pbrMetallicRoughness.baseColorTexture=this.textures[o.pbrMetallicRoughness.baseColorTexture.index],a.push({name:"BASECOLORTEXTURE"}),e){const t=e.KHR_texture_transform;if(t){const e=t.offset&&(new i).set([1,0,0,0,1,0,t.offset[0],t.offset[1],1]),r=t.rotation&&(new i).set([-Math.sin(t.rotation),Math.cos(t.rotation),0,Math.cos(t.rotation),Math.sin(t.rotation),0,0,0,1]),n=t.scale&&(new i).set([t.scale[0],0,0,0,t.scale[1],0,0,0,1]),s=new i;n&&s.multiply(n),r&&s.multiply(r),e&&s.multiply(e),o.matrix=s,a.push({name:"TEXTURE_TRANSFORM"})}}}if(o.emissiveTexture){const{texCoord:e}=o.emissiveTexture;o.emissiveTexture=this.textures[o.emissiveTexture.index],a.push({name:"EMISSIVEMAP",value:e?2:1})}let l;if(void 0!==r&&a.push({name:"JOINTNUMBER",value:this.skins[r].jointNames.length}),(s.attributes.TANGENT||o.normalTexture)&&a.push({name:"TANGENT"}),"MASK"===o.alphaMode?a.push({name:"ALPHATEST",value:o.alphaCutoff||.5}):"BLEND"===o.alphaMode&&a.push({name:"ALPHATEST",value:.01}),this.programs[a.map(e=>`${e.name}${e.value||1}`).join("")])l=this.programs[a.map(e=>`${e.name}${e.value||1}`).join("")];else{const e=a.map(e=>`#define ${e.name} ${e.value||1}`+"\n").join("");l=P(pe.a.replace(/\n/,`\n${e}`),Ee.a.replace(/\n/,`\n${e}`)),this.programs[a.map(e=>`${e.name}${e.value||1}`).join("")]=l}const c=void 0!==r?new d(t,e).setSkin(r):new m(t,e),h=new ge(ve,this.json,this.arrayBuffer,n,s,o.normalTexture);return c.setProgram(l),c.setMode(s.mode),c.setMaterial(o),c.setGeometry(h),c.setDefines(a),c.updateMatrix(),o.pbrMetallicRoughness.baseColorTexture&&(c.material.uniforms.baseColorTexture=ve.getUniformLocation(c.program,"baseColorTexture")),o.pbrMetallicRoughness.metallicRoughnessTexture&&(c.material.uniforms.metallicRoughnessTexture=ve.getUniformLocation(c.program,"metallicRoughnessTexture")),o.normalTexture&&(c.material.uniforms.normalTexture=ve.getUniformLocation(c.program,"normalTexture")),o.occlusionTexture&&(c.material.uniforms.occlusionTexture=ve.getUniformLocation(c.program,"occlusionTexture")),o.emissiveTexture&&(c.material.uniforms.emissiveTexture=ve.getUniformLocation(c.program,"emissiveTexture")),c}walkByMesh(e,t){const r=this.json.nodes[t];let n;if(void 0!==r.camera){Re.__update("camera",Object.assign({zoom:1,aspect:this.canvas.offsetWidth/this.canvas.offsetHeight},this.json.cameras[r.camera]),t,e);const i=S((n=this._camera).props);n.setProjection(i),this.cameras.push(n)}else n=void 0!==r.isBone?new p(t,e):new f(t,e);if(r.translation||r.rotation||r.scale?n.setPosition(r.translation,r.rotation,r.scale):r.matrix&&n.setMatrix(r.matrix),n.updateMatrix(),e.children.push(n),e=n,void 0!==r.mesh){if(void 0!==r.skin)for(const e of this.skins[r.skin].jointNames)B(this.scene,this.buildBones.bind(this,e,this.skins[r.skin]));e.children.push(...this.json.meshes[r.mesh].primitives.map(this.buildPrim.bind(this,e,this.json.meshes[r.mesh].name,r.skin,this.json.meshes[r.mesh].weights)))}r.children&&r.children.length&&r.children.forEach(this.walkByMesh.bind(this,e))}calculateFov(){let e;B(this.scene,t=>{t instanceof m&&(e||(e=t),t.geometry.boundingSphere.radius>e.geometry.boundingSphere.radius&&(e=t))});const t=Math.max(e.matrixWorld.getScaleZ(),1),r=Math.hypot(...e.getPosition());this._camera.modelSize=e.geometry.boundingSphere.radius*t+r+Math.hypot(...e.geometry.boundingSphere.center.elements),this.resize()}buildMesh(){this.json.scenes[void 0!==this.json.scene?this.json.scene:0].nodes.forEach(e=>{this.json.nodes[e].children&&this.json.nodes[e].children.length&&this.walkByMesh(this.scene,e),void 0!==this.json.nodes[e].mesh&&this.walkByMesh(this.scene,e),void 0!==this.json.nodes[e].camera&&this.walkByMesh(this.scene,e)}),this.calculateFov();const e=h(this._camera.getViewProjMatrix());B(this.scene,t=>{if(t instanceof d){t.bones=this.skins[t.skin].bones,t.boneInverses=this.skins[t.skin].boneInverses;const e=t.getJointMatrix(),r=new Float32Array(16*e.length);let n=0;for(const t of e)r.set(t.elements,0+16*n),n++;const i=ve.getUniformBlockIndex(t.program,"Skin");ve.uniformBlockBinding(t.program,i,2);const s=ve.createBuffer();ve.bindBuffer(ve.UNIFORM_BUFFER,s),ve.bufferData(ve.UNIFORM_BUFFER,r,ve.DYNAMIC_DRAW),t.geometry.SKIN=s,ve.bindBuffer(ve.UNIFORM_BUFFER,null)}if(t instanceof m){const r=new I;r.add("baseColorFactor",t.material.pbrMetallicRoughness.baseColorFactor||[.8,.8,.8,1]),r.add("lightPos",this.light.getPosition()),r.add("viewPos",this._camera.getPosition()),r.add("textureMatrix",t.material.matrix&&t.material.matrix.elements||(new i).elements),r.add("specularFactor",t.material.pbrMetallicRoughness.specularFactor||[0,0,0]),r.add("glossinessFactor",t.material.pbrMetallicRoughness.glossinessFactor||[0]),r.done();const n=ve.getUniformBlockIndex(t.program,"Material");ve.uniformBlockBinding(t.program,n,1);const o=ve.createBuffer();ve.bindBuffer(ve.UNIFORM_BUFFER,o),ve.bufferData(ve.UNIFORM_BUFFER,r.store,ve.STATIC_DRAW),t.material.UBO=o,t.material.uniformBuffer=r;const a=new s(t.matrixWorld);a.invert().transpose();const l=new I;l.add("model",t.matrixWorld.elements),l.add("normalMatrix",a.elements),l.add("view",this._camera.matrixWorldInvert.elements),l.add("projection",this._camera.projection.elements),l.add("light",this.light.matrixWorldInvert.elements),l.add("isShadow",new Float32Array([0])),l.done();const c=ve.getUniformBlockIndex(t.program,"Matrices");ve.uniformBlockBinding(t.program,c,0);const h=ve.createBuffer();ve.bindBuffer(ve.UNIFORM_BUFFER,h),ve.bufferData(ve.UNIFORM_BUFFER,l.store,ve.DYNAMIC_DRAW),t.geometry.UBO=h,t.geometry.uniformBuffer=l,ve.bindBuffer(ve.UNIFORM_BUFFER,null),t.material.alphaMode?this.scene.transparentChildren.push(t):this.scene.opaqueChildren.push(t),this.scene.meshes.push(t),t.visible=t.isVisible(e)}}),this.scene.opaqueChildren.sort((e,t)=>e.distance-t.distance),this.scene.transparentChildren.sort((e,t)=>e.distance-t.distance)}buildAnimation(){if(!this.json.animations)return!0;for(const e of this.json.animations)for(const t of e.channels){const r=e.samplers[t.sampler];if(r){const{target:n}=t,i=n.node,s=void 0!==e.parameters?e.parameters[r.input]:r.input,o=void 0!==e.parameters?e.parameters[r.output]:r.output,a=this.json.accessors[s],l=this.json.accessors[o],c=this.json.bufferViews[a.bufferView],h=this.json.bufferViews[l.bufferView],u=U(this.arrayBuffer[c.buffer],a.componentType,N(c.byteOffset,a.byteOffset),b(a.type)*a.count),m=U(this.arrayBuffer[h.buffer],l.componentType,N(h.byteOffset,l.byteOffset),b(l.type)*l.count),d=[];B(this.scene,e=>{e.name===i&&("weights"===n.path&&e instanceof f&&(e=e.children[0]),d.push(e))});const p=A(n.path)||d[0].geometry.targets.length,T=[];for(let e=0;e<u.length;e++){const t=u[e],r=m.slice(e*p,(e+1)*p);T.push({time:t,value:r})}this.duration=Math.max(T[T.length-1].time,this.duration),d.length&&this.tracks.push({stoped:!1,meshes:d,type:n.path,name:`${d[0].name}.${n.path}`,keys:T,interpolation:r.interpolation})}}}buildSkin(){if(!this.json.skins)return!0;for(const e of this.json.skins){const t=this.json.accessors[e.inverseBindMatrices],r=this.json.bufferViews[t.bufferView],n=U(this.arrayBuffer[r.buffer],t.componentType,N(r.byteOffset,t.byteOffset),b(t.type)*t.count),i={jointNames:e.joints,inverseBindMatrices:n,bones:[],boneInverses:[]};let o=0;for(const e of i.jointNames){this.json.nodes[e].isBone=!0;const t=i.inverseBindMatrices,r=(new s).set(t.slice(16*o,16*(o+1)));i.boneInverses.push(r),o++}this.skins.push(i)}}buildBones(e,t,r){r.name===e&&t.bones.push(r)}getJson(){return fetch(this.url).then(e=>e.json()).then(e=>{for(const t in e.buffers)this.scene.bin.push(e.buffers[t].uri);return this.json=e,!0})}initTextures(){if(!this.json.textures)return!0;const e=this.json.samplers||[{}];this.samplers=e.map(e=>{const t=ve.createSampler();return ve.samplerParameteri(t,ve.TEXTURE_MIN_FILTER,e.minFilter||9986),ve.samplerParameteri(t,ve.TEXTURE_MAG_FILTER,e.magFilter||9729),ve.samplerParameteri(t,ve.TEXTURE_WRAP_S,e.wrapS||10497),ve.samplerParameteri(t,ve.TEXTURE_WRAP_T,e.wrapT||10497),t});const t={};this.json.textures.forEach(e=>{const r=String(e.sampler)+String(e.source);t[r]=e,t[r].name=r,e.name=r});const r=Object.values(t).map(e=>new Promise((t,r)=>{const n=this.samplers[void 0!==e.sampler?e.sampler:0],i=this.json.images[e.source],s=new Image;s.onload=(()=>{t(this.handleTextureLoaded(n,s,e.name))}),s.onerror=(e=>{r(e)}),s.crossOrigin="anonymous",s.src=`${this.host}${i.uri}`}));return Promise.all(r).then(e=>(this.textures=this.json.textures.map(t=>e.find(e=>e.name===t.name)),!0))}handleTextureLoaded(e,t,r){const n=ve.createTexture();return n.name=r,n.image=t.src.substr(t.src.lastIndexOf("/")),n.sampler=e,ve.activeTexture(ve.TEXTURE31),ve.bindTexture(ve.TEXTURE_2D,n),ve.texImage2D(ve.TEXTURE_2D,0,ve.RGBA,ve.RGBA,ve.UNSIGNED_BYTE,t),ve.generateMipmap(ve.TEXTURE_2D),n}}var xe=r(12),be=r.n(xe),Ae=r(1),Fe=r.n(Ae);let _e;const Ue=4,Me=32;var Pe=r(13),we=r.n(Pe);let Be;var ye=r(14),Le=r.n(ye);let Se;const Ne={bloom:class extends X{setGL(e){Be=e}attachUniform(e){Be.uniform1i(Be.getUniformLocation(e,"bloom"),this.blurTexture.index)}postProcessing(e){Be.bindFramebuffer(Be.FRAMEBUFFER,this.framebuffer),Be.useProgram(this.bloorProgram),Be.framebufferTexture2D(Be.FRAMEBUFFER,Be.COLOR_ATTACHMENT0,Be.TEXTURE_2D,this.hdrTexture,0),Be.uniform1i(Be.getUniformLocation(this.bloorProgram,"diff"),e.screenTexture.index),Be.drawArrays(Be.TRIANGLES,0,6),Be.useProgram(this.program),Be.viewport(0,0,this.width/2,this.height/2),this.renderBlur(this.hdrTexture,this.program),this.renderBlur(this.blurTexture,this.program),this.renderBlur(this.blurTexture,this.program),this.renderBlur(this.blurTexture,this.program),this.renderBlur(this.blurTexture,this.program),Be.bindFramebuffer(Be.FRAMEBUFFER,null),Be.viewport(0,0,this.width,this.height)}buildScreenBuffer(e){return this.framebuffer=Be.createFramebuffer(),Be.bindFramebuffer(Be.FRAMEBUFFER,this.framebuffer),this.tempBlurTexture=e.createDefaultTexture(2),this.blurTexture=e.createDefaultTexture(2),this.hdrTexture=e.createByteTexture(),Be.bindFramebuffer(Be.FRAMEBUFFER,null),this.program=P(ue.a,Fe.a),this.bloorProgram=P(ue.a,we.a),{name:"BLOOM"}}renderBlur(e,t){Be.framebufferTexture2D(Be.FRAMEBUFFER,Be.COLOR_ATTACHMENT0,Be.TEXTURE_2D,this.tempBlurTexture,0),Be.clearColor(...v),Be.clear(Be.COLOR_BUFFER_BIT|Be.DEPTH_BUFFER_BIT|Be.STENSIL_BUFFER_BIT),Be.uniform1i(Be.getUniformLocation(t,"uTexture"),e.index),Be.uniform2f(Be.getUniformLocation(t,"denom"),1,0),Be.drawArrays(Be.TRIANGLES,0,6),Be.framebufferTexture2D(Be.FRAMEBUFFER,Be.COLOR_ATTACHMENT0,Be.TEXTURE_2D,this.blurTexture,0),Be.uniform1i(Be.getUniformLocation(t,"uTexture"),this.tempBlurTexture.index),Be.uniform2f(Be.getUniformLocation(t,"denom"),0,1),Be.drawArrays(Be.TRIANGLES,0,6)}preProcessing(){}},ssao:class extends X{constructor(){super(),this.scale=2}setGL(e){_e=e}attachUniform(e){_e.uniform1i(_e.getUniformLocation(e,"ssao"),this.ssaoTexture.index)}postProcessing(e){_e.bindFramebuffer(_e.FRAMEBUFFER,this.framebuffer),_e.framebufferTexture2D(_e.FRAMEBUFFER,_e.COLOR_ATTACHMENT0,_e.TEXTURE_2D,this.ssaoTexture,0),_e.clearColor(...v),_e.clear(_e.COLOR_BUFFER_BIT|_e.DEPTH_BUFFER_BIT),_e.useProgram(this.ssaoProgram);const t=this.camera.props.perspective||this.camera.props.orthographic;_e.uniform1i(_e.getUniformLocation(this.ssaoProgram,"normBuff"),e.normalTexture.index),_e.uniform1i(_e.getUniformLocation(this.ssaoProgram,"depthBuff"),e.depthTexture.index),_e.uniform1i(_e.getUniformLocation(this.ssaoProgram,"noice"),this.noice.index),_e.uniform2f(_e.getUniformLocation(this.ssaoProgram,"noiseScale"),this.width/this.scale/Ue,this.height/this.scale/Ue),_e.uniform1f(_e.getUniformLocation(this.ssaoProgram,"zFar"),t.zfar),_e.uniform1f(_e.getUniformLocation(this.ssaoProgram,"zNear"),t.znear),_e.uniformMatrix4fv(_e.getUniformLocation(this.ssaoProgram,"proj"),!1,this.camera.projection.elements),_e.uniformMatrix4fv(_e.getUniformLocation(this.ssaoProgram,"view"),!1,this.camera.matrixWorldInvert.elements),_e.uniformMatrix4fv(_e.getUniformLocation(this.ssaoProgram,"projI"),!1,(new s).setInverseOf(this.camera.projection).elements),_e.uniform3fv(_e.getUniformLocation(this.ssaoProgram,"kernels"),this.kernels),_e.viewport(0,0,this.width/this.scale,this.height/this.scale),_e.drawArrays(_e.TRIANGLES,0,6),_e.framebufferTexture2D(_e.FRAMEBUFFER,_e.COLOR_ATTACHMENT0,_e.TEXTURE_2D,this.ssaoBlurTexture,0),_e.clear(_e.COLOR_BUFFER_BIT|_e.DEPTH_BUFFER_BIT),_e.useProgram(this.ssaoBlurProgram),_e.uniform1i(_e.getUniformLocation(this.ssaoBlurProgram,"uTexture"),this.ssaoTexture.index),_e.uniform2f(_e.getUniformLocation(this.ssaoBlurProgram,"denom"),1,0),_e.drawArrays(_e.TRIANGLES,0,6),_e.framebufferTexture2D(_e.FRAMEBUFFER,_e.COLOR_ATTACHMENT0,_e.TEXTURE_2D,this.ssaoTexture,0),_e.uniform1i(_e.getUniformLocation(this.ssaoBlurProgram,"uTexture"),this.ssaoBlurTexture.index),_e.uniform2f(_e.getUniformLocation(this.ssaoBlurProgram,"denom"),0,1),_e.drawArrays(_e.TRIANGLES,0,6),_e.bindFramebuffer(_e.FRAMEBUFFER,null),_e.viewport(0,0,this.width,this.height)}buildScreenBuffer(e){return this.framebuffer=_e.createFramebuffer(),_e.bindFramebuffer(_e.FRAMEBUFFER,this.framebuffer),this.ssaoTexture=e.createOneChannelTexture(this.scale),this.ssaoBlurTexture=e.createOneChannelTexture(this.scale),_e.framebufferTexture2D(_e.FRAMEBUFFER,_e.COLOR_ATTACHMENT0,_e.TEXTURE_2D,this.ssaoTexture,0),this.ssaoProgram=P(ue.a,be.a),this.ssaoBlurProgram=P(ue.a,Fe.a),this.buildNoice(e),this.buildKernels(),_e.bindFramebuffer(_e.FRAMEBUFFER,null),{name:"SSAO"}}buildNoice(e){const t=new Float32Array(Ue*Ue*3);for(let e=0;e<Ue*Ue;e++){const r=new a([2*R(0,1)-1,2*R(0,1)-1,.1]);t[3*e]=r.elements[0],t[3*e+1]=r.elements[1],t[3*e+2]=r.elements[2]}this.noice=e.createNoiceTexture(Ue,t)}buildKernels(){const e=new Array(Me);for(let t=0;t<e.length;t++){e[t]=new a([2*R(0,1)-1,2*R(0,1)-1,R(0,1)]),e[t].normalize(),e[t].scale(R(0,1));let r=t/e.length;r=x(.1,1,r*r),e[t].scale(r)}this.kernels=new Float32Array(3*e.length);let t=0;for(const r of e)this.kernels.set(r.elements,3*t),t++}preProcessing(){}},shadow:$,light:q};class De{constructor(e,t){this.renderScene=t,this.postprocessors=e.map(e=>new Ne[e]),this.MSAA=4}setRenderer(e){this.renderer=e}setCamera(e){this.camera=e,this.postprocessors.forEach(t=>{t.setCamera(e)})}setLight(e){this.postprocessors.forEach(t=>{t.light=e})}setGl(e){e&&(Se=e,this.postprocessors.forEach(e=>{e.setGL(Se)}),this.fakeDepth=this.createNoiceTexture(1,new Float32Array([1,1,0])))}setCanvas(e){this.canvas=e,this.postprocessors.forEach(t=>{t.setCanvas(e)})}get width(){return this.canvas.offsetWidth*devicePixelRatio}get height(){return this.canvas.offsetHeight*devicePixelRatio}bindPrePass(){Se.bindFramebuffer(Se.FRAMEBUFFER,this.preframebuffer)}bindPostPass(){Se.bindFramebuffer(Se.FRAMEBUFFER,this.renderframebuffer)}preProcessing(){this.postprocessors.forEach(e=>e.preProcessing(this))}postProcessing(){Se.bindFramebuffer(Se.READ_FRAMEBUFFER,this.renderframebuffer),Se.bindFramebuffer(Se.DRAW_FRAMEBUFFER,this.framebuffer),Se.readBuffer(Se.COLOR_ATTACHMENT0),Se.drawBuffers([Se.COLOR_ATTACHMENT0]),Se.blitFramebuffer(0,0,this.width,this.height,0,0,this.width,this.height,Se.COLOR_BUFFER_BIT,Se.NEAREST),Se.readBuffer(Se.COLOR_ATTACHMENT1),Se.drawBuffers([Se.NONE,Se.COLOR_ATTACHMENT1]),Se.blitFramebuffer(0,0,this.width,this.height,0,0,this.width,this.height,Se.COLOR_BUFFER_BIT,Se.NEAREST),Se.blitFramebuffer(0,0,this.width,this.height,0,0,this.width,this.height,Se.DEPTH_BUFFER_BIT,Se.NEAREST),Se.bindVertexArray(this.VAO),this.postprocessors.forEach(e=>e.postProcessing(this)),Se.bindFramebuffer(Se.FRAMEBUFFER,null),Se.useProgram(this.program),this.postprocessors.forEach(e=>{e.attachUniform(this.program)}),Se.uniform1i(Se.getUniformLocation(this.program,"original"),this.screenTexture.index),Se.uniform1i(Se.getUniformLocation(this.program,"normal"),this.normalTexture.index),Se.uniform1i(Se.getUniformLocation(this.program,"depth"),this.depthTexture.index),Se.uniform1i(Se.getUniformLocation(this.program,"preDepth"),this.preDepthTexture.index),Se.drawArrays(Se.TRIANGLES,0,6)}createByteTexture(){const e=w();return Se.texParameteri(Se.TEXTURE_2D,Se.TEXTURE_MAG_FILTER,Se.NEAREST),Se.texParameteri(Se.TEXTURE_2D,Se.TEXTURE_MIN_FILTER,Se.NEAREST),Se.texImage2D(Se.TEXTURE_2D,0,Se.RGBA,this.width,this.height,0,Se.RGBA,Se.UNSIGNED_BYTE,null),e}createDefaultTexture(e=1){const t=w();return Se.texParameteri(Se.TEXTURE_2D,Se.TEXTURE_MAG_FILTER,Se.NEAREST),Se.texParameteri(Se.TEXTURE_2D,Se.TEXTURE_MIN_FILTER,Se.NEAREST),Se.texImage2D(Se.TEXTURE_2D,0,Se.RGBA16F,this.width/e,this.height/e,0,Se.RGBA,Se.FLOAT,null),t}createOneChannelTexture(e=1){const t=w();return Se.texParameteri(Se.TEXTURE_2D,Se.TEXTURE_MAG_FILTER,Se.LINEAR),Se.texParameteri(Se.TEXTURE_2D,Se.TEXTURE_MIN_FILTER,Se.LINEAR),Se.texImage2D(Se.TEXTURE_2D,0,Se.R8,this.width/e,this.height/e,0,Se.RED,Se.UNSIGNED_BYTE,null),t}createDepthTexture(){const e=w();return Se.texParameteri(Se.TEXTURE_2D,Se.TEXTURE_MAG_FILTER,Se.NEAREST),Se.texParameteri(Se.TEXTURE_2D,Se.TEXTURE_MIN_FILTER,Se.NEAREST),Se.texImage2D(Se.TEXTURE_2D,0,Se.DEPTH_COMPONENT24,this.width,this.height,0,Se.DEPTH_COMPONENT,Se.UNSIGNED_INT,null),e}createNoiceTexture(e,t){const r=w();return Se.texParameteri(Se.TEXTURE_2D,Se.TEXTURE_MAG_FILTER,Se.NEAREST),Se.texParameteri(Se.TEXTURE_2D,Se.TEXTURE_MIN_FILTER,Se.NEAREST),Se.texParameteri(Se.TEXTURE_2D,Se.TEXTURE_WRAP_S,Se.REPEAT),Se.texParameteri(Se.TEXTURE_2D,Se.TEXTURE_WRAP_T,Se.REPEAT),Se.texImage2D(Se.TEXTURE_2D,0,Se.RGB16F,e,e,0,Se.RGB,Se.FLOAT,t),r}buildScreenBuffer(){if(Se.getExtension("EXT_color_buffer_float"),Se.getExtension("OES_texture_float_linear"),0===this.postprocessors.length)return!0;const e=this.postprocessors.map(e=>e.buildScreenBuffer(this)).map(e=>`#define ${e.name} ${e.value||1}`+"\n").join("");this.VAO=Se.createVertexArray(),Se.bindVertexArray(this.VAO);const t=Se.createBuffer();Se.bindBuffer(Se.ARRAY_BUFFER,t),Se.bufferData(Se.ARRAY_BUFFER,new Float32Array([1,1,-1,1,-1,-1,-1,-1,1,-1,1,1]),Se.STATIC_DRAW),Se.enableVertexAttribArray(0),Se.vertexAttribPointer(0,2,Se.FLOAT,!1,0,0),Se.bindVertexArray(null);const r=Se.createRenderbuffer();Se.bindRenderbuffer(Se.RENDERBUFFER,r),Se.renderbufferStorageMultisample(Se.RENDERBUFFER,this.MSAA,Se.RGBA16F,this.width,this.height);const n=Se.createRenderbuffer();Se.bindRenderbuffer(Se.RENDERBUFFER,n),Se.renderbufferStorageMultisample(Se.RENDERBUFFER,this.MSAA,Se.RGBA16F,this.width,this.height);const i=Se.createRenderbuffer();Se.bindRenderbuffer(Se.RENDERBUFFER,i),Se.renderbufferStorageMultisample(Se.RENDERBUFFER,this.MSAA,Se.DEPTH_COMPONENT24,this.width,this.height),this.renderframebuffer=Se.createFramebuffer(),Se.bindFramebuffer(Se.FRAMEBUFFER,this.renderframebuffer),Se.framebufferRenderbuffer(Se.FRAMEBUFFER,Se.COLOR_ATTACHMENT0,Se.RENDERBUFFER,r),Se.framebufferRenderbuffer(Se.FRAMEBUFFER,Se.COLOR_ATTACHMENT1,Se.RENDERBUFFER,n),Se.framebufferRenderbuffer(Se.FRAMEBUFFER,Se.DEPTH_ATTACHMENT,Se.RENDERBUFFER,i),Se.drawBuffers([Se.COLOR_ATTACHMENT0,Se.COLOR_ATTACHMENT1]),this.framebuffer=Se.createFramebuffer(),Se.bindFramebuffer(Se.FRAMEBUFFER,this.framebuffer),this.screenTexture=this.createDefaultTexture(),this.normalTexture=this.createDefaultTexture(),this.depthTexture=this.createDepthTexture(),Se.framebufferTexture2D(Se.FRAMEBUFFER,Se.COLOR_ATTACHMENT0,Se.TEXTURE_2D,this.screenTexture,0),Se.framebufferTexture2D(Se.FRAMEBUFFER,Se.COLOR_ATTACHMENT1,Se.TEXTURE_2D,this.normalTexture,0),Se.framebufferTexture2D(Se.FRAMEBUFFER,Se.DEPTH_ATTACHMENT,Se.TEXTURE_2D,this.depthTexture,0),Se.drawBuffers([Se.COLOR_ATTACHMENT0,Se.COLOR_ATTACHMENT1]),Se.bindFramebuffer(Se.FRAMEBUFFER,null),this.preframebuffer=Se.createFramebuffer(),Se.bindFramebuffer(Se.FRAMEBUFFER,this.preframebuffer),this.preDepthTexture=this.createDepthTexture(),Se.framebufferTexture2D(Se.FRAMEBUFFER,Se.DEPTH_ATTACHMENT,Se.TEXTURE_2D,this.preDepthTexture,0),Se.bindFramebuffer(Se.FRAMEBUFFER,null),this.program=P(ue.a.replace(/\n/,`\n${e}`),Le.a.replace(/\n/,`\n${e}`))}clear(){console.error("implement")}}function Ce(e,t,r){this.x=e,this.y=t,this.z=r}Ce.prototype.dot2=function(e,t){return this.x*e+this.y*t},Ce.prototype.dot3=function(e,t,r){return this.x*e+this.y*t+this.z*r};var Oe=[new Ce(1,1,0),new Ce(-1,1,0),new Ce(1,-1,0),new Ce(-1,-1,0),new Ce(1,0,1),new Ce(-1,0,1),new Ce(1,0,-1),new Ce(-1,0,-1),new Ce(0,1,1),new Ce(0,-1,1),new Ce(0,1,-1),new Ce(0,-1,-1)],Ie=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],Ve=new Array(512),Xe=new Array(512);!function(e){e>0&&e<1&&(e*=65536),(e=Math.floor(e))<256&&(e|=e<<8);for(var t=0;t<256;t++){var r;r=1&t?Ie[t]^255&e:Ie[t]^e>>8&255,Ve[t]=Ve[t+256]=r,Xe[t]=Xe[t+256]=Oe[r%12]}}(0);Math.sqrt(3),Math.sqrt(3);function Ge(e){return e*e*e*(e*(6*e-15)+10)}function ke(e,t,r){return(1-r)*e+r*t}function He(e,t,r){var n=Math.floor(e),i=Math.floor(t),s=Math.floor(r);e-=n,t-=i,r-=s;var o=Xe[(n&=255)+Ve[(i&=255)+Ve[s&=255]]].dot3(e,t,r),a=Xe[n+Ve[i+Ve[s+1]]].dot3(e,t,r-1),l=Xe[n+Ve[i+1+Ve[s]]].dot3(e,t-1,r),c=Xe[n+Ve[i+1+Ve[s+1]]].dot3(e,t-1,r-1),h=Xe[n+1+Ve[i+Ve[s]]].dot3(e-1,t,r),u=Xe[n+1+Ve[i+Ve[s+1]]].dot3(e-1,t,r-1),f=Xe[n+1+Ve[i+1+Ve[s]]].dot3(e-1,t-1,r),m=Xe[n+1+Ve[i+1+Ve[s+1]]].dot3(e-1,t-1,r-1),d=Ge(e),p=Ge(t),T=Ge(r);return ke(ke(ke(o,h,d),ke(a,u,d),T),ke(ke(l,f,d),ke(c,m,d),T),p)}var ze=r(15),je=r.n(ze),We=r(16),Ye=r.n(We),qe=r(17),$e=r.n(qe),Ke=r(18),Je=r.n(Ke);let Ze;const Qe=1e3;class et{constructor(e){this.getLight=e}setGl(e){Ze=e}setCamera(e){this.camera=e}build(){this.currentSourceIdx=0;const e=Ze.createProgram();M(Ze.VERTEX_SHADER,Je.a,e),M(Ze.FRAGMENT_SHADER,$e.a,e);Ze.transformFeedbackVaryings(e,["v_position","v_velocity","v_spawntime","v_lifetime"],Ze.SEPARATE_ATTRIBS),Ze.linkProgram(e),this.program=e;const t=P(je.a,Ye.a);this.program2=t;const r=[Ze.createVertexArray(),Ze.createVertexArray()],n=[Ze.createTransformFeedback(),Ze.createTransformFeedback()];this.VAO=r,this.TFO=n;for(const e of[0,1]){Ze.bindVertexArray(r[e]);const t=[];{const e=new Float32Array(3*Qe);for(let t=0;t<Qe;t++)e[3*t]=0,e[3*t+1]=0,e[3*t+2]=0;const r=Ze.createBuffer();Ze.bindBuffer(Ze.ARRAY_BUFFER,r),Ze.bufferData(Ze.ARRAY_BUFFER,e,Ze.STREAM_COPY),Ze.enableVertexAttribArray(0),Ze.vertexAttribPointer(0,3,Ze.FLOAT,!1,0,0),Ze.vertexAttribDivisor(0,1),t.push(r)}{const e=new Float32Array(3*Qe);for(let t=0;t<Qe;t++)e[3*t]=0,e[3*t+1]=0,e[3*t+2]=0;const r=Ze.createBuffer();Ze.bindBuffer(Ze.ARRAY_BUFFER,r),Ze.bufferData(Ze.ARRAY_BUFFER,e,Ze.STREAM_COPY),Ze.enableVertexAttribArray(1),Ze.vertexAttribPointer(1,3,Ze.FLOAT,!1,0,0),Ze.vertexAttribDivisor(1,1),t.push(r)}{const e=new Float32Array(1*Qe);for(let t=0;t<Qe;t++)e[2*t]=0;const r=Ze.createBuffer();Ze.bindBuffer(Ze.ARRAY_BUFFER,r),Ze.bufferData(Ze.ARRAY_BUFFER,e,Ze.STREAM_COPY),Ze.enableVertexAttribArray(2),Ze.vertexAttribPointer(2,1,Ze.FLOAT,!1,0,0),Ze.vertexAttribDivisor(2,1),t.push(r)}{const e=new Float32Array(1*Qe);for(let t=0;t<Qe;t++)e[2*t]=0;const r=Ze.createBuffer();Ze.bindBuffer(Ze.ARRAY_BUFFER,r),Ze.bufferData(Ze.ARRAY_BUFFER,e,Ze.STREAM_COPY),Ze.enableVertexAttribArray(3),Ze.vertexAttribPointer(3,1,Ze.FLOAT,!1,0,0),Ze.vertexAttribDivisor(3,1),t.push(r)}Ze.bindBuffer(Ze.ARRAY_BUFFER,null),Ze.bindTransformFeedback(Ze.TRANSFORM_FEEDBACK,n[e]);let i=0;for(const e of t)Ze.bindBufferBase(Ze.TRANSFORM_FEEDBACK_BUFFER,i,e),i++}const i=new Uint8Array(2097152);for(let e=0;e<128;++e)for(let t=0;t<128;++t)for(let r=0;r<128;++r){let n=He(r/8,t/8,e/8);n=128*(1+n),i[r+128*t+128*e*128]=n}this.texture3d=w(Ze.TEXTURE_3D),Ze.texParameteri(Ze.TEXTURE_3D,Ze.TEXTURE_BASE_LEVEL,0),Ze.texParameteri(Ze.TEXTURE_3D,Ze.TEXTURE_MAX_LEVEL,Math.log2(128)),Ze.texParameteri(Ze.TEXTURE_3D,Ze.TEXTURE_MIN_FILTER,Ze.LINEAR_MIPMAP_LINEAR),Ze.texParameteri(Ze.TEXTURE_3D,Ze.TEXTURE_MAG_FILTER,Ze.LINEAR),Ze.texImage3D(Ze.TEXTURE_3D,0,Ze.R8,128,128,128,0,Ze.RED,Ze.UNSIGNED_BYTE,i),Ze.generateMipmap(Ze.TEXTURE_3D)}draw(e){const t=(this.currentSourceIdx+1)%2;Ze.useProgram(this.program),Ze.bindVertexArray(this.VAO[this.currentSourceIdx]),Ze.bindTransformFeedback(Ze.TRANSFORM_FEEDBACK,this.TFO[t]);const r=new s;r.multiply(this.camera.projection),r.multiply(this.camera.matrixWorldInvert),Ze.uniform1f(Ze.getUniformLocation(this.program,"u_time"),e+5e3),Ze.uniform1f(Ze.getUniformLocation(this.program,"count"),Qe),Ze.uniform1i(Ze.getUniformLocation(this.program,"noize"),this.texture3d.index),Ze.enable(Ze.RASTERIZER_DISCARD),Ze.beginTransformFeedback(Ze.POINTS),Ze.drawArraysInstanced(Ze.POINTS,0,1,Qe),Ze.endTransformFeedback(),Ze.disable(Ze.RASTERIZER_DISCARD),Ze.bindTransformFeedback(Ze.TRANSFORM_FEEDBACK,null),Ze.bindBuffer(Ze.TRANSFORM_FEEDBACK_BUFFER,null);const n=Ze.fenceSync(Ze.SYNC_GPU_COMMANDS_COMPLETE,0);Ze.waitSync(n,0,Ze.TIMEOUT_IGNORED),Ze.deleteSync(n),Ze.useProgram(this.program2),Ze.bindVertexArray(this.VAO[t]),Ze.uniformMatrix4fv(Ze.getUniformLocation(this.program2,"MVPMatrix"),!1,r.elements),Ze.uniform1i(Ze.getUniformLocation(this.program2,"light"),this.getLight()),Ze.drawArraysInstanced(Ze.POINTS,0,1,Qe),this.currentSourceIdx=(this.currentSourceIdx+1)%2}}let tt;r.d(t,"RedCube",function(){return nt});const rt=15;class nt{constructor(e,t,r,i,s){this.canvas=t,this.processors=r;const o=[];0===r.length&&o.push({name:"TONE"}),r.some(e=>"shadow"===e)&&o.push({name:"SHADOWMAP"}),"pbr"===s&&o.push({name:"USE_PBR"}),this.ioc=new n,this.ioc.register("env",me,["camera","canvas","gl"],i),this.ioc.register("camera",C,[],{type:"perspective",isInitial:!0,zoom:1,aspect:this.canvas.offsetWidth/this.canvas.offsetHeight,perspective:{yfov:rt*Math.PI/180}}),this.ioc.register("canvas",t),this.ioc.register("scene",u),this.ioc.register("light",O),this.ioc.register("pp",De,["light","camera","canvas","gl"],r,this.renderScene.bind(this)),this.ioc.register("parser",Re,["scene","light","camera","canvas","gl"],e,o,this.resize.bind(this)),this.ioc.register("particles",et,["camera","gl"],()=>{return this.PP.postprocessors.find(e=>e instanceof q).texture.index}),this.ioc.register("renderer",K,["gl","parser","pp","scene","camera","particles","env"],this.getState.bind(this)),this.events=new J(this.redraw.bind(this))}get renderer(){return this.ioc.get("renderer")}get scene(){return this.ioc.get("scene")}get camera(){return this.ioc.get("camera")}get light(){return this.ioc.get("light")}get env(){return this.ioc.get("env")}get PP(){return this.ioc.get("pp")}get Particles(){return this.ioc.get("particles")}get parse(){return this.ioc.get("parser")}async init(e){await this.parse.getJson(),this.glInit(),this.Particles.build(),await this.parse.initTextures(),this.PP.buildScreenBuffer(),await this.parse.getBuffer(),this.parse.buildSkin(),this.parse.buildMesh(),this.resize(null),this.parse.buildAnimation(),await this.env.createEnvironmentBuffer(),this.draw(),e()}renderScene(...e){this.renderer.renderScene(...e)}redraw(e,t,r){"zoom"===e&&(this.camera.zoom(t),this.renderer.needUpdateProjection=!0),"rotate"===e&&(this.camera.rotate(t,r,this.canvas.offsetWidth,this.canvas.offsetHeight),this.renderer.needUpdateView=!0),"pan"===e&&(this.camera.pan(t,r,this.canvas.offsetWidth,this.canvas.offsetHeight),this.renderer.needUpdateView=!0),"resize"===e&&(this.resize(e),this.renderer.needUpdateProjection=!0),this.renderer.reflow=!0}resize(e){if(this.camera.props.aspect=this.canvas.offsetWidth/this.canvas.offsetHeight,this.canvas.width=this.canvas.offsetWidth*devicePixelRatio,this.canvas.height=this.canvas.offsetHeight*devicePixelRatio,tt.viewport(0,0,this.canvas.offsetWidth*devicePixelRatio,this.canvas.offsetHeight*devicePixelRatio),this.camera.props.isInitial){const e=1e4/this.canvas.width*this.camera.modelSize*devicePixelRatio;this.camera.setZ(e),this.light.setZ(e),this.light.update(Math.PI/2),this.renderer.needUpdateView=!0}else this.light.setZ(this.camera.matrixWorld.elements[14]),this.light.update(Math.PI/2),this.renderer.needUpdateView=!0;this.camera.updateNF(),e&&(this.PP.clear(),this.PP.buildScreenBuffer())}glInit(){if(tt=this.canvas.getContext("webgl2",{antialias:0===this.processors.length}),this.gl=tt,!tt)throw new Error("Webgl 2 doesnt support");!function(e){E=e;for(const e in E){const t=E[e];"number"==typeof t&&(T[t]=e)}}(tt),this.ioc.register("gl",tt)}draw(){tt.clearColor(...v),this.renderer.render()}getState(){return{camera:this.camera,light:this.light,preDepthTexture:this.PP.preDepthTexture,fakeDepth:this.PP.fakeDepth,needUpdateView:this.renderer.needUpdateView,needUpdateProjection:this.renderer.needUpdateProjection,irradiancemap:this.env.irradiancemap,prefilterMap:this.env.prefilterMap,brdfLUT:this.env.brdfLUTTexture}}}}])});
//# sourceMappingURL=redcube.js.map