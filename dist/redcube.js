!function(e,r){"object"==typeof exports&&"object"==typeof module?module.exports=r():"function"==typeof define&&define.amd?define("redcube",[],r):"object"==typeof exports?exports.redcube=r():e.redcube=r()}(self,()=>(()=>{var e,r,t={603:()=>{},843:e=>{e.exports=function(e){e instanceof ArrayBuffer&&(e=new Uint8Array(e));var r=0,t=e.length;function n(){var n="";do{var i=e[r];if(10==i){++r;break}n+=String.fromCharCode(i)}while(++r<t);return n}for(var i=0,s=0,o=1,a=!1,c=0;c<20;c++){var l,u=n();if(l=u.match("#\\?RADIANCE"));else if(l=u.match("FORMAT=32-bit_rle_rgbe"))a=!0;else if(l=u.match("EXPOSURE=\\s*([0-9]*[.][0-9]*)"))o=Number(l[1]);else if(l=u.match("#.*"));else if(l=u.match("-Y ([0-9]+) \\+X ([0-9]+)")){s=Number(l[1]),i=Number(l[2]);break}}if(!a)throw new Error("File is not run length encoded!");var f=new Uint8Array(i*s*4);!function(e,r,t,n,i,s){var o,a,c,l=new Array(4),u=null,f=new Array(2),h=e.length;function m(r){var t=0;do{r[t++]=e[n]}while(++n<h&&t<r.length);return t}function T(r,t,i){var s=0;do{r[t+s++]=e[n]}while(++n<h&&s<i);return s}function d(e,r,t,n){var i=4*n,s=T(r,t,i);if(s<i)throw new Error("Error reading raw pixels: got "+s+" bytes, expected "+i)}for(;s>0;){if(m(l)<l.length)throw new Error("Error reading bytes: expected "+l.length);if(2!=l[0]||2!=l[1]||128&l[2])return r[t++]=l[0],r[t++]=l[1],r[t++]=l[2],r[t++]=l[3],void d(0,r,t,i*s-1);if(((255&l[2])<<8|255&l[3])!=i)throw new Error("Wrong scanline width "+((255&l[2])<<8|255&l[3])+", expected "+i);null==u&&(u=new Array(4*i)),o=0;for(var E=0;E<4;E++)for(a=(E+1)*i;o<a;){if(m(f)<f.length)throw new Error("Error reading 2-byte buffer");if((255&f[0])>128){if(0==(c=(255&f[0])-128)||c>a-o)throw new Error("Bad scanline data");for(;c-- >0;)u[o++]=f[1]}else{if(0==(c=255&f[0])||c>a-o)throw new Error("Bad scanline data");if(u[o++]=f[1],--c>0){if(T(u,o,c)<c)throw new Error("Error reading non-run data");o+=c}}}for(E=0;E<i;E++)r[t+0]=u[E],r[t+1]=u[E+i],r[t+2]=u[E+2*i],r[t+3]=u[E+3*i],t+=4;s--}}(e,f,0,r,i,s);for(var h=new Float32Array(i*s*4),m=0;m<f.length;m+=4){var T=f[m+0]/255,d=f[m+1]/255,E=f[m+2]/255,p=f[m+3],R=Math.pow(2,p-128);T*=R,d*=R,E*=R;var x=m;h[x+0]=T,h[x+1]=d,h[x+2]=E,h[x+3]=1}return{shape:[i,s],exposure:o,gamma:1,data:h}}}},n={};function i(e){var r=n[e];if(void 0!==r)return r.exports;var s=n[e]={exports:{}};return t[e](s,s.exports,i),s.exports}i.m=t,i.n=e=>{var r=e&&e.__esModule?()=>e.default:()=>e;return i.d(r,{a:r}),r},i.d=(e,r)=>{for(var t in r)i.o(r,t)&&!i.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:r[t]})},i.f={},i.e=e=>Promise.all(Object.keys(i.f).reduce((r,t)=>(i.f[t](e,r),r),[])),i.u=e=>"libs/"+{621:"draco3d",971:"libktx"}[e]+".js",i.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),i.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r),e={},r="redcube:",i.l=(t,n,s,o)=>{if(e[t])e[t].push(n);else{var a,c;if(void 0!==s)for(var l=document.getElementsByTagName("script"),u=0;u<l.length;u++){var f=l[u];if(f.getAttribute("src")==t||f.getAttribute("data-webpack")==r+s){a=f;break}}a||(c=!0,(a=document.createElement("script")).charset="utf-8",a.timeout=120,i.nc&&a.setAttribute("nonce",i.nc),a.setAttribute("data-webpack",r+s),a.src=t),e[t]=[n];var h=(r,n)=>{a.onerror=a.onload=null,clearTimeout(m);var i=e[t];if(delete e[t],a.parentNode&&a.parentNode.removeChild(a),i&&i.forEach(e=>e(n)),r)return r(n)},m=setTimeout(h.bind(null,void 0,{type:"timeout",target:a}),12e4);a.onerror=h.bind(null,a.onerror),a.onload=h.bind(null,a.onload),c&&document.head.appendChild(a)}},i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e;i.g.importScripts&&(e=i.g.location+"");var r=i.g.document;if(!e&&r&&(r.currentScript&&"SCRIPT"===r.currentScript.tagName.toUpperCase()&&(e=r.currentScript.src),!e)){var t=r.getElementsByTagName("script");if(t.length)for(var n=t.length-1;n>-1&&(!e||!/^http(s?):/.test(e));)e=t[n--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/^blob:/,"").replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),i.p=e})(),(()=>{var e={792:0};i.f.j=(r,t)=>{var n=i.o(e,r)?e[r]:void 0;if(0!==n)if(n)t.push(n[2]);else{var s=new Promise((t,i)=>n=e[r]=[t,i]);t.push(n[2]=s);var o=i.p+i.u(r),a=new Error;i.l(o,t=>{if(i.o(e,r)&&(0!==(n=e[r])&&(e[r]=void 0),n)){var s=t&&("load"===t.type?"missing":t.type),o=t&&t.target&&t.target.src;a.message="Loading chunk "+r+" failed.\n("+s+": "+o+")",a.name="ChunkLoadError",a.type=s,a.request=o,n[1](a)}},"chunk-"+r,r)}};var r=(r,t)=>{var n,s,[o,a,c]=t,l=0;if(o.some(r=>0!==e[r])){for(n in a)i.o(a,n)&&(i.m[n]=a[n]);c&&c(i)}for(r&&r(t);l<o.length;l++)s=o[l],i.o(e,s)&&e[s]&&e[s][0](),e[s]=0},t=self.webpackChunkredcube=self.webpackChunkredcube||[];t.forEach(r.bind(null,0)),t.push=r.bind(null,t.push.bind(t))})();var s={};return(()=>{"use strict";i.r(s),i.d(s,{RedCube:()=>He});class e{_services;_singletons;constructor(){this._services=new Map,this._singletons=new Map,this.update=this.update.bind(this)}register(e,r,t=[],...n){this._services.set(e,{definition:r,dependencies:t,args:n}),this._isClass(r)?r.__update=this.update:this._updateDep(e,r)}get(e){const r=this._services.get(e);if(!r)return null;if(this._isClass(r.definition)){const t=this._singletons.get(e);if(t)return t;{const t=this._createInstance(r);return this._singletons.set(e,t),t}}return r.definition}update(e,...r){this._services.get(e).args=r,this._singletons.delete(e);const t=this.get(e);this._updateDep(e,t)}_updateDep(e,r){for(const[t,n]of this._singletons)this._services.get(t).dependencies.some(r=>r===e)&&n[`set${e.charAt(0).toUpperCase()+e.slice(1)}`].call(n,r);this._singletons.set(e,r)}_getResolvedDependencies(e){let r=[];return e.dependencies&&(r=e.dependencies.map(e=>[e,this.get(e)])),r}_createInstance(e){const r=new e.definition(...e.args);return this._getResolvedDependencies(e).forEach(([e,t])=>{r[`set${e.charAt(0).toUpperCase()+e.slice(1)}`].call(r,t)}),r}_isClass(e){return"function"==typeof e&&/^class\s/.test(Function.prototype.toString.call(e))}}class r{elements;constructor(e){let r,t,n;if(e&&"object"==typeof e&&e.hasOwnProperty("elements")){for(t=e.elements,n=new Float32Array(16),r=0;r<16;++r)n[r]=t[r];this.elements=n}else this.elements=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}set(e){let r,t,n;if(t=e,n=this.elements,t!==n){for(r=0;r<16;++r)n[r]=t[r];return this}}multiply(e){return this.concat(e),this}concat({elements:e}){let r,t,n,i,s,o,a,c;if(t=this.elements,n=this.elements,i=e,t===i)for(i=new Float32Array(16),r=0;r<16;++r)i[r]=t[r];for(r=0;r<4;r++)s=n[r],o=n[r+4],a=n[r+8],c=n[r+12],t[r]=s*i[0]+o*i[1]+a*i[2]+c*i[3],t[r+4]=s*i[4]+o*i[5]+a*i[6]+c*i[7],t[r+8]=s*i[8]+o*i[9]+a*i[10]+c*i[11],t[r+12]=s*i[12]+o*i[13]+a*i[14]+c*i[15];return this}setInverseOf({elements:e}){let r,t,n,i,s;if(t=e,n=this.elements,i=new Float32Array(16),i[0]=t[5]*t[10]*t[15]-t[5]*t[11]*t[14]-t[9]*t[6]*t[15]+t[9]*t[7]*t[14]+t[13]*t[6]*t[11]-t[13]*t[7]*t[10],i[4]=-t[4]*t[10]*t[15]+t[4]*t[11]*t[14]+t[8]*t[6]*t[15]-t[8]*t[7]*t[14]-t[12]*t[6]*t[11]+t[12]*t[7]*t[10],i[8]=t[4]*t[9]*t[15]-t[4]*t[11]*t[13]-t[8]*t[5]*t[15]+t[8]*t[7]*t[13]+t[12]*t[5]*t[11]-t[12]*t[7]*t[9],i[12]=-t[4]*t[9]*t[14]+t[4]*t[10]*t[13]+t[8]*t[5]*t[14]-t[8]*t[6]*t[13]-t[12]*t[5]*t[10]+t[12]*t[6]*t[9],i[1]=-t[1]*t[10]*t[15]+t[1]*t[11]*t[14]+t[9]*t[2]*t[15]-t[9]*t[3]*t[14]-t[13]*t[2]*t[11]+t[13]*t[3]*t[10],i[5]=t[0]*t[10]*t[15]-t[0]*t[11]*t[14]-t[8]*t[2]*t[15]+t[8]*t[3]*t[14]+t[12]*t[2]*t[11]-t[12]*t[3]*t[10],i[9]=-t[0]*t[9]*t[15]+t[0]*t[11]*t[13]+t[8]*t[1]*t[15]-t[8]*t[3]*t[13]-t[12]*t[1]*t[11]+t[12]*t[3]*t[9],i[13]=t[0]*t[9]*t[14]-t[0]*t[10]*t[13]-t[8]*t[1]*t[14]+t[8]*t[2]*t[13]+t[12]*t[1]*t[10]-t[12]*t[2]*t[9],i[2]=t[1]*t[6]*t[15]-t[1]*t[7]*t[14]-t[5]*t[2]*t[15]+t[5]*t[3]*t[14]+t[13]*t[2]*t[7]-t[13]*t[3]*t[6],i[6]=-t[0]*t[6]*t[15]+t[0]*t[7]*t[14]+t[4]*t[2]*t[15]-t[4]*t[3]*t[14]-t[12]*t[2]*t[7]+t[12]*t[3]*t[6],i[10]=t[0]*t[5]*t[15]-t[0]*t[7]*t[13]-t[4]*t[1]*t[15]+t[4]*t[3]*t[13]+t[12]*t[1]*t[7]-t[12]*t[3]*t[5],i[14]=-t[0]*t[5]*t[14]+t[0]*t[6]*t[13]+t[4]*t[1]*t[14]-t[4]*t[2]*t[13]-t[12]*t[1]*t[6]+t[12]*t[2]*t[5],i[3]=-t[1]*t[6]*t[11]+t[1]*t[7]*t[10]+t[5]*t[2]*t[11]-t[5]*t[3]*t[10]-t[9]*t[2]*t[7]+t[9]*t[3]*t[6],i[7]=t[0]*t[6]*t[11]-t[0]*t[7]*t[10]-t[4]*t[2]*t[11]+t[4]*t[3]*t[10]+t[8]*t[2]*t[7]-t[8]*t[3]*t[6],i[11]=-t[0]*t[5]*t[11]+t[0]*t[7]*t[9]+t[4]*t[1]*t[11]-t[4]*t[3]*t[9]-t[8]*t[1]*t[7]+t[8]*t[3]*t[5],i[15]=t[0]*t[5]*t[10]-t[0]*t[6]*t[9]-t[4]*t[1]*t[10]+t[4]*t[2]*t[9]+t[8]*t[1]*t[6]-t[8]*t[2]*t[5],s=t[0]*i[0]+t[1]*i[4]+t[2]*i[8]+t[3]*i[12],0===s)return this;for(s=1/s,r=0;r<16;r++)n[r]=i[r]*s;return this}invert(){return this.setInverseOf(this)}makeOrthographic(e,r,t,n,i,s){var o=this.elements,a=1/(r-e),c=1/(t-n),l=1/(s-i),u=(r+e)*a,f=(t+n)*c,h=(s+i)*l;return o[0]=2*a,o[4]=0,o[8]=0,o[12]=-u,o[1]=0,o[5]=2*c,o[9]=0,o[13]=-f,o[2]=0,o[6]=0,o[10]=-2*l,o[14]=-h,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}setOrtho(e,r,t,n){let i,s,o,a;return s=1/e,o=1/r,a=2/(t-n),i=this.elements,i[0]=s,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=o,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=a,i[11]=(n+t)/(t-n),i[12]=0,i[13]=0,i[14]=0,i[15]=1,this}setPerspective(e,r,t,n){let i,s,o,a;if(t===n||0===r)throw"null frustum";if(t<=0)throw"near <= 0";if(n<=0)throw"far <= 0";if(e/=2,o=Math.sin(e),0===o)throw"null frustum";return s=1/(n-t),a=Math.cos(e)/o,i=this.elements,i[0]=a/r,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=a,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=-(n+t)*s,i[11]=-1,i[12]=0,i[13]=0,i[14]=-2*t*n*s,i[15]=0,this}perspective(e,t,n,i){return this.concat((new r).setPerspective(e,t,n,i))}multiplyVector4({elements:e}){const r=this.elements,t=e,n=new a,i=n.elements;return i[0]=t[0]*r[0]+t[1]*r[4]+t[2]*r[8]+t[3]*r[12],i[1]=t[0]*r[1]+t[1]*r[5]+t[2]*r[9]+t[3]*r[13],i[2]=t[0]*r[2]+t[1]*r[6]+t[2]*r[10]+t[3]*r[14],i[3]=t[0]*r[3]+t[1]*r[7]+t[2]*r[11]+t[3]*r[15],n}getScaling(){let e=this.elements,r=e[0],t=e[1],i=e[2],s=e[4],o=e[5],a=e[6],c=e[8],l=e[9],u=e[10];return new n([Math.sqrt(r*r+t*t+i*i),Math.sqrt(s*s+o*o+a*a),Math.sqrt(c*c+l*l+u*u)])}scale(e){const r=e.elements[0],t=e.elements[1],n=e.elements[2],i=this.elements;return i[0]*=r,i[4]*=t,i[8]*=n,i[1]*=r,i[5]*=t,i[9]*=n,i[2]*=r,i[6]*=t,i[10]*=n,i[3]*=r,i[7]*=t,i[11]*=n,this}restoreScale(e){const r=e.elements[0],t=e.elements[1],n=e.elements[2],i=this.elements;return i[0]/=r,i[4]/=t,i[8]/=n,i[1]/=r,i[5]/=t,i[9]/=n,i[2]/=r,i[6]/=t,i[10]/=n,i[3]/=r,i[7]/=t,i[11]/=n,this}setTranslate(e){const r=this.elements,t=e.elements[0],n=e.elements[1],i=e.elements[2];return r[12]=t,r[13]=n,r[14]=i,r[15]=1,this}translate(e,r,t){const n=this.elements;return n[12]+=n[0]*e+n[4]*r+n[8]*t,n[13]+=n[1]*e+n[5]*r+n[9]*t,n[14]+=n[2]*e+n[6]*r+n[10]*t,n[15]+=n[3]*e+n[7]*r+n[11]*t,this}getMaxScaleOnAxis(){const e=this.elements,r=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],t=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],n=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(r,t,n))}rotate(e,r){let t,n,i,s,o,a,c,l,u,f,h,m,T,d,E,p,R,x,_,A,g,v,S,b,F=e.elements[0],U=e.elements[1],M=e.elements[2],I=Math.hypot(F,U,M);if(I<Number.EPSILON)return null;I=1/I,F*=I,U*=I,M*=I,t=Math.sin(r),n=Math.cos(r),i=1-n;let N=this.elements;return s=N[0],o=N[1],a=N[2],c=N[3],l=N[4],u=N[5],f=N[6],h=N[7],m=N[8],T=N[9],d=N[10],E=N[11],p=F*F*i+n,R=U*F*i+M*t,x=M*F*i-U*t,_=F*U*i-M*t,A=U*U*i+n,g=M*U*i+F*t,v=F*M*i+U*t,S=U*M*i-F*t,b=M*M*i+n,N[0]=s*p+l*R+m*x,N[1]=o*p+u*R+T*x,N[2]=a*p+f*R+d*x,N[3]=c*p+h*R+E*x,N[4]=s*_+l*A+m*g,N[5]=o*_+u*A+T*g,N[6]=a*_+f*A+d*g,N[7]=c*_+h*A+E*g,N[8]=s*v+l*S+m*b,N[9]=o*v+u*S+T*b,N[10]=a*v+f*S+d*b,N[11]=c*v+h*S+E*b,this}makeRotationAxis(e,r){const t=this.elements,n=Math.cos(r),i=Math.sin(r),s=1-n,o=e.elements[0],a=e.elements[1],c=e.elements[2],l=s*o,u=s*a;return t[0]=l*o+n,t[1]=l*a-i*c,t[2]=l*c+i*a,t[3]=0,t[4]=l*a+i*c,t[5]=u*a+n,t[6]=u*c-i*o,t[7]=0,t[8]=l*c-i*a,t[9]=u*c+i*o,t[10]=s*c*c+n,t[11]=0,t[15]=1,this}makeRotationFromQuaternion(e){const r=this.elements,t=e[0],n=e[1],i=e[2],s=e[3],o=t+t,a=n+n,c=i+i,l=t*o,u=t*a,f=t*c,h=n*a,m=n*c,T=i*c,d=s*o,E=s*a,p=s*c;return r[0]=1-(h+T),r[4]=u-p,r[8]=f+E,r[1]=u+p,r[5]=1-(l+T),r[9]=m-d,r[2]=f-E,r[6]=m+d,r[10]=1-(l+h),this}transpose(){let e,r;return e=this.elements,r=e[1],e[1]=e[4],e[4]=r,r=e[2],e[2]=e[8],e[8]=r,r=e[3],e[3]=e[12],e[12]=r,r=e[6],e[6]=e[9],e[9]=r,r=e[7],e[7]=e[13],e[13]=r,r=e[11],e[11]=e[14],e[14]=r,this}}class t{elements;constructor(e){this.elements=e.slice()}lerp(e,r,t){const n=this.elements;for(let i=0;i<n.length;i++)n[i]=e[i]+t*(r[i]-e[i]);return this}}class n{elements;get x(){return this.elements[0]}get y(){return this.elements[1]}get z(){return this.elements[2]}set x(e){this.elements[0]=e}set y(e){this.elements[1]=e}set z(e){this.elements[2]=e}static FromArrayToRef(e,r,t){t.x=e[r],t.y=e[r+1],t.z=e[r+2]}constructor(e){const r=new Float32Array(3);e&&"object"==typeof e&&(r[0]=e[0],r[1]=e[1],r[2]=e[2]),this.elements=r}projectOnVector(e){const r=n.dot(e,this)/e.lengthSq();return new n(e).scale(r)}applyQuaternion({elements:e}){const r=this.elements[0],t=this.elements[1],n=this.elements[2],i=e[0],s=e[1],o=e[2],a=e[3],c=a*r+s*n-o*t,l=a*t+o*r-i*n,u=a*n+i*t-s*r,f=-i*r-s*t-o*n;return this.elements[0]=c*a+f*-i+l*-o-u*-s,this.elements[1]=l*a+f*-s+u*-i-c*-o,this.elements[2]=u*a+f*-o+c*-s-l*-i,this}normalize(){const e=this.elements,r=e[0],t=e[1],n=e[2];let i=Math.sqrt(r*r+t*t+n*n);return i?(1==i||(i=1/i,e[0]=r*i,e[1]=t*i,e[2]=n*i),this):(e[0]=0,e[1]=0,e[2]=0,this)}add(e){const r=this.elements;return e=e.elements,r[0]=r[0]+e[0],r[1]=r[1]+e[1],r[2]=r[2]+e[2],this}addS(e){const r=this.elements;return r[0]=r[0]+e,r[1]=r[1]+e,r[2]=r[2]+e,this}scale(e){const r=this.elements;return r[0]=r[0]*e,r[1]=r[1]*e,r[2]=r[2]*e,this}scale2(e){return new n([this.x*e,this.y*e,this.z*e])}subtract2(e){return new n([this.x-e.x,this.y-e.y,this.z-e.z])}add2(e){return new n([this.x+e.x,this.y+e.y,this.z+e.z])}distanceToSquared(e,r,t){const n=this.elements[0]-e,i=this.elements[1]-r,s=this.elements[2]-t;return n*n+i*i+s*s}subtract(e){const r=this.elements;return e=e.elements,r[0]=r[0]-e[0],r[1]=r[1]-e[1],r[2]=r[2]-e[2],this}divideScalar(e){return this.scale(1/e)}applyMatrix4({elements:e}){const r=this.elements[0],t=this.elements[1],n=this.elements[2],i=e;this.elements[0]=i[0]*r+i[4]*t+i[8]*n+i[12],this.elements[1]=i[1]*r+i[5]*t+i[9]*n+i[13],this.elements[2]=i[2]*r+i[6]*t+i[10]*n+i[14];const s=i[3]*r+i[7]*t+i[11]*n+i[15];return this.divideScalar(s)}lerp(e,r,t){const n=this.elements,i=e[0],s=e[1],o=e[2];return n[0]=i+t*(r[0]-i),n[1]=s+t*(r[1]-s),n[2]=o+t*(r[2]-o),this}lengthSq(){return this.elements[0]*this.elements[0]+this.elements[1]*this.elements[1]+this.elements[2]*this.elements[2]}multiply({elements:e}){return this.elements[0]*=e[0],this.elements[1]*=e[1],this.elements[2]*=e[2],this}static angle(e,r){const t=new n(e.elements),i=new n(r.elements);t.normalize(),i.normalize();const s=n.dot(t,i);return s>1?0:Math.acos(s)}static cross(e,r){e=e.elements,r=r.elements;const t=e[0],i=e[1],s=e[2],o=r[0],a=r[1],c=r[2],l=new n;return l.elements[0]=i*c-s*a,l.elements[1]=s*o-t*c,l.elements[2]=t*a-i*o,l}static dot(e,r){return e=e.elements,r=r.elements,e[0]*r[0]+e[1]*r[1]+e[2]*r[2]}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}subVectors(e,r){return this.x=e.x-r.x,this.y=e.y-r.y,this.z=e.z-r.z,this}}class o{min=new n([1/0,1/0,1/0]);max=new n([-1/0,-1/0,-1/0]);expand(e){this.min.min(e.min),this.max.max(e.max)}getSize(){const e=new n;return e.subVectors(this.max,this.min),e.length()}}class a{elements;constructor(e){const r=new Float32Array(4);e&&"object"==typeof e&&(r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3]),this.elements=r}set(e){const r=this.elements;return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],this}add(e){const r=this.elements;return e=e.elements,r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=r[3]+e[3],this}normalize(){const e=this.elements[0],r=this.elements[1],t=this.elements[2],n=this.elements[3];let i=e*e+r*r+t*t+n*n;return i>0&&(i=1/Math.sqrt(i),this.elements[0]=e*i,this.elements[1]=r*i,this.elements[2]=t*i,this.elements[3]=n*i),this}setFromRotationMatrix({elements:e}){const r=e,t=r[0],n=r[4],i=r[8],s=r[1],o=r[5],a=r[9],c=r[2],l=r[6],u=r[10],f=t+o+u;let h;return f>0?(h=.5/Math.sqrt(f+1),this.elements[3]=.25/h,this.elements[0]=(l-a)*h,this.elements[1]=(i-c)*h,this.elements[2]=(s-n)*h):t>o&&t>u?(h=2*Math.sqrt(1+t-o-u),this.elements[3]=(l-a)/h,this.elements[0]=.25*h,this.elements[1]=(n+s)/h,this.elements[2]=(i+c)/h):o>u?(h=2*Math.sqrt(1+o-t-u),this.elements[3]=(i-c)/h,this.elements[0]=(n+s)/h,this.elements[1]=.25*h,this.elements[2]=(a+l)/h):(h=2*Math.sqrt(1+u-t-o),this.elements[3]=(s-n)/h,this.elements[0]=(i+c)/h,this.elements[1]=(a+l)/h,this.elements[2]=.25*h),this}lerp(e,r,t){const n=this.elements;if(0===t)return n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],this;if(1===t)return n[0]=r[0],n[1]=r[1],n[2]=r[2],n[3]=r[3],this;const i=e[0],s=e[1],o=e[2],a=e[3];let c=a*r[3]+i*r[0]+s*r[1]+o*r[2];if(c<0?(n[3]=-r[3],n[0]=-r[0],n[1]=-r[1],n[2]=-r[2],c=-c):(n[0]=r[0],n[1]=r[1],n[2]=r[2],n[3]=r[3]),c>=1)return n[3]=a,n[0]=i,n[1]=s,n[2]=o,this;const l=1-c*c;if(l<=Number.EPSILON){var u=1-t;return n[3]=u*a+t*n[3],n[0]=u*i+t*n[0],n[1]=u*s+t*n[1],n[2]=u*o+t*n[2],this.normalize()}const f=Math.sqrt(l),h=Math.atan2(f,c),m=Math.sin((1-t)*h)/f,T=Math.sin(t*h)/f;return n[3]=a*m+n[3]*T,n[0]=i*m+n[0]*T,n[1]=s*m+n[1]*T,n[2]=o*m+n[2]*T,this}inverse(){return this.elements[0]=-this.elements[0],this.elements[1]=-this.elements[1],this.elements[2]=-this.elements[2],this}}class c{elements;get x(){return this.elements[0]}get y(){return this.elements[1]}set x(e){this.elements[0]=e}set y(e){this.elements[1]=e}constructor(e){const r=new Float32Array(2);e&&"object"==typeof e&&(r[0]=e[0],r[1]=e[1]),this.elements=r}subtract(e){const r=this.elements;return e=e.elements,r[0]=r[0]-e[0],r[1]=r[1]-e[1],this}lerp(e,r,t){const n=this.elements,i=e[0],s=e[1];return n[0]=i+t*(r[0]-i),n[1]=s+t*(r[1]-s),this}}function l(e){const r=[new a,new a,new a,new a,new a,new a],t=e.elements;let n=t[0],i=t[1],s=t[2],o=t[3],c=t[4],l=t[5],u=t[6],f=t[7],h=t[8],m=t[9],T=t[10],d=t[11],E=t[12],p=t[13],R=t[14],x=t[15];return r[0].set([o-n,f-c,d-h,x-E]).normalize(),r[1].set([o+n,f+c,d+h,x+E]).normalize(),r[2].set([o+i,f+l,d+m,x+p]).normalize(),r[3].set([o-i,f-l,d-m,x-p]).normalize(),r[4].set([o-s,f-u,d-T,x-R]).normalize(),r[5].set([o+s,f+u,d+T,x+R]).normalize(),r}class u{children;bin;matrixWorld;matrix;transparentChildren;opaqueChildren;meshes;tracks;cameras;lights;variants;constructor(){this.opaqueChildren=[],this.transparentChildren=[],this.meshes=[],this.children=[],this.bin=[],this.matrixWorld=new r,this.matrix=new r,this.variants=[]}}class f{uuid;name;id;children;matrix;matrixWorld;parent;reflow;repaint;constructor(e,t){this.uuid=Math.floor(Date.now()*Math.random()),this.name=e,this.children=[],this.matrix=new r,this.matrixWorld=new r,this.parent=t}getPosition(){return new Float32Array([this.matrixWorld.elements[12],this.matrixWorld.elements[13],this.matrixWorld.elements[14]])}setPosition(e,r,t){r&&this.matrix.makeRotationFromQuaternion(r),t&&this.matrix.scale(new n(t)),e&&this.matrix.setTranslate(new n(e))}setMatrix(e){this.matrix.set(e)}setMatrixWorld(e){this.matrixWorld.set(e)}updateMatrix(){const e=new r;e.multiply(this.parent.matrixWorld),e.multiply(this.matrix),this.setMatrixWorld(e.elements)}}const h={0:"NONE",1:"ONE",2:"LINE_LOOP",3:"LINE_STRIP",4:"TRIANGLES",5:"TRIANGLE_STRIP",6:"TRIANGLE_FAN",256:"DEPTH_BUFFER_BIT",512:"NEVER",513:"LESS",514:"EQUAL",515:"LEQUAL",516:"GREATER",517:"NOTEQUAL",518:"GEQUAL",519:"ALWAYS",768:"SRC_COLOR",769:"ONE_MINUS_SRC_COLOR",770:"SRC_ALPHA",771:"ONE_MINUS_SRC_ALPHA",772:"DST_ALPHA",773:"ONE_MINUS_DST_ALPHA",774:"DST_COLOR",775:"ONE_MINUS_DST_COLOR",776:"SRC_ALPHA_SATURATE",1024:"STENCIL_BUFFER_BIT",1028:"FRONT",1029:"BACK",1032:"FRONT_AND_BACK",1280:"INVALID_ENUM",1281:"INVALID_VALUE",1282:"INVALID_OPERATION",1285:"OUT_OF_MEMORY",1286:"INVALID_FRAMEBUFFER_OPERATION",1798:"drawingBufferHeight",2304:"CW",2305:"CCW",2712:"drawingBufferWidth",2849:"LINE_WIDTH",2884:"CULL_FACE",2885:"CULL_FACE_MODE",2886:"FRONT_FACE",2928:"DEPTH_RANGE",2929:"DEPTH_TEST",2930:"DEPTH_WRITEMASK",2931:"DEPTH_CLEAR_VALUE",2932:"DEPTH_FUNC",2960:"STENCIL_TEST",2961:"STENCIL_CLEAR_VALUE",2962:"STENCIL_FUNC",2963:"STENCIL_VALUE_MASK",2964:"STENCIL_FAIL",2965:"STENCIL_PASS_DEPTH_FAIL",2966:"STENCIL_PASS_DEPTH_PASS",2967:"STENCIL_REF",2968:"STENCIL_WRITEMASK",2978:"VIEWPORT",3024:"DITHER",3042:"BLEND",3074:"READ_BUFFER",3088:"SCISSOR_BOX",3089:"SCISSOR_TEST",3106:"COLOR_CLEAR_VALUE",3107:"COLOR_WRITEMASK",3314:"UNPACK_ROW_LENGTH",3315:"UNPACK_SKIP_ROWS",3316:"UNPACK_SKIP_PIXELS",3317:"UNPACK_ALIGNMENT",3330:"PACK_ROW_LENGTH",3331:"PACK_SKIP_ROWS",3332:"PACK_SKIP_PIXELS",3333:"PACK_ALIGNMENT",3379:"MAX_TEXTURE_SIZE",3386:"MAX_VIEWPORT_DIMS",3408:"SUBPIXEL_BITS",3410:"RED_BITS",3411:"GREEN_BITS",3412:"BLUE_BITS",3413:"ALPHA_BITS",3414:"DEPTH_BITS",3415:"STENCIL_BITS",3553:"TEXTURE_2D",4352:"DONT_CARE",4353:"FASTEST",4354:"NICEST",5120:"BYTE",5121:"UNSIGNED_BYTE",5122:"SHORT",5123:"UNSIGNED_SHORT",5124:"INT",5125:"UNSIGNED_INT",5126:"FLOAT",5131:"HALF_FLOAT",5386:"INVERT",5890:"TEXTURE",6144:"COLOR",6145:"DEPTH",6146:"STENCIL",6402:"DEPTH_COMPONENT",6403:"RED",6406:"ALPHA",6407:"RGB",6408:"RGBA",6409:"LUMINANCE",6410:"LUMINANCE_ALPHA",7680:"KEEP",7681:"REPLACE",7682:"INCR",7683:"DECR",7936:"VENDOR",7937:"RENDERER",7938:"VERSION",9728:"NEAREST",9729:"LINEAR",9984:"NEAREST_MIPMAP_NEAREST",9985:"LINEAR_MIPMAP_NEAREST",9986:"NEAREST_MIPMAP_LINEAR",9987:"LINEAR_MIPMAP_LINEAR",10240:"TEXTURE_MAG_FILTER",10241:"TEXTURE_MIN_FILTER",10242:"TEXTURE_WRAP_S",10243:"TEXTURE_WRAP_T",10497:"REPEAT",10752:"POLYGON_OFFSET_UNITS",16384:"COLOR_BUFFER_BIT",32769:"CONSTANT_COLOR",32770:"ONE_MINUS_CONSTANT_COLOR",32771:"CONSTANT_ALPHA",32772:"ONE_MINUS_CONSTANT_ALPHA",32773:"BLEND_COLOR",32774:"FUNC_ADD",32775:"MIN",32776:"MAX",32777:"BLEND_EQUATION_RGB",32778:"FUNC_SUBTRACT",32779:"FUNC_REVERSE_SUBTRACT",32819:"UNSIGNED_SHORT_4_4_4_4",32820:"UNSIGNED_SHORT_5_5_5_1",32823:"POLYGON_OFFSET_FILL",32824:"POLYGON_OFFSET_FACTOR",32849:"RGB8",32854:"RGBA4",32855:"RGB5_A1",32856:"RGBA8",32857:"RGB10_A2",32873:"TEXTURE_BINDING_2D",32874:"TEXTURE_BINDING_3D",32877:"UNPACK_SKIP_IMAGES",32878:"UNPACK_IMAGE_HEIGHT",32879:"TEXTURE_3D",32882:"TEXTURE_WRAP_R",32883:"MAX_3D_TEXTURE_SIZE",32926:"SAMPLE_ALPHA_TO_COVERAGE",32928:"SAMPLE_COVERAGE",32936:"SAMPLE_BUFFERS",32937:"SAMPLES",32938:"SAMPLE_COVERAGE_VALUE",32939:"SAMPLE_COVERAGE_INVERT",32968:"BLEND_DST_RGB",32969:"BLEND_SRC_RGB",32970:"BLEND_DST_ALPHA",32971:"BLEND_SRC_ALPHA",33e3:"MAX_ELEMENTS_VERTICES",33001:"MAX_ELEMENTS_INDICES",33071:"CLAMP_TO_EDGE",33082:"TEXTURE_MIN_LOD",33083:"TEXTURE_MAX_LOD",33084:"TEXTURE_BASE_LEVEL",33085:"TEXTURE_MAX_LEVEL",33170:"GENERATE_MIPMAP_HINT",33189:"DEPTH_COMPONENT16",33190:"DEPTH_COMPONENT24",33296:"FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING",33297:"FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE",33298:"FRAMEBUFFER_ATTACHMENT_RED_SIZE",33299:"FRAMEBUFFER_ATTACHMENT_GREEN_SIZE",33300:"FRAMEBUFFER_ATTACHMENT_BLUE_SIZE",33301:"FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE",33302:"FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE",33303:"FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE",33304:"FRAMEBUFFER_DEFAULT",33306:"DEPTH_STENCIL_ATTACHMENT",33319:"RG",33320:"RG_INTEGER",33321:"R8",33323:"RG8",33325:"R16F",33326:"R32F",33327:"RG16F",33328:"RG32F",33329:"R8I",33330:"R8UI",33331:"R16I",33332:"R16UI",33333:"R32I",33334:"R32UI",33335:"RG8I",33336:"RG8UI",33337:"RG16I",33338:"RG16UI",33339:"RG32I",33340:"RG32UI",33503:"TEXTURE_IMMUTABLE_LEVELS",33635:"UNSIGNED_SHORT_5_6_5",33640:"UNSIGNED_INT_2_10_10_10_REV",33648:"MIRRORED_REPEAT",33901:"ALIASED_POINT_SIZE_RANGE",33902:"ALIASED_LINE_WIDTH_RANGE",33984:"TEXTURE0",33985:"TEXTURE1",33986:"TEXTURE2",33987:"TEXTURE3",33988:"TEXTURE4",33989:"TEXTURE5",33990:"TEXTURE6",33991:"TEXTURE7",33992:"TEXTURE8",33993:"TEXTURE9",33994:"TEXTURE10",33995:"TEXTURE11",33996:"TEXTURE12",33997:"TEXTURE13",33998:"TEXTURE14",33999:"TEXTURE15",34e3:"TEXTURE16",34001:"TEXTURE17",34002:"TEXTURE18",34003:"TEXTURE19",34004:"TEXTURE20",34005:"TEXTURE21",34006:"TEXTURE22",34007:"TEXTURE23",34008:"TEXTURE24",34009:"TEXTURE25",34010:"TEXTURE26",34011:"TEXTURE27",34012:"TEXTURE28",34013:"TEXTURE29",34014:"TEXTURE30",34015:"TEXTURE31",34016:"ACTIVE_TEXTURE",34024:"MAX_RENDERBUFFER_SIZE",34041:"DEPTH_STENCIL",34042:"UNSIGNED_INT_24_8",34045:"MAX_TEXTURE_LOD_BIAS",34055:"INCR_WRAP",34056:"DECR_WRAP",34067:"TEXTURE_CUBE_MAP",34068:"TEXTURE_BINDING_CUBE_MAP",34069:"TEXTURE_CUBE_MAP_POSITIVE_X",34070:"TEXTURE_CUBE_MAP_NEGATIVE_X",34071:"TEXTURE_CUBE_MAP_POSITIVE_Y",34072:"TEXTURE_CUBE_MAP_NEGATIVE_Y",34073:"TEXTURE_CUBE_MAP_POSITIVE_Z",34074:"TEXTURE_CUBE_MAP_NEGATIVE_Z",34076:"MAX_CUBE_MAP_TEXTURE_SIZE",34229:"VERTEX_ARRAY_BINDING",34338:"VERTEX_ATTRIB_ARRAY_ENABLED",34339:"VERTEX_ATTRIB_ARRAY_SIZE",34340:"VERTEX_ATTRIB_ARRAY_STRIDE",34341:"VERTEX_ATTRIB_ARRAY_TYPE",34342:"CURRENT_VERTEX_ATTRIB",34373:"VERTEX_ATTRIB_ARRAY_POINTER",34467:"COMPRESSED_TEXTURE_FORMATS",34660:"BUFFER_SIZE",34661:"BUFFER_USAGE",34816:"STENCIL_BACK_FUNC",34817:"STENCIL_BACK_FAIL",34818:"STENCIL_BACK_PASS_DEPTH_FAIL",34819:"STENCIL_BACK_PASS_DEPTH_PASS",34836:"RGBA32F",34837:"RGB32F",34842:"RGBA16F",34843:"RGB16F",34852:"MAX_DRAW_BUFFERS",34853:"DRAW_BUFFER0",34854:"DRAW_BUFFER1",34855:"DRAW_BUFFER2",34856:"DRAW_BUFFER3",34857:"DRAW_BUFFER4",34858:"DRAW_BUFFER5",34859:"DRAW_BUFFER6",34860:"DRAW_BUFFER7",34861:"DRAW_BUFFER8",34862:"DRAW_BUFFER9",34863:"DRAW_BUFFER10",34864:"DRAW_BUFFER11",34865:"DRAW_BUFFER12",34866:"DRAW_BUFFER13",34867:"DRAW_BUFFER14",34868:"DRAW_BUFFER15",34877:"BLEND_EQUATION_ALPHA",34892:"TEXTURE_COMPARE_MODE",34893:"TEXTURE_COMPARE_FUNC",34894:"COMPARE_REF_TO_TEXTURE",34917:"CURRENT_QUERY",34918:"QUERY_RESULT",34919:"QUERY_RESULT_AVAILABLE",34921:"MAX_VERTEX_ATTRIBS",34922:"VERTEX_ATTRIB_ARRAY_NORMALIZED",34930:"MAX_TEXTURE_IMAGE_UNITS",34962:"ARRAY_BUFFER",34963:"ELEMENT_ARRAY_BUFFER",34964:"ARRAY_BUFFER_BINDING",34965:"ELEMENT_ARRAY_BUFFER_BINDING",34975:"VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",35040:"STREAM_DRAW",35041:"STREAM_READ",35042:"STREAM_COPY",35044:"STATIC_DRAW",35045:"STATIC_READ",35046:"STATIC_COPY",35048:"DYNAMIC_DRAW",35049:"DYNAMIC_READ",35050:"DYNAMIC_COPY",35051:"PIXEL_PACK_BUFFER",35052:"PIXEL_UNPACK_BUFFER",35053:"PIXEL_PACK_BUFFER_BINDING",35055:"PIXEL_UNPACK_BUFFER_BINDING",35056:"DEPTH24_STENCIL8",35069:"VERTEX_ATTRIB_ARRAY_INTEGER",35070:"VERTEX_ATTRIB_ARRAY_DIVISOR",35071:"MAX_ARRAY_TEXTURE_LAYERS",35076:"MIN_PROGRAM_TEXEL_OFFSET",35077:"MAX_PROGRAM_TEXEL_OFFSET",35097:"SAMPLER_BINDING",35345:"UNIFORM_BUFFER",35368:"UNIFORM_BUFFER_BINDING",35369:"UNIFORM_BUFFER_START",35370:"UNIFORM_BUFFER_SIZE",35371:"MAX_VERTEX_UNIFORM_BLOCKS",35373:"MAX_FRAGMENT_UNIFORM_BLOCKS",35374:"MAX_COMBINED_UNIFORM_BLOCKS",35375:"MAX_UNIFORM_BUFFER_BINDINGS",35376:"MAX_UNIFORM_BLOCK_SIZE",35377:"MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS",35379:"MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS",35380:"UNIFORM_BUFFER_OFFSET_ALIGNMENT",35382:"ACTIVE_UNIFORM_BLOCKS",35383:"UNIFORM_TYPE",35384:"UNIFORM_SIZE",35386:"UNIFORM_BLOCK_INDEX",35387:"UNIFORM_OFFSET",35388:"UNIFORM_ARRAY_STRIDE",35389:"UNIFORM_MATRIX_STRIDE",35390:"UNIFORM_IS_ROW_MAJOR",35391:"UNIFORM_BLOCK_BINDING",35392:"UNIFORM_BLOCK_DATA_SIZE",35394:"UNIFORM_BLOCK_ACTIVE_UNIFORMS",35395:"UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES",35396:"UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER",35398:"UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER",35632:"FRAGMENT_SHADER",35633:"VERTEX_SHADER",35657:"MAX_FRAGMENT_UNIFORM_COMPONENTS",35658:"MAX_VERTEX_UNIFORM_COMPONENTS",35659:"MAX_VARYING_COMPONENTS",35660:"MAX_VERTEX_TEXTURE_IMAGE_UNITS",35661:"MAX_COMBINED_TEXTURE_IMAGE_UNITS",35663:"SHADER_TYPE",35664:"FLOAT_VEC2",35665:"FLOAT_VEC3",35666:"FLOAT_VEC4",35667:"INT_VEC2",35668:"INT_VEC3",35669:"INT_VEC4",35670:"BOOL",35671:"BOOL_VEC2",35672:"BOOL_VEC3",35673:"BOOL_VEC4",35674:"FLOAT_MAT2",35675:"FLOAT_MAT3",35676:"FLOAT_MAT4",35678:"SAMPLER_2D",35679:"SAMPLER_3D",35680:"SAMPLER_CUBE",35682:"SAMPLER_2D_SHADOW",35685:"FLOAT_MAT2x3",35686:"FLOAT_MAT2x4",35687:"FLOAT_MAT3x2",35688:"FLOAT_MAT3x4",35689:"FLOAT_MAT4x2",35690:"FLOAT_MAT4x3",35712:"DELETE_STATUS",35713:"COMPILE_STATUS",35714:"LINK_STATUS",35715:"VALIDATE_STATUS",35717:"ATTACHED_SHADERS",35718:"ACTIVE_UNIFORMS",35721:"ACTIVE_ATTRIBUTES",35723:"FRAGMENT_SHADER_DERIVATIVE_HINT",35724:"SHADING_LANGUAGE_VERSION",35725:"CURRENT_PROGRAM",35738:"IMPLEMENTATION_COLOR_READ_TYPE",35739:"IMPLEMENTATION_COLOR_READ_FORMAT",35863:"UNSIGNED_NORMALIZED",35866:"TEXTURE_2D_ARRAY",35869:"TEXTURE_BINDING_2D_ARRAY",35887:"ANY_SAMPLES_PASSED",35898:"R11F_G11F_B10F",35899:"UNSIGNED_INT_10F_11F_11F_REV",35901:"RGB9_E5",35902:"UNSIGNED_INT_5_9_9_9_REV",35904:"SRGB",35905:"SRGB8",35907:"SRGB8_ALPHA8",35967:"TRANSFORM_FEEDBACK_BUFFER_MODE",35968:"MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS",35971:"TRANSFORM_FEEDBACK_VARYINGS",35972:"TRANSFORM_FEEDBACK_BUFFER_START",35973:"TRANSFORM_FEEDBACK_BUFFER_SIZE",35976:"TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN",35977:"RASTERIZER_DISCARD",35978:"MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS",35979:"MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS",35980:"INTERLEAVED_ATTRIBS",35981:"SEPARATE_ATTRIBS",35982:"TRANSFORM_FEEDBACK_BUFFER",35983:"TRANSFORM_FEEDBACK_BUFFER_BINDING",36003:"STENCIL_BACK_REF",36004:"STENCIL_BACK_VALUE_MASK",36005:"STENCIL_BACK_WRITEMASK",36006:"FRAMEBUFFER_BINDING",36007:"RENDERBUFFER_BINDING",36008:"READ_FRAMEBUFFER",36009:"DRAW_FRAMEBUFFER",36010:"READ_FRAMEBUFFER_BINDING",36011:"RENDERBUFFER_SAMPLES",36012:"DEPTH_COMPONENT32F",36013:"DEPTH32F_STENCIL8",36048:"FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",36049:"FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",36050:"FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",36051:"FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",36052:"FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER",36053:"FRAMEBUFFER_COMPLETE",36054:"FRAMEBUFFER_INCOMPLETE_ATTACHMENT",36055:"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",36057:"FRAMEBUFFER_INCOMPLETE_DIMENSIONS",36061:"FRAMEBUFFER_UNSUPPORTED",36063:"MAX_COLOR_ATTACHMENTS",36064:"COLOR_ATTACHMENT0",36065:"COLOR_ATTACHMENT1",36066:"COLOR_ATTACHMENT2",36067:"COLOR_ATTACHMENT3",36068:"COLOR_ATTACHMENT4",36069:"COLOR_ATTACHMENT5",36070:"COLOR_ATTACHMENT6",36071:"COLOR_ATTACHMENT7",36072:"COLOR_ATTACHMENT8",36073:"COLOR_ATTACHMENT9",36074:"COLOR_ATTACHMENT10",36075:"COLOR_ATTACHMENT11",36076:"COLOR_ATTACHMENT12",36077:"COLOR_ATTACHMENT13",36078:"COLOR_ATTACHMENT14",36079:"COLOR_ATTACHMENT15",36096:"DEPTH_ATTACHMENT",36128:"STENCIL_ATTACHMENT",36160:"FRAMEBUFFER",36161:"RENDERBUFFER",36162:"RENDERBUFFER_WIDTH",36163:"RENDERBUFFER_HEIGHT",36164:"RENDERBUFFER_INTERNAL_FORMAT",36168:"STENCIL_INDEX8",36176:"RENDERBUFFER_RED_SIZE",36177:"RENDERBUFFER_GREEN_SIZE",36178:"RENDERBUFFER_BLUE_SIZE",36179:"RENDERBUFFER_ALPHA_SIZE",36180:"RENDERBUFFER_DEPTH_SIZE",36181:"RENDERBUFFER_STENCIL_SIZE",36182:"FRAMEBUFFER_INCOMPLETE_MULTISAMPLE",36183:"MAX_SAMPLES",36194:"RGB565",36202:"ANY_SAMPLES_PASSED_CONSERVATIVE",36203:"MAX_ELEMENT_INDEX",36208:"RGBA32UI",36209:"RGB32UI",36214:"RGBA16UI",36215:"RGB16UI",36220:"RGBA8UI",36221:"RGB8UI",36226:"RGBA32I",36227:"RGB32I",36232:"RGBA16I",36233:"RGB16I",36238:"RGBA8I",36239:"RGB8I",36244:"RED_INTEGER",36248:"RGB_INTEGER",36249:"RGBA_INTEGER",36255:"INT_2_10_10_10_REV",36269:"FLOAT_32_UNSIGNED_INT_24_8_REV",36289:"SAMPLER_2D_ARRAY",36292:"SAMPLER_2D_ARRAY_SHADOW",36293:"SAMPLER_CUBE_SHADOW",36294:"UNSIGNED_INT_VEC2",36295:"UNSIGNED_INT_VEC3",36296:"UNSIGNED_INT_VEC4",36298:"INT_SAMPLER_2D",36299:"INT_SAMPLER_3D",36300:"INT_SAMPLER_CUBE",36303:"INT_SAMPLER_2D_ARRAY",36306:"UNSIGNED_INT_SAMPLER_2D",36307:"UNSIGNED_INT_SAMPLER_3D",36308:"UNSIGNED_INT_SAMPLER_CUBE",36311:"UNSIGNED_INT_SAMPLER_2D_ARRAY",36336:"LOW_FLOAT",36337:"MEDIUM_FLOAT",36338:"HIGH_FLOAT",36339:"LOW_INT",36340:"MEDIUM_INT",36341:"HIGH_INT",36347:"MAX_VERTEX_UNIFORM_VECTORS",36348:"MAX_VARYING_VECTORS",36349:"MAX_FRAGMENT_UNIFORM_VECTORS",36386:"TRANSFORM_FEEDBACK",36387:"TRANSFORM_FEEDBACK_PAUSED",36388:"TRANSFORM_FEEDBACK_ACTIVE",36389:"TRANSFORM_FEEDBACK_BINDING",36662:"COPY_READ_BUFFER_BINDING",36663:"COPY_WRITE_BUFFER_BINDING",36756:"R8_SNORM",36757:"RG8_SNORM",36758:"RGB8_SNORM",36759:"RGBA8_SNORM",36764:"SIGNED_NORMALIZED",36975:"RGB10_A2UI",37137:"MAX_SERVER_WAIT_TIMEOUT",37138:"OBJECT_TYPE",37139:"SYNC_CONDITION",37140:"SYNC_STATUS",37141:"SYNC_FLAGS",37142:"SYNC_FENCE",37143:"SYNC_GPU_COMMANDS_COMPLETE",37144:"UNSIGNALED",37145:"SIGNALED",37146:"ALREADY_SIGNALED",37147:"TIMEOUT_EXPIRED",37148:"CONDITION_SATISFIED",37149:"WAIT_FAILED",37154:"MAX_VERTEX_OUTPUT_COMPONENTS",37157:"MAX_FRAGMENT_INPUT_COMPONENTS",37167:"TEXTURE_IMMUTABLE_FORMAT",37440:"UNPACK_FLIP_Y_WEBGL",37441:"UNPACK_PREMULTIPLY_ALPHA_WEBGL",37442:"CONTEXT_LOST_WEBGL",37443:"UNPACK_COLORSPACE_CONVERSION_WEBGL",37444:"BROWSER_DEFAULT_WEBGL",37447:"MAX_CLIENT_WAIT_TIMEOUT_WEBGL",4294967295:"INVALID_INDEX","-1":"TIMEOUT_IGNORED"};let m,T=31;const d=[0,0,0,1];function E(e,r){return Math.random()*(r-e)+e}function p(e,r,t){return e+t*(r-e)}function R(e){let r;switch(e){case"MAT2":case"VEC4":r=4;break;case"MAT3":r=9;break;case"MAT4":r=16;break;case"VEC3":r=3;break;case"VEC2":r=2;break;case"SCALAR":r=1}return r}function x(e,r){if(0===r.length)return[-1,-1,0];let t=-1;for(let n=r.length-1;n>=0;n--)if(e>=r[n].time){t=n;break}if(-1===t||t===r.length-1)return t<0&&(t=0),[t,t,0];{const s=r[t],o=r[t+1];return e=Math.max(s.time,Math.min(e,o.time)),[t,t+1,(n=s.time,i=o.time,(e-n)/(i-n))]}var n,i}const _=new Map;function A(e,r,t){const n=function(e){let r;switch(h[e]){case"BYTE":case"UNSIGNED_BYTE":r=1;break;case"SHORT":case"UNSIGNED_SHORT":r=2;break;case"UNSIGNED_INT":case"FLOAT":r=4}return r}(r.componentType),i=R(r.type),s=(t.byteOffset||0)+(r.byteOffset||0),o=t.byteStride,a=o*r.count/n,c=r.count*i;let l,u=a||c;switch(e.byteLength<u*n+s&&(u-=r.byteOffset),h[r.componentType]){case"BYTE":l=new Int8Array(e,s,u);break;case"UNSIGNED_BYTE":l=new Uint8Array(e,s,u);break;case"SHORT":l=new Int16Array(e,s,u);break;case"UNSIGNED_SHORT":l=new Uint16Array(e,s,u);break;case"UNSIGNED_INT":l=new Uint32Array(e,s,u);break;case"FLOAT":l=new Float32Array(e,s,u)}if(u!==c){const e=new l.constructor(c);let r=0;for(let t=0;t<e.length;t+=i){for(let n=0;n<i;n++)e[t+n]=l[r+n];r+=o/n}return e}return l}function g(e,r,t,n){let i;switch(h[r]){case"BYTE":i=new Int8Array(e,t,n);break;case"UNSIGNED_BYTE":i=new Uint8Array(e,t,n);break;case"SHORT":i=new Int16Array(e,t,n);break;case"UNSIGNED_SHORT":i=new Uint16Array(e,t,n);break;case"UNSIGNED_INT":i=new Uint32Array(e,t,n);break;case"FLOAT":i=new Float32Array(e,t,n)}return i}function v(e,r,t){const n=m.createShader(e);m.shaderSource(n,r),m.compileShader(n),m.attachShader(t,n);const i=m.getShaderInfoLog(n);if(i)throw new Error(i)}function S(e,r){const t=m.createProgram();if(v(m.VERTEX_SHADER,e,t),v(m.FRAGMENT_SHADER,r,t),m.linkProgram(t),m.validateProgram(t),!m.getProgramParameter(t,m.LINK_STATUS)){const e=m.getProgramInfoLog(t);throw new Error(`Could not compile WebGL program. ${e}`)}return t}function b(e=m.TEXTURE_2D,r=function(){return T--,T}()){const t=m.createTexture();return m.activeTexture(m[`TEXTURE${r}`]),m.bindTexture(e,t),t.index=r,t}function F(e,r){!function e(t){r(t),t.children&&t.children.forEach(e)}(e)}function U(e,t,i,s){const[o,c]=e,l=new r;l.setTranslate(new n([0,0,.05]));const u=new r(t);u.multiply(l);const f=u.multiplyVector4(new a([0,0,0,1]));f.elements[0]=(2*o/i-1)*f.elements[3],f.elements[1]=(-2*c/s+1)*f.elements[3];const h=u.invert().multiplyVector4(f);return[h.elements[0],h.elements[1]]}function M(e){const{aspect:t,zoom:n}=e;let i;if("perspective"===e.type&&e.perspective){const{yfov:n}=e.perspective,i=1/Math.tan(n/2),s=1/(e.perspective.znear-e.perspective.zfar);return(new r).set([i/t,0,0,0,0,i,0,0,0,0,e.perspective.zfar*s,-1,0,0,e.perspective.znear*e.perspective.zfar*s,0])}return"orthographic"===e.type&&e.orthographic&&(i=(new r).setOrtho(e.orthographic.xmag*n,e.orthographic.ymag*n,e.orthographic.znear,e.orthographic.zfar)),i}function I(e=0,r=0){return e+r}function N(e){return h[e]}function P(e){let r;switch(!0){case e instanceof Uint8Array:r=e=>e/255;break;case e instanceof Int8Array:r=e=>Math.max(e/127,-1);break;case e instanceof Uint16Array:r=e=>e/65535;break;case e instanceof Int16Array:r=e=>Math.max(e/32767,-1)}if(r){const t=new Float32Array(e.length);for(let n=0;n<e.length;n++)t[n]=r(e[n]);return t}return e}async function O(e,r,t,n,i,{isCube:s=!1}={}){const o=e.createShaderModule({code:"\n    @group(0) @binding(0) var mySampler: sampler;\n    @group(0) @binding(1) var myTexture: texture_2d<f32>;\n\n    struct VSOut {\n      @builtin(position) pos: vec4f,\n      @location(0) uv: vec2f\n    };\n\n    @vertex\n    fn vs_main(@builtin(vertex_index) vi: u32) -> VSOut {\n      var pos = array<vec2f, 6>(\n        vec2f(-1.0, -1.0),\n        vec2f( 1.0, -1.0),\n        vec2f(-1.0,  1.0),\n        vec2f(-1.0,  1.0),\n        vec2f( 1.0, -1.0),\n        vec2f( 1.0,  1.0)\n      );\n      var out: VSOut;\n      out.pos = vec4f(pos[vi], 0.0, 1.0);\n      var  uv = (pos[vi] + vec2f(1.0)) * 0.5;\n      uv.y = 1.0 - uv.y;\n      out.uv  = uv;\n      return out;\n    }\n\n    @fragment\n    fn fs_main(@location(0) uv: vec2f) -> @location(0) vec4f {\n      // sample exactly mip 0 of the bound view (which we create from src mip)\n      return textureSampleLevel(myTexture, mySampler, uv, 0.0);\n    }\n  "}),a=e.createRenderPipeline({layout:"auto",vertex:{module:o,entryPoint:"vs_main"},fragment:{module:o,entryPoint:"fs_main",targets:[{format:r.format}]},primitive:{topology:"triangle-list"}}),c=e.createSampler({magFilter:"linear",minFilter:"linear",mipmapFilter:"nearest",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"});for(let o=1;o<i;o++){const i=Math.max(1,Math.floor(t/Math.pow(2,o))),l=Math.max(1,Math.floor(n/Math.pow(2,o))),u=s?6:1;for(let t=0;t<u;t++){const n=r.createView({baseMipLevel:o-1,mipLevelCount:1,baseArrayLayer:s?t:0,arrayLayerCount:s?1:void 0,dimension:"2d"}),u=r.createView({baseMipLevel:o,mipLevelCount:1,baseArrayLayer:s?t:0,arrayLayerCount:s?1:void 0,dimension:"2d"}),f=e.createBindGroup({layout:a.getBindGroupLayout(0),entries:[{binding:0,resource:c},{binding:1,resource:n}]}),h=e.createCommandEncoder(),m=h.beginRenderPass({colorAttachments:[{view:u,clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]});m.setPipeline(a),m.setBindGroup(0,f),m.setViewport(0,0,i,l,0,1),m.draw(6),m.end(),e.queue.submit([h.finish()])}}}_.set(Int8Array,"BYTE"),_.set(Uint8Array,"UNSIGNED_BYTE"),_.set(Int16Array,"SHORT"),_.set(Uint16Array,"UNSIGNED_SHORT"),_.set(Uint32Array,"UNSIGNED_INT"),_.set(Float32Array,"FLOAT");class C extends f{geometry;material;program;defines;mode;frontFace;distance;visible;variants;order;uniformBindGroup1;pipeline;constructor(e,r){super(e,r),this.program=null,this.defines=null,this.mode=4,this.variants=[]}setDefines(e){this.defines=e}setBlend(e){this.material.blend=e}setMaterial(e){this.material=e}drawWebGPU(e,r,t,{renderState:n,storage2:i,storage:s}){const{isprerefraction:o}=n;if(!this.defines.find(e=>"TRANSMISSION"===e.name)||!o){if(this.reflow&&(i.store.set(this.matrixWorld.elements,t*this.geometry.uniformBuffer.store.length),e.device.queue.writeBuffer(i.bufferWebGPU,0,i.store.buffer,i.store.byteOffset,i.store.byteLength)),this.repaint&&(s.store.set(this.material.materialUniformBuffer.store,t*this.material.materialUniformBuffer.store.length),e.device.queue.writeBuffer(s.bufferWebGPU,0,s.store.buffer,s.store.byteOffset,s.store.byteLength)),this instanceof L&&this.bones.some(e=>e.reflow)){const r=this.getJointMatrix(),t=new Float32Array(16*r.length);let n=0;for(const e of r)t.set(e.elements,0+16*n),n++;e.device.queue.writeBuffer(this.skinBuffer,0*Float32Array.BYTES_PER_ELEMENT,t.buffer,t.byteOffset,t.byteLength)}r.setBindGroup(0,this.uniformBindGroup1),r.setVertexBuffer(0,this.geometry.verticesWebGPUBuffer),this.geometry.indicesBuffer?(this.geometry.indexType,r.setIndexBuffer(this.geometry.indicesWebGPUBuffer,"uint32"),r.drawIndexed(this.geometry.indicesBuffer.length,1,0,0,t)):r.draw(this.geometry.attributes.POSITION.length/3,1,0,t)}}draw(e,{lights:r,camera:t,needUpdateProjection:n,preDepthTexture:i,colorTexture:s,renderState:o,fakeDepth:a,isIBL:c,isDefaultLight:l}){const{isprepender:u,isprerefraction:f}=o;if(!this.defines.find(e=>"TRANSMISSION"===e.name)||!f){if(e.useProgram(this.program),e.bindVertexArray(this.geometry.VAO),n&&this.geometry.uniformBuffer.update(e,"projection",t.projection.elements),this.geometry.uniformBuffer.update(e,"isShadow",u?1:0),this instanceof L&&(e.bindBufferBase(e.UNIFORM_BUFFER,2,this.geometry.SKIN),this.bones.some(e=>e.reflow))){const r=this.getJointMatrix(),t=new Float32Array(16*r.length);let n=0;for(const e of r)t.set(e.elements,0+16*n),n++;e.bufferSubData(e.UNIFORM_BUFFER,0,t)}this.material.matrices.length&&e.bindBufferBase(e.UNIFORM_BUFFER,8,this.material.lightUBO5),this.material.sphericalHarmonics&&e.bindBufferBase(e.UNIFORM_BUFFER,7,this.material.sphericalHarmonics),e.uniform1i(this.material.uniforms.depthTexture,i&&!u?i.index:a.index),e.uniform1i(this.material.uniforms.colorTexture,f?a.index:s.index),e.uniform2f(this.material.uniforms.isTone,f?0:1,0),e.uniform2f(this.material.uniforms.isIBL,c?1:0,0),e.uniform2f(this.material.uniforms.isDefaultLight,l||r.some(e=>!e.isInitial)?1:0,0),this.material.baseColorTexture&&(e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,this.material.baseColorTexture),e.bindSampler(0,this.material.baseColorTexture.sampler)),this.material.metallicRoughnessTexture&&(e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,this.material.metallicRoughnessTexture),e.bindSampler(1,this.material.metallicRoughnessTexture.sampler)),this.material.normalTexture&&(e.activeTexture(e.TEXTURE2),e.bindTexture(e.TEXTURE_2D,this.material.normalTexture),e.bindSampler(2,this.material.normalTexture.sampler)),this.material.occlusionTexture&&(e.activeTexture(e.TEXTURE3),e.bindTexture(e.TEXTURE_2D,this.material.occlusionTexture),e.bindSampler(3,this.material.occlusionTexture.sampler)),this.material.emissiveTexture&&(e.activeTexture(e.TEXTURE4),e.bindTexture(e.TEXTURE_2D,this.material.emissiveTexture),e.bindSampler(4,this.material.emissiveTexture.sampler)),this.material.clearcoatTexture&&(e.activeTexture(e.TEXTURE8),e.bindTexture(e.TEXTURE_2D,this.material.clearcoatTexture),e.bindSampler(8,this.material.clearcoatTexture.sampler)),this.material.clearcoatRoughnessTexture&&(e.activeTexture(e.TEXTURE9),e.bindTexture(e.TEXTURE_2D,this.material.clearcoatRoughnessTexture),e.bindSampler(9,this.material.clearcoatRoughnessTexture.sampler)),this.material.sheenColorTexture&&(e.activeTexture(e.TEXTURE11),e.bindTexture(e.TEXTURE_2D,this.material.sheenColorTexture),e.bindSampler(11,this.material.sheenColorTexture.sampler)),this.material.sheenRoughnessTexture&&(e.activeTexture(e.TEXTURE12),e.bindTexture(e.TEXTURE_2D,this.material.sheenRoughnessTexture),e.bindSampler(12,this.material.sheenRoughnessTexture.sampler)),this.material.iridescenceThicknessTexture&&(e.activeTexture(e.TEXTURE17),e.bindTexture(e.TEXTURE_2D,this.material.iridescenceThicknessTexture),e.bindSampler(17,this.material.iridescenceThicknessTexture.sampler)),this.material.iridescenceTexture&&(e.activeTexture(e.TEXTURE23),e.bindTexture(e.TEXTURE_2D,this.material.iridescenceTexture),e.bindSampler(23,this.material.iridescenceTexture.sampler)),this.material.diffuseTransmissionTexture&&(e.activeTexture(e.TEXTURE20),e.bindTexture(e.TEXTURE_2D,this.material.diffuseTransmissionTexture),e.bindSampler(20,this.material.diffuseTransmissionTexture.sampler)),this.material.diffuseTransmissionColorTexture&&(e.activeTexture(e.TEXTURE21),e.bindTexture(e.TEXTURE_2D,this.material.diffuseTransmissionColorTexture),e.bindSampler(21,this.material.diffuseTransmissionColorTexture.sampler)),this.material.anisotropyTexture&&(e.activeTexture(e.TEXTURE22),e.bindTexture(e.TEXTURE_2D,this.material.anisotropyTexture),e.bindSampler(22,this.material.anisotropyTexture.sampler)),this.material.clearcoatNormalTexture&&(e.activeTexture(e.TEXTURE10),e.bindTexture(e.TEXTURE_2D,this.material.clearcoatNormalTexture),e.bindSampler(10,this.material.clearcoatNormalTexture.sampler)),this.material.transmissionTexture&&(e.activeTexture(e.TEXTURE14),e.bindTexture(e.TEXTURE_2D,this.material.transmissionTexture),e.bindSampler(14,this.material.transmissionTexture.sampler)),this.material.specularTexture&&(e.activeTexture(e.TEXTURE15),e.bindTexture(e.TEXTURE_2D,this.material.specularTexture),e.bindSampler(15,this.material.specularTexture.sampler)),this.material.specularColorTexture&&(e.activeTexture(e.TEXTURE19),e.bindTexture(e.TEXTURE_2D,this.material.specularColorTexture),e.bindSampler(19,this.material.specularColorTexture.sampler)),this.material.thicknessTexture&&(e.activeTexture(e.TEXTURE16),e.bindTexture(e.TEXTURE_2D,this.material.thicknessTexture),e.bindSampler(16,this.material.thicknessTexture.sampler)),this.material.doubleSided&&e.disable(e.CULL_FACE),this.frontFace&&e.frontFace(e.CW),this.geometry.indicesBuffer?e.drawElements(this.mode,this.geometry.indicesBuffer.length,e[_.get(this.geometry.indicesBuffer.constructor)],0):e.drawArrays(this.mode,0,this.geometry.attributes.POSITION.length/3),this.material.doubleSided&&e.enable(e.CULL_FACE),this.frontFace&&e.frontFace(e.CCW)}}setGeometry(e){this.geometry=e}setProgram(e){this.program=e}setMode(e=4){this.mode=e}setVariants(e){this.variants=e}setFrontFace(){this.frontFace=!0}isVisible(e){const r=new n(this.geometry.boundingSphere.center.elements).applyMatrix4(this.matrixWorld),t=this.geometry.boundingSphere.radius*this.matrixWorld.getMaxScaleOnAxis();let i,s=!0;for(const n of e)if(i=n.elements[0]*r.elements[0]+n.elements[1]*r.elements[1]+n.elements[2]*r.elements[2]+n.elements[3],i<-t){s=!1;break}return this.distance=i+t,s}calculateBounding(){this.geometry.calculateBounding(this.matrixWorld)}}class L extends C{bones;boneInverses;skin;skinBuffer;constructor(e,r){super(e,r)}setSkinWebGPU(e,r){this.bones=r.bones,this.boneInverses=r.boneInverses;const t=this.getJointMatrix(),n=new Float32Array(16*t.length);let i=0;for(const e of t)n.set(e.elements,0+16*i),i++;const s=n.byteLength,o=256+s,{device:a}=e,c=a.createBuffer({size:o,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});this.skinBuffer=c;const l={binding:22,resource:{buffer:c,offset:0,size:s}};return a.queue.writeBuffer(c,0,n.buffer,n.byteOffset,n.byteLength),l}setSkin(e,r){this.bones=r.bones,this.boneInverses=r.boneInverses;const t=this.getJointMatrix(),n=new Float32Array(16*t.length);let i=0;for(const e of t)n.set(e.elements,0+16*i),i++;const s=e.getUniformBlockIndex(this.program,"Skin");e.uniformBlockBinding(this.program,s,2);const o=e.createBuffer();return e.bindBuffer(e.UNIFORM_BUFFER,o),e.bufferData(e.UNIFORM_BUFFER,n,e.DYNAMIC_DRAW),this.geometry.SKIN=o,e.bindBuffer(e.UNIFORM_BUFFER,null),this}getJointMatrix(){const e=new r(this.matrixWorld).invert(),t=[];for(let n=0;n<this.boneInverses.length;n++){const i=(new r).multiply(e).multiply(this.bones[n].matrixWorld).multiply(this.boneInverses[n]);t.push(i)}return t}}class B extends f{}class y extends f{isInitial;props;matrixWorldInvert;projection;modelSize;modelXSize;modelYSize;yaw;pitch;matrixInitial;rotation;constructor(e,t,n){super(t,n),this.matrixWorldInvert=new r,this.projection=new r,this.props=e,this.yaw=0,this.pitch=-Math.PI,this.rotation=new r}setProjection(e){this.projection.set(e.elements)}setMatrixWorld(e){super.setMatrixWorld(e),this.matrixWorldInvert.setInverseOf(this.matrixWorld),this.matrixInitial||(this.matrixInitial=new r(this.matrixWorld))}setZ(e){this.matrix.elements[14]=e,this.matrixInitial=new r(this.matrix),this.setMatrixWorld(this.matrix.elements)}getViewProjMatrix(){const e=new r;return e.multiply(this.projection),e.multiply(this.matrixWorldInvert),e}pan(e,t,i,s){const o=U(e,this.projection,i,s),a=U(t,this.projection,i,s),c=new n([...o,0]),l=new n([...a,0]);if("orthographic"===this.props.type){const e=2*this.matrixWorld.elements[14],r=c.subtract(l).scale(e);this.matrixInitial.translate(r.elements[0],r.elements[1],0)}else{const e=10*this.matrixWorld.elements[14],r=l.subtract(c).scale(e);this.matrixInitial.translate(r.elements[0],r.elements[1],0)}const u=new r(this.rotation);u.multiply(this.matrixInitial),this.setMatrixWorld(u.elements)}rotate(e,t){var i,s,o;this.yaw+=.01*(e[0]-t[0]),this.pitch+=.01*(e[1]-t[1]),this.pitch=(i=this.pitch,s=-1.5*Math.PI,o=-.5*Math.PI,i<s?s:i>o?o:i);const a=new r;a.rotate(new n([1,0,0]),this.pitch),a.rotate(new n([0,1,0]),-this.yaw),a.rotate(new n([1,0,0]),Math.PI),this.rotation=a;const c=new r(a);c.multiply(this.matrixInitial),this.setMatrixWorld(c.elements)}zoom(e){if(this.matrixInitial.elements[14]>5*this.modelSize&&e>0)return;this.matrixInitial.elements[14]+=e*this.modelSize*.001;const t=new r(this.rotation);t.multiply(this.matrixInitial),this.setMatrixWorld(t.elements),this.updateNF()}updateNF(){if(this.props.isInitial){const e=Math.min(...this.matrixWorld.getScaling().elements),r=this.modelSize/e,t=Math.abs(this.matrixWorldInvert.elements[14]),n=this.props.perspective||this.props.orthographic;n.znear=Math.max(t-r,.05*r),n.zfar=t+r}this.setProjection(M(this.props))}}class D extends f{matrixWorldInvert;type;color;intensity;isInitial;spot;constructor(e,t,i){super(t,i);const{type:s,color:o=[1,1,1],intensity:a,isInitial:c,spot:l={}}=e;this.type=s,this.color=new n(o),this.intensity=a,this.isInitial=c,this.spot=l,this.matrixWorldInvert=new r}setMatrixWorld(e){super.setMatrixWorld(e),this.matrixWorldInvert.setInverseOf(this.matrixWorld)}setZ(e){this.matrix.elements[13]=e,this.matrix.elements[14]=e,this.setMatrixWorld(this.matrix.elements)}update(e){if(this.isInitial||"directional"===this.type){const t=new r;t.makeRotationAxis(new n([0,1,0]),e),t.multiply(this.matrix),this.setMatrixWorld(t.elements)}}}class w{offset;map;tempStore;store;bufferWebGPU;constructor(){this.map=new Map,this.tempStore={},this.offset=0}getBuffer(e){const{length:r}=e;return 3===r?new Float32Array([e[0],e[1],e[2],0]):9===r?new Float32Array([e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0]):12===r?new Float32Array([e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,e[9],e[10],e[11],0]):6===r?new Float32Array([e[0],e[1],e[2],0,e[3],e[4],e[5],0]):e}add(e,r){void 0===r.length&&(r=[r]),this.map.set(e,this.offset);const t=this.getBuffer(r);this.tempStore[e]=t,this.offset+=Math.max(t.length,4)}update(e,r,t,n=!1){void 0===t.length&&(t=new Float32Array([t]));const i=this.map.get(r);if(void 0===i)return;const s=this.getBuffer(t);this.store.set(s,i),n||e.bufferSubData(e.UNIFORM_BUFFER,i*Float32Array.BYTES_PER_ELEMENT,s)}updateWebGPU(e,r,t,n=!1){const{device:i}=e;void 0===t.length&&(t=new Float32Array([t]));const s=this.map.get(r);if(void 0===s)return;const o=this.getBuffer(t);this.store.set(o,s),n||i.queue.writeBuffer(this.bufferWebGPU,s*Float32Array.BYTES_PER_ELEMENT,o.buffer,o.byteOffset,o.byteLength)}done(){this.store=new Float32Array(this.offset);for(const[e,r]of this.map)this.store.set(this.tempStore[e],r);this.tempStore=null}}class G{name;extensions;extras;pbrMetallicRoughness;normalTexture;occlusionTexture;emissiveTexture;emissiveFactor;alphaMode;alphaCutoff;doubleSided}const V={baseColorFactor:[1,0,0,1]},X={directional:0,point:1,spot:2};class H extends G{blend;uniforms;alpha;UBO;defines;matrices;uniformBuffer;lightUBO1;lightUniformBuffer1;lightUBO2;lightUniformBuffer2;lightUBO3;lightUniformBuffer3;lightUBO4;lightUBO5;lightUniformBuffer4;matricesMap=new Map;uniformBindGroup1;constructor(e=V,r,t){super();const n=Object.assign({},e);if(this.defines=t,this.name=n.name,this.matrices=[],this.diffuseTransmissionColorFactor=[1,1,1],this.defines.push({name:"LIGHTINDEX",value:0}),!n.pbrMetallicRoughness&&n.extensions&&n.extensions.KHR_materials_pbrSpecularGlossiness){n.pbrMetallicRoughness={};const e=n.extensions.KHR_materials_pbrSpecularGlossiness;n.pbrMetallicRoughness.baseColorTexture=e.diffuseTexture,n.pbrMetallicRoughness.metallicRoughnessTexture=e.specularGlossinessTexture,n.pbrMetallicRoughness.baseColorFactor=e.diffuseFactor,n.pbrMetallicRoughness.specularFactor=e.specularFactor,n.pbrMetallicRoughness.glossinessFactor=e.glossinessFactor,t.push({name:"SPECULARGLOSSINESSMAP"})}if(n.extensions&&n.extensions.KHR_materials_clearcoat){const e=n.extensions.KHR_materials_clearcoat;if(this.clearcoatFactor=e.clearcoatFactor,this.clearcoatRoughnessFactor=e.clearcoatRoughnessFactor,t.push({name:"CLEARCOAT"}),e.clearcoatTexture){const{extensions:n,texCoord:i}=e.clearcoatTexture;if(this.clearcoatTexture=r[e.clearcoatTexture.index],t.push({name:"CLEARCOATMAP",value:i??0}),n){const e=n.KHR_texture_transform;e&&this.matricesMap.set("clearcoatTexture",this.buildTrans(e,t,"CLEARCOATMAP"))}}if(e.clearcoatNormalTexture){const{extensions:n,texCoord:i}=e.clearcoatNormalTexture;if(this.clearcoatNormalTexture=r[e.clearcoatNormalTexture.index],t.push({name:"CLEARCOATNORMALMAP",value:i??0}),n){const e=n.KHR_texture_transform;e&&this.matricesMap.set("clearcoatNormalTexture",this.buildTrans(e,t,"CLEARCOATNORMALMAP"))}}if(e.clearcoatRoughnessTexture){const{extensions:n,texCoord:i}=e.clearcoatRoughnessTexture;if(this.clearcoatRoughnessTexture=r[e.clearcoatRoughnessTexture.index],t.push({name:"CLEARCOATROUGHMAP",value:i??0}),n){const e=n.KHR_texture_transform;e&&this.matricesMap.set("clearcoatRoughnessTexture",this.buildTrans(e,t,"CLEARCOATROUGHMAP"))}}}if(n.extensions&&n.extensions.KHR_materials_sheen){const{sheenColorTexture:e,sheenColorFactor:i,sheenRoughnessFactor:s,sheenRoughnessTexture:o}=n.extensions.KHR_materials_sheen;if(this.sheenColorFactor=i,this.sheenRoughnessFactor=s,e){const{extensions:n,texCoord:i}=e;if(this.sheenColorTexture=r[e.index],t.push({name:"SHEENMAP",value:i??0}),n){const e=n.KHR_texture_transform;e&&this.matricesMap.set("sheenColorTexture",this.buildTrans(e,t,"SHEENMAP"))}}if(o){const{extensions:e,texCoord:n}=o;if(this.sheenRoughnessTexture=r[o.index],t.push({name:"SHEENROUGHNESSMAP",value:n??0}),e){const r=e.KHR_texture_transform;r&&this.matricesMap.set("sheenRoughnessTexture",this.buildTrans(r,t,"SHEENROUGHNESSMAP"))}}t.push({name:"SHEEN"})}if(n.extensions&&n.extensions.KHR_materials_transmission){const{transmissionFactor:e,transmissionTexture:i}=n.extensions.KHR_materials_transmission;if(this.transmissionFactor=e,i){const{extensions:e,texCoord:n}=i;if(this.transmissionTexture=r[i.index],t.push({name:"TRANSMISSIONMAP",value:n??0}),e){const r=e.KHR_texture_transform;r&&this.matricesMap.set("transmissionTexture",this.buildTrans(r,t,"TRANSMISSIONMAP"))}}t.push({name:"TRANSMISSION"})}if(n.extensions&&n.extensions.KHR_materials_volume){const{attenuationColor:e,attenuationDistance:i,thicknessFactor:s,thicknessTexture:o}=n.extensions.KHR_materials_volume;if(this.attenuationColor=e,this.attenuationDistance=i,this.thicknessFactor=s,this.ior=1.5,o){const{extensions:e,texCoord:n}=o;if(this.thicknessTexture=r[o.index],t.push({name:"THICKNESSMAP",value:n??0}),e){const r=e.KHR_texture_transform;r&&this.matricesMap.set("thicknessTexture",this.buildTrans(r,t,"THICKNESSMAP"))}}t.push({name:"VOLUME"})}if(n.extensions&&n.extensions.KHR_materials_emissive_strength){const{emissiveStrength:e}=n.extensions.KHR_materials_emissive_strength;this.emissiveStrength=e}if(n.extensions&&n.extensions.KHR_materials_anisotropy){const{anisotropyStrength:e,anisotropyRotation:i,anisotropyTexture:s}=n.extensions.KHR_materials_anisotropy;if(this.anisotropyStrength=e,this.anisotropyRotation=i,s&&(this.anisotropyTexture=r[s.index],t.push({name:"ANISOTROPYMAP",value:s.texCoord??0}),s.extensions)){const e=s.extensions.KHR_texture_transform;e&&this.matricesMap.set("anisotropyTexture",this.buildTrans(e,t,"ANISOTROPYMAP"))}t.push({name:"ANISOTROPY"})}if(n.extensions&&n.extensions.KHR_materials_dispersion){const{dispersion:e}=n.extensions.KHR_materials_dispersion;this.dispersion=e,t.push({name:"DISPERSION"})}if(n.extensions&&n.extensions.KHR_materials_iridescence){const{iridescenceTexture:e,iridescenceThicknessTexture:i,iridescenceFactor:s,iridescenceIor:o,iridescenceThicknessMaximum:a,iridescenceThicknessMinimum:c}=n.extensions.KHR_materials_iridescence;if(this.iridescenceFactor=s,this.iridescenceIOR=o,this.iridescenceThicknessMaximum=a,this.iridescenceThicknessMinimum=c,e&&(this.iridescenceTexture=r[e.index],t.push({name:"IRIDESCENCE_COLOR",value:e.texCoord??0}),e.extensions)){const r=e.extensions.KHR_texture_transform;r&&this.matricesMap.set("iridescenceTexture",this.buildTrans(r,t,"IRIDESCENCE_COLOR"))}if(i&&(this.iridescenceThicknessTexture=r[i.index],t.push({name:"IRIDESCENCEMAP",value:i.texCoord??0}),i.extensions)){const e=i.extensions.KHR_texture_transform;e&&this.matricesMap.set("iridescenceThicknessTexture",this.buildTrans(e,t,"IRIDESCENCEMAP"))}t.push({name:"IRIDESCENCE"})}if(n.extensions&&n.extensions.KHR_materials_diffuse_transmission){const{diffuseTransmissionFactor:e,diffuseTransmissionTexture:i,diffuseTransmissionColorFactor:s,diffuseTransmissionColorTexture:o}=n.extensions.KHR_materials_diffuse_transmission;if(this.diffuseTransmissionFactor=e,i&&(this.diffuseTransmissionTexture=r[i.index],t.push({name:"DIFFUSE_TRANSMISSION_MAP",value:i.texCoord??0}),i.extensions)){const e=i.extensions.KHR_texture_transform;e&&this.matricesMap.set("diffuseTransmissionTexture",this.buildTrans(e,t,"DIFFUSE_TRANSMISSION_MAP"))}if(this.diffuseTransmissionColorFactor=s??[1,1,1],o&&(this.diffuseTransmissionColorTexture=r[o.index],t.push({name:"DIFFUSE_TRANSMISSION_COLOR_MAP",value:o.texCoord??0}),o.extensions)){const e=o.extensions.KHR_texture_transform;e&&this.matricesMap.set("diffuseTransmissionColorTexture",this.buildTrans(e,t,"DIFFUSE_TRANSMISSION_COLOR_MAP"))}t.push({name:"DIFFUSE_TRANSMISSION"})}if(n.extensions&&n.extensions.KHR_materials_ior&&(this.ior=n.extensions.KHR_materials_ior.ior,t.push({name:"IOR"})),n.extensions&&n.extensions.KHR_materials_specular){const{specularFactor:e,specularTexture:i,specularColorFactor:s,specularColorTexture:o}=n.extensions.KHR_materials_specular;if(this.specularFactor=e,this.specularColorFactor=s,i&&(this.specularTexture=r[i.index],t.push({name:"SPECULARMAP"}),i.extensions)){const e=i.extensions.KHR_texture_transform;e&&this.matricesMap.set("specularTexture",this.buildTrans(e,t,"SPECULARMAP"))}if(o&&(this.specularColorTexture=r[o.index],t.push({name:"SPECULARCOLORMAP"}),o.extensions)){const e=o.extensions.KHR_texture_transform;e&&this.matricesMap.set("specularColorTexture",this.buildTrans(e,t,"SPECULARCOLORMAP"))}t.push({name:"SPECULAR"})}this.uniforms={baseColorTexture:null,metallicRoughnessTexture:null,normalTexture:null,occlusionTexture:null,clearcoatTexture:null,clearcoatRoughnessTexture:null,sheenRoughnessTexture:null,iridescenceThicknessTexture:null,iridescenceTexture:null,sheenColorTexture:null,clearcoatNormalTexture:null,emissiveTexture:null,prefilterMap:null,charlieMap:null,brdfLUT:null,irradianceMap:null,transmissionTexture:null,specularTexture:null,specularColorTexture:null,thicknessTexture:null,colorTexture:null,Sheen_E:null,depthTexture:null,diffuseTransmissionTexture:null,diffuseTransmissionColorTexture:null,anisotropyTexture:null,isTone:null,isIBL:null,isDefaultLight:null};const{pbrMetallicRoughness:i}=n;if(i&&(this.baseColorFactor=i.baseColorFactor,this.roughnessFactor=i.roughnessFactor,this.metallicFactor=i.metallicFactor,i.specularFactor&&(this.specularFactor=i.specularFactor),i.glossinessFactor&&(this.glossinessFactor=i.glossinessFactor)),this.alpha="BLEND"===n.alphaMode,this.doubleSided=n.doubleSided,this.emissiveFactor=n.emissiveFactor,this.extras=n.extras,i&&i.metallicRoughnessTexture){const{extensions:e,texCoord:n}=i.metallicRoughnessTexture;if(this.metallicRoughnessTexture=r[i.metallicRoughnessTexture.index],t.push({name:"METALROUGHNESSMAP",value:n??0}),e){const r=e.KHR_texture_transform;r&&this.matricesMap.set("metallicRoughnessTexture",this.buildTrans(r,t,"METALROUGHNESSMAP"))}}if(n.normalTexture){const{extensions:e,texCoord:i,scale:s}=n.normalTexture;if(this.normalTexture=r[n.normalTexture.index],this.normalTextureScale=s,t.push({name:"NORMALMAP",value:i??0}),e){const r=e.KHR_texture_transform;r&&(this.normalTextureScale=void 0,this.matricesMap.set("normalTexture",this.buildTrans(r,t,"NORMALMAP")))}}if(n.occlusionTexture){const{extensions:e,texCoord:i}=n.occlusionTexture;if(this.occlusionTexture=r[n.occlusionTexture.index],t.push({name:"OCCLUSIONMAP",value:i??0}),e){const r=e.KHR_texture_transform;r&&this.matricesMap.set("occlusionTexture",this.buildTrans(r,t,"OCCLUSIONMAP"))}}if(i&&i.baseColorTexture){const{extensions:e,texCoord:n}=i.baseColorTexture;if(this.baseColorTexture=r[i.baseColorTexture.index],t.push({name:"BASECOLORTEXTURE",value:n??0}),e){const r=e.KHR_texture_transform;r&&this.matricesMap.set("baseColorTexture",this.buildTrans(r,t,"BASECOLORTEXTURE"))}}if(n.emissiveTexture){const{extensions:e,texCoord:i}=n.emissiveTexture;if(this.emissiveTexture=r[n.emissiveTexture.index],t.push({name:"EMISSIVEMAP",value:i??0}),e){const r=e.KHR_texture_transform;r&&this.matricesMap.set("emissiveTexture",this.buildTrans(r,t,"EMISSIVEMAP"))}}"MASK"===n.alphaMode?t.push({name:"ALPHATEST",value:n.alphaCutoff??.5}):"BLEND"===n.alphaMode&&t.push({name:"ALPHATEST",value:.01}),this.doubleSided&&t.push({name:"DOUBLESIDED"}),n.extensions&&n.extensions.KHR_materials_unlit&&t.push({name:"NOLIGHT"}),this.matrices.length&&t.push({name:"MATRICES",value:this.matrices.length})}buildTrans(e,t,n=""){if(void 0!==e.offset||void 0!==e.scale||void 0!==e.rotation){const i=e.offset||[0,0],s=e.scale||[1,1],o=e.rotation||0,a=this.matrices.push((new r).set([...i,0,0,...s,0,0,o,0,0,0,0,0,0,0]))-1;return t.push({name:`${n}_TEXTURE_TRANSFORM`,value:a}),a}}setHarmonics(e){this.sphericalHarmonics=e}updateUniformsWebgl(e,r){e.useProgram(r),this.uniforms.isTone=e.getUniformLocation(r,"isTone"),this.uniforms.isIBL=e.getUniformLocation(r,"isIBL"),this.uniforms.isDefaultLight=e.getUniformLocation(r,"isDefaultLight"),this.baseColorTexture&&(this.uniforms.baseColorTexture=e.getUniformLocation(r,"baseColorTexture"),e.uniform1i(this.uniforms.baseColorTexture,0)),this.metallicRoughnessTexture&&(this.uniforms.metallicRoughnessTexture=e.getUniformLocation(r,"metallicRoughnessTexture"),e.uniform1i(this.uniforms.metallicRoughnessTexture,1)),this.normalTexture&&(this.uniforms.normalTexture=e.getUniformLocation(r,"normalTexture"),e.uniform1i(this.uniforms.normalTexture,2)),this.occlusionTexture&&(this.uniforms.occlusionTexture=e.getUniformLocation(r,"occlusionTexture"),e.uniform1i(this.uniforms.occlusionTexture,3)),this.emissiveTexture&&(this.uniforms.emissiveTexture=e.getUniformLocation(r,"emissiveTexture"),e.uniform1i(this.uniforms.emissiveTexture,4)),this.clearcoatTexture&&(this.uniforms.clearcoatTexture=e.getUniformLocation(r,"clearcoatTexture"),e.uniform1i(this.uniforms.clearcoatTexture,8)),this.clearcoatRoughnessTexture&&(this.uniforms.clearcoatRoughnessTexture=e.getUniformLocation(r,"clearcoatRoughnessTexture"),e.uniform1i(this.uniforms.clearcoatRoughnessTexture,9)),this.clearcoatNormalTexture&&(this.uniforms.clearcoatNormalTexture=e.getUniformLocation(r,"clearcoatNormalTexture"),e.uniform1i(this.uniforms.clearcoatNormalTexture,10)),this.sheenRoughnessTexture&&(this.uniforms.sheenRoughnessTexture=e.getUniformLocation(r,"sheenRoughnessTexture"),e.uniform1i(this.uniforms.sheenRoughnessTexture,12)),this.iridescenceThicknessTexture&&(this.uniforms.iridescenceThicknessTexture=e.getUniformLocation(r,"iridescenceThicknessTexture"),e.uniform1i(this.uniforms.iridescenceThicknessTexture,17)),this.iridescenceTexture&&(this.uniforms.iridescenceTexture=e.getUniformLocation(r,"iridescenceTexture"),e.uniform1i(this.uniforms.iridescenceTexture,23)),this.anisotropyTexture&&(this.uniforms.anisotropyTexture=e.getUniformLocation(r,"anisotropyTexture"),e.uniform1i(this.uniforms.anisotropyTexture,22)),this.diffuseTransmissionColorTexture&&(this.uniforms.diffuseTransmissionColorTexture=e.getUniformLocation(r,"diffuseTransmissionColorTexture"),e.uniform1i(this.uniforms.diffuseTransmissionColorTexture,21)),this.diffuseTransmissionTexture&&(this.uniforms.diffuseTransmissionTexture=e.getUniformLocation(r,"diffuseTransmissionTexture"),e.uniform1i(this.uniforms.diffuseTransmissionTexture,20)),this.sheenColorTexture&&(this.uniforms.sheenColorTexture=e.getUniformLocation(r,"sheenColorTexture"),e.uniform1i(this.uniforms.sheenColorTexture,11)),this.transmissionTexture&&(this.uniforms.transmissionTexture=e.getUniformLocation(r,"transmissionTexture"),e.uniform1i(this.uniforms.transmissionTexture,14)),this.specularTexture&&(this.uniforms.specularTexture=e.getUniformLocation(r,"specularTexture"),e.uniform1i(this.uniforms.specularTexture,15)),this.specularColorTexture&&(this.uniforms.specularColorTexture=e.getUniformLocation(r,"specularColorTexture"),e.uniform1i(this.uniforms.specularColorTexture,19)),this.thicknessTexture&&(this.uniforms.thicknessTexture=e.getUniformLocation(r,"thicknessTexture"),e.uniform1i(this.uniforms.thicknessTexture,16)),this.uniforms.prefilterMap=e.getUniformLocation(r,"prefilterMap"),this.uniforms.charlieMap=e.getUniformLocation(r,"charlieMap"),this.uniforms.brdfLUT=e.getUniformLocation(r,"brdfLUT"),this.uniforms.irradianceMap=e.getUniformLocation(r,"irradianceMap"),this.uniforms.depthTexture=e.getUniformLocation(r,"depthTexture"),this.uniforms.colorTexture=e.getUniformLocation(r,"colorTexture"),this.uniforms.Sheen_E=e.getUniformLocation(r,"Sheen_E"),e.uniform1i(this.uniforms.prefilterMap,6),e.uniform1i(this.uniforms.charlieMap,18),e.uniform1i(this.uniforms.brdfLUT,7),e.uniform1i(this.uniforms.irradianceMap,5),e.uniform1i(this.uniforms.Sheen_E,13);{const t=e.getUniformBlockIndex(r,"LightColor");e.uniformBlockBinding(r,t,4)}{const t=e.getUniformBlockIndex(r,"LightPos");e.uniformBlockBinding(r,t,3)}{const t=e.getUniformBlockIndex(r,"Spotdir");e.uniformBlockBinding(r,t,5)}{const t=e.getUniformBlockIndex(r,"LightIntensity");e.uniformBlockBinding(r,t,6)}if(this.matrices.length){const t=e.getUniformBlockIndex(r,"TextureMatrices");e.uniformBlockBinding(r,t,8);const n=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,n),e.bufferData(e.UNIFORM_BUFFER,this.textureMatricesBuffer.store,e.STATIC_DRAW),this.lightUBO5=n}}createUniforms(e,r){const t=new Float32Array(4*r.length),i=new Float32Array(4*r.length),s=new Float32Array(4*r.length),o=new Float32Array(4*r.length),a=new Float32Array(16*this.matrices.length);r.forEach((e,r)=>{t.set(new n([e.matrixWorld.elements[8],e.matrixWorld.elements[9],e.matrixWorld.elements[10]]).normalize().elements,4*r),i.set(e.getPosition(),4*r),s.set(e.color.elements,4*r),o.set([e.intensity,e.spot.innerConeAngle??0,e.spot.outerConeAngle??0,X[e.type]],4*r)}),this.matrices.forEach((e,r)=>{a.set(e.elements,16*r)});{const e=new w;e.add("baseColorFactor",this.baseColorFactor??[.8,.8,.8,1]),e.add("specularFactor",this.specularFactor??1),e.add("specularColorFactor",this.specularColorFactor??[1,1,1]),e.add("emissiveFactor",this.emissiveFactor??[0,0,0]),e.add("glossinessFactor",this.glossinessFactor??.5),e.add("metallicFactor",this.metallicFactor??1),e.add("roughnessFactor",this.roughnessFactor??1),e.add("clearcoatFactor",this.clearcoatFactor??0),e.add("clearcoatRoughnessFactor",this.clearcoatRoughnessFactor??0),e.add("sheenColorFactor",this.sheenColorFactor??0),e.add("sheenRoughnessFactor",this.sheenRoughnessFactor??0),e.add("transmissionFactor",this.transmissionFactor??0),e.add("ior",this.ior??1),e.add("normalTextureScale",this.normalTextureScale??1),e.add("attenuationColor",this.attenuationColor??[1,1,1]),e.add("attenuationDistance",this.attenuationDistance??1),e.add("thicknessFactor",this.thicknessFactor??0),e.add("emissiveStrength",this.emissiveStrength??1),e.add("anisotropy",[this.anisotropyStrength??0,this.anisotropyRotation??0]),e.add("iridescence",[this.iridescenceFactor??0,this.iridescenceIOR??1.3,this.iridescenceThicknessMaximum??400,this.iridescenceThicknessMinimum??100]),e.add("diffuseTransmissionFactor",[this.diffuseTransmissionFactor??0,...this.diffuseTransmissionColorFactor]),e.add("dispersionFactor",[this.dispersion??0]),e.done(),this.materialUniformBuffer=e}if(this.matrices.length){const e=new w;e.add("textureMatrices",a),e.done(),this.textureMatricesBuffer=e}}updateUniformsWebGPU(e){const{device:r,nearestSampler:t,linearSampler:n}=e;let i;this.textureMatricesBuffer&&(i=r.createBuffer({size:256+this.textureMatricesBuffer.store.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.textureMatricesBuffer.bufferWebGPU=i);const s=[{binding:2,resource:this.baseColorTexture?this.baseColorTexture.sampler:n},{binding:37,resource:t},{binding:24,resource:n},{binding:3,resource:this.baseColorTexture?.view},{binding:4,resource:this.metallicRoughnessTexture?.view},{binding:5,resource:this.normalTexture?.view},{binding:6,resource:this.emissiveTexture?.view},{binding:7,resource:this.occlusionTexture?.view},{binding:8,resource:this.clearcoatTexture?.view},{binding:9,resource:this.clearcoatRoughnessTexture?.view},{binding:10,resource:this.transmissionTexture?.view},{binding:11,resource:this.sheenColorTexture?.view},{binding:12,resource:this.sheenRoughnessTexture?.view},{binding:13,resource:this.clearcoatNormalTexture?.view},{binding:14,resource:this.specularTexture?.view},{binding:29,resource:this.thicknessTexture?.view},{binding:31,resource:this.anisotropyTexture?.view},{binding:32,resource:this.iridescenceThicknessTexture?.view},{binding:38,resource:this.iridescenceTexture?.view},{binding:33,resource:this.specularColorTexture?.view},{binding:34,resource:this.diffuseTransmissionTexture?.view},{binding:36,resource:this.diffuseTransmissionColorTexture?.view},{binding:23,resource:this.textureMatricesBuffer&&{buffer:i,offset:0,size:this.textureMatricesBuffer.store.byteLength}}];this.textureMatricesBuffer&&r.queue.writeBuffer(i,0,this.textureMatricesBuffer.store.buffer,this.textureMatricesBuffer.store.byteOffset,this.textureMatricesBuffer.store.byteLength),this.uniformBindGroup1=s.filter(e=>e.resource)}hasNormal(){return Boolean(this.normalTexture)||Boolean(this.clearcoatNormalTexture)}setColor(e,r,t){this.materialUniformBuffer.update(e,r,t.elements,!0)}setTexture(e,r,t,n){e.bindBufferBase(e.UNIFORM_BUFFER,8,this.lightUBO5);const i=16*this.matricesMap.get(r);"offset"===t&&(this.textureMatricesBuffer.store[i]=n.elements[0],this.textureMatricesBuffer.store[i+1]=n.elements[1]),"scale"===t&&(this.textureMatricesBuffer.store[i+4]=n.elements[0],this.textureMatricesBuffer.store[i+5]=n.elements[1]),"rotation"===t&&(this.textureMatricesBuffer.store[i+8]=n.elements[0]),e.bufferSubData(e.UNIFORM_BUFFER,0,this.textureMatricesBuffer.store)}setTextureWebGPU(e,r,t,n){const i=16*this.matricesMap.get(r);"offset"===t&&(this.textureMatricesBuffer.store[i]=n.elements[0],this.textureMatricesBuffer.store[i+1]=n.elements[1]),"scale"===t&&(this.textureMatricesBuffer.store[i+4]=n.elements[0],this.textureMatricesBuffer.store[i+5]=n.elements[1]),"rotation"===t&&(this.textureMatricesBuffer.store[i+8]=n.elements[0]),e.device.queue.writeBuffer(this.textureMatricesBuffer.bufferWebGPU,0,this.textureMatricesBuffer.store.buffer,this.textureMatricesBuffer.store.byteOffset,this.textureMatricesBuffer.store.byteLength)}setColorWebGPU(e,r,t){this.materialUniformBuffer.updateWebGPU(e,r,t.elements,!0)}}class z{counterEl;fps;elapsedTime;lastTime;constructor(){this.counterEl=document.createElement("div"),this.counterEl.setAttribute("style","position: absolute; top: 0; right: 0; color: #fff; font-size: 30px; background: #000;"),document.body.appendChild(this.counterEl),this.fps=0,this.elapsedTime=0,this.lastTime=0}tick(e){this.fps++,this.elapsedTime+=e-this.lastTime,this.lastTime=e,this.elapsedTime>=1e3&&(this.counterEl.innerHTML=String(this.fps),this.fps=0,this.elapsedTime-=1e3)}}class k{canvas;camera;light;framebuffer;setCanvas(e){this.canvas=e}setCamera(e){this.camera=e}setLight(e){this.light=e}get width(){return this.canvas.offsetWidth*devicePixelRatio}get height(){return this.canvas.offsetHeight*devicePixelRatio}}const W=new Float32Array([-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1]),j=new Float32Array([-1,1,-1,-1,1,1,1,-1]);let Y,K;new Float32Array([-1,1,-1,-1,1,-1,1,-1,1,1,-1,1]);class q extends k{texture;program;scale;quadVAO;constructor(){super(),this.scale=2}setGL(e){Y=e}preProcessing(e){Y.clear(Y.COLOR_BUFFER_BIT|Y.DEPTH_BUFFER_BIT),e.renderScene({isprepender:!0}),Y.bindFramebuffer(Y.FRAMEBUFFER,this.framebuffer),Y.framebufferTexture2D(Y.FRAMEBUFFER,Y.COLOR_ATTACHMENT0,Y.TEXTURE_2D,this.texture,0),Y.useProgram(this.program),Y.viewport(0,0,this.width/this.scale,this.height/this.scale),Y.bindVertexArray(this.quadVAO);const t=M(Object.assign({},this.camera.props,{zoom:1}));Y.uniformMatrix4fv(Y.getUniformLocation(this.program,"Iproj"),!1,(new r).setInverseOf(t).elements),Y.uniformMatrix4fv(Y.getUniformLocation(this.program,"proj"),!1,t.elements),Y.uniformMatrix4fv(Y.getUniformLocation(this.program,"Iview"),!1,this.camera.matrixWorld.elements),Y.uniformMatrix4fv(Y.getUniformLocation(this.program,"view"),!1,this.camera.matrixWorldInvert.elements),Y.uniformMatrix4fv(Y.getUniformLocation(this.program,"light"),!1,this.light.matrixWorldInvert.elements),Y.uniform1i(Y.getUniformLocation(this.program,"lightTexture"),e.preDepthTexture.index),Y.uniform1i(Y.getUniformLocation(this.program,"cameraTexture"),e.depthTexture.index),Y.uniform3fv(Y.getUniformLocation(this.program,"viewPos"),this.camera.getPosition()),Y.uniform3fv(Y.getUniformLocation(this.program,"lightPos"),this.light.getPosition()),Y.drawArrays(Y.TRIANGLE_STRIP,0,4),Y.bindFramebuffer(Y.FRAMEBUFFER,null),Y.viewport(0,0,this.width,this.height)}buildScreenBuffer(e){this.framebuffer=Y.createFramebuffer(),Y.bindFramebuffer(Y.FRAMEBUFFER,this.framebuffer),this.texture=e.createOneChannelTexture(this.scale),Y.framebufferTexture2D(Y.FRAMEBUFFER,Y.COLOR_ATTACHMENT0,Y.TEXTURE_2D,this.texture,0),this.program=S("#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec2 pos;\r\n\r\nout vec2 uv;\r\nout vec4 vPosLight1;\r\nout vec4 vPosLight2;\r\nout vec3 outPositionView;\r\nout vec3 outPositionLight;\r\n\r\nuniform mat4 proj;\r\nuniform mat4 light;\r\nuniform mat4 Iproj;\r\nuniform mat4 Iview;\r\nuniform mat4 view;\r\n\r\nvoid main() {\r\n    vec4 p1 = Iview * Iproj * vec4(pos, -1.0/16.0, 1.0);\r\n    vec4 p2 = Iview * Iproj * vec4(pos, 1.0/16.0, 1.0);\r\n\r\n\tvPosLight1 = proj * light * p1;\r\n    vPosLight2 = proj * light * p2;\r\n    outPositionLight = vec3(light * p1);\r\n    outPositionView = vec3(view * p1);\r\n\r\n\tuv = pos * 0.5 + 0.5;\r\n\tgl_Position = vec4(pos, 0.0, 1.0);\r\n}\r\n","#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\n// in vec4 tPos1;\r\n// in vec4 tPos2;\r\nin vec4 vPosLight1;\r\nin vec4 vPosLight2;\r\nout float color;\r\n\r\nuniform sampler2D lightTexture;\r\nuniform sampler2D cameraTexture;\r\n\r\nuniform mat4 proj;\r\nuniform mat4 light;\r\nuniform mat4 view;\r\nuniform vec3 viewPos;\r\nuniform vec3 lightPos;\r\n\r\nin vec3 outPositionView;\r\nin vec3 outPositionLight;\r\n\r\nconst int samples = 80;\r\n\r\nvoid main() {\r\n    float stp = 1.0/float(samples);\r\n\tfloat k = 0.0;\r\n    float d = 0.0;\r\n\r\n    for (int i = 0; i < samples; i++) {\r\n\r\n        //vec4 vPos = mix(tPos1,tPos2,k);\r\n        vec4 vPosLight = mix(vPosLight1,vPosLight2,k);\r\n        k += stp;\r\n\r\n        vec3 ShadowTexC = (vPosLight.xyz/vPosLight.w) * 0.5 + 0.5;\r\n\r\n        float add = step(texture(lightTexture, ShadowTexC.xy).x, ShadowTexC.z);\r\n        d += add*stp;\r\n\t}\r\n\r\n    vec3 viewDir = normalize(viewPos - outPositionView);\r\n    vec3 L = normalize(lightPos - outPositionLight);\r\n    color = min((1.0 - d), (1.0 - dot(L, viewDir)) * 0.2);\r\n}\r\n"),this.quadVAO=Y.createVertexArray(),Y.bindVertexArray(this.quadVAO);const r=Y.createBuffer();return Y.bindBuffer(Y.ARRAY_BUFFER,r),Y.bufferData(Y.ARRAY_BUFFER,new Float32Array(j),Y.STATIC_DRAW),Y.enableVertexAttribArray(0),Y.vertexAttribPointer(0,2,Y.FLOAT,!1,0,0),Y.bindVertexArray(null),Y.bindFramebuffer(Y.FRAMEBUFFER,null),{name:"LIGHT"}}attachUniform(e){Y.uniform1i(Y.getUniformLocation(e,"light"),this.texture.index)}postProcessing(){}}class Z{parse;PP;scene;Particles;fps;camera;getState;reflow;needUpdateProjection=!0;needUpdateView=!0;env;currentTrack;constructor(e){this.reflow=!0,this.fps=new z,this.getState=e,this.currentTrack=0}setEnv(e){this.env=e}setCamera(e){this.camera=e}setParticles(e){this.Particles=e}setScene(e){this.scene=e}setPp(e){this.PP=e}setGl(e){K=e}setParser(e){this.parse=e}step(e,r){const i=x(e,r.keys);if(-1===i[0]||-1===i[1]||0===i[0]&&0===i[1])return!1;const s=r.keys[i[0]],{component:o}=r;let c;c=3===o?n:4===o?a:t;const l=new c(s.value);if("rotation"===r.type)for(const e of r.meshes){const r=e.matrix.getScaling();e.matrix.makeRotationFromQuaternion(l.elements),e.matrix.scale(r)}else if("scale"===r.type)for(const e of r.meshes){if(e.matrix.animated){const r=e.matrix.getScaling();e.matrix.restoreScale(r)}e.matrix.scale(l),e.matrix.animated=!0}else if("translation"===r.type)for(const e of r.meshes)e.matrix.setTranslate(l)}spline(e,r){const t=x(e,r.keys);if(-1===t[0]||-1===t[1]||0===t[0]&&0===t[1])return!1;const i=e,s=r.keys[t[1]].time,o=r.keys[t[0]].time,c=r.component,l=s-o,u=(i-o)/l,f=u*u,h=f*u,m=-2*h+3*f,T=h-f,d=1-m,E=T-f+u,p=new Float32Array(c);for(let e=0;e!==c;e++){const n=r.keys[t[0]].value[c+e],i=r.keys[t[0]].value[2*c+e]*l,s=r.keys[t[1]].value[c+e],o=r.keys[t[1]].value[e]*l;if(p[e]=d*n+E*i+m*s+T*o,isNaN(p[e]))return!1}if("rotation"===r.type){const e=new a(p).normalize();for(const t of r.meshes){const r=t.matrix.getScaling();t.matrix.makeRotationFromQuaternion(e.elements),t.matrix.scale(r)}}else if("scale"===r.type){const e=new n(p);for(const t of r.meshes){if(t.matrix.animated){const e=t.matrix.getScaling();t.matrix.restoreScale(e)}t.matrix.scale(e),t.matrix.animated=!0}}else if("translation"===r.type){const e=new n(p);for(const t of r.meshes)t.matrix.setTranslate(e)}}updateGeometry(e,r){e.geometry.update(K,r)}interpolation(e,r){const i=x(e,r.keys);if(-1===i[0]||-1===i[1]||0===i[0]&&0===i[1])return!1;const s=r.keys[i[0]],o=r.keys[i[1]],l=i[2],{component:u}=r;let f;f=2===u?c:3===u?n:4===u?a:t;const h=new f(s.value),m=new f(o.value);if("rotation"===r.type){const e=new a;e.lerp(h.elements,m.elements,l);for(const t of r.meshes){const r=t.matrix.getScaling();t.matrix.makeRotationFromQuaternion(e.elements),t.matrix.scale(r)}}else if("scale"===r.type){const e=new n;e.lerp(h.elements,m.elements,l);for(const t of r.meshes){if(t.matrix.animated){const e=t.matrix.getScaling();t.matrix.restoreScale(e)}t.matrix.scale(e),t.matrix.animated=!0}}else if("weights"===r.type){const e=new t(h.elements);e.lerp(h.elements,m.elements,l);for(const t of r.meshes){const r={};for(const n in t.geometry.targets[0])if("POSITION"===n){r[n]=t.geometry.attributes[n].slice();for(let i=0;i<e.elements.length;i++){if(0===e.elements[i])continue;const s=0;for(let o=0;o<r[n].length;o++)r[n][o]+=e.elements[i]*t.geometry.targets[i][n][o-s]}}this.updateGeometry(t,r)}}else if("translation"===r.type){const e=new n;e.lerp(h.elements,m.elements,l);for(const t of r.meshes)t.matrix.setTranslate(e)}else{const e=2===r.component?new c:4===r.component?new a:new t(new Float32Array(1));e.lerp(h.elements,m.elements,l);for(const t of r.meshes)this.updateMaterial(t,r.type,e)}}updateMaterial(e,r,t){const n=r.split("/"),i=n[n.length-1];if("offset"===i||"rotation"===i||"scale"===i){const r=n[n.length-4];e.material.setTexture(K,r,i,t)}else e.repaint=!0,e.material.setColor(K,n[n.length-1],t)}animate(e){if(!this.parse.tracks.length)return;const r=Math.max(...this.parse.tracks.map(e=>e[0].duration));e-=Math.floor(e/r)*r;for(const r of this.parse.tracks.sort((e,r)=>e[0].duration-r[0].duration))for(const t of r){let r;switch(t.interpolation){case"LINEAR":default:r=this.interpolation(e,t);break;case"CUBICSPLINE":r=this.spline(e,t);break;case"STEP":r=this.step(e,t)}if(!1!==r){for(const e of t.meshes)F(e,e=>{e.updateMatrix(),e instanceof B&&(e.reflow=!0),e instanceof C&&(e.reflow=!0),e instanceof y&&e===this.camera&&(this.needUpdateView=!0)});this.reflow=!0}}}render(e=0){const r=e/1e3;window.__FORCE_DETERMINISTIC__||this.animate(r),this.reflow&&(this.PP.hasPrePass&&(this.PP.bindPrePass(),this.PP.preProcessing()),this.PP.hasPostPass&&this.PP.bindPostPass(),K.clear(K.COLOR_BUFFER_BIT|K.DEPTH_BUFFER_BIT),this.parse.json.extensions&&this.parse.json.extensions.EXT_lights_image_based&&this.env.draw(),this.renderScene(),this.clean(),this.PP.postprocessors.some(e=>e instanceof q)&&(K.bindFramebuffer(K.DRAW_FRAMEBUFFER,null),this.Particles.draw(e),this.reflow=!0),this.PP.hasPostPass&&this.PP.postProcessing()),this.fps.tick(e),requestAnimationFrame(this.render.bind(this))}renderScene(){if(this.needUpdateView){const e=l(this.camera.getViewProjMatrix());this.scene.meshes.forEach(r=>{r.visible=r.isVisible(e)})}const e=this.getState();if(e.needUpdateView){K.bindBufferBase(K.UNIFORM_BUFFER,1,e.UBO),e.cameraBuffer.update(K,"view",e.camera.matrixWorldInvert.elements),e.cameraBuffer.update(K,"light",e.light.matrixWorldInvert.elements),K.bindBufferBase(K.UNIFORM_BUFFER,3,e.lightUBO1);const r=new Float32Array(3);r.set(e.light.getPosition(),0),e.lightPosBuffer.update(K,"lightPos",r)}e.needUpdateProjection&&(K.bindBufferBase(K.UNIFORM_BUFFER,1,e.UBO),e.cameraBuffer.update(K,"projection",e.camera.projection.elements)),this.scene.meshes.forEach((r,t)=>{r.reflow&&(K.activeTexture(K.TEXTURE31),K.bindTexture(K.TEXTURE_2D,e.storage2.texture),K.texSubImage2D(K.TEXTURE_2D,0,0,t,this.scene.meshes[0].geometry.uniformBuffer.store.length/Float32Array.BYTES_PER_ELEMENT,1,K.RGBA,K.FLOAT,r.matrixWorld.elements),r.reflow=!1),r.repaint&&(K.activeTexture(K.TEXTURE30),K.bindTexture(K.TEXTURE_2D,e.storage.texture2),K.texSubImage2D(K.TEXTURE_2D,0,0,t,this.scene.meshes[0].material.materialUniformBuffer.store.length/Float32Array.BYTES_PER_ELEMENT,1,K.RGBA,K.FLOAT,r.material.materialUniformBuffer.store),r.repaint=!1)}),this.scene.opaqueChildren.forEach(e=>{e.visible&&e.draw(K,this.getState())}),this.scene.transparentChildren.length&&(K.enable(K.BLEND),K.blendFunc(K.SRC_ALPHA,K.ONE_MINUS_SRC_ALPHA),this.scene.transparentChildren.forEach(e=>{e.visible&&e.draw(K,this.getState())}),K.disable(K.BLEND),K.blendFunc(K.ONE,K.ZERO))}clean(){F(this.scene,e=>{e.reflow=!1}),this.needUpdateView=!1,this.needUpdateProjection=!1,this.reflow=!1}}class ${redraw;isPan;isDrag;x;y;constructor(e,r){this.redraw=r,document.addEventListener("wheel",this,{passive:!1}),e.addEventListener("mousedown",this),e.addEventListener("mousemove",this),e.addEventListener("mouseup",this),document.addEventListener("keyup",this),document.addEventListener("keydown",this),addEventListener("resize",this)}handleEvent(e){switch(e.type){case"wheel":this.zoom(e);break;case"mousedown":this.onStart(e);break;case"mousemove":this.onMove(e);break;case"mouseup":this.onEnd();break;case"keyup":this.onKeyUp();break;case"keydown":this.onKeyDown(e);break;case"resize":this.onResize()}}onResize(){this.redraw("resize")}onKeyDown(e){(e.shiftKey||e.ctrlKey)&&(this.isPan=!0)}onKeyUp(){this.isPan=!1}onStart(e){this.x=e.clientX,this.y=e.clientY,this.isDrag=!0}onMove(e){this.isDrag&&(this.isPan?this.redraw("pan",[this.x,this.y],[e.clientX,e.clientY]):this.redraw("rotate",[this.x,this.y],[e.clientX,e.clientY]),this.x=e.clientX,this.y=e.clientY)}onEnd(){this.isDrag=!1}zoom(e){e.preventDefault(),this.redraw("zoom",e.deltaY)}}var J=i(843),Q=i.n(J);const ee="#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 inPosition;\r\n\r\nuniform mat4 projection;\r\nuniform mat4 view;\r\n\r\nout vec3 outUV;\r\n\r\nvoid main() {\r\n\toutUV = inPosition;\r\n    mat4 rotView = mat4(mat3(view));\r\n    gl_Position = projection * rotView * vec4(inPosition, 1.0);\r\n}\r\n",re="#version 300 es\r\nlayout (location = 0) in vec2 pos;\r\n\r\nout vec2 uv;\r\n\r\nvoid main() {\r\n    uv = pos * 0.5 + 0.5;\r\n    gl_Position = vec4(pos, 0.0, 1.0); \r\n}\r\n",te=[Math.sqrt(1/(4*Math.PI)),-Math.sqrt(3/(4*Math.PI)),Math.sqrt(3/(4*Math.PI)),-Math.sqrt(3/(4*Math.PI)),Math.sqrt(15/(4*Math.PI)),-Math.sqrt(15/(4*Math.PI)),Math.sqrt(5/(16*Math.PI)),-Math.sqrt(15/(4*Math.PI)),Math.sqrt(15/(16*Math.PI))];class ne{preScaled=!1;l00=new n;l1_1=new n;l10=new n;l11=new n;l2_2=new n;l2_1=new n;l20=new n;l21=new n;l22=new n;scaleInPlace(e){this.l00.scale(e),this.l1_1.scale(e),this.l10.scale(e),this.l11.scale(e),this.l2_2.scale(e),this.l2_1.scale(e),this.l20.scale(e),this.l21.scale(e),this.l22.scale(e)}convertIrradianceToLambertianRadiance(){this.scaleInPlace(1/Math.PI)}preScaleForRendering(){this.preScaled=!0,this.l00.scale(te[0]),this.l1_1.scale(te[1]),this.l10.scale(te[2]),this.l11.scale(te[3]),this.l2_2.scale(te[4]),this.l2_1.scale(te[5]),this.l20.scale(te[6]),this.l21.scale(te[7]),this.l22.scale(te[8])}static FromArray(e){const r=new ne;return n.FromArrayToRef(e[0],0,r.l00),n.FromArrayToRef(e[1],0,r.l1_1),n.FromArrayToRef(e[2],0,r.l10),n.FromArrayToRef(e[3],0,r.l11),n.FromArrayToRef(e[4],0,r.l2_2),n.FromArrayToRef(e[5],0,r.l2_1),n.FromArrayToRef(e[6],0,r.l20),n.FromArrayToRef(e[7],0,r.l21),n.FromArrayToRef(e[8],0,r.l22),r}}class ie{_harmonics;get preScaledHarmonics(){return this._harmonics.preScaled||this._harmonics.preScaleForRendering(),this._harmonics}x=new n;y=new n;z=new n;xx=new n;yy=new n;zz=new n;xy=new n;yz=new n;zx=new n;scale(e){this.x.scale(e),this.y.scale(e),this.z.scale(e),this.xx.scale(e),this.yy.scale(e),this.zz.scale(e),this.yz.scale(e),this.zx.scale(e),this.xy.scale(e)}static FromHarmonics(e){const r=new ie;return r._harmonics=e,r.x=e.l11.scale2(1.02333).scale2(-1),r.y=e.l1_1.scale2(1.02333).scale2(-1),r.z=e.l10.scale2(1.02333),r.xx=e.l00.scale2(.886277).subtract2(e.l20.scale2(.247708)).add2(e.l22.scale2(.429043)),r.yy=e.l00.scale2(.886277).subtract2(e.l20.scale2(.247708)).subtract2(e.l22.scale2(.429043)),r.zz=e.l00.scale2(.886277).add2(e.l20.scale2(.495417)),r.yz=e.l2_1.scale2(.858086).scale2(-1),r.zx=e.l21.scale2(.858086).scale2(-1),r.xy=e.l2_2.scale2(.858086),r.scale(1/Math.PI),r}}const se=i.p+"assets/Sheen_E.hdr";let oe;class ae{camera;envMatrix;VAO;quadVAO;IndexBufferLength;cubeprogram;irradianceprogram;mipmapcubeprogram;bdrfprogram;level;diffuse;MVPMatrix;framebuffer;irradiancebuffer;prefilterbuffer;views;views2;prefilterrender;brdfbuffer;canvas;url;sampler;samplerCube;envData;uniformBuffer;originalCubeTexture;brdfLUTTexture;original2DTexture;irradiancemap;prefilterMap;charlieMap;Sheen_E;constructor(e){this.url=e,this.envMatrix=new r}setCamera(e){this.camera=e}setGl(e){oe=e}setCanvas(e){this.canvas=e}get width(){return this.canvas.offsetWidth*devicePixelRatio}get height(){return this.canvas.offsetHeight*devicePixelRatio}drawQuad(){const e=new r,t=Object.assign({},this.camera.props,{perspective:{yfov:.3,znear:.01,zfar:1e4}});e.multiply(M(t)),oe.enable(oe.CULL_FACE);const n=oe.createProgram();v(oe.VERTEX_SHADER,"#version 300 es\n        precision highp float;\n        \n        layout (location = 0) in vec2 inPosition;\n        \n        out vec2 outUV;\n\n        uniform mat4 projection;\n        uniform mat4 view;\n        \n        void main() {\n            outUV = inPosition;\n            gl_Position = projection * view * vec4(inPosition, 0.0, 1.0);\n        }\n        ",n),v(oe.FRAGMENT_SHADER,"#version 300 es\n        precision highp float;\n        \n        in vec2 outUV;\n        layout (location = 0) out vec4 color;\n\n        uniform sampler2D environmentMap;\n        \n        void main() {\n            vec3 c = texture(environmentMap, outUV).rgb;\n            \n            color = vec4(c, 1.0);\n        }\n        ",n),oe.linkProgram(n),oe.useProgram(n),oe.bindVertexArray(this.quadVAO),oe.uniformMatrix4fv(oe.getUniformLocation(n,"projection"),!1,e.elements),oe.uniform1i(oe.getUniformLocation(n,"environmentMap"),this.brdfLUTTexture.index),oe.uniformMatrix4fv(oe.getUniformLocation(n,"view"),!1,this.camera.matrixWorldInvert.elements),oe.drawArrays(oe.TRIANGLE_STRIP,0,4)}draw(){const e=new r,t=Object.assign({},this.camera.props,{perspective:{yfov:.3,znear:.01,zfar:1e4}});e.multiply(M(t)),oe.enable(oe.CULL_FACE);const i=oe.createProgram();v(oe.VERTEX_SHADER,"#version 300 es\n        precision highp float;\n        \n        layout (location = 0) in vec3 inPosition;\n        \n        out vec3 outUV;\n\n        uniform mat4 projection;\n        uniform mat4 view;\n        uniform mat4 model;\n        \n        void main() {\n            outUV = inPosition;\n            gl_Position = projection * view * model * vec4(inPosition, 1.0);\n        }\n        ",i),v(oe.FRAGMENT_SHADER,"#version 300 es\n        precision highp float;\n        \n        in vec3 outUV;\n        layout (location = 0) out vec4 color;\n        uniform mat4 rotation;\n\n        uniform samplerCube environmentMap;\n        \n        void main() {\n            vec3 uv = outUV;\n            vec4 c = textureLod(environmentMap, uv, 7.0);\n            \n            color = c;\n        }\n        ",i),oe.disable(oe.DEPTH_TEST),oe.linkProgram(i),oe.useProgram(i),oe.bindVertexArray(this.VAO),oe.uniformMatrix4fv(oe.getUniformLocation(i,"projection"),!1,e.elements);const s=2*this.camera.modelSize;oe.uniformMatrix4fv(oe.getUniformLocation(i,"model"),!1,(new r).makeRotationAxis(new n([1,0,0]),Math.PI).scale(new n([s,s,s])).elements),oe.uniform1i(oe.getUniformLocation(i,"environmentMap"),this.originalCubeTexture.index),oe.uniformMatrix4fv(oe.getUniformLocation(i,"view"),!1,this.camera.matrixWorldInvert.elements),oe.drawArrays(oe.TRIANGLES,0,36),oe.enable(oe.DEPTH_TEST)}createEnvironment(){oe.enable(oe.CULL_FACE);const e=new r,t=Object.assign({},this.camera.props,{aspect:1,perspective:{yfov:Math.PI/2,znear:.01,zfar:1e4}});if(e.multiply(M(t)),!this.envData){oe.bindFramebuffer(oe.FRAMEBUFFER,this.framebuffer),oe.useProgram(this.cubeprogram),oe.bindVertexArray(this.VAO),oe.viewport(0,0,this.framebuffer.size,this.framebuffer.size),oe.uniformMatrix4fv(oe.getUniformLocation(this.cubeprogram,"projection"),!1,e.elements),oe.uniform1i(oe.getUniformLocation(this.cubeprogram,"diffuse"),this.original2DTexture.index);const r=10;for(let e=0;e<r;++e){const r=this.framebuffer.size*Math.pow(.5,e),t=this.framebuffer.size*Math.pow(.5,e);oe.viewport(0,0,r,t);for(let r=0;r<6;r++)oe.framebufferTexture2D(oe.FRAMEBUFFER,oe.COLOR_ATTACHMENT0,oe.TEXTURE_CUBE_MAP_POSITIVE_X+r,this.originalCubeTexture,e),oe.uniformMatrix4fv(oe.getUniformLocation(this.cubeprogram,"view"),!1,this.views[r].elements),oe.clear(oe.COLOR_BUFFER_BIT|oe.DEPTH_BUFFER_BIT),oe.drawArrays(oe.TRIANGLES,0,36)}oe.bindVertexArray(null),oe.bindFramebuffer(oe.FRAMEBUFFER,null)}if(!this.envData){oe.bindFramebuffer(oe.FRAMEBUFFER,this.irradiancebuffer),oe.useProgram(this.irradianceprogram),oe.bindVertexArray(this.VAO),oe.viewport(0,0,this.irradiancebuffer.size,this.irradiancebuffer.size),oe.uniformMatrix4fv(oe.getUniformLocation(this.irradianceprogram,"projection"),!1,e.elements),oe.uniform1i(oe.getUniformLocation(this.irradianceprogram,"environmentMap"),this.originalCubeTexture.index);for(let e=0;e<6;e++)oe.framebufferTexture2D(oe.FRAMEBUFFER,oe.COLOR_ATTACHMENT0,oe.TEXTURE_CUBE_MAP_POSITIVE_X+e,this.irradiancemap,0),oe.uniformMatrix4fv(oe.getUniformLocation(this.irradianceprogram,"view"),!1,this.views2[e].elements),oe.clear(oe.COLOR_BUFFER_BIT|oe.DEPTH_BUFFER_BIT),oe.drawArrays(oe.TRIANGLES,0,36);oe.bindVertexArray(null),oe.bindFramebuffer(oe.FRAMEBUFFER,null)}if(!this.envData){oe.bindFramebuffer(oe.FRAMEBUFFER,this.prefilterbuffer),oe.useProgram(this.mipmapcubeprogram),oe.bindVertexArray(this.VAO),oe.uniformMatrix4fv(oe.getUniformLocation(this.mipmapcubeprogram,"projection"),!1,e.elements),oe.uniform1i(oe.getUniformLocation(this.mipmapcubeprogram,"environmentMap"),this.originalCubeTexture.index);const r=5;for(let e=0;e<r;++e){const t=this.prefilterbuffer.size*Math.pow(.5,e),n=this.prefilterbuffer.size*Math.pow(.5,e);oe.viewport(0,0,t,n);const i=e/(r-1);oe.uniform1f(oe.getUniformLocation(this.mipmapcubeprogram,"roughness"),i);for(let r=0;r<6;r++)oe.framebufferTexture2D(oe.FRAMEBUFFER,oe.COLOR_ATTACHMENT0,oe.TEXTURE_CUBE_MAP_POSITIVE_X+r,this.prefilterMap,e),oe.framebufferTexture2D(oe.FRAMEBUFFER,oe.COLOR_ATTACHMENT1,oe.TEXTURE_CUBE_MAP_POSITIVE_X+r,this.charlieMap,e),oe.uniformMatrix4fv(oe.getUniformLocation(this.mipmapcubeprogram,"view"),!1,this.views2[r].elements),oe.clear(oe.COLOR_BUFFER_BIT|oe.DEPTH_BUFFER_BIT),oe.drawArrays(oe.TRIANGLES,0,36)}oe.bindVertexArray(null),oe.bindFramebuffer(oe.FRAMEBUFFER,null)}oe.bindFramebuffer(oe.FRAMEBUFFER,this.brdfbuffer),oe.useProgram(this.bdrfprogram),oe.bindVertexArray(this.quadVAO),oe.viewport(0,0,this.brdfbuffer.size,this.brdfbuffer.size),oe.framebufferTexture2D(oe.FRAMEBUFFER,oe.COLOR_ATTACHMENT0,oe.TEXTURE_2D,this.brdfLUTTexture,0),oe.clear(oe.COLOR_BUFFER_BIT|oe.DEPTH_BUFFER_BIT),oe.drawArrays(oe.TRIANGLE_STRIP,0,4),oe.bindVertexArray(null),oe.bindFramebuffer(oe.FRAMEBUFFER,null),oe.disable(oe.CULL_FACE),oe.viewport(0,0,this.width,this.height)}updateUniform(e,r){if(this.uniformBuffer){const t=e.getUniformBlockIndex(r,"SphericalHarmonics");e.uniformBlockBinding(r,t,7);const n=e.createBuffer();return e.bindBuffer(e.UNIFORM_BUFFER,n),e.bufferData(e.UNIFORM_BUFFER,this.uniformBuffer.store,e.STATIC_DRAW),n}}async createEnvironmentBuffer(e){if(this.envData=e,e){const t=new r;t.makeRotationFromQuaternion(new a(e.rotation).elements);const n=ne.FromArray(e.irradianceCoefficients);n.scaleInPlace(e.intensity),n.convertIrradianceToLambertianRadiance();const i=ie.FromHarmonics(n),{preScaledHarmonics:s}=i,o=new w;o.add("vSphericalL00",s.l00.elements),o.add("vSphericalL1_1",s.l1_1.elements),o.add("vSphericalL10",s.l10.elements),o.add("vSphericalL11",s.l11.elements),o.add("vSphericalL2_2",s.l2_2.elements),o.add("vSphericalL2_1",s.l2_1.elements),o.add("vSphericalL20",s.l20.elements),o.add("vSphericalL21",s.l21.elements),o.add("vSphericalL22",s.l22.elements),o.add("rotationMatrix",t.elements),o.done(),this.uniformBuffer=o}{const e=oe.createSampler();oe.samplerParameteri(e,oe.TEXTURE_MIN_FILTER,oe.LINEAR),oe.samplerParameteri(e,oe.TEXTURE_MAG_FILTER,oe.LINEAR),oe.samplerParameteri(e,oe.TEXTURE_WRAP_S,oe.CLAMP_TO_EDGE),oe.samplerParameteri(e,oe.TEXTURE_WRAP_T,oe.CLAMP_TO_EDGE),this.sampler=e}{const e=oe.createSampler();oe.samplerParameteri(e,oe.TEXTURE_MIN_FILTER,oe.LINEAR_MIPMAP_LINEAR),oe.samplerParameteri(e,oe.TEXTURE_MAG_FILTER,oe.LINEAR),oe.samplerParameteri(e,oe.TEXTURE_WRAP_S,oe.CLAMP_TO_EDGE),oe.samplerParameteri(e,oe.TEXTURE_WRAP_T,oe.CLAMP_TO_EDGE),oe.samplerParameteri(e,oe.TEXTURE_WRAP_R,oe.CLAMP_TO_EDGE),this.samplerCube=e}{const e=32,r=oe.createFramebuffer();this.irradiancebuffer=r,this.irradiancebuffer.size=e,oe.bindFramebuffer(oe.FRAMEBUFFER,r);const t=b(oe.TEXTURE_CUBE_MAP,5);for(let r=0;r<6;r++)oe.texImage2D(oe.TEXTURE_CUBE_MAP_POSITIVE_X+r,0,oe.RGBA16F,e,e,0,oe.RGBA,oe.FLOAT,null),oe.framebufferTexture2D(oe.FRAMEBUFFER,oe.COLOR_ATTACHMENT0,oe.TEXTURE_CUBE_MAP_POSITIVE_X+r,t,0);oe.texParameteri(oe.TEXTURE_CUBE_MAP,oe.TEXTURE_MIN_FILTER,oe.LINEAR),oe.texParameteri(oe.TEXTURE_CUBE_MAP,oe.TEXTURE_MAG_FILTER,oe.LINEAR),oe.texParameteri(oe.TEXTURE_CUBE_MAP,oe.TEXTURE_WRAP_S,oe.CLAMP_TO_EDGE),oe.texParameteri(oe.TEXTURE_CUBE_MAP,oe.TEXTURE_WRAP_T,oe.CLAMP_TO_EDGE),oe.texParameteri(oe.TEXTURE_CUBE_MAP,oe.TEXTURE_WRAP_R,oe.CLAMP_TO_EDGE),this.irradiancemap=t}{const e=512,r=oe.createFramebuffer();this.framebuffer=r,this.framebuffer.size=e,oe.bindFramebuffer(oe.FRAMEBUFFER,r);const t=b(oe.TEXTURE_CUBE_MAP);for(let r=0;r<6;r++)oe.texImage2D(oe.TEXTURE_CUBE_MAP_POSITIVE_X+r,0,oe.RGBA16F,e,e,0,oe.RGBA,oe.FLOAT,null),oe.framebufferTexture2D(oe.FRAMEBUFFER,oe.COLOR_ATTACHMENT0,oe.TEXTURE_CUBE_MAP_POSITIVE_X+r,t,0);oe.bindSampler(t.index,this.samplerCube),oe.generateMipmap(oe.TEXTURE_CUBE_MAP),this.originalCubeTexture=t}{const e=128,r=oe.createFramebuffer();this.prefilterbuffer=r,this.prefilterbuffer.size=e,oe.bindFramebuffer(oe.FRAMEBUFFER,r);const t=b(oe.TEXTURE_CUBE_MAP,6);if(this.envData){const e=[oe.TEXTURE_CUBE_MAP_POSITIVE_X,oe.TEXTURE_CUBE_MAP_NEGATIVE_X,oe.TEXTURE_CUBE_MAP_NEGATIVE_Y,oe.TEXTURE_CUBE_MAP_POSITIVE_Y,oe.TEXTURE_CUBE_MAP_POSITIVE_Z,oe.TEXTURE_CUBE_MAP_NEGATIVE_Z];for(let r=0;r<this.envData.specularImages.length;r++){const t=this.envData.specularImageSize*Math.pow(.5,r);for(let n=0;n<6;n++)oe.texImage2D(e[n],r,oe.RGBA,t,t,0,oe.RGBA,oe.UNSIGNED_BYTE,this.envData.specularImages[r][n])}oe.bindSampler(t.index,this.samplerCube),oe.generateMipmap(oe.TEXTURE_CUBE_MAP)}else{oe.pixelStorei(oe.UNPACK_FLIP_Y_WEBGL,!0);for(let r=0;r<6;r++)oe.texImage2D(oe.TEXTURE_CUBE_MAP_POSITIVE_X+r,0,oe.RGBA16F,e,e,0,oe.RGBA,oe.FLOAT,null),oe.framebufferTexture2D(oe.FRAMEBUFFER,oe.COLOR_ATTACHMENT0,oe.TEXTURE_CUBE_MAP_POSITIVE_X+r,t,r);oe.bindSampler(t.index,this.samplerCube),oe.generateMipmap(oe.TEXTURE_CUBE_MAP);const r=b(oe.TEXTURE_CUBE_MAP,18);oe.pixelStorei(oe.UNPACK_FLIP_Y_WEBGL,!0);for(let t=0;t<6;t++)oe.texImage2D(oe.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,oe.RGBA16F,e,e,0,oe.RGBA,oe.FLOAT,null),oe.framebufferTexture2D(oe.FRAMEBUFFER,oe.COLOR_ATTACHMENT1,oe.TEXTURE_CUBE_MAP_POSITIVE_X+t,r,t);oe.bindSampler(r.index,this.samplerCube),oe.generateMipmap(oe.TEXTURE_CUBE_MAP),this.charlieMap=r,oe.drawBuffers([oe.COLOR_ATTACHMENT0,oe.COLOR_ATTACHMENT1])}this.prefilterMap=t}{const e=512,r=oe.createFramebuffer();this.brdfbuffer=r,this.brdfbuffer.size=e,oe.bindFramebuffer(oe.FRAMEBUFFER,r);const t=b(oe.TEXTURE_2D,7);oe.texImage2D(oe.TEXTURE_2D,0,oe.RGBA16F,e,e,0,oe.RGBA,oe.FLOAT,null),oe.bindSampler(t.index,this.sampler),this.brdfLUTTexture=t,this.quadVAO=oe.createVertexArray(),oe.bindVertexArray(this.quadVAO);const n=oe.createBuffer();oe.bindBuffer(oe.ARRAY_BUFFER,n),oe.bufferData(oe.ARRAY_BUFFER,new Float32Array(j),oe.STATIC_DRAW),oe.enableVertexAttribArray(0),oe.vertexAttribPointer(0,2,oe.FLOAT,!1,0,0),oe.bindVertexArray(null)}const t=[[new n([0,1,0]),Math.PI/2],[new n([0,1,0]),-Math.PI/2],[new n([1,0,0]),0],[new n([1,0,0]),Math.PI],[new n([1,0,0]),-Math.PI/2],[new n([1,0,0]),Math.PI/2]];this.views=t.map((e,t)=>{const i=new r;if(i.makeRotationAxis(e[0],e[1]),5===t){const e=new r;e.makeRotationAxis(new n([0,0,1]),Math.PI),i.multiply(e)}if(0===t){const e=new r;e.makeRotationAxis(new n([0,0,1]),Math.PI/2),i.multiply(e)}if(1===t){const e=new r;e.makeRotationAxis(new n([0,0,1]),-Math.PI/2),i.multiply(e)}return(new r).setInverseOf(i)});const i=[[new n([0,1,0]),Math.PI],[new n([0,1,0]),0],[new n([1,0,0]),Math.PI/2],[new n([1,0,0]),-Math.PI/2],[new n([0,1,0]),Math.PI/2],[new n([0,1,0]),-Math.PI/2]];this.views2=i.map((e,t)=>{const i=new r;if(i.makeRotationAxis(e[0],e[1]),2===t){const e=new r;e.makeRotationAxis(new n([0,0,1]),Math.PI/2),i.multiply(e)}if(3===t){const e=new r;e.makeRotationAxis(new n([0,0,1]),-Math.PI/2),i.multiply(e)}return(new r).setInverseOf(i)}),this.VAO=oe.createVertexArray(),oe.bindVertexArray(this.VAO);{const e=oe.createBuffer();oe.bindBuffer(oe.ARRAY_BUFFER,e),oe.bufferData(oe.ARRAY_BUFFER,new Float32Array(W),oe.STATIC_DRAW),oe.enableVertexAttribArray(0),oe.vertexAttribPointer(0,3,oe.FLOAT,!1,0,0)}oe.bindVertexArray(null),this.cubeprogram=S(ee,"#version 300 es\r\nprecision highp float;\r\n\r\nin vec3 outUV;\r\nlayout (location = 0) out vec4 color;\r\n\r\nuniform sampler2D diffuse;\r\n\r\nconst vec2 invAtan = vec2(0.1591, 0.3183);\r\nvec2 SampleSphericalMap(vec3 v) {\r\n    vec2 uv = vec2(atan(v.y, v.x), asin(v.z));\r\n    uv *= invAtan;\r\n    uv += 0.5;\r\n    return uv;\r\n}\r\n\r\nvoid main() {\t\t\r\n    vec2 uv = SampleSphericalMap(normalize(outUV));\r\n    vec3 c = texture(diffuse, uv).rgb;\r\n    \r\n    color = vec4(c, 1.0);\r\n}\r\n"),this.irradianceprogram=S(ee,"#version 300 es\r\nprecision highp float;\r\n\r\nin vec3 outUV;\r\nlayout (location = 0) out vec4 color;\r\n\r\nuniform samplerCube environmentMap;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nvoid main() {\r\n    vec3 N = normalize(outUV);\r\n    vec3 irradiance = vec3(0.0);\r\n\r\n    vec3 up    = vec3(0.0, 1.0, 0.0);\r\n    vec3 right = cross(up, N);\r\n    up         = cross(N, right);\r\n\r\n    float sampleDelta = 0.025;\r\n    float nrSamples = 0.0; \r\n    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\r\n    {\r\n        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\r\n        {\r\n            // spherical to cartesian (in tangent space)\r\n            vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\r\n            // tangent space to world\r\n            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N; \r\n\r\n            float mip = floor(log2(512.0)) - 3.0;\r\n            irradiance += textureLod(environmentMap, sampleVec, mip).rgb * cos(theta) * sin(theta);\r\n            nrSamples++;\r\n        }\r\n    }\r\n    irradiance = PI * irradiance * (1.0 / float(nrSamples));\r\n    \r\n    color = vec4(irradiance, 1.0);\r\n}\r\n"),this.mipmapcubeprogram=S(ee,"#version 300 es\r\nprecision highp float;\r\n\r\nin vec3 outUV;\r\nlayout (location = 0) out vec4 color;\r\nlayout (location = 1) out vec4 color2;\r\n\r\nuniform samplerCube environmentMap;\r\nuniform float roughness;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nfloat RadicalInverse_VdC(uint bits) {\r\n    bits = (bits << 16u) | (bits >> 16u);\r\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r\n}\r\n// ----------------------------------------------------------------------------\r\nvec2 Hammersley(uint i, uint N) {\r\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\r\n}  \r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness, bool isCharlie, inout float cosZ) {\r\n    float a = max(roughness*roughness, 0.000001);\r\n\t\r\n    float phi = 2.0 * PI * Xi.x;\r\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\r\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\r\n\r\n    if (isCharlie) {\r\n        sinTheta = pow(Xi.y, a / (2.0*a + 1.0));\r\n        cosTheta = sqrt(1.0 - sinTheta * sinTheta);\r\n        cosZ = cosTheta;\r\n    }\r\n\t\r\n    // from spherical coordinates to cartesian coordinates\r\n    vec3 H;\r\n    H.x = cos(phi) * sinTheta;\r\n    H.y = sin(phi) * sinTheta;\r\n    H.z = cosTheta;\r\n\t\r\n    // from tangent-space vector to world-space sample vector\r\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r\n    vec3 tangent   = normalize(cross(up, N));\r\n    vec3 bitangent = cross(N, tangent);\r\n\t\r\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\r\n    return normalize(sampleVec);\r\n} \r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = max(a*a, 0.0001);\r\n    float NdotH = max(dot(N, H), 0.0);\r\n    float NdotH2 = NdotH*NdotH;\r\n\r\n    float nom   = a2;\r\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n\r\n    return nom / max(denom, 0.0001);\r\n}\r\n\r\nfloat D_Charlie(float sheenRoughness, float NdotH) {\r\n    sheenRoughness = max(sheenRoughness, 0.000001); //clamp (0,1]\r\n    float invR = 1.0 / sheenRoughness;\r\n    float cos2h = NdotH * NdotH;\r\n    float sin2h = 1.0 - cos2h;\r\n    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\r\n}\r\n\r\nvec3 x(bool isCharlie) {\r\n    vec3 N = normalize(outUV);    \r\n    vec3 R = N;\r\n    vec3 V = R;\r\n\r\n    uint SAMPLE_COUNT = isCharlie ? 64u : 1024u;\r\n    float totalWeight = 0.0;   \r\n    vec3 prefilteredColor = vec3(0.0);     \r\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i) {\r\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\r\n        float cosZ = 0.0;\r\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness, isCharlie, cosZ);\r\n        vec3 L  = normalize(reflect(-V, H));\r\n\r\n        float NdotL = max(dot(N, L), 0.0);\r\n        if (NdotL > 0.0) {\r\n            float D = DistributionGGX(N, H, roughness);\r\n            float pdf = (D * max(dot(N, H), 0.0) / (4.0 * max(dot(H, V), 0.0))) + 0.0001;\r\n            if (isCharlie) {\r\n                pdf = D_Charlie(roughness * roughness, cosZ);\r\n                pdf /= 4.0;\r\n            }\r\n\r\n            float mip = floor(log2(512.0)) - 1.0;\r\n            float lod = roughness == 0.0 ? 0.0 : 0.5 * log2( mip * float(512) * float(512) / (float(SAMPLE_COUNT) * pdf));\r\n\r\n            prefilteredColor += textureLod( environmentMap, L, clamp(lod, 0.0, 4.0) ).rgb * NdotL;\r\n            totalWeight += NdotL;\r\n        }\r\n    }\r\n    prefilteredColor = prefilteredColor / totalWeight;\r\n    return prefilteredColor;\r\n}\r\n\r\nvoid main() {\r\n    color = vec4(x(false), 1.0);\r\n    color2 = vec4(x(true), 1.0);\r\n}\r\n"),this.bdrfprogram=S(re,"#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\nlayout (location = 0) out vec4 color;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nfloat V_Ashikhmin(float NdotL, float NdotV) {\r\n    return clamp(1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV)), 0.0, 1.0);\r\n}\r\n\r\nfloat D_Charlie(float sheenRoughness, float NdotH) {\r\n    sheenRoughness = max(sheenRoughness, 0.000001); //clamp (0,1]\r\n    float invR = 1.0 / sheenRoughness;\r\n    float cos2h = NdotH * NdotH;\r\n    float sin2h = 1.0 - cos2h;\r\n    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\r\n}\r\n\r\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\r\n    float a = roughness;\r\n    float k = (a * a) / 2.0;\r\n\r\n    float nom   = NdotV;\r\n    float denom = NdotV * (1.0 - k) + k;\r\n\r\n    return nom / denom;\r\n}\r\n\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float NdotV = max(dot(N, V), 0.0);\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\r\n\r\n    return ggx1 * ggx2;\r\n} \r\n\r\nfloat RadicalInverse_VdC(uint bits) {\r\n    bits = (bits << 16u) | (bits >> 16u);\r\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r\n}\r\n\r\nvec2 Hammersley(uint i, uint N) {\r\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\r\n}  \r\n\r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness, bool isCharlie) {\r\n    float a = roughness*roughness;\r\n\t\r\n    float phi = 2.0 * PI * Xi.x;\r\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\r\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\r\n\r\n    if (isCharlie) {\r\n        sinTheta = pow(Xi.y, a / (2.0*a + 1.0));\r\n        cosTheta = sqrt(1.0 - sinTheta * sinTheta);\r\n    }\r\n\t\r\n    // from spherical coordinates to cartesian coordinates\r\n    vec3 H;\r\n    H.x = cos(phi) * sinTheta;\r\n    H.y = sin(phi) * sinTheta;\r\n    H.z = cosTheta;\r\n\t\r\n    // from tangent-space vector to world-space sample vector\r\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r\n    vec3 tangent   = normalize(cross(up, N));\r\n    vec3 bitangent = cross(N, tangent);\r\n\t\r\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\r\n    return normalize(sampleVec);\r\n} \r\n\r\nvec3 IntegrateBRDF(float NdotV, float roughness) {\r\n    vec3 V;\r\n    V.x = sqrt(1.0 - NdotV*NdotV);\r\n    V.y = 0.0;\r\n    V.z = NdotV;\r\n\r\n    float A = 0.0;\r\n    float B = 0.0;\r\n    float C = 0.0;\r\n\r\n    vec3 N = vec3(0.0, 0.0, 1.0);\r\n\r\n    const uint SAMPLE_COUNT = 1024u;\r\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i) {\r\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\r\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness, false);\r\n        vec3 L  = normalize(reflect(-V, H));\r\n\r\n        float NdotL = max(L.z, 0.0);\r\n        float NdotH = max(H.z, 0.0);\r\n        float VdotH = max(dot(V, H), 0.0);\r\n\r\n        if(NdotL > 0.0) {\r\n            float G = GeometrySmith(N, V, L, roughness);\r\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\r\n            float Fc = pow(1.0 - VdotH, 5.0);\r\n\r\n            A += (1.0 - Fc) * G_Vis;\r\n            B += Fc * G_Vis;\r\n        }\r\n\r\n        H  = ImportanceSampleGGX(Xi, N, roughness, true);\r\n        L  = normalize(2.0 * dot(V, H) * H - V);\r\n        NdotL = max(L.z, 0.0);\r\n        NdotH = max(H.z, 0.0);\r\n        VdotH = max(dot(V, H), 0.0);\r\n        if (NdotL > 0.0) {\r\n            float sheenDistribution = D_Charlie(roughness, NdotH);\r\n            float sheenVisibility = V_Ashikhmin(NdotL, NdotV);\r\n\r\n            C += sheenVisibility * sheenDistribution * NdotL * VdotH;\r\n        }\r\n    }\r\n    A /= float(SAMPLE_COUNT);\r\n    B /= float(SAMPLE_COUNT);\r\n    C = 4.0 * 2.0 * PI * C / float(SAMPLE_COUNT);\r\n    return vec3(A, B, C);\r\n}\r\n\r\nvoid main() {\t\t\r\n    vec3 integratedBRDF = IntegrateBRDF(uv.x, uv.y);\r\n    color = vec4(integratedBRDF, 1.0);\r\n}\r\n"),await fetch(this.url).then(e=>e.arrayBuffer()).then(e=>{const{data:r,shape:t}=Q()(e);return this.original2DTexture=b(),oe.texImage2D(oe.TEXTURE_2D,0,oe.RGBA16F,t[0],t[1],0,oe.RGBA,oe.FLOAT,r),oe.bindSampler(this.original2DTexture.index,this.sampler),this.createEnvironment(),!0}),await fetch(se).then(e=>e.arrayBuffer()).then(e=>{const{data:r,shape:t}=Q()(e);return this.Sheen_E=b(oe.TEXTURE_2D,13),oe.pixelStorei(oe.UNPACK_FLIP_Y_WEBGL,!0),oe.texImage2D(oe.TEXTURE_2D,0,oe.RGBA16F,t[0],t[1],0,oe.RGBA,oe.FLOAT,r),oe.bindSampler(this.Sheen_E.index,this.sampler),!0})}}var ce=i(603);function le(e){const{ktxTexture:r,TranscodeTarget:t,transcoderConfig:n}=window.LIBKTX,{astcSupported:i,dxtSupported:s,pvrtcSupported:o,etc1Supported:a,etc2Supported:c}=n,l=new Uint8Array(e);if(!function(e){if(e.byteLength>=12){const r=new Uint8Array(e.buffer,e.byteOffset,12);if(171===r[0]&&75===r[1]&&84===r[2]&&88===r[3]&&32===r[4]&&50===r[5]&&48===r[6]&&187===r[7]&&13===r[8]&&10===r[9]&&26===r[10]&&10===r[11])return!0}return!1}(l))throw new Error("Texture is not valid ktx 2.0 file");const u=new r(l);if(u.needsTranscoding){let e;if(e=i?t.ASTC_4x4_RGBA:s?t.BC1_OR_3:o?t.PVRTC1_4_RGBA:a||c?t.ETC:t.RGBA4444,u.transcodeBasis(e,0)!==window.LIBKTX.ErrorCode.SUCCESS)throw new Error("Texture transcode failed. See console for details.");return u.glUpload().texture}}function ue(e){return"undefined"!=typeof window?window.fetch(e).then(e=>e.arrayBuffer()):new Promise(r=>{ce.readFile(e,(e,t)=>{if(e)throw e;r(new Uint8Array(t).buffer)})})}let fe;function he(e,r,t,n,i){let s,o;switch(e){case"BYTE":s=new Int8Array(r),s.type="BYTE",o=new fe.DracoInt8Array,t&&i.GetAttributeInt8ForAllPoints(t,n,o);break;case"UNSIGNED_BYTE":s=new Uint8Array(r),s.type="UNSIGNED_BYTE",o=new fe.DracoUInt8Array,t&&i.GetAttributeUInt8ForAllPoints(t,n,o);break;case"SHORT":s=new Int16Array(r),s.type="SHORT",o=new fe.DracoInt16Array,t&&i.GetAttributeInt16ForAllPoints(t,n,o);break;case"UNSIGNED_SHORT":s=new Uint16Array(r),s.type="UNSIGNED_SHORT",o=new fe.DracoUInt16Array,t&&i.GetAttributeUInt16ForAllPoints(t,n,o);break;case"UNSIGNED_INT":s=new Uint32Array(r),s.type="UNSIGNED_INT",o=new fe.DracoUInt32Array,t&&i.GetAttributeUInt32ForAllPoints(t,n,o);break;case"FLOAT":s=new Float32Array(r),s.type="FLOAT",o=new fe.DracoFloat32Array,t&&i.GetAttributeFloatForAllPoints(t,n,o)}return[o,s]}const me='#include "./vert.h"\r\n\r\nvoid main() {\r\n    #if defined(WEBGPU)\r\n    Transform tr = transforms.data[gl_InstanceIndex];\r\n    #else\r\n    Transform tr = fetchTransform(int(uMaterialID));\r\n    #endif\r\n    mat4 model = tr.model;\r\n\r\n    #ifdef JOINTNUMBER\r\n        mat4 skin = inWeight.x * joint[int(inJoint.x)];\r\n        skin += inWeight.y * joint[int(inJoint.y)];\r\n        skin += inWeight.z * joint[int(inJoint.z)];\r\n        skin += inWeight.w * joint[int(inJoint.w)];\r\n    #else\r\n        mat4 skin = mat4(1.0);\r\n    #endif\r\n\r\n    #ifdef COLOR\r\n    #ifdef COLOR_255\r\n        vColor = inColor / 255.0;\r\n    #else\r\n        vColor = inColor;\r\n    #endif\r\n    #endif\r\n    outUV0 = inUV;\r\n    #ifdef MULTIUV\r\n    outUV2 = inUV2;\r\n    #endif\r\n    #ifdef MULTIUV2\r\n    outUV3 = inUV3;\r\n    #endif\r\n    #ifdef TANGENT\r\n        vec3 normalW = normalize(vec3(model * vec4(inNormal.xyz, 0.0)));\r\n        vec3 tangentW = normalize(vec3(model * vec4(inTangent.xyz, 0.0)));\r\n        vec3 bitangentW = cross(normalW, tangentW) * inTangent.w;\r\n        #ifdef USERIGHTHANDEDSYSTEM\r\n        tangentW *= 1.0; // invertX\r\n        bitangentW *= -1.0; // invertY\r\n        #endif\r\n        outTBN = mat3(tangentW, bitangentW, normalW);\r\n    #else\r\n        outNormal = normalize(mat3(transpose(inverse(model))) * mat3(skin) * inNormal);\r\n    #endif\r\n    outPosition = vec3(model * skin * vec4(inPosition, 1.0));\r\n    outPositionView = projection * light * model * skin * vec4(inPosition, 1.0);\r\n    if (isShadow.x == 1.0) {\r\n        gl_Position = projection * light * model * skin * vec4(inPosition, 1.0);\r\n    } else {\r\n        gl_Position = projection * view * model * skin * vec4(inPosition, 1.0);\r\n    }\r\n\r\n    gl_PointSize = 1.0;\r\n    #if defined(WEBGPU)\r\n    id = gl_InstanceIndex;\r\n    #else\r\n    id = uMaterialID;\r\n    #endif\r\n}\r\n',Te='#include "./frag.h"\r\n\r\nconst float RECIPROCAL_PI = 0.31830988618;\r\nconst float PI = 3.141592653589793;\r\nconst float EPSILON = 1e-6;\r\nconst float ambientStrength = 0.1;\r\nconst float specularStrength = 2.5;\r\nconst float specularPower = 32.0;\r\nconst float gamma = 2.2;\r\n\r\n\r\nvec2 getUV(int index) {\r\n    #ifdef MULTIUV\r\n    if (index == 2) {\r\n        return outUV3;\r\n    }\r\n    if (index == 1) {\r\n        return outUV2;\r\n    }\r\n    #endif\r\n    if (index == 0) {\r\n        return outUV0;\r\n    }\r\n}\r\n#ifdef SHADOWMAP\r\nfloat ShadowCalculation(vec4 fragPosLightSpace, float bias) {\r\n    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\r\n    projCoords = projCoords * 0.5 + 0.5;\r\n    float currentDepth = projCoords.z;\r\n\r\n    float shadow = 0.0;\r\n    vec2 texelSize = 1.0 / vec2(textureSize(depthTexture, 0));\r\n    for (int x = -2; x <= 2; ++x) {\r\n        for (int y = -2; y <= 2; ++y) {\r\n            float pcfDepth = texture2D(depthTexture, projCoords.xy + vec2(x, y) * texelSize).r;\r\n            shadow += currentDepth - bias > pcfDepth ? 0.5 : 0.0;\r\n        }\r\n    }\r\n    shadow /= 25.0;\r\n\r\n    return shadow;\r\n}\r\n#endif\r\n\r\nvec3 srgbToLinear(vec4 srgbIn) {\r\n    #ifdef BASISU\r\n    return srgbIn.rgb;\r\n    #else\r\n    return pow(srgbIn.rgb, vec3(2.2));\r\n    #endif\r\n}\r\n\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nfloat fresnelSchlick(float cosTheta, float F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 Schlick_to_F0(vec3 f, vec3 f90, float VdotH) {\r\n    float x = clamp(1.0 - VdotH, 0.0, 1.0);\r\n    float x2 = x * x;\r\n    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);\r\n\r\n    return (f - f90 * x5) / (1.0 - x5);\r\n}\r\nvec3 Schlick_to_F0(vec3 f, float VdotH) {\r\n    return Schlick_to_F0(f, vec3(1.0), VdotH);\r\n}\r\nfloat sq(float t) {\r\n    return t * t;\r\n}\r\nvec3 sq(vec3 t) {\r\n    return t * t;\r\n}\r\n// XYZ to sRGB color space\r\nconst mat3 XYZ_TO_REC709 = mat3(\r\n     3.2404542, -0.9692660,  0.0556434,\r\n    -1.5371385,  1.8760108, -0.2040259,\r\n    -0.4985314,  0.0415560,  1.0572252\r\n);\r\n\r\nfloat applyIorToRoughness(float roughness, float ior) {\r\n    #if defined VOLUME\r\n    // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\r\n    // an IOR of 1.5 results in the default amount of microfacet refraction.\r\n    return roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\r\n    #else\r\n    return roughness;\r\n    #endif\r\n}\r\n\r\n// Assume air interface for top\r\n// Note: We don\'t handle the case fresnel0 == 1\r\nvec3 Fresnel0ToIor(vec3 fresnel0) {\r\n    vec3 sqrtF0 = sqrt(fresnel0);\r\n    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\r\n}\r\n\r\n// Conversion FO/IOR\r\nvec3 IorToFresnel0(vec3 transmittedIor, float incidentIor) {\r\n    return sq((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)));\r\n}\r\n\r\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\r\nfloat IorToFresnel0(float transmittedIor, float incidentIor) {\r\n    return sq((transmittedIor - incidentIor) / (transmittedIor + incidentIor));\r\n}\r\n\r\n// Fresnel equations for dielectric/dielectric interfaces.\r\n// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\r\n// Evaluation XYZ sensitivity curves in Fourier space\r\nvec3 evalSensitivity(float OPD, vec3 shift) {\r\n    float phase = 2.0 * PI * OPD * 1.0e-9;\r\n    vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\r\n    vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\r\n    vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\r\n\r\n    vec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-sq(phase) * var);\r\n    xyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * sq(phase));\r\n    xyz /= 1.0685e-7;\r\n\r\n    vec3 srgb = XYZ_TO_REC709 * xyz;\r\n    return srgb;\r\n}\r\n\r\nvec3 evalIridescence(float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0) {\r\n    vec3 I;\r\n\r\n    // Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0\r\n    float iridescenceIOR = mix(outsideIOR, eta2, smoothstep(0.0, 0.03, thinFilmThickness));\r\n    // Evaluate the cosTheta on the base layer (Snell law)\r\n    float sinTheta2Sq = sq(outsideIOR / iridescenceIOR) * (1.0 - sq(cosTheta1));\r\n\r\n    // Handle TIR:\r\n    float cosTheta2Sq = 1.0 - sinTheta2Sq;\r\n    if (cosTheta2Sq < 0.0) {\r\n        return vec3(1.0);\r\n    }\r\n\r\n    float cosTheta2 = sqrt(cosTheta2Sq);\r\n\r\n    // First interface\r\n    float R0 = IorToFresnel0(iridescenceIOR, outsideIOR);\r\n    float R12 = fresnelSchlick(cosTheta1, R0);\r\n    float R21 = R12;\r\n    float T121 = 1.0 - R12;\r\n    float phi12 = 0.0;\r\n    if (iridescenceIOR < outsideIOR) phi12 = PI;\r\n    float phi21 = PI - phi12;\r\n\r\n    // Second interface\r\n    vec3 baseIOR = Fresnel0ToIor(clamp(baseF0, 0.0, 0.9999)); // guard against 1.0\r\n    vec3 R1 = IorToFresnel0(baseIOR, iridescenceIOR);\r\n    vec3 R23 = fresnelSchlick(cosTheta2, R1);\r\n    vec3 phi23 = vec3(0.0);\r\n    if (baseIOR[0] < iridescenceIOR) phi23[0] = PI;\r\n    if (baseIOR[1] < iridescenceIOR) phi23[1] = PI;\r\n    if (baseIOR[2] < iridescenceIOR) phi23[2] = PI;\r\n\r\n    // Phase shift\r\n    float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\r\n    vec3 phi = vec3(phi21) + phi23;\r\n\r\n    // Compound terms\r\n    vec3 R123 = clamp(R12 * R23, 1e-5, 0.9999);\r\n    vec3 r123 = sqrt(R123);\r\n    vec3 Rs = sq(T121) * R23 / (vec3(1.0) - R123);\r\n\r\n    // Reflectance term for m = 0 (DC term amplitude)\r\n    vec3 C0 = R12 + Rs;\r\n    I = C0;\r\n\r\n    // Reflectance term for m > 0 (pairs of diracs)\r\n    vec3 Cm = Rs - T121;\r\n    for (int m = 1; m <= 2; ++m)\r\n    {\r\n        Cm *= r123;\r\n        vec3 Sm = 2.0 * evalSensitivity(float(m) * OPD, float(m) * phi);\r\n        I += Cm * Sm;\r\n    }\r\n\r\n    // Since out of gamut colors might be produced, negative color values are clamped to 0.\r\n    return max(I, vec3(0.0));\r\n}\r\n#ifdef ANISOTROPY\r\nfloat DistributionGGX(vec3 N, vec3 H, vec3 anisotropicT, vec3 anisotropicB, float at, float ab) {\r\n    float NdotH = dot(N, H);\r\n    float TdotH = dot(anisotropicT, H);\r\n    float BdotH = dot(anisotropicB, H);\r\n\r\n    float a2 = at * ab;\r\n    vec3 f = vec3(ab * TdotH, at * BdotH, a2 * NdotH);\r\n    float w2 = a2 / dot(f, f);\r\n    return a2 * w2 * w2 / PI;\r\n}\r\n\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, vec3 anisotropicT, vec3 anisotropicB, float at, float ab) {\r\n    float NdotV = dot(N, V);\r\n    float NdotL = dot(N, L);\r\n    float TdotV = dot(anisotropicT, V);\r\n    float TdotL = dot(anisotropicT, L);\r\n    float BdotV = dot(anisotropicB, V);\r\n    float BdotL = dot(anisotropicB, L);\r\n\r\n    float GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));\r\n    float GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));\r\n    float v = 0.5 / (GGXV + GGXL);\r\n    return clamp(v, 0.0, 1.0);\r\n}\r\n#else\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float NdotH = max(dot(N, H), 0.01);\r\n    float a = max(roughness*roughness, 0.01);\r\n    float alphaRoughnessSq = a * a;\r\n    float f = (NdotH * NdotH) * (alphaRoughnessSq - 1.0) + 1.0;\r\n    return alphaRoughnessSq / (PI * f * f);\r\n}\r\n\r\nfloat GeometrySchlickGGX(float cosTheta, float roughness) {\r\n    float r = (roughness + 1.0);\r\n    float k = (r * r) / 8.0;\r\n\r\n    float nom   = cosTheta;\r\n    float denom = cosTheta * (1.0 - k) + k;\r\n\r\n    return nom / denom;\r\n}\r\n\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float NdotV = max(dot(N, V), 0.0);\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\r\n\r\n    return ggx1 * ggx2;\r\n}\r\n#endif\r\n\r\nfloat fresnelSchlickRoughness(float cosTheta, float F0, float roughness) {\r\n    return F0 + (max(1.0 - roughness, F0) - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\r\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 calcTransmission(float dispersionFactor, float ior, vec3 color, vec3 N, float roughness, vec3 V, float transmission, float thickness) {\r\n    float refraction_ior = 1.0 / ior;\r\n    vec3 environmentRefraction = vec3(0.0);\r\n    #ifdef DISPERSION\r\n    float realIOR = 1.0 / ior;\r\n    float iorDispersionSpread = 0.04 * dispersionFactor * (realIOR - 1.0);\r\n    vec3 iors = vec3(realIOR - iorDispersionSpread, refraction_ior, realIOR + iorDispersionSpread);\r\n    for (int i = 0; i < 3; i++) {\r\n        refraction_ior = iors[i];\r\n    #endif\r\n\r\n    vec4 refractS = projection * view * vec4(outPosition + refract(-V, N, refraction_ior) * thickness, 1.0);\r\n    refractS.xy = refractS.xy / refractS.w;\r\n    refractS.xy = refractS.xy * 0.5 + 0.5;\r\n    const float MAX_REFLECTION_LOD = 7.0;\r\n    #if defined(WEBGPU)\r\n    refractS.y = 1.0 - refractS.y;\r\n    #endif\r\n    vec3 baseColor = textureLod2D2(colorTexture, refractS.xy, applyIorToRoughness(roughness, 1.0 / refraction_ior) * MAX_REFLECTION_LOD).xyz;\r\n\r\n    #ifdef DISPERSION\r\n        environmentRefraction[i] = baseColor[i];\r\n    }\r\n    #else\r\n        environmentRefraction = baseColor;\r\n    #endif\r\n\r\n    return transmission * environmentRefraction * color;\r\n}\r\n\r\n#ifdef SPHERICAL_HARMONICS\r\nvec3 computeEnvironmentIrradiance(vec3 normal) {\r\n    return vSphericalL00.xyz\r\n        + vSphericalL1_1.xyz * (normal.y)\r\n        + vSphericalL10.xyz * (normal.z)\r\n        + vSphericalL11.xyz * (normal.x)\r\n        + vSphericalL2_2.xyz * (normal.y * normal.x)\r\n        + vSphericalL2_1.xyz * (normal.y * normal.z)\r\n        + vSphericalL20.xyz * ((3.0 * normal.z * normal.z) - 1.0)\r\n        + vSphericalL21.xyz * (normal.z * normal.x)\r\n        + vSphericalL22.xyz * (normal.x * normal.x - (normal.y * normal.y));\r\n}\r\n#endif\r\nfloat sheenDistribution(float sheenRoughness, vec3 N, vec3 H) {\r\n    float NdotH = max(dot(N, H), 0.0);\r\n    float alphaG = max(sheenRoughness * sheenRoughness, 0.01);\r\n    float invR = 1.0 / alphaG;\r\n    float cos2h = NdotH * NdotH;\r\n    float sin2h = 1.0 - cos2h;\r\n    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\r\n}\r\nfloat lambdaSheenNumericHelper(float x, float alphaG) {\r\n    float oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);\r\n    float a = mix(21.5473, 25.3245, oneMinusAlphaSq);\r\n    float b = mix(3.82987, 3.32435, oneMinusAlphaSq);\r\n    float c = mix(0.19823, 0.16801, oneMinusAlphaSq);\r\n    float d = mix(-1.97760, -1.27393, oneMinusAlphaSq);\r\n    float e = mix(-4.32054, -4.85967, oneMinusAlphaSq);\r\n    return a / (1.0 + b * pow(x, c)) + d * x + e;\r\n}\r\nfloat lambdaSheen(float cosTheta, float alphaG) {\r\n    if (abs(cosTheta) < 0.5) {\r\n        return exp(lambdaSheenNumericHelper(cosTheta, alphaG));\r\n    } else {\r\n        return exp(2.0 * lambdaSheenNumericHelper(0.5, alphaG) - lambdaSheenNumericHelper(1.0 - cosTheta, alphaG));\r\n    }\r\n}\r\nfloat sheenVisibility(vec3 N, vec3 V, vec3 L, float sheenRoughness) {\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    float NdotV = max(dot(N, V), 0.0);\r\n\r\n    sheenRoughness = max(sheenRoughness, 0.000001); //clamp (0,1]\r\n    float alphaG = sheenRoughness * sheenRoughness;\r\n\r\n    return clamp(1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) *\r\n        (4.0 * NdotV * NdotL)), 0.0, 1.0);\r\n}\r\nfloat E(float x, float y) {\r\n    return clamp(texture2D(Sheen_E, vec2(x,y)).r, 0.0, 1.0);\r\n}\r\nfloat max3(vec3 v) { return max(max(v.x, v.y), v.z); }\r\nfloat pow2(float v) { return v * v; }\r\nvec3 IBLAmbient(vec3 baseColor, float metallic, vec3 n, float roughness, vec3 viewDir, float transmission, vec3 sheenColor, float sheenRoughness, vec3 iridescenceFresnel, float iridescenceFactor, vec3 F0, float specularWeight, float anisotropy, vec3 anisotropicB, inout vec3 f_sheen, out vec3 specular) {\r\n    #ifdef ANISOTROPY\r\n    vec3 Normal = cross(anisotropicB, viewDir);\r\n    Normal = normalize(cross(Normal, anisotropicB));\r\n    float a = pow2(pow2(1.0 - anisotropy * (1.0 - roughness)));\r\n    n = normalize(mix(Normal, n, a));\r\n    #endif\r\n    \r\n    vec3 F = fresnelSchlickRoughness(max(dot(n, viewDir), 0.0), F0, roughness);\r\n\r\n    vec3 kD = vec3(1.0) - F * specularWeight;\r\n    #if defined SPECULARGLOSSINESSMAP\r\n    #else\r\n        kD *= 1.0 - clamp(metallic, 0.0, 0.9);\r\n    #endif\r\n    #if defined IRIDESCENCE\r\n    kD = vec3(1.0) - mix(F, iridescenceFresnel, iridescenceFactor) * specularWeight;\r\n    kD *= 1.0 - clamp(metallic, 0.0, 0.9);\r\n    #endif\r\n\r\n    vec3 R;\r\n    #ifdef SPHERICAL_HARMONICS\r\n    R = reflect(viewDir, n);\r\n    vec4 rotatedR = rotationMatrix * vec4(R.x * -1.0, R.y, R.z, 0.0);\r\n    R = rotatedR.xyz;\r\n    vec4 prefilterColor = textureLodCube(prefilterMap, R, roughness * float(SPHERICAL_HARMONICS));\r\n    vec3 prefilteredColor = srgbToLinear(vec4(prefilterColor.rgb, 0.0)) / pow(prefilterColor.a, 2.2);\r\n    vec3 irradianceVector = vec3(rotationMatrix * vec4(n.x, n.y, n.z * -1.0, 0)).xyz;\r\n    vec3 irradiance = computeEnvironmentIrradiance(irradianceVector).rgb;\r\n    #else\r\n    const float MAX_REFLECTION_LOD = 4.0;\r\n    R = reflect(-viewDir, n);\r\n    vec3 prefilteredColor = textureLodCube(prefilterMap, R, roughness * MAX_REFLECTION_LOD).rgb;\r\n    vec3 irradiance = textureCube(irradianceMap, n).rgb;\r\n    #endif\r\n    vec2 envBRDF  = textureLod2D(brdfLUT, vec2(max(dot(n, viewDir), 0.0), roughness), 0.0).rg;\r\n    vec3 kS = F;\r\n    #if defined IRIDESCENCE\r\n    kS = mix(F, iridescenceFresnel, iridescenceFactor);\r\n    #endif\r\n    specular = prefilteredColor * (kS * specularWeight * envBRDF.x + envBRDF.y);\r\n\r\n    #if defined SHEEN\r\n    float charliebrdf = textureLod2D(brdfLUT, vec2(max(dot(n, viewDir), 0.0), sheenRoughness), 0.0).b;\r\n    vec3 sheenSample = textureLodCube(charlieMap, R, sheenRoughness * MAX_REFLECTION_LOD).rgb;\r\n    f_sheen += sheenSample * sheenColor * charliebrdf;\r\n    #endif\r\n\r\n    return (1.0 - transmission) * kD * irradiance * baseColor;\r\n}\r\n\r\nfloat specEnv(vec3 N, vec3 V, float metallic, float roughness, vec3 F0, float specularWeight) {\r\n    float F = fresnelSchlickRoughness(max(dot(N, V), 0.0), (F0.x+F0.y+F0.z)/3.0, roughness);\r\n    vec2 envBRDF  = textureLod2D(brdfLUT, vec2(max(dot(N, V), 0.0), roughness), 0.0).rg;\r\n    return (F * specularWeight * envBRDF.x + envBRDF.y);\r\n}\r\n\r\n#ifdef ANISOTROPY\r\nvec3 CookTorranceSpecular2(vec3 baseColor, float metallic, vec3 n, vec3 H, vec3 anisotropicT, vec3 anisotropicB, float roughness, vec3 viewDir, vec3 lightDir, float anisotropy, vec3 iridescenceFresnel, float iridescenceFactor, vec3 F0, float specularWeight) {\r\n    roughness = roughness * roughness;\r\n    float at = max(mix(roughness, 1.0, anisotropy * anisotropy), 0.001);\r\n    float ab = max(roughness, 0.001);\r\n    float D = DistributionGGX(n, H, anisotropicT, anisotropicB, at, ab);\r\n    float G = GeometrySmith(n, viewDir, lightDir, anisotropicT, anisotropicB, at, ab);\r\n    vec3 F = mix(fresnelSchlick(max(dot(viewDir, H), 0.0), F0), iridescenceFresnel, iridescenceFactor);\r\n\r\n    vec3 nominator = D * G * F * specularWeight;\r\n    float denominator = 4.0 * max(dot(n, viewDir), 0.0) * max(dot(n, lightDir), 0.0);\r\n    return D * G * F;\r\n}\r\nvec3 CookTorranceSpecular(vec3 baseColor, float metallic, vec3 n, vec3 H, vec3 anisotropicT, vec3 anisotropicB, float roughness, vec3 viewDir, vec3 lightDir, float anisotropy, vec3 F0, float specularWeight) {\r\n    roughness = roughness * roughness;\r\n    float at = max(mix(roughness, 1.0, anisotropy * anisotropy), 0.001);\r\n    float ab = max(roughness, 0.001);\r\n    float D = DistributionGGX(n, H, anisotropicT, anisotropicB, at, ab);\r\n    float G = GeometrySmith(n, viewDir, lightDir, anisotropicT, anisotropicB, at, ab);\r\n    vec3 F = fresnelSchlick(max(dot(viewDir, H), 0.0), F0); \r\n\r\n    vec3 nominator = D * G * F * specularWeight;\r\n    float denominator = 4.0 * max(dot(n, viewDir), 0.0) * max(dot(n, lightDir), 0.0);\r\n    return D * G * F;\r\n}\r\n#else\r\nvec3 CookTorranceSpecular2(vec3 baseColor, float metallic, vec3 n, vec3 H, vec3 anisotropicT, vec3 anisotropicB, float roughness, vec3 viewDir, vec3 lightDir, float anisotropy, vec3 iridescenceFresnel, float iridescenceFactor, vec3 F0, float specularWeight) {\r\n    float D = DistributionGGX(n, H, roughness);\r\n    float G = GeometrySmith(n, viewDir, lightDir, roughness);\r\n    vec3 F = mix(fresnelSchlick(max(dot(viewDir, H), 0.0), F0), iridescenceFresnel, iridescenceFactor);\r\n\r\n    vec3 nominator = D * G * F * specularWeight;\r\n    float denominator = 4.0 * max(dot(n, viewDir), 0.0) * max(dot(n, lightDir), 0.0);\r\n    return nominator / max(denominator, 0.001);\r\n}\r\nvec3 CookTorranceSpecular(vec3 baseColor, float metallic, vec3 n, vec3 H, vec3 anisotropicT, vec3 anisotropicB, float roughness, vec3 viewDir, vec3 lightDir, float anisotropy, vec3 F0, float specularWeight) {\r\n    float D = DistributionGGX(n, H, roughness);\r\n    float G = GeometrySmith(n, viewDir, lightDir, roughness);\r\n    vec3 F = fresnelSchlick(max(dot(viewDir, H), 0.0), F0); \r\n\r\n    vec3 nominator = D * G * F * specularWeight;\r\n    float denominator = 4.0 * max(dot(n, viewDir), 0.0) * max(dot(n, lightDir), 0.0);\r\n    return nominator / max(denominator, 0.001);\r\n}\r\n#endif\r\n\r\nvec3 LambertDiffuse(vec3 baseColor, float metallic, vec3 n, vec3 H, float roughness, vec3 viewDir, vec3 lightDir, vec3 F0, float specularWeight) {\r\n    float NdotL = max(dot(n, lightDir), 0.0);\r\n\r\n    vec3 F = fresnelSchlick(max(dot(H, viewDir), 0.0), F0);    \r\n\r\n    vec3 kD = vec3(1.0) - F * specularWeight;\r\n    #if defined SPECULARGLOSSINESSMAP\r\n    #else\r\n        kD *= 1.0 - metallic;\r\n    #endif\r\n    return baseColor * kD / PI;\r\n}\r\n\r\nfloat saturate(float a) {\r\n\tif (a > 1.0) return 1.0;\r\n\tif (a < 0.0) return 0.0;\r\n\treturn a;\r\n}\r\nvec3 ImprovedOrenNayarDiffuse(vec3 baseColor, float metallic, vec3 N, vec3 H, float a, vec3 V, vec3 L, vec3 F0, vec3 iridescenceFresnel, float iridescenceFactor, float specularWeight) {\r\n    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);\r\n    vec3 kD = vec3(1.0) - F * specularWeight;\r\n    #if defined SPECULARGLOSSINESSMAP\r\n    #else\r\n        kD *= 1.0 - metallic;\r\n    #endif\r\n    #if defined IRIDESCENCE\r\n    kD = vec3(1.0) - mix(F, iridescenceFresnel, iridescenceFactor) * specularWeight;\r\n    kD *= 1.0 - clamp(metallic, 0.0, 0.9);\r\n    #endif\r\n    vec3 diffuseColor = baseColor * kD;\r\n\t// calculate intermediary values\r\n\tfloat dotNL = saturate(dot(N, L));\r\n\tfloat dotNV = saturate(dot(N, V));\r\n\tfloat dotLV = saturate(dot(L, V));\r\n\tfloat dotLH = saturate(dot(L, H));\r\n\r\n\tfloat s = dotLV - dotNL * dotNV;\r\n\tfloat t = mix(1.0, max(max(dotNL, dotNV), 0.001), step(0.0, s));\r\n\tfloat st = s * (1.0 / (t + EPSILON));\r\n\r\n\tfloat sigma2 = a;\r\n\tvec3 A = diffuseColor * (0.17 * sigma2 / (sigma2 + 0.13)) + vec3(1.0 - 0.5 * sigma2 / (sigma2 + 0.33));\r\n\tfloat B = 0.45 * sigma2 / (sigma2 + 0.09);\r\n\treturn (diffuseColor * max(0.0, dotNL)) * (A + vec3(B * s / t) / PI) / PI;\r\n}\r\n\r\nvec2 applyTransform(vec2 uv, mat4 textureMatrix) {\r\n    mat3 translation = mat3(1, 0, 0, 0, 1, 0, textureMatrix[0].x, textureMatrix[0].y, 1);\r\n    mat3 rotation = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\r\n    if (textureMatrix[2].x != 0.0) {\r\n        rotation = mat3(\r\n            cos(-textureMatrix[2].x), sin(-textureMatrix[2].x), 0,\r\n            -sin(-textureMatrix[2].x), cos(-textureMatrix[2].x), 0,\r\n            0, 0, 1\r\n        );\r\n    }\r\n    mat3 scale = mat3(textureMatrix[1].x, 0, 0, 0, textureMatrix[1].y, 0, 0, 0, 1);\r\n\r\n    mat3 matrix = translation * rotation * scale;\r\n    vec2 outUV = ( matrix * vec3(uv, 1.0) ).xy;\r\n    return outUV;\r\n}\r\nfloat computeWrappedDiffuseNdotL(float NdotL, float w) {\r\n    float t = 1.0+w;\r\n    float invt2 = 1.0/(t*t);\r\n    return saturate((NdotL+w)*invt2);\r\n}\r\nfloat pow5(float value) {\r\n    float sq = value*value;\r\n    return sq*sq*value;\r\n}\r\nfloat diffuseBRDF_Burley(float NdotL, float NdotV, float VdotH, float roughness) {\r\n    float diffuseFresnelNV = pow5(saturate(1.0-NdotL)+EPSILON);\r\n    float diffuseFresnelNL = pow5(saturate(1.0-NdotV)+EPSILON);\r\n    float diffuseFresnel90 = 0.5+2.0*VdotH*VdotH*roughness;\r\n    float fresnel = (1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *\r\n    (1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);\r\n    return fresnel/PI;\r\n}\r\n#define absEps(x) abs(x)+EPSILON\r\n\r\nvec3 cocaLambert(vec3 alpha, float distance) {\r\n    return exp(-alpha*distance);\r\n}\r\n#define maxEps(x) max(x, EPSILON)\r\nvec3 transmittanceBRDF_Burley(const vec3 tintColor, const vec3 diffusionDistance, float thickness) {\r\n    vec3 S = 1./maxEps(diffusionDistance);\r\n    vec3 temp = exp((-0.333333333*thickness)*S);\r\n    return tintColor.rgb*0.25*(temp*temp*temp+3.0*temp);\r\n}\r\n\r\nvec3 computeColorAtDistanceInMedia(vec3 color, float distance) {\r\n    return -log(color)/distance;\r\n}\r\n\r\nvoid main() {\r\n    mat4 inverseViewMatrix = inverse(view);\r\n    vec3 viewPos = inverseViewMatrix[3].xyz;\r\n\r\n    #if defined(WEBGPU)\r\n    Material mat = materials.data[int(id)];\r\n    #else\r\n    Material mat = fetchMaterial(int(id));\r\n    #endif\r\n    vec4 baseColorFactor = mat.baseColorFactor;\r\n    vec3 specularFactor = mat.specularFactor;\r\n    vec3 specularColorFactor = mat.specularColorFactor;\r\n    vec3 emissiveFactor = mat.emissiveFactor;\r\n    vec4 glossinessFactor = mat.glossinessFactor;\r\n    vec4 metallicFactor = mat.metallicFactor;\r\n    vec4 roughnessFactor = mat.roughnessFactor;\r\n    vec4 clearcoatFactor = mat.clearcoatFactor;\r\n    vec4 clearcoatRoughnessFactor = mat.clearcoatRoughnessFactor;;\r\n    vec4 sheenColorFactor = mat.sheenColorFactor;\r\n    vec4 sheenRoughnessFactor = mat.sheenRoughnessFactor;\r\n    vec4 transmissionFactor = mat.transmissionFactor;\r\n    vec4 ior = mat.ior;\r\n    vec4 normalTextureScale = mat.normalTextureScale;;\r\n    vec4 attenuationColorFactor = mat.attenuationColorFactor; \r\n    vec4 attenuationDistance = mat.attenuationDistance;\r\n    vec4 thicknessFactor = mat.thicknessFactor;\r\n    vec4 emissiveStrength = mat.emissiveStrength;\r\n    vec4 anisotropyFactor = mat.anisotropyFactor;\r\n    vec4 iridescence = mat.iridescence;\r\n    vec4 diffuseTransmissionFactor = mat.diffuseTransmissionFactor;\r\n    vec4 dispersionFactor = mat.dispersionFactor;\r\n\r\n    vec2 outUV = outUV0;\r\n    #ifdef BASECOLORTEXTURE\r\n        outUV = getUV(BASECOLORTEXTURE);\r\n        #ifdef BASECOLORTEXTURE_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[BASECOLORTEXTURE_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        vec3 baseColor = texture2D(baseColorTexture, outUV).rgb * baseColorFactor.rgb;\r\n        float alpha = min(texture2D(baseColorTexture, outUV).a, baseColorFactor.a);\r\n    #else\r\n        vec3 baseColor = baseColorFactor.rgb;\r\n        float alpha = baseColorFactor.a;\r\n    #endif\r\n\r\n    #ifdef ALPHATEST\r\n    if ( alpha < ALPHATEST ) {\r\n        discard;\r\n    }\r\n    if ( ALPHATEST > 0.01 ) {\r\n        alpha = 1.0;\r\n    }\r\n    #else\r\n        alpha = 1.0;\r\n    #endif\r\n\r\n    if ( length(vColor.rgb) != 0.0 ) {\r\n        baseColor.rgb *= vColor.rgb;\r\n    }\r\n\r\n    #ifdef NOLIGHT\r\n        color = vec4(baseColor, alpha);\r\n        return;\r\n    #endif\r\n\r\n    float ao = 1.0;\r\n    #ifdef OCCLUSIONMAP\r\n        outUV = getUV(OCCLUSIONMAP);\r\n        #ifdef OCCLUSIONMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[OCCLUSIONMAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        ao = texture2D(occlusionTexture, outUV).r;\r\n    #endif\r\n\r\n    float roughness = roughnessFactor.x;\r\n    float metallic = metallicFactor.x;\r\n    float clearcoatRoughness = clearcoatRoughnessFactor.x;\r\n    float clearcoat = clearcoatFactor.x;\r\n    float clearcoatBlendFactor = clearcoat;\r\n    vec3 sheenColor = sheenColorFactor.xyz;\r\n    float sheenRoughness = sheenRoughnessFactor.x;\r\n    float transmission = transmissionFactor.x;\r\n    float transmissionDiffuse = diffuseTransmissionFactor.x;\r\n    float thickness = thicknessFactor.x;\r\n    #ifdef DIFFUSE_TRANSMISSION_MAP\r\n        #ifdef DIFFUSE_TRANSMISSION_MAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[DIFFUSE_TRANSMISSION_MAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        vec4 diffuseTransmissionTextureV = texture2D(diffuseTransmissionTexture, outUV);\r\n        transmissionDiffuse *= diffuseTransmissionTextureV.a;\r\n    #endif\r\n    vec3 attenuationColor = attenuationColorFactor.rgb;\r\n    vec3 tintColor = diffuseTransmissionFactor.yzw;\r\n    #ifdef DIFFUSE_TRANSMISSION_COLOR_MAP\r\n        #ifdef DIFFUSE_TRANSMISSION_COLOR_MAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[DIFFUSE_TRANSMISSION_COLOR_MAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        vec4 diffuseTransmissionColorTextureV = texture2D(diffuseTransmissionColorTexture, outUV);\r\n        tintColor *= diffuseTransmissionColorTextureV.rgb;\r\n    #endif\r\n    #ifdef CLEARCOATMAP\r\n        outUV = getUV(CLEARCOATMAP);\r\n        #ifdef CLEARCOATMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[CLEARCOATMAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        clearcoatBlendFactor = texture2D(clearcoatTexture, outUV).r * clearcoat;\r\n    #endif\r\n    #ifdef CLEARCOATROUGHMAP\r\n        outUV = getUV(CLEARCOATROUGHMAP);\r\n        #ifdef CLEARCOATROUGHMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[CLEARCOATROUGHMAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        clearcoatRoughness = texture2D(clearcoatRoughnessTexture, outUV).g * clearcoatRoughness;\r\n    #endif\r\n    #ifdef SHEENMAP\r\n        outUV = getUV(SHEENMAP);\r\n        #ifdef SHEENMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[SHEENMAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        vec3 sheenColorTextureV = texture2D(sheenColorTexture, outUV).rgb;\r\n        sheenColor = sheenColorTextureV * sheenColor;\r\n    #endif\r\n    #ifdef SHEENROUGHNESSMAP\r\n        outUV = getUV(SHEENROUGHNESSMAP);\r\n        #ifdef SHEENROUGHNESSMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[SHEENROUGHNESSMAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n    vec4 sheenRoughnessTextureV = texture2D(sheenRoughnessTexture, outUV);\r\n    sheenRoughness = sheenRoughnessTextureV.a * sheenRoughness;\r\n    #endif\r\n    float iridescenceThickness = iridescence.z;\r\n    #ifdef IRIDESCENCEMAP\r\n        #ifdef IRIDESCENCEMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[IRIDESCENCEMAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        iridescenceThickness = mix(iridescence.w, iridescence.z, texture2D(iridescenceThicknessTexture, outUV).g);\r\n    #endif\r\n    float iridescenceFactor = iridescence.y;\r\n    #ifdef IRIDESCENCE_COLOR\r\n        #ifdef IRIDESCENCE_COLOR_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[IRIDESCENCE_COLOR_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        iridescenceFactor *= texture2D(iridescenceTexture, outUV).r;\r\n    #endif\r\n    #ifdef TRANSMISSIONMAP\r\n        #ifdef TRANSMISSIONMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[TRANSMISSIONMAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        float transmissionTextureV = texture2D(transmissionTexture, outUV).r;\r\n        transmission = transmissionTextureV * transmission;\r\n    #endif\r\n    #ifdef THICKNESSMAP\r\n        #ifdef THICKNESSMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[THICKNESSMAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        float thicknessTextureV = texture2D(thicknessTexture, outUV).g;\r\n        thickness = thicknessTextureV * thickness;\r\n    #endif\r\n    #ifdef DIFFUSE_TRANSMISSION\r\n        thickness *= 2.2;\r\n    #endif\r\n    vec3 specularMap = vec3(0);\r\n    #ifdef SPECULARGLOSSINESSMAP\r\n        #ifdef METALROUGHNESSMAP\r\n            outUV = getUV(METALROUGHNESSMAP);\r\n            #ifdef METALROUGHNESSMAP_TEXTURE_TRANSFORM\r\n                outUV = applyTransform(outUV, textureMatrices[METALROUGHNESSMAP_TEXTURE_TRANSFORM]);\r\n            #endif\r\n            roughness = 1.0 - texture2D(metallicRoughnessTexture, outUV).a;\r\n            specularMap = texture2D(metallicRoughnessTexture, outUV).rgb;\r\n        #else\r\n            roughness = glossinessFactor.x;\r\n            specularMap = specularFactor;\r\n        #endif\r\n    #else\r\n        #ifdef METALROUGHNESSMAP\r\n            outUV = getUV(METALROUGHNESSMAP);\r\n            #ifdef METALROUGHNESSMAP_TEXTURE_TRANSFORM\r\n                outUV = applyTransform(outUV, textureMatrices[METALROUGHNESSMAP_TEXTURE_TRANSFORM]);\r\n            #endif\r\n            vec4 metallicRoughness = texture2D(metallicRoughnessTexture, outUV);\r\n            roughness *= metallicRoughness.g;\r\n            metallic *= metallicRoughness.b;\r\n        #endif\r\n    #endif\r\n    float specularWeight = 1.0;\r\n    #ifdef SPECULAR\r\n        specularMap = specularColorFactor;\r\n        #ifdef SPECULARCOLORMAP\r\n        #ifdef SPECULARCOLORMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[SPECULARCOLORMAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        specularMap *= texture2D(specularColorTexture, outUV).rgb;\r\n        #endif\r\n        specularWeight = specularFactor.x;\r\n        #ifdef SPECULARMAP\r\n        #ifdef SPECULARMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[SPECULARMAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        specularWeight *= texture2D(specularTexture, outUV).a;\r\n        #endif\r\n    #endif\r\n    vec3 F0 = mix(vec3(0.04), baseColor, metallic);\r\n    #if defined(IOR) && defined(VOLUME)\r\n    F0 = vec3(pow(( ior.x - 1.0) /  (ior.x + 1.0), 2.0));\r\n    #endif\r\n    #if defined SPECULAR\r\n    F0 = mix(min(F0 * specularMap, vec3(1.0)), baseColor, metallic);\r\n    #endif\r\n    #if defined SPECULARGLOSSINESSMAP\r\n        F0 = specularMap;\r\n    #endif\r\n\r\n    #ifdef TANGENT\r\n        #ifdef NORMALMAP\r\n            outUV = getUV(NORMALMAP);\r\n            #ifdef NORMALMAP_TEXTURE_TRANSFORM\r\n                outUV = applyTransform(outUV, textureMatrices[NORMALMAP_TEXTURE_TRANSFORM]);\r\n            #endif\r\n            vec3 n = texture2D(normalTexture, outUV).rgb;\r\n            n = normalize(outTBN * (2.0 * n - 1.0) * vec3(normalTextureScale.x, normalTextureScale.x, 1.0));\r\n        #else\r\n            vec3 n = normalize(outTBN[2].xyz);\r\n        #endif\r\n    #else\r\n        vec3 n = normalize(outNormal);\r\n    #endif\r\n\r\n    #ifdef TANGENT\r\n    #ifdef CLEARCOATNORMALMAP\r\n        outUV = getUV(CLEARCOATNORMALMAP);\r\n        #ifdef CLEARCOATNORMALMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[CLEARCOATNORMALMAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        vec3 clearcoatNormal = texture2D(clearcoatNormalTexture, outUV).rgb;\r\n        clearcoatNormal = normalize(outTBN * (2.0 * clearcoatNormal - 1.0));\r\n    #else\r\n        vec3 clearcoatNormal = outTBN[2].xyz;\r\n    #endif\r\n    #else\r\n        vec3 clearcoatNormal = outNormal;\r\n    #endif\r\n\r\n    vec3 viewDir = normalize(viewPos - outPosition);\r\n\r\n    #ifdef DOUBLESIDED\r\n    if (gl_FrontFacing == false) {\r\n        n = -n;\r\n        clearcoatNormal = -clearcoatNormal;\r\n    }\r\n    #endif\r\n\r\n    float shadow = 1.0;\r\n    #ifdef SHADOWMAP\r\n        vec3 l = normalize(lightPos[0] - outPosition);\r\n        float shadowBias = max(0.05 * (1.0 - dot(n, l)), 0.005);\r\n        shadow = 1.0 - ShadowCalculation(outPositionView, shadowBias);\r\n    #endif\r\n\r\n    vec3 anisotropicT = vec3(0.0);\r\n    vec3 anisotropicB = vec3(0.0);\r\n    vec3 anisotropy = anisotropyFactor.xyz;\r\n    anisotropy.yz = vec2(cos(anisotropy.y), sin(anisotropy.y));\r\n    #ifdef ANISOTROPYMAP\r\n        #ifdef ANISOTROPYMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV, textureMatrices[ANISOTROPYMAP_TEXTURE_TRANSFORM]);\r\n        #endif\r\n        vec4 anisotropyTex = texture2D(anisotropyTexture, outUV);\r\n        vec2 direction = anisotropyTex.rg * 2.0 - vec2(1.0);\r\n        direction = mat2(anisotropy.y, anisotropy.z, -anisotropy.z, anisotropy.y) * normalize(direction);\r\n        anisotropy.x = anisotropyTex.b * anisotropyFactor.x;\r\n        anisotropy.yz = direction;\r\n    #endif\r\n    #ifdef TANGENT\r\n        anisotropicT = normalize(outTBN * vec3(anisotropy.yz, 0.0));\r\n        anisotropicB = normalize(cross(n, anisotropicT));\r\n    #endif\r\n\r\n    #ifdef USE_PBR\r\n        vec3 finalDiffuse = vec3(0.0);\r\n        vec3 f_sheen = vec3(0.0);\r\n        float albedoSheenScaling = 1.0;\r\n        vec3 Lo = vec3(0.0);\r\n\r\n        #ifdef DIFFUSE_TRANSMISSION\r\n        float translucencyIntensity = transmissionDiffuse;\r\n        vec3 transmittance = transmittanceBRDF_Burley(tintColor, vec3(1.0), thickness);\r\n        transmittance *= translucencyIntensity;\r\n        vec3 f_transmission = transmittance;\r\n        vec3 f_transmission2 = transmittance;\r\n        #else\r\n        vec3 f_transmission = cocaLambert(computeColorAtDistanceInMedia(attenuationColor.rgb, attenuationDistance.x), thickness) * calcTransmission(dispersionFactor.x, ior.x, baseColor, n, roughness, viewDir, transmission, thickness);\r\n        #endif\r\n\r\n        if (isDefaultLight.x == 1.0) {\r\n            int i = LIGHTINDEX;\r\n        //for (int i = 0; i < LIGHTNUMBER; ++i) {\r\n            vec3 lightDir = normalize(lightPos[i].xyz - outPosition);\r\n            float NdotL = max(dot(n, lightDir), 0.0);\r\n            vec3 H = normalize(viewDir + lightDir);\r\n\r\n            vec3 radiance = lightColor[i].xyz * lightIntensity[i].x;\r\n            float distance = dot(lightPos[i].xyz - outPosition, lightPos[i].xyz - outPosition);\r\n            float attenuation = 1.0 / (distance * distance);\r\n            // radiance = radiance * attenuation;\r\n            if (lightIntensity[i].w == 1.0) { // point\r\n                radiance = radiance * attenuation;\r\n            }\r\n            if (lightIntensity[i].w == 2.0) { // spot\r\n                float lightAngleScale = 1.0 / max(0.001, cos(lightIntensity[i].y) - cos(lightIntensity[i].z));\r\n                float lightAngleOffset = -cos(lightIntensity[i].z) * lightAngleScale;\r\n\r\n                float cd = dot(spotdir[i].xyz, lightDir);\r\n                float attenuationSpot = saturate(cd * lightAngleScale + lightAngleOffset);\r\n                attenuationSpot *= attenuationSpot;\r\n\r\n                radiance = radiance * attenuationSpot * attenuation;\r\n            }\r\n\r\n            float NdotV = saturate(dot(n, viewDir));\r\n            vec3 iridescenceF0 = vec3(0.0);\r\n            #if defined IRIDESCENCE\r\n            vec3 iridescenceFresnel = evalIridescence(1.0, iridescenceFactor, NdotV, iridescenceThickness, F0);\r\n            iridescenceF0 = Schlick_to_F0(iridescenceFresnel, NdotV);\r\n            vec3 specular = CookTorranceSpecular2(baseColor, metallic, n, H, anisotropicT, anisotropicB, roughness, viewDir, lightDir, anisotropy.x, iridescenceF0, iridescence.x, F0, specularWeight);\r\n            #else\r\n            vec3 specular = CookTorranceSpecular(baseColor, metallic, n, H, anisotropicT, anisotropicB, roughness, viewDir, lightDir, anisotropy.x, F0, specularWeight);\r\n            #endif\r\n            vec3 f_clearcoat = CookTorranceSpecular(vec3(0.0), 0.0, clearcoatNormal, H, anisotropicT, anisotropicB, clearcoatRoughness, viewDir, lightDir, anisotropy.x, F0, specularWeight);\r\n            vec3 clearcoatFresnel = 1.0 - clearcoatBlendFactor * fresnelSchlick(saturate(dot(clearcoatNormal, viewDir)), vec3(0.04));\r\n            #ifndef DIFFUSE_TRANSMISSION\r\n            vec3 diffuse = ImprovedOrenNayarDiffuse(baseColor, metallic, n, H, roughness, viewDir, lightDir, F0, iridescenceF0, iridescence.x, specularWeight);\r\n            //#ifdef CLEARCOAT\r\n            diffuse *= radiance * clearcoatFresnel;\r\n            //#endif\r\n            #else\r\n            float NdotV2 = absEps(dot(n, viewDir));\r\n            float NdotL2 = absEps(dot(n, lightDir));\r\n            float VdotH = absEps(dot(viewDir, H));\r\n            float diffuse = diffuseBRDF_Burley(NdotL2, NdotV2, VdotH, roughness);\r\n            #endif\r\n            #if defined SPECULARGLOSSINESSMAP\r\n                diffuse = baseColor * (1.0 - max(max(specularMap.r, specularMap.g), specularMap.b));\r\n            #endif\r\n            #if defined SHEEN\r\n            f_sheen = NdotL * (sheenColor * sheenDistribution(sheenRoughness, n, H) * sheenVisibility(n, viewDir, lightDir, sheenRoughness));\r\n            albedoSheenScaling = min(1.0 - max3(sheenColor) * E(max(dot(viewDir, n), 0.0), sheenRoughness), 1.0 - max3(sheenColor) * E(max(dot(lightDir, n), 0.0), sheenRoughness));\r\n            #endif\r\n\r\n            Lo += (specular * NdotL);\r\n            //#ifdef CLEARCOAT\r\n            Lo = Lo * radiance * clearcoatFresnel + f_clearcoat * clearcoatBlendFactor;\r\n            //#endif\r\n            vec3 diffuseLobe = vec3(diffuse);\r\n\r\n            #ifdef DIFFUSE_TRANSMISSION\r\n            float trAdapt = step(0., dot(n, lightDir));\r\n            float wrapNdotL = computeWrappedDiffuseNdotL(absEps(dot(n, lightDir)), 0.02);\r\n            vec3 transmittanceNdotL = mix(f_transmission*wrapNdotL, vec3(wrapNdotL), trAdapt);\r\n            diffuseLobe = diffuseLobe * radiance * baseColor;\r\n            diffuseLobe = mix(diffuseLobe, f_transmission * transmittanceNdotL, transmissionDiffuse);\r\n            transmission = 0.0;\r\n            f_transmission = vec3(0.0);\r\n            #else\r\n            diffuseLobe *= (1.0 - transmission);\r\n            #endif\r\n\r\n            #ifndef SCATTERING\r\n            Lo += diffuseLobe;\r\n            #endif\r\n\r\n            finalDiffuse += diffuseLobe;\r\n        //}\r\n        }\r\n\r\n        vec3 ambient = vec3(0.0);\r\n        vec3 ambientClearcoat = vec3(0.0);\r\n        vec3 clearcoatFresnel = vec3(1.0);\r\n        vec3 aSpecular;\r\n        vec3 cSpecular;\r\n        if (isIBL.x == 1.0) {\r\n            float NdotV = saturate(dot(n, viewDir));\r\n            vec3 iridescenceFresnel = evalIridescence(1.0, iridescenceFactor, NdotV, iridescenceThickness, F0);\r\n            vec3 iridescenceF0 = Schlick_to_F0(iridescenceFresnel, NdotV);\r\n            ambient = IBLAmbient(baseColor, metallic, n, roughness, viewDir, transmission, sheenColor, sheenRoughness, iridescenceF0, iridescence.x, F0, specularWeight, anisotropy.x, anisotropicB, f_sheen, aSpecular);\r\n            vec3 placeholder = vec3(0.0);\r\n            ambientClearcoat = IBLAmbient(vec3(0.0), 0.0, clearcoatNormal, clearcoatRoughness, viewDir, transmission, sheenColor, sheenRoughness, iridescenceF0, iridescence.x, F0, specularWeight, anisotropy.x, anisotropicB, placeholder, cSpecular) * clearcoatBlendFactor;\r\n            #ifdef DIFFUSE_TRANSMISSION\r\n            ambient = mix(ambient, f_transmission2, transmissionDiffuse);\r\n            #endif\r\n            #ifndef SPHERICAL_HARMONICS\r\n            #ifndef SCATTERING\r\n            ambient += aSpecular;\r\n            #endif\r\n            ambientClearcoat += cSpecular * clearcoatBlendFactor;\r\n            #endif\r\n            clearcoatFresnel = (1.0 - clearcoatBlendFactor * fresnelSchlick(saturate(dot(clearcoatNormal, viewDir)), vec3(0.04)));\r\n        } else {\r\n            ambient = vec3(0.03) * baseColor * 0.2;\r\n        }\r\n\r\n        vec3 emissive = emissiveFactor;\r\n        #ifdef EMISSIVEMAP\r\n            outUV = getUV(EMISSIVEMAP);\r\n            #ifdef EMISSIVEMAP_TEXTURE_TRANSFORM\r\n                outUV = applyTransform(outUV, textureMatrices[EMISSIVEMAP_TEXTURE_TRANSFORM]);\r\n            #endif\r\n            emissive *= texture2D(emissiveTexture, outUV).rgb;\r\n        #endif\r\n        emissive *= emissiveStrength.x;\r\n\r\n        #ifdef TRANSMISSION\r\n            float kT = 1.0 - specEnv(n, viewDir, metallic, roughness, F0, specularWeight);\r\n            f_transmission = f_transmission * kT;\r\n            color = vec4((Lo) * clearcoatFresnel + ambientClearcoat, alpha);\r\n            #ifndef SCATTERING\r\n            color.rgb += (ambient * ao + emissive + f_transmission) * clearcoatFresnel;\r\n            #endif\r\n        #else\r\n            color = vec4(ao * ((emissive + Lo) * clearcoatFresnel + ambientClearcoat), alpha);\r\n            #ifndef SCATTERING\r\n            color.rgb += ambient * ao * clearcoatFresnel;\r\n            #endif\r\n        #endif\r\n\r\n        color.rgb = f_sheen + color.rgb * albedoSheenScaling;\r\n    #else\r\n        vec3 lightDir = normalize(lightPos[0].xyz - outPosition);\r\n        vec3 ambient = ambientStrength * lightColor[0].xyz;\r\n\r\n        float diff = max(dot(n, lightDir), 0.0);\r\n        vec3 diffuse = diff * lightColor[0].XYZ;\r\n\r\n        vec3 reflectDir = reflect(-lightDir, n);\r\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), specularPower);\r\n        vec3 specular = specularStrength * spec * lightColor[0].xyz;\r\n\r\n        color = vec4(baseColor.rgb * (ambient + diffuse + specular) * shadow, alpha);\r\n    #endif\r\n\r\n    #ifndef SCATTERING\r\n    if (isTone.x == 1.0) {\r\n        #ifdef SPHERICAL_HARMONICS\r\n        color.rgb  *= 4.0;\r\n        vec3 X = max(vec3(0.0, 0.0, 0.0), color.rgb - 0.004);\r\n        vec3 retColor = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);\r\n        color.rgb = retColor * retColor;\r\n        #else\r\n        // color.rgb = color.rgb / (color.rgb + vec3(1.0));\r\n        color.rgb = pow(color.rgb, vec3(1.0 / gamma));\r\n        #endif\r\n    }\r\n    #endif\r\n\r\n    #ifdef SPHERICAL_HARMONICS\r\n    color.rgb += aSpecular;\r\n    #endif\r\n\r\n    // normalColor = vec4(n, 0.0);\r\n\r\n    #ifdef SCATTERING\r\n    specColor = vec4(Lo + aSpecular, 1.0);\r\n\r\n    vec3 irradiance = finalDiffuse;\r\n    irradiance += ambient;\r\n    irradiance += f_transmission;\r\n    irradiance /= sqrt(baseColor.rgb);\r\n\r\n    irradianceColor = vec4(clamp(irradiance, vec3(0.), vec3(1.)), 1.0);\r\n    #ifdef TRANSMISSION\r\n    albedoColor = vec4(sqrt(attenuationColor.rgb), 1.0);\r\n    #else\r\n    albedoColor = vec4(sqrt(baseColor), 1.0);\r\n    #endif\r\n    #else\r\n    irradianceColor = vec4(0.0);\r\n    albedoColor = vec4(0.0);\r\n    specColor = vec4(0.0);\r\n    #endif\r\n}\r\n',de={POSITION:[0,3],TEXCOORD_0:[2,2],NORMAL:[1,3],TANGENT:[3,4],JOINTS_0:[4,4],WEIGHTS_0:[5,4],COLOR_0:[6,4],TEXCOORD_1:[7,2],TEXCOORD_2:[8,2]};class Ee{UBO;VAO;uniformBuffer;indicesBuffer;attributes;targets;blend;uniforms;SKIN;boundingSphere;vertexAccessor;indexType;cubeVertexSize;VBO;indicesWebGPUBuffer;verticesWebGPUBuffer;uniformBindGroup1;g;constructor(e,r,t,i,s){let o;this.boundingSphere={center:new n,radius:null,min:null,max:null},this.uniformBuffer=null,this.UBO=null,this.VAO=null,this.indicesBuffer=null,this.attributes=null,this.targets=null,this.blend=null,this.uniforms=null,this.SKIN=null,this.targets=[];const a={},l=e.accessors[s.indices];this.indexType=l?.componentType;const u=new Map;for(const r in s.attributes)u.set(r,e.accessors[s.attributes[r]]);const f={min:u.get("POSITION").min,max:u.get("POSITION").max},h=s.extensions&&s.extensions.KHR_draco_mesh_compression;if(h){const t=e.bufferViews[h.bufferView],n=new i.Decoder,s=function(e,r,t,n){const i=new fe.DecoderBuffer;i.Init(new Int8Array(e,t,n),e.byteLength);const s=new fe.Mesh;return r.DecodeBufferToMesh(i,s),fe.destroy(i),s}(r[t.buffer],n,t.byteOffset,t.byteLength),c=s.num_faces(),l=s.num_points();for(const e of u.keys()){const r=n.GetAttributeByUniqueId(s,h.attributes[e]),t=R(u.get(e).type),[o,c]=he(N(u.get(e).componentType),l*t,s,r,n);for(let e=0;e<l*t;e+=t)c[e]=o.GetValue(e),c[e+1]=o.GetValue(e+1),t>2&&(c[e+2]=o.GetValue(e+2)),t>3&&(c[e+3]=o.GetValue(e+3));i.destroy(o),a[e]=c}{o=new Uint32Array(3*c),o.type="UNSIGNED_INT";const e=new i.DracoUInt32Array;for(let r=0;r<c;++r){n.GetFaceFromMesh(s,r,e);const t=3*r;o[t]=e.GetValue(0),o[t+1]=e.GetValue(1),o[t+2]=e.GetValue(2)}i.destroy(e)}i.destroy(n),i.destroy(s)}else{if(l){const t=e.bufferViews[l.bufferView];o=g(r[t.buffer],l.componentType,I(t.byteOffset,l.byteOffset),R(l.type)*l.count),6===s.mode&&(o=function(e){if(e.length<3)return new Uint32Array(0);e instanceof Uint32Array||Math.max(...e);const r=new Uint32Array(3*(e.length-2)),t=e[0];let n=0;for(let i=1;i<e.length-1;i++)r[n++]=t,r[n++]=e[i],r[n++]=e[i+1];return r}(o)),2===s.mode&&(o=function(e){const r=e.length,t=new e.constructor(2*r);for(let n=0;n<r;n++){const i=e[n],s=e[(n+1)%r];t[2*n]=i,t[2*n+1]=s}return t}(o))}for(const t of u.keys()){const n=u.get(t),i=e.bufferViews[n.bufferView];a[t]=A(r[i.buffer],n,i)}}if(s.targets){for(const t of s.targets){const n={};for(const i in t){n[i]=e.accessors[t[i]];const s=n[i],o=e.bufferViews[s.bufferView];n[i]=A(r[o.buffer],s,o)}this.targets.push(n)}for(const e of u.keys())if(this.targets[0][e]){let r=0;const n=a[e];a[e]=new n.constructor(n.length);for(let i=0;i<a[e].length;i++)"TANGENT"!==e||(i+1)%4!=0?a[e][i]=n[i]+t.reduce((n,s,o)=>n+t[o]*this.targets[o][e][i-r],0):r++}}for(const t of u.keys()){const n=u.get(t);if("COLOR_0"===t&&"VEC3"===n.type){const e=new a[t].constructor(4*n.count);let r=0;for(let n=0;n<e.length;n++)(n+1)%4==0?e[n]=1:(e[n]=a[t][r],r++);a[t]=e}if(void 0!==n.sparse){const i=R(n.type),s=e.bufferViews[n.sparse.indices.bufferView],o=e.bufferViews[n.sparse.values.bufferView],c=g(r[s.buffer],n.sparse.indices.componentType,I(s.byteOffset,n.sparse.indices.byteOffset),n.sparse.count),l=g(r[o.buffer],n.componentType,I(o.byteOffset,n.byteOffset),R(n.type)*n.sparse.count);for(let e=0,r=c.length;e<r;e++){const r=c[e];a[t][r*i]=l[e*i],i>=2&&(a[t][r*i+1]=l[e*i+1]),i>=3&&(a[t][r*i+2]=l[e*i+2]),i>=4&&(a[t][r*i+3]=l[e*i+3])}}}void 0===a.NORMAL&&o&&(a.NORMAL=function(e,r){const t=new Float32Array(r.length/3*3);for(let s=0;s<e.length;s+=3){const o=[e[s],e[s+1],e[s+2]].map(e=>i(r,e)),a=o[1].subtract(o[0]),c=o[2].subtract(o[0]),l=n.cross(a.normalize(),c.normalize()),[u,f,h]=l.elements;for(let r=0;r<3;r++)t[3*e[s+r]+0]=t[3*e[s+r]+0]+u,t[3*e[s+r]+1]=t[3*e[s+r]+1]+f,t[3*e[s+r]+2]=t[3*e[s+r]+2]+h}return t;function i(e,r,t=3){return new n([e[r*=t],e[r+1],e[r+2]])}}(o,a.POSITION),u.set("NORMAL",{componentType:5126})),void 0===a.NORMAL&&void 0===o&&(a.NORMAL=function(e){const r=new Float32Array(e.length);for(let t=0;t<e.length;t+=9){const i=[new n([e[t],e[t+1],e[t+2]]),new n([e[t+3],e[t+4],e[t+5]]),new n([e[t+6],e[t+7],e[t+8]])],s=i[1].subtract(i[0]),o=i[2].subtract(i[0]),a=n.cross(s.normalize(),o.normalize()),[c,l,u]=a.elements;r[t]=c,r[t+1]=l,r[t+2]=u,r[t+3]=c,r[t+4]=l,r[t+5]=u,r[t+6]=c,r[t+7]=l,r[t+8]=u}return r}(a.POSITION),u.set("NORMAL",{componentType:5126})),void 0===a.TEXCOORD_0&&o&&(a.TEXCOORD_0=function(e,r){const t=new Float32Array(e.length/3*2),i=new c([1/0,1/0]),s=new c([-1/0,-1/0]);for(let o=0;o<e.length/3;++o){const a=[],c=[];for(let t=0;t<3;++t)a.push(e[3*o+t]),c.push(r[3*o+t]);const l=new n(c),u=["x","y","z"].sort((e,r)=>Math.abs(l[e])-Math.abs(l[r])),f=new n(a),h=f[u[0]],m=f[u[1]];t[2*o]=h,t[2*o+1]=m,s.x=Math.max(s.x,h),s.y=Math.max(s.y,m),i.x=Math.min(i.x,h),i.y=Math.min(i.y,m)}const o=new c(s.elements).subtract(i);for(let r=0;r<e.length/3;++r){const e=2*r;t[e]=(t[e]-i.x)/o.x,t[e+1]=(t[e+1]-i.y)/o.y}return t}(a.POSITION,a.NORMAL),u.set("TEXCOORD_0",{componentType:5126})),void 0===s.attributes.TANGENT&&o&&(a.TANGENT=function(e,r,t,i){const s=new Float32Array(t.length/3*4);for(let t=0;t<e.length;t+=3){const c=[e[t],e[t+1],e[t+2]],l=c.map(e=>o(r,e)),u=c.map(e=>o(i,e,2)),f=l[1].subtract(l[0]),h=l[2].subtract(l[0]),m=u[1].subtract(u[0]),T=u[2].subtract(u[0]);let d=m.elements[0]*T.elements[1]-m.elements[1]*T.elements[0];const E=d>0?1:-1;d=0!==d?1/d:1;const p=new n([(T.elements[1]*f.elements[0]-m.elements[1]*h.elements[0])*d,(T.elements[1]*f.elements[1]-m.elements[1]*h.elements[1])*d,(T.elements[1]*f.elements[2]-m.elements[1]*h.elements[2])*d]);p.normalize(),c.forEach(e=>{a(s,e,p,E)})}return s;function o(e,r,t=3){return r*=t,3===t?new n([e[r],e[r+1],e[r+2]]):2===t?new c([e[r],e[r+1]]):void 0}function a(e,r,t,n,i=4,s=(e,r)=>e+r){r*=i;for(let o=0;o<i;++o)e[r+o]=3===o?n:s(e[r+o],t.elements[o])}}(o,a.POSITION,a.NORMAL,a.TEXCOORD_0),u.set("TANGENT",{componentType:5126})),this.vertexAccessor=u,this.attributes=a,this.indicesBuffer=o;const{min:m,max:T}=f;this.boundingSphere.min=new n(m),this.boundingSphere.max=new n(T)}compose(e){let r=12;void 0!==e&&(r=13);const t=this.attributes.POSITION.length/3,n=new Float32Array((void 0!==e?t:0)+3*t+2*t+3*t+4*t+(this.attributes.JOINTS_0?.length??0)+(this.attributes.WEIGHTS_0?.length??0)+(this.attributes.COLOR_0?.length??0)+(this.attributes.TEXCOORD_1?.length??0)+(this.attributes.TEXCOORD_2?.length??0));this.attributes.WEIGHTS_0&&(r+=8),this.attributes.COLOR_0&&(r+=4),this.attributes.TEXCOORD_1&&(r+=2),this.attributes.TEXCOORD_2&&(r+=2);let i=0,s=0,o=0;for(let t=0;t<n.length;t+=r){let r=12;n[t]=this.attributes.POSITION[i],n[t+1]=this.attributes.POSITION[i+1],n[t+2]=this.attributes.POSITION[i+2],this.attributes.TEXCOORD_0&&(n[t+3]=this.attributes.TEXCOORD_0[s],n[t+4]=this.attributes.TEXCOORD_0[s+1]),n[t+5]=this.attributes.NORMAL[i],n[t+6]=this.attributes.NORMAL[i+1],n[t+7]=this.attributes.NORMAL[i+2],this.attributes.TANGENT&&(n[t+8]=this.attributes.TANGENT[o],n[t+9]=this.attributes.TANGENT[o+1],n[t+10]=this.attributes.TANGENT[o+2],n[t+11]=this.attributes.TANGENT[o+3]),this.attributes.WEIGHTS_0&&(n[t+12]=this.attributes.JOINTS_0[o],n[t+13]=this.attributes.JOINTS_0[o+1],n[t+14]=this.attributes.JOINTS_0[o+2],n[t+15]=this.attributes.JOINTS_0[o+3],n[t+16]=this.attributes.WEIGHTS_0[o],n[t+17]=this.attributes.WEIGHTS_0[o+1],n[t+18]=this.attributes.WEIGHTS_0[o+2],n[t+19]=this.attributes.WEIGHTS_0[o+3],r+=8),this.attributes.COLOR_0&&(n[t+12]=this.attributes.COLOR_0[o],n[t+13]=this.attributes.COLOR_0[o+1],n[t+14]=this.attributes.COLOR_0[o+2],n[t+15]=this.attributes.COLOR_0[o+3],r+=4),this.attributes.TEXCOORD_1&&(n[t+12]=this.attributes.TEXCOORD_1[s],n[t+13]=this.attributes.TEXCOORD_1[s+1],r+=2),this.attributes.TEXCOORD_2&&(n[t+14]=this.attributes.TEXCOORD_2[s],n[t+15]=this.attributes.TEXCOORD_2[s+1],r+=2),void 0!==e&&(n[t+r]=e),i+=3,s+=2,o+=4}this.g=n}createGeometryForWebGPU(e){const{device:r}=e;this.compose();const t=r.createBuffer({size:this.g.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});if(new Float32Array(t.getMappedRange()).set(this.g),t.unmap(),this.verticesWebGPUBuffer=t,this.indicesBuffer){this.indicesBuffer=new Uint32Array(this.indicesBuffer);const e=r.createBuffer({size:this.indicesBuffer.byteLength,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0});new Uint32Array(e.getMappedRange()).set(this.indicesBuffer),e.unmap(),this.indicesWebGPUBuffer=e}}createGeometryForWebGl(e,r,t){const n=e.createVertexArray();e.bindVertexArray(n),this.compose(t);const i=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,i),e.bufferData(e.ARRAY_BUFFER,this.g,e.STATIC_DRAW),this.VBO=i;const s=[3,2,3,4];r.find(e=>"JOINTNUMBER"===e.name)&&s.push(4,4),r.find(e=>"COLOR"===e.name)&&s.push(4),r.find(e=>"MULTIUV"===e.name)&&s.push(2),this.attributes.TEXCOORD_2&&s.push(2),s.push(1);const o=Float32Array.BYTES_PER_ELEMENT*s.reduce((e,r)=>e+r,0);this.cubeVertexSize=o;let a=0;for(const r in de)if(r in this.attributes||"TANGENT"===r||"TEXCOORD_0"===r){const t=de[r];e.enableVertexAttribArray(t[0]),e.vertexAttribPointer(t[0],t[1],e.FLOAT,!1,o,Float32Array.BYTES_PER_ELEMENT*a),a+=t[1]}if(e.enableVertexAttribArray(9),e.vertexAttribPointer(9,1,e.FLOAT,!1,o,Float32Array.BYTES_PER_ELEMENT*a),this.indicesBuffer){const r=e.createBuffer();e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r),e.bufferData(e.ELEMENT_ARRAY_BUFFER,this.indicesBuffer,e.STATIC_DRAW)}this.VAO=n,e.bindVertexArray(null)}calculateBounding(e){this.boundingSphere.min.applyMatrix4(e),this.boundingSphere.max.applyMatrix4(e);const r=this.attributes.POSITION;let t=0;this.boundingSphere.center.add(this.boundingSphere.min).add(this.boundingSphere.max).scale(.5);for(let e=0;e<r.length;e+=3)t=Math.max(t,this.boundingSphere.center.distanceToSquared(r[e],r[e+1],r[e+2]));this.boundingSphere.radius=Math.sqrt(t)}createUniforms(e){const r=new w;r.add("model",e.elements),r.done(),this.uniformBuffer=r}updateUniformsWebGPU(e,r,t=GPUBufferUsage.UNIFORM){const n=r.store.byteLength,i=256+n,{device:s}=e,o=s.createBuffer({size:i,usage:t|GPUBufferUsage.COPY_DST});r.bufferWebGPU=o;const a=[{binding:0,resource:{buffer:o,offset:0,size:n}}];return s.queue.writeBuffer(o,0,r.store.buffer,r.store.byteOffset,r.store.byteLength),a}updateUniformsWebGl(e,r){const t=e.getUniformBlockIndex(r,"Matrices2");e.uniformBlockBinding(r,t,1)}async updateWebGPU(e,r){const{device:t}=e;let n=12;this.attributes.COLOR_0&&(n+=4),this.attributes.TEXCOORD_1&&(n+=2);let i=0,s=0,o=0;const{g:a}=this;for(let e=0;e<a.length;e+=n)r.POSITION&&(a[e]=r.POSITION[i],a[e+1]=r.POSITION[i+1],a[e+2]=r.POSITION[i+2]),r.TEXCOORD_0&&(a[e+3]=r.TEXCOORD_0[s],a[e+4]=r.TEXCOORD_0[s+1]),r.NORMAL&&(a[e+5]=r.NORMAL[i],a[e+6]=r.NORMAL[i+1],a[e+7]=r.NORMAL[i+2]),r.TANGENT&&(a[e+8]=r.TANGENT[o],a[e+9]=r.TANGENT[o+1],a[e+10]=r.TANGENT[o+2],a[e+11]=r.TANGENT[o+3]),i+=3,s+=2,o+=4;t.queue.writeBuffer(this.verticesWebGPUBuffer,0,a.buffer,a.byteOffset,a.byteLength)}update(e,r){e.bindVertexArray(this.VAO);let t=13;this.attributes.COLOR_0&&(t+=4),this.attributes.TEXCOORD_1&&(t+=2);let n=0,i=0,s=0;const{g:o}=this;for(let e=0;e<o.length;e+=t)r.POSITION&&(o[e]=r.POSITION[n],o[e+1]=r.POSITION[n+1],o[e+2]=r.POSITION[n+2]),r.TEXCOORD_0&&(o[e+3]=r.TEXCOORD_0[i],o[e+4]=r.TEXCOORD_0[i+1]),r.NORMAL&&(o[e+5]=r.NORMAL[n],o[e+6]=r.NORMAL[n+1],o[e+7]=r.NORMAL[n+2]),r.TANGENT&&(o[e+8]=r.TANGENT[s],o[e+9]=r.TANGENT[s+1],o[e+10]=r.TANGENT[s+2],o[e+11]=r.TANGENT[s+3]),n+=3,i+=2,s+=4;e.bindBuffer(e.ARRAY_BUFFER,this.VBO),e.bufferData(e.ARRAY_BUFFER,o,e.STATIC_DRAW),e.bindVertexArray(null)}}let pe;class Re{tracks;url;host;skins;textures;images;samplers;arrayBuffer;cameras;lights;programs;scene;camera;light;aspect;zoom;canvas;resize;json;defines;draco;constructor(e,r,t){this.url=e,this.host=e.substr(0,e.lastIndexOf("/")+1),this.tracks=[],this.skins=[],this.textures=null,this.images=new Map,this.samplers=null,this.arrayBuffer=null,this.cameras=[],this.lights=[],this.programs={},this.defines=r,this.resize=t}setScene(e){this.scene=e}setGl(e){pe=e}setCamera(e){this.camera=e}setLight(e){this.light=e}setCanvas(e){this.canvas=e}getBuffer(){return Promise.all(this.scene.bin.map(e=>{if("string"==typeof e){if(/base64/.test(e)){const r=e.indexOf(";base64,")+8,t=e.substring(r),n=window.atob(t),i=new ArrayBuffer(n.length),s=new Uint8Array(i);for(let e=0;e<n.length;e++)s[e]=n.charCodeAt(e);return i}return ue(`${this.host}${e}`)}return Promise.resolve(e)})).then(e=>{this.arrayBuffer=e})}createProgram(e){let r;const t=e.map(e=>`${e.name}${e.value??1}`).join("");if(this.programs[t])r=this.programs[t];else{const n=e.map(e=>`#define ${e.name} ${e.value??1}\n`).join(""),i=[me,Te].map(e=>e.replace(/#include ".*/g,e=>{const[,r]=e.split('"');return r.includes("vert")?"#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 inPosition;\r\nlayout (location = 1) in vec3 inNormal;\r\nlayout (location = 2) in vec2 inUV;\r\nlayout (location = 4) in vec4 inJoint;\r\nlayout (location = 5) in vec4 inWeight;\r\nlayout (location = 3) in vec4 inTangent;\r\nlayout (location = 6) in vec4 inColor;\r\nlayout (location = 7) in vec2 inUV2;\r\nlayout (location = 8) in vec2 inUV3;\r\nlayout (location = 9) in float uMaterialID;\r\n\r\nuniform sampler2D uTransformTex;\r\n\r\nout vec4 vColor;\r\nout vec2 outUV0;\r\nout vec2 outUV2;\r\nout vec2 outUV3;\r\nout vec3 outPosition;\r\nout vec4 outPositionView;\r\nout float id;\r\n#ifdef TANGENT\r\n    out mat3 outTBN;\r\n#else\r\n    out vec3 outNormal;\r\n#endif\r\n\r\nstruct Transform {\r\n    mat4 model;\r\n};\r\nTransform fetchTransform(int id) {\r\n    Transform t;\r\n\r\n    // 8 texels across (0..7)\r\n    t.model[0] = texelFetch(uTransformTex, ivec2(0, id), 0);\r\n    t.model[1] = texelFetch(uTransformTex, ivec2(1, id), 0);\r\n    t.model[2] = texelFetch(uTransformTex, ivec2(2, id), 0);\r\n    t.model[3] = texelFetch(uTransformTex, ivec2(3, id), 0);\r\n\r\n    return t;\r\n}\r\nuniform Matrices2 {\r\n    mat4 view;\r\n    mat4 projection;\r\n    mat4 light;\r\n    vec4 isShadow;\r\n};\r\n#ifdef JOINTNUMBER\r\nuniform Skin {\r\n    mat4 joint[JOINTNUMBER];\r\n};\r\n#endif":"#version 300 es\r\nprecision highp float;\r\n\r\n// #ifdef DIFFUSE_TRANSMISSION\r\n//     #define SCATTERING 1\r\n// #endif\r\n\r\n#define texture2D(p, uv) texture(p, uv)\r\n#define textureCube(p, uv) texture(p, uv)\r\n#define textureLodCube(p, uv, i) textureLod(p, uv, i)\r\n#define textureLod2D(p, uv, i) textureLod(p, uv, i)\r\n#define textureLod2D2(p, uv, i) textureLod(p, uv, i)\r\n\r\nuniform sampler2D uMaterialTex;\r\n\r\nin vec4 vColor;\r\nin vec2 outUV0;\r\nin vec2 outUV2;\r\nin vec2 outUV3;\r\nin vec3 outPosition;\r\nin vec4 outPositionView;\r\nin float id;\r\n#ifdef TANGENT\r\n    in mat3 outTBN;\r\n#else\r\n    in vec3 outNormal;\r\n#endif\r\n\r\nlayout (location = 0) out vec4 color;\r\nlayout (location = 1) out vec4 normalColor;\r\nlayout (location = 2) out vec4 irradianceColor;\r\nlayout (location = 3) out vec4 albedoColor;\r\nlayout (location = 4) out vec4 specColor;\r\n\r\nstruct Material {\r\n    vec4 baseColorFactor;\r\n    vec3 specularFactor;\r\n    vec3 specularColorFactor;\r\n    vec3 emissiveFactor;\r\n    vec4 glossinessFactor;\r\n    vec4 metallicFactor;\r\n    vec4 roughnessFactor;\r\n    vec4 clearcoatFactor;\r\n    vec4 clearcoatRoughnessFactor;\r\n    vec4 sheenColorFactor;\r\n    vec4 sheenRoughnessFactor;\r\n    vec4 transmissionFactor;\r\n    vec4 ior;\r\n    vec4 normalTextureScale;\r\n    vec4 attenuationColorFactor; \r\n    vec4 attenuationDistance; \r\n    vec4 thicknessFactor;\r\n    vec4 emissiveStrength;\r\n    vec4 anisotropyFactor;\r\n    vec4 iridescence;\r\n    vec4 diffuseTransmissionFactor;\r\n    vec4 dispersionFactor;\r\n};\r\n\r\nMaterial fetchMaterial(int id) {\r\n    Material m;\r\n    int row = id;\r\n    m.baseColorFactor         = texelFetch(uMaterialTex, ivec2(0, row), 0);\r\n    m.specularFactor          = texelFetch(uMaterialTex, ivec2(1, row), 0).xyz;\r\n    m.specularColorFactor     = texelFetch(uMaterialTex, ivec2(2, row), 0).xyz;\r\n    m.emissiveFactor          = texelFetch(uMaterialTex, ivec2(3, row), 0).xyz;\r\n    m.glossinessFactor        = texelFetch(uMaterialTex, ivec2(4, row), 0);\r\n    m.metallicFactor          = texelFetch(uMaterialTex, ivec2(5, row), 0);\r\n    m.roughnessFactor         = texelFetch(uMaterialTex, ivec2(6, row), 0);\r\n    m.clearcoatFactor         = texelFetch(uMaterialTex, ivec2(7, row), 0);\r\n    m.clearcoatRoughnessFactor= texelFetch(uMaterialTex, ivec2(8, row), 0);\r\n    m.sheenColorFactor        = texelFetch(uMaterialTex, ivec2(9, row), 0);\r\n    m.sheenRoughnessFactor    = texelFetch(uMaterialTex, ivec2(10, row), 0);\r\n    m.transmissionFactor      = texelFetch(uMaterialTex, ivec2(11, row), 0);\r\n    m.ior                     = texelFetch(uMaterialTex, ivec2(12, row), 0);\r\n    m.normalTextureScale      = texelFetch(uMaterialTex, ivec2(13, row), 0);\r\n    m.attenuationColorFactor  = texelFetch(uMaterialTex, ivec2(14, row), 0);\r\n    m.attenuationDistance     = texelFetch(uMaterialTex, ivec2(15, row), 0);\r\n    m.thicknessFactor         = texelFetch(uMaterialTex, ivec2(16, row), 0);\r\n    m.emissiveStrength        = texelFetch(uMaterialTex, ivec2(17, row), 0);\r\n    m.anisotropyFactor        = texelFetch(uMaterialTex, ivec2(18, row), 0);\r\n    m.iridescence             = texelFetch(uMaterialTex, ivec2(19, row), 0);\r\n    m.diffuseTransmissionFactor= texelFetch(uMaterialTex, ivec2(20, row), 0);\r\n    m.dispersionFactor        = texelFetch(uMaterialTex, ivec2(21, row), 0);\r\n    return m;\r\n}\r\n\r\nuniform Matrices2 {\r\n    mat4 view;\r\n    mat4 projection;\r\n    mat4 light;\r\n    vec4 isShadow;\r\n};\r\nuniform LightPos {\r\n    vec4 lightPos[LIGHTNUMBER];\r\n};\r\nuniform LightColor {\r\n    vec4 lightColor[LIGHTNUMBER];\r\n};\r\nuniform Spotdir {\r\n    vec4 spotdir[LIGHTNUMBER];\r\n};\r\nuniform LightIntensity {\r\n    vec4 lightIntensity[LIGHTNUMBER];\r\n};\r\n#if defined MATRICES\r\nuniform TextureMatrices {\r\n    mat4 textureMatrices[MATRICES];\r\n};\r\n#endif\r\n#ifdef SPHERICAL_HARMONICS\r\nuniform SphericalHarmonics {\r\n    vec4 vSphericalL00;\r\n    vec4 vSphericalL1_1;\r\n    vec4 vSphericalL10;\r\n    vec4 vSphericalL11;\r\n    vec4 vSphericalL2_2;\r\n    vec4 vSphericalL2_1;\r\n    vec4 vSphericalL20;\r\n    vec4 vSphericalL21;\r\n    vec4 vSphericalL22;\r\n    mat4 rotationMatrix;\r\n};\r\n#endif\r\n\r\nuniform sampler2D baseColorTexture;\r\nuniform sampler2D metallicRoughnessTexture;\r\nuniform sampler2D normalTexture;\r\nuniform sampler2D emissiveTexture;\r\nuniform sampler2D occlusionTexture;\r\nuniform sampler2D clearcoatTexture;\r\nuniform sampler2D clearcoatRoughnessTexture;\r\nuniform sampler2D transmissionTexture;\r\nuniform sampler2D sheenColorTexture;\r\nuniform sampler2D sheenRoughnessTexture;\r\nuniform sampler2D iridescenceThicknessTexture;\r\nuniform sampler2D iridescenceTexture;\r\nuniform sampler2D clearcoatNormalTexture;\r\nuniform sampler2D specularTexture;\r\nuniform sampler2D specularColorTexture;\r\nuniform sampler2D thicknessTexture;\r\nuniform sampler2D diffuseTransmissionTexture;\r\nuniform sampler2D diffuseTransmissionColorTexture;\r\nuniform sampler2D anisotropyTexture;\r\n\r\nuniform samplerCube prefilterMap;\r\nuniform samplerCube charlieMap;\r\nuniform sampler2D brdfLUT;  \r\nuniform samplerCube irradianceMap;\r\nuniform sampler2D depthTexture;\r\nuniform sampler2D colorTexture;\r\nuniform vec2 isTone;\r\nuniform vec2 isIBL;\r\nuniform vec2 isDefaultLight;\r\nuniform sampler2D Sheen_E;\r\n"})).map(e=>e.replace(/\n/,`\n${n}`));this.programs[t]=S(i[0],i[1]),r=this.programs[t]}return r}buildPrim(e,r,t,n,i,s){const o=this.json.materials&&this.json.materials[s.material];this.json.extensions&&this.json.extensions.EXT_lights_image_based&&this.defines.push({name:"SPHERICAL_HARMONICS",value:Math.ceil(Math.log(this.json.extensions.EXT_lights_image_based.lights[0].specularImageSize)*Math.LOG2E)+10}),this.json.extensionsUsed&&this.json.extensionsUsed.includes("KHR_texture_basisu")&&this.defines.push({name:"BASISU"});const a=[...this.defines],c=new H(o,this.textures,a);void 0!==n&&a.push({name:"JOINTNUMBER",value:this.skins[n].jointNames.length}),void 0===s.indices&&void 0===s.attributes.TANGENT||a.push({name:"TANGENT"}),void 0===s.attributes.TEXCOORD_1&&void 0===s.attributes.TEXCOORD_2||a.push({name:"MULTIUV"}),void 0!==s.attributes.TEXCOORD_2&&a.push({name:"MULTIUV2"}),s.attributes.COLOR_0&&a.push({name:"COLOR"});const l=void 0!==n?new L(t,r):new C(t,r),u=new Ee(this.json,this.arrayBuffer,i,this.draco,s);if(u.attributes.COLOR_0&&u.attributes.COLOR_0.constructor!==Float32Array&&a.push({name:"COLOR_255"}),void 0===s.attributes.TANGENT&&a.push({name:"USERIGHTHANDEDSYSTEM"}),s.extensions&&s.extensions.KHR_materials_variants){const e=s.extensions.KHR_materials_variants.mappings.map(e=>({...e,m:new H(this.json.materials[e.material],this.textures,[...a])}));l.setVariants(e)}return l.setMode(s.mode),l.setMaterial(c),l.setGeometry(u),e.scale&&e.scale[0]<0&&l.setFrontFace(),e.scale&&c.thicknessFactor&&(c.thicknessFactor*=e.scale[0]),l.setDefines(c.defines),l instanceof L&&(l.skin=n),l.updateMatrix(),l.calculateBounding(),l}buildNode(e,r){const t=this.json.nodes[r];let n;if(void 0!==t.camera){const i=Object.assign({zoom:1,aspect:this.canvas?this.canvas.offsetWidth/this.canvas.offsetHeight:1},this.json.cameras[t.camera]);n=new y(i,r,e);const s=M(n.props);n.setProjection(s),this.cameras.push(n)}else if(t.extensions&&t.extensions.KHR_lights_punctual){const i=this.json.extensions.KHR_lights_punctual.lights[t.extensions.KHR_lights_punctual.light];i.isInitial=!1,n=new D(i,r,e),this.lights.push(n)}else n=void 0!==t.isBone?new B(r,e):new f(r,e);t.translation||t.rotation||t.scale?n.setPosition(t.translation,t.rotation,t.scale):t.matrix&&n.setMatrix(t.matrix),n.updateMatrix(),n.id=t.name,e.children.push(n),e=n,void 0!==t.mesh&&e.children.push(...this.json.meshes[t.mesh].primitives.map(this.buildPrim.bind(this,t,e,this.json.meshes[t.mesh].name,t.skin,this.json.meshes[t.mesh].weights))),t.children&&t.children.length&&t.children.forEach(this.buildNode.bind(this,e))}calculateFov(e){const t=new o;F(this.scene,e=>{e instanceof C&&t.expand(e.geometry.boundingSphere)});const i=t.getSize();if(e){const e=(new n).add(t.min).add(t.max).scale(.5),i=new r;i.translate(e.x,e.y,e.z),i.invert(),this.scene.matrixWorld.multiply(i),F(this.scene,e=>{e instanceof f&&e.updateMatrix()})}this.cameras.forEach(e=>{e.modelSize=i}),this.resize()}async buildMesh(){this.json.extensionsUsed&&this.json.extensionsUsed.includes("KHR_draco_mesh_compression")&&(this.draco=await new Promise(e=>{const r={onModuleLoaded(r){fe=r,e(fe)}};i.e(621).then(i.bind(i,252)).then(e=>e.default(r))})),this.json.extensions&&this.json.extensions.KHR_materials_variants&&(this.scene.variants=this.json.extensions.KHR_materials_variants.variants),this.json.scenes[void 0!==this.json.scene?this.json.scene:0].nodes.forEach(e=>{this.json.nodes[e].extensions&&this.buildNode(this.scene,e)}),0===this.lights.length&&this.light&&this.lights.push(this.light),this.json.scenes[void 0!==this.json.scene?this.json.scene:0].nodes.forEach(e=>{this.json.nodes[e].children&&this.json.nodes[e].children.length&&!this.json.nodes[e].extensions&&this.buildNode(this.scene,e),void 0!==this.json.nodes[e].mesh&&this.buildNode(this.scene,e),void 0!==this.json.nodes[e].camera&&this.buildNode(this.scene,e)}),F(this.scene,e=>{if(e instanceof C&&(e.material.alpha?this.scene.transparentChildren.push(e):this.scene.opaqueChildren.push(e),this.scene.meshes.push(e),e.material.defines.push({name:"LIGHTNUMBER",value:this.lights.length})),e instanceof D){const r=this.lights.findIndex(r=>r===e);F(e.parent,e=>{e instanceof C&&(e.material.defines.find(e=>"LIGHTINDEX"===e.name).value=r)})}}),this.scene.opaqueChildren.sort((e,r)=>e.distance-r.distance),this.scene.transparentChildren.sort((e,r)=>e.distance-r.distance)}buildAnimation(){if(!this.json.animations)return!0;for(const e of this.json.animations){const r=[];for(const t of e.channels){const n=0,i=e.samplers[t.sampler];if(i){const{target:s}=t;let o=s.node,a=s.path;if(void 0===o){const e=s.extensions.KHR_animation_pointer.pointer.split("/"),r=this.json.materials[e[2]].name;o=this.scene.meshes.find(e=>e.material.name===r).name,a=e.splice(3).join("/")}const c=void 0!==e.parameters?e.parameters[i.input]:i.input,l=void 0!==e.parameters?e.parameters[i.output]:i.output,u=this.json.accessors[c],h=this.json.accessors[l],m=this.json.bufferViews[u.bufferView],T=this.json.bufferViews[h.bufferView],d=g(this.arrayBuffer[m.buffer],u.componentType,I(m.byteOffset,u.byteOffset),R(u.type)*u.count),E=g(this.arrayBuffer[T.buffer],h.componentType,I(T.byteOffset,h.byteOffset),R(h.type)*h.count),p=[];F(this.scene,e=>{e.name===o&&("weights"===a&&e instanceof f?p.push(...e.children):p.push(e))});let x="weights"===a?p[0].geometry.targets.length:R(h.type);"CUBICSPLINE"===i.interpolation&&(x*=3);const _=[];for(let e=0;e<d.length;e++){const r=d[e],t=E.slice(e*x,(e+1)*x);_.push({time:r,value:P(t)})}_.length>=2&&p.length&&r.push({duration:Math.max(_[_.length-1].time,n),stoped:!1,meshes:p,component:x,type:a,name:`${p[0].name}.${a}`,keys:_,interpolation:i.interpolation})}}this.tracks.push(r)}}buildSkin(){if(!this.json.skins)return!0;for(const e of this.json.skins){const t=this.json.accessors[e.inverseBindMatrices],n=this.json.bufferViews[t.bufferView],i=g(this.arrayBuffer[n.buffer],t.componentType,I(n.byteOffset,t.byteOffset),R(t.type)*t.count),s={jointNames:e.joints,inverseBindMatrices:i,bones:[],boneInverses:[]};let o=0;for(const e of s.jointNames){this.json.nodes[e].isBone=!0;const t=s.inverseBindMatrices,n=(new r).set(t.slice(16*o,16*(o+1)));s.boneInverses.push(n),o++}this.skins.push(s)}}getJson(){return/glb/.test(this.url)?ue(this.url).then(e=>{const r=new TextDecoder("utf-8"),[t]=new Uint32Array(e,12,1),n=new Uint8Array(e,20,t),i=JSON.parse(r.decode(n)),[s]=new Uint32Array(e,20+t,1),o=e.slice(28+t,28+t+s);this.json=i,this.scene.bin.push(o)}):(e=this.url,"undefined"!=typeof window?window.fetch(e).then(e=>e.json()):new Promise(r=>{ce.readFile(e,"utf8",(e,t)=>{if(e)throw e;r(JSON.parse(t))})})).then(e=>{for(const r in e.buffers)this.scene.bin.push(e.buffers[r].uri);return this.json=e,!0});var e}createSamplers(){const e=this.json.samplers||[{}];this.samplers=e.map(e=>{const r=pe.createSampler();return pe.samplerParameteri(r,pe.TEXTURE_MIN_FILTER,e.minFilter||pe.NEAREST_MIPMAP_LINEAR),pe.samplerParameteri(r,pe.TEXTURE_MAG_FILTER,e.magFilter||pe.LINEAR),pe.samplerParameteri(r,pe.TEXTURE_WRAP_S,e.wrapS||pe.REPEAT),pe.samplerParameteri(r,pe.TEXTURE_WRAP_T,e.wrapT||pe.REPEAT),r})}createSamplersWebGPU(e){function r(e){return{9729:"linear",9728:"linear",10497:"repeat",33648:"mirror-repeat",33071:"clamp-to-edge"}[e]}const t=this.json.samplers||[{}];this.samplers=t.map(t=>e.device.createSampler({mipmapFilter:"linear",magFilter:r(t.minFilter)||"linear",minFilter:r(t.magFilter)||"nearest",addressModeU:r(t.wrapS)||"repeat",addressModeV:r(t.wrapT)||"repeat",addressModeW:r(t.wrapS)||"repeat"}))}createTexturesWebGPU(e){this.createTextures(this.handleTextureLoadedWebGPU.bind(this,e))}createTexturesWebGL(){this.createTextures(this.handleTextureLoaded.bind(this))}createTextures(e){this.scene.meshes.forEach(r=>{const t=[r.material,...r.variants.map(e=>e.m)],n=["baseColorTexture","metallicRoughnessTexture","emissiveTexture","normalTexture","occlusionTexture","clearcoatTexture","clearcoatRoughnessTexture","clearcoatNormalTexture","sheenColorTexture","sheenRoughnessTexture","transmissionTexture","specularTexture","specularColorTexture","thicknessTexture","iridescenceThicknessTexture","iridescenceTexture","diffuseTransmissionTexture","diffuseTransmissionColorTexture","anisotropyTexture"],i=["baseColorTexture","sheenColorTexture","emissiveTexture",r.defines.find(e=>"SPECULARGLOSSINESSMAP"===e.name)&&"metallicRoughnessTexture"];for(let r=0;r<n.length;r++)for(const s of t){const t=n[r],o=s[t];o&&(i.find(e=>e===t)&&(o.srgb=!0),s[t]=e(o,t))}})}async initTextures(e){if(!this.json.textures)return!0;const r={};let t=!1;this.json.textures.forEach(e=>{e.extensions&&e.extensions.KHR_texture_basisu&&(t=!0);let n=e.extensions&&e.extensions.KHR_texture_basisu?e.extensions.KHR_texture_basisu.source:e.source;n=e.extensions&&e.extensions.EXT_texture_webp?e.extensions.EXT_texture_webp.source:n;const i=String(e.sampler)+String(n);r[i]=e,r[i].name=i,e.name=i}),t&&((await i.e(971).then(i.bind(i,606))).default({preinitializedWebGLContext:pe}).then(e=>{const r={astcSupported:pe.getExtension("WEBGL_compressed_texture_astc"),etc1Supported:pe.getExtension("WEBGL_compressed_texture_etc1"),etc2Supported:pe.getExtension("WEBGL_compressed_texture_etc"),dxtSupported:pe.getExtension("WEBGL_compressed_texture_s3tc"),bptcSupported:pe.getExtension("EXT_texture_compression_bptc"),pvrtcSupported:pe.getExtension("WEBGL_compressed_texture_pvrtc")||pe.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc")};window.LIBKTX=e,window.LIBKTX.transcoderConfig=r,window.LIBKTX.GL.makeContextCurrent(window.LIBKTX.GL.registerContext(pe,{majorVersion:2}))}),await new Promise(e=>setTimeout(e,1e3)));const n=Object.values(r).map(r=>{let t=r.extensions&&r.extensions.KHR_texture_basisu?r.extensions.KHR_texture_basisu.source:r.source;t=r.extensions&&r.extensions.EXT_texture_webp?r.extensions.EXT_texture_webp.source:t;const n=this.json.images[t];return function(e,r,{bufferView:t,mimeType:n,uri:i},{url:s,name:o},a){return"undefined"!=typeof window?new Promise((c,l)=>{if("image/ktx2"===n)window.fetch(s).then(e=>e.arrayBuffer()).then(e=>{c({sampler:a,mimeType:n,name:o,image:le(e)})});else{const u=new Image;if(u.onload=()=>{e?createImageBitmap(u).then(e=>{c({sampler:a,name:o,bitmap:e})}):c({sampler:a,name:o,image:u})},u.onerror=()=>{l(new Error("Cant load texture"))},u.crossOrigin="anonymous",void 0!==t){const e=r.json.bufferViews[t],i=new Uint8Array(r.arrayBuffer[e.buffer],e.byteOffset,e.byteLength),s=new Blob([i],{type:n});u.src=URL.createObjectURL(s)}else/base64/.test(i)?u.src=i:u.src=s}}):new Promise(e=>{ce.readFile(s,(r,t)=>{if(r)throw r;e({sampler:a,url:s,name:o,image:new Uint8Array(t).buffer})})})}(e,this,n,{url:`${this.host}${n.uri}`,name:r.name},r.sampler)});return Promise.all(n).then(e=>(this.textures=this.json.textures.map(r=>e.find(e=>e.name===r.name)),!0))}handleTextureLoadedWebGPU(e,{image:r,sampler:t,srgb:n,name:i},s){if(this.images.get(i))return this.images.get(i);const{device:o}=e,a=this.samplers[void 0!==t?t:0],c=Math.max(1,Math.floor(Math.log2(Math.max(r.width,r.height)))-2),l=o.createTexture({label:s,size:[r.width,r.height,1],format:n?"rgba8unorm-srgb":"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:c});return o.queue.copyExternalImageToTexture({source:r},{premultipliedAlpha:!1,texture:l,mipLevel:0,origin:{x:0,y:0,z:0}},{width:r.width,height:r.height,depthOrArrayLayers:1}),l.sampler=a,l.view=l.createView(),O(o,l,r.width,r.height,c),this.images.set(i,l),l}handleTextureLoaded({image:e,name:r,mimeType:t,sampler:n,srgb:i}){const s=this.samplers[void 0!==n?n:0];if(t)return e.sampler=s,e;if(this.images.get(r))return this.images.get(r);const o=pe.createTexture();return o.name=r,o.image=e.src.substr(e.src.lastIndexOf("/")),o.sampler=s,pe.activeTexture(pe.TEXTURE31),pe.bindTexture(pe.TEXTURE_2D,o),pe.pixelStorei(pe.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),pe.pixelStorei(pe.UNPACK_COLORSPACE_CONVERSION_WEBGL,pe.NONE),pe.texImage2D(pe.TEXTURE_2D,0,i?pe.SRGB8_ALPHA8:pe.RGBA,pe.RGBA,pe.UNSIGNED_BYTE,e),pe.generateMipmap(pe.TEXTURE_2D),this.images.set(r,o),o}async getEnv(e){if(this.json.extensions&&this.json.extensions.EXT_lights_image_based){const[r]=this.json.extensions.EXT_lights_image_based.lights;if(r.specularImages=r.specularImages.map(e=>e.map(e=>{const r=this.json.images[e],t=this.json.bufferViews[r.bufferView],{buffer:n,byteLength:i,byteOffset:s}=t,o=new Uint8Array(this.arrayBuffer[n],s,i),a=new Blob([o],{type:r.mimeType}),c=window.URL.createObjectURL(a),l=new Image;return l.src=c,l})),await new Promise(e=>setTimeout(e,200)),e)for(const e of r.specularImages)for(const r of e)r.bitmap=await createImageBitmap(r);return r}}}const xe="#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\nout vec4 color;\r\n\r\nuniform vec2 denom;\r\nuniform sampler2D uTexture;\r\n\r\nconst float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\r\n\r\nvoid main() {             \r\n    vec2 offset = 1.0 / vec2(textureSize(uTexture, 0));\r\n    vec3 result = texture(uTexture, uv).rgb * weight[0];\r\n\r\n    for (int i = 1; i < 5; ++i) {\r\n        result += texture(uTexture, uv + denom * (offset * float(i))).rgb * weight[i];\r\n        result += texture(uTexture, uv - denom * (offset * float(i))).rgb * weight[i];\r\n    }\r\n\r\n    color = vec4(result, 1.0);\r\n}\r\n";let _e,Ae,ge,ve,Se,be;class Fe extends k{texture;setGL(e){ve=e}preProcessing(e){ve.clear(ve.COLOR_BUFFER_BIT|ve.DEPTH_BUFFER_BIT),e.renderScene({isprerefraction:!0}),ve.bindFramebuffer(ve.FRAMEBUFFER,null),ve.activeTexture(ve[`TEXTURE${this.texture.index}`]),ve.bindTexture(ve.TEXTURE_2D,this.texture),ve.generateMipmap(ve.TEXTURE_2D)}preProcessingWebGPU(e){e.target=[{view:this.texture.view,storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1}},...e.pipeline.pass.colorAttachments.slice(1)],e.renderScene({isprerefraction:!0});const r=Math.max(1,Math.floor(Math.log2(Math.max(e.width,e.height)))-2);O(ve.device,this.texture.texture,e.width,e.height,r)}buildScreenBuffer(e){return this.texture=e.createDefaultTexture(1,!0),ve.generateMipmap(ve.TEXTURE_2D),ve.bindFramebuffer(ve.FRAMEBUFFER,e.preframebuffer),ve.framebufferTexture2D(ve.FRAMEBUFFER,ve.COLOR_ATTACHMENT0,ve.TEXTURE_2D,this.texture,0),ve.bindFramebuffer(ve.FRAMEBUFFER,null),{name:"REFRACTION"}}buildScreenBufferWebGPU(e){return this.texture=e.createDefaultTexture("refractionTexture"),{name:"REFRACTION"}}attachUniform(){}postProcessing(){}postProcessingWebGPU(){}}const Ue={bloom:class extends k{tempBlurTexture;blurTexture;blurTexture2;blurTexture3;blurTexture4;program;bloorProgram;hdrTexture;setGL(e){Ae=e}attachUniform(e){Ae.uniform1i(Ae.getUniformLocation(e,"bloom"),this.blurTexture.index)}postProcessing(e){Ae.bindFramebuffer(Ae.FRAMEBUFFER,this.framebuffer),Ae.useProgram(this.bloorProgram),Ae.framebufferTexture2D(Ae.FRAMEBUFFER,Ae.COLOR_ATTACHMENT0,Ae.TEXTURE_2D,this.hdrTexture,0),Ae.uniform1i(Ae.getUniformLocation(this.bloorProgram,"diff"),e.screenTexture.index),Ae.drawArrays(Ae.TRIANGLE_STRIP,0,4),Ae.useProgram(this.program),Ae.viewport(0,0,this.width/2,this.height/2),this.renderBlur(this.hdrTexture,this.program),this.renderBlur(this.blurTexture,this.program),this.renderBlur(this.blurTexture,this.program),this.renderBlur(this.blurTexture,this.program),this.renderBlur(this.blurTexture,this.program),Ae.bindFramebuffer(Ae.FRAMEBUFFER,null),Ae.viewport(0,0,this.width,this.height)}buildScreenBuffer(e){return this.framebuffer=Ae.createFramebuffer(),Ae.bindFramebuffer(Ae.FRAMEBUFFER,this.framebuffer),this.tempBlurTexture=e.createDefaultTexture(2),this.blurTexture=e.createDefaultTexture(2),this.hdrTexture=e.createByteTexture(),Ae.bindFramebuffer(Ae.FRAMEBUFFER,null),this.program=S(re,xe),this.bloorProgram=S(re,"#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\nout vec4 color;\r\n\r\nuniform sampler2D diff;\r\n\r\nconst vec3 hdrColor = vec3(0.2126, 0.7152, 0.0722);\r\nconst float brightnessThreshold = 0.8;\r\n\r\nvoid main() {\r\n    vec3 c = texture(diff, uv).rgb;\r\n    float brightness = dot(c, hdrColor);\r\n    if (brightness > brightnessThreshold) {\r\n        color = vec4(c, 1.0);\r\n    } else {\r\n        color = vec4(0.0, 0.0, 0.0, 1.0);\r\n    }\r\n}\r\n"),{name:"BLOOM"}}renderBlur(e,r){Ae.framebufferTexture2D(Ae.FRAMEBUFFER,Ae.COLOR_ATTACHMENT0,Ae.TEXTURE_2D,this.tempBlurTexture,0),Ae.clearColor(...d),Ae.clear(Ae.COLOR_BUFFER_BIT|Ae.DEPTH_BUFFER_BIT|Ae.STENSIL_BUFFER_BIT),Ae.uniform1i(Ae.getUniformLocation(r,"uTexture"),e.index),Ae.uniform2f(Ae.getUniformLocation(r,"denom"),1,0),Ae.drawArrays(Ae.TRIANGLE_STRIP,0,4),Ae.framebufferTexture2D(Ae.FRAMEBUFFER,Ae.COLOR_ATTACHMENT0,Ae.TEXTURE_2D,this.blurTexture,0),Ae.uniform1i(Ae.getUniformLocation(r,"uTexture"),this.tempBlurTexture.index),Ae.uniform2f(Ae.getUniformLocation(r,"denom"),0,1),Ae.drawArrays(Ae.TRIANGLE_STRIP,0,4)}preProcessing(){}},ssao:class extends k{ssaoBlurTexture;ssaoTexture;noice;kernels;ssaoProgram;ssaoBlurProgram;scale;constructor(){super(),this.scale=2}setGL(e){_e=e}attachUniform(e){_e.uniform1i(_e.getUniformLocation(e,"ssao"),this.ssaoTexture.index)}postProcessing(e){_e.bindFramebuffer(_e.FRAMEBUFFER,this.framebuffer),_e.framebufferTexture2D(_e.FRAMEBUFFER,_e.COLOR_ATTACHMENT0,_e.TEXTURE_2D,this.ssaoTexture,0),_e.clearColor(...d),_e.clear(_e.COLOR_BUFFER_BIT|_e.DEPTH_BUFFER_BIT),_e.useProgram(this.ssaoProgram);const t=this.camera.props.perspective||this.camera.props.orthographic;_e.uniform1i(_e.getUniformLocation(this.ssaoProgram,"normBuff"),e.normalTexture.index),_e.uniform1i(_e.getUniformLocation(this.ssaoProgram,"depthBuff"),e.depthTexture.index),_e.uniform1i(_e.getUniformLocation(this.ssaoProgram,"noice"),this.noice.index),_e.uniform2f(_e.getUniformLocation(this.ssaoProgram,"noiseScale"),this.width/this.scale/4,this.height/this.scale/4),_e.uniform1f(_e.getUniformLocation(this.ssaoProgram,"zFar"),t.zfar),_e.uniform1f(_e.getUniformLocation(this.ssaoProgram,"zNear"),t.znear),_e.uniform1f(_e.getUniformLocation(this.ssaoProgram,"bias"),.03*Math.sqrt(this.camera.modelSize)),_e.uniformMatrix4fv(_e.getUniformLocation(this.ssaoProgram,"proj"),!1,this.camera.projection.elements),_e.uniformMatrix4fv(_e.getUniformLocation(this.ssaoProgram,"view"),!1,this.camera.matrixWorldInvert.elements),_e.uniformMatrix4fv(_e.getUniformLocation(this.ssaoProgram,"projI"),!1,(new r).setInverseOf(this.camera.projection).elements),_e.uniform3fv(_e.getUniformLocation(this.ssaoProgram,"kernels"),this.kernels),_e.viewport(0,0,this.width/this.scale,this.height/this.scale),_e.drawArrays(_e.TRIANGLE_STRIP,0,4),_e.framebufferTexture2D(_e.FRAMEBUFFER,_e.COLOR_ATTACHMENT0,_e.TEXTURE_2D,this.ssaoBlurTexture,0),_e.clear(_e.COLOR_BUFFER_BIT|_e.DEPTH_BUFFER_BIT),_e.useProgram(this.ssaoBlurProgram),_e.uniform1i(_e.getUniformLocation(this.ssaoBlurProgram,"uTexture"),this.ssaoTexture.index),_e.uniform2f(_e.getUniformLocation(this.ssaoBlurProgram,"denom"),1,0),_e.drawArrays(_e.TRIANGLE_STRIP,0,4),_e.framebufferTexture2D(_e.FRAMEBUFFER,_e.COLOR_ATTACHMENT0,_e.TEXTURE_2D,this.ssaoTexture,0),_e.uniform1i(_e.getUniformLocation(this.ssaoBlurProgram,"uTexture"),this.ssaoBlurTexture.index),_e.uniform2f(_e.getUniformLocation(this.ssaoBlurProgram,"denom"),0,1),_e.drawArrays(_e.TRIANGLE_STRIP,0,4),_e.bindFramebuffer(_e.FRAMEBUFFER,null),_e.viewport(0,0,this.width,this.height)}buildScreenBuffer(e){return this.framebuffer=_e.createFramebuffer(),_e.bindFramebuffer(_e.FRAMEBUFFER,this.framebuffer),this.ssaoTexture=e.createOneChannelTexture(this.scale),this.ssaoBlurTexture=e.createOneChannelTexture(this.scale),_e.framebufferTexture2D(_e.FRAMEBUFFER,_e.COLOR_ATTACHMENT0,_e.TEXTURE_2D,this.ssaoTexture,0),this.ssaoProgram=S(re,"#version 300 es\nprecision highp float;\n\nin vec2 uv;\nout float color;\n\nconst int kernelSize = 32;\nconst float power = 5.0;\n\nuniform sampler2D normBuff;\nuniform sampler2D depthBuff;\nuniform sampler2D noice;\nuniform vec2 noiseScale;\nuniform vec3 kernels[kernelSize];\nuniform mat4 proj;\nuniform mat4 projI;\nuniform mat4 view;\nuniform float zFar;\nuniform float zNear;\nuniform float bias;\n\nvec3 getPositionFromDepth(float depth) {\n\tvec4 clipSpaceLocation = vec4(0.0);\n\tclipSpaceLocation.xy = uv * 2.0 - 1.0;\n\tclipSpaceLocation.z = depth * 2.0 - 1.0;;\n\tclipSpaceLocation.w = 1.0;\n\tvec4 homogenousLocation = projI * clipSpaceLocation;\n\thomogenousLocation.xyz = homogenousLocation.xyz / homogenousLocation.w;\n\treturn homogenousLocation.xyz;\n}\n\nvoid main() {\n\tfloat depth = texture(depthBuff, uv).x;\n\tif ((2.0 * zNear) / (zFar + zNear - depth * (zFar - zNear)) > 0.99) {\n\t\tdiscard;\n\t}\n\n\tfloat radius = bias * 2.0;\n\tvec3 pos = getPositionFromDepth(depth);\n\tvec3 normal = normalize(vec3(view * texture(normBuff, uv)));\n\tvec3 rvec = normalize(texture(noice, uv * noiseScale).xyz);\n\n\tvec3 tangent = normalize(rvec - normal * dot(rvec, normal));\n\tvec3 bitangent = cross(tangent, normal);\n\tmat3 rotate = mat3(tangent, bitangent, normal);\n\n\tfloat occlusion  = 0.0;\n\tfor (int i = 0; i < kernelSize; i++) {\n\t\tvec3 samplePos = rotate * kernels[i];\n\t\tsamplePos = pos + samplePos * radius;\n\n\t\tvec4 shift = proj * vec4(samplePos, 1.0);\n\t\tshift.xy /= shift.w;\n\t\tshift.xy = shift.xy * 0.5 + 0.5;\n\n\t\tfloat sampleDepth = getPositionFromDepth(texture(depthBuff, shift.xy).r).z;\n\n\t\tfloat distanceCheck = smoothstep(0.0, 1.0, radius / abs(pos.z - sampleDepth));\n\t\tocclusion  += (sampleDepth >= samplePos.z + bias ? 1.0 : 0.0) * distanceCheck;\n\t}\n\n\tocclusion = 1.0 - (occlusion / float(kernelSize));\n\tcolor = pow(occlusion, power);\n}\n"),this.ssaoBlurProgram=S(re,xe),this.buildNoice(e),this.buildKernels(),_e.bindFramebuffer(_e.FRAMEBUFFER,null),{name:"SSAO"}}buildNoice(e){const r=new Float32Array(48);for(let e=0;e<16;e++){const t=new n([2*E(0,1)-1,2*E(0,1)-1,.1]);r[3*e]=t.elements[0],r[3*e+1]=t.elements[1],r[3*e+2]=t.elements[2]}this.noice=e.createNoiceTexture(4,r)}buildKernels(){const e=new Array(32);for(let r=0;r<e.length;r++){e[r]=new n([2*E(0,1)-1,2*E(0,1)-1,E(0,1)]),e[r].normalize(),e[r].scale(E(0,1));let t=r/e.length;t=p(.1,1,t*t),e[r].scale(t)}this.kernels=new Float32Array(3*e.length);let r=0;for(const t of e)this.kernels.set(t.elements,3*r),r++}preProcessing(){}},shadow:class extends k{setGL(e){ge=e}preProcessing(e){ge.clear(ge.COLOR_BUFFER_BIT|ge.DEPTH_BUFFER_BIT),e.renderScene({isprepender:!0})}buildScreenBuffer(){return{name:"SHADOW"}}attachUniform(){}postProcessing(){}},light:q,refraction:Fe,scattering:class extends k{output;program;pipeline;bindGroup;setGL(e){Se=e}attachUniform(e){Se.uniform1i(Se.getUniformLocation(e,"scattering"),this.output.index)}attachUniformWebGPU(){return{binding:8,resource:this.output.view}}postProcessing(e){Se.bindFramebuffer(Se.FRAMEBUFFER,this.framebuffer),Se.useProgram(this.program),Se.framebufferTexture2D(Se.FRAMEBUFFER,Se.COLOR_ATTACHMENT0,Se.TEXTURE_2D,this.output,0),Se.uniform1i(Se.getUniformLocation(this.program,"textureSampler"),e.screenTexture.index),Se.uniform1i(Se.getUniformLocation(this.program,"depthSampler"),e.depthTexture.index),Se.uniform1i(Se.getUniformLocation(this.program,"albedoSampler"),e.albedoTexture.index),Se.uniform1i(Se.getUniformLocation(this.program,"irradianceSampler"),e.irradianceTexture.index),Se.drawArrays(Se.TRIANGLE_STRIP,0,4)}postProcessingWebGPU(e){const{device:r}=Se,t=r.createCommandEncoder(),n=t.beginRenderPass({colorAttachments:[{view:this.output.view,storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1}}]});n.setPipeline(this.pipeline),n.setVertexBuffer(0,e.vertexBuffer),n.setBindGroup(0,this.bindGroup),n.draw(6),n.end(),r.queue.submit([t.finish()])}buildScreenBuffer(e){return this.framebuffer=Se.createFramebuffer(),Se.bindFramebuffer(Se.FRAMEBUFFER,this.framebuffer),this.output=e.createByteTexture(),Se.bindFramebuffer(Se.FRAMEBUFFER,null),this.program=S(re,"#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\nout vec4 color;\r\n\r\n#define rcp(x) 1./x\r\n#define GOLDEN_RATIO 1.618033988749895\r\n#define TWO_PI 6.2831855\r\nvec2 Golden2dSeq(int i, float n) {\r\n    return vec2(float(i) / n + (0.5f / n), fract(float(i) * rcp(GOLDEN_RATIO)));\r\n}\r\nvec2 SampleDiskGolden(int i, int sampleCount) {\r\n    vec2 f = Golden2dSeq(i, float(sampleCount));\r\n    return vec2(sqrt(f.x), TWO_PI * f.y);\r\n}\r\nconst float PI = 3.1415926535897932384626433832795f;\r\nconst float RECIPROCAL_PI = 0.3183098861837907f;\r\nconst float RECIPROCAL_PI2 = 0.15915494309189535f;\r\nconst float HALF_MIN = 5.96046448e-08f;\r\nconst float LinearEncodePowerApprox = 2.2f;\r\nconst float GammaEncodePowerApprox = 1.0f / LinearEncodePowerApprox;\r\nconst vec3 LuminanceEncodeApprox = vec3(0.2126f, 0.7152f, 0.0722f);\r\nconst float Epsilon = 0.0000001f;\r\n#define saturate(x) clamp(x, 0.0, 1.0)\r\n#define absEps(x) abs(x)+Epsilon\r\n#define maxEps(x) max(x, Epsilon)\r\n#define saturateEps(x) clamp(x, Epsilon, 1.0)\r\nmat3 transposeMat3(mat3 inMatrix) {\r\n    vec3 i0 = inMatrix[0];\r\n    vec3 i1 = inMatrix[1];\r\n    vec3 i2 = inMatrix[2];\r\n    mat3 outMatrix = mat3(vec3(i0.x, i1.x, i2.x), vec3(i0.y, i1.y, i2.y), vec3(i0.z, i1.z, i2.z));\r\n    return outMatrix;\r\n}\r\nmat3 inverseMat3(mat3 inMatrix) {\r\n    float a00 = inMatrix[0][0], a01 = inMatrix[0][1], a02 = inMatrix[0][2];\r\n    float a10 = inMatrix[1][0], a11 = inMatrix[1][1], a12 = inMatrix[1][2];\r\n    float a20 = inMatrix[2][0], a21 = inMatrix[2][1], a22 = inMatrix[2][2];\r\n    float b01 = a22 * a11 - a12 * a21;\r\n    float b11 = -a22 * a10 + a12 * a20;\r\n    float b21 = a21 * a10 - a11 * a20;\r\n    float det = a00 * b01 + a01 * b11 + a02 * b21;\r\n    return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11), b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10), b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\r\n}\r\nfloat toLinearSpace(float color) {\r\n    return pow(color, LinearEncodePowerApprox);\r\n}\r\nvec3 toLinearSpace(vec3 color) {\r\n    return pow(color, vec3(LinearEncodePowerApprox));\r\n}\r\nvec4 toLinearSpace(vec4 color) {\r\n    return vec4(pow(color.rgb, vec3(LinearEncodePowerApprox)), color.a);\r\n}\r\nfloat toGammaSpace(float color) {\r\n    return pow(color, GammaEncodePowerApprox);\r\n}\r\nvec3 toGammaSpace(vec3 color) {\r\n    return pow(color, vec3(GammaEncodePowerApprox));\r\n}\r\nvec4 toGammaSpace(vec4 color) {\r\n    return vec4(pow(color.rgb, vec3(GammaEncodePowerApprox)), color.a);\r\n}\r\nfloat square(float value) {\r\n    return value * value;\r\n}\r\nvec3 square(vec3 value) {\r\n    return value * value;\r\n}\r\nfloat pow5(float value) {\r\n    float sq = value * value;\r\n    return sq * sq * value;\r\n}\r\nfloat getLuminance(vec3 color) {\r\n    return clamp(dot(color, LuminanceEncodeApprox), 0.f, 1.f);\r\n}\r\nfloat getRand(vec2 seed) {\r\n    return fract(sin(dot(seed.xy, vec2(12.9898f, 78.233f))) * 43758.5453f);\r\n}\r\nfloat dither(vec2 seed, float varianceAmount) {\r\n    float rand = getRand(seed);\r\n    float normVariance = varianceAmount / 255.0f;\r\n    float dither = mix(-normVariance, normVariance, rand);\r\n    return dither;\r\n}\r\nconst float rgbdMaxRange = 255.0f;\r\nvec4 toRGBD(vec3 color) {\r\n    float maxRGB = maxEps(max(color.r, max(color.g, color.b)));\r\n    float D = max(rgbdMaxRange / maxRGB, 1.f);\r\n    D = clamp(floor(D) / 255.0f, 0.f, 1.f);\r\n    vec3 rgb = color.rgb * D;\r\n    rgb = toGammaSpace(rgb);\r\n    return vec4(clamp(rgb, 0.f, 1.f), D);\r\n}\r\nvec3 fromRGBD(vec4 rgbd) {\r\n    rgbd.rgb = toLinearSpace(rgbd.rgb);\r\n    return rgbd.rgb / rgbd.a;\r\n}\r\nvec3 parallaxCorrectNormal(vec3 vertexPos, vec3 origVec, vec3 cubeSize, vec3 cubePos) {\r\n    vec3 invOrigVec = vec3(1.0f, 1.0f, 1.0f) / origVec;\r\n    vec3 halfSize = cubeSize * 0.5f;\r\n    vec3 intersecAtMaxPlane = (cubePos + halfSize - vertexPos) * invOrigVec;\r\n    vec3 intersecAtMinPlane = (cubePos - halfSize - vertexPos) * invOrigVec;\r\n    vec3 largestIntersec = max(intersecAtMaxPlane, intersecAtMinPlane);\r\n    float distance = min(min(largestIntersec.x, largestIntersec.y), largestIntersec.z);\r\n    vec3 intersectPositionWS = vertexPos + origVec * distance;\r\n    return intersectPositionWS - cubePos;\r\n}\r\nbool testLightingForSSS(float diffusionProfile) {\r\n    return diffusionProfile < 1.f;\r\n}\r\n\r\nconst vec3 diffusionS = vec3(1.0);\r\nconst float diffusionD = 1.0;\r\nconst float filterRadii = 16.5644;\r\n\r\nuniform sampler2D textureSampler;\r\nuniform sampler2D irradianceSampler;\r\nuniform sampler2D depthSampler;\r\nuniform sampler2D albedoSampler;\r\nconst float metersPerUnit = 0.1;\r\n\r\nconst float LOG2_E = 1.4426950408889634f;\r\nconst float SSS_PIXELS_PER_SAMPLE = 4.f;\r\nconst int _SssSampleBudget = 40;\r\n#define rcp(x) 1./x\r\n#define Sq(x) x*x\r\n#define SSS_BILATERAL_FILTER true\r\nvec3 EvalBurleyDiffusionProfile(float r, vec3 S) {\r\n    vec3 exp_13 = exp2(((LOG2_E * (-1.0f / 3.0f)) * r) * S);\r\n    vec3 expSum = exp_13 * (1.f + exp_13 * exp_13);\r\n    return (S * rcp(8.f * PI)) * expSum;\r\n}\r\nvec2 SampleBurleyDiffusionProfile(float u, float rcpS) {\r\n    u = 1.f - u;\r\n    float g = 1.f + (4.f * u) * (2.f * u + sqrt(1.f + (4.f * u) * u));\r\n    float n = exp2(log2(g) * (-1.0f / 3.0f));\r\n    float p = (g * n) * n;\r\n    float c = 1.f + p + n;\r\n    float d = (3.f / LOG2_E * 2.f) + (3.f / LOG2_E) * log2(u);\r\n    float x = (3.f / LOG2_E) * log2(c) - d;\r\n    float rcpExp = ((c * c) * c) * rcp((4.f * u) * ((c * c) + (4.f * u) * (4.f * u)));\r\n    float r = x * rcpS;\r\n    float rcpPdf = (8.f * PI * rcpS) * rcpExp;\r\n    return vec2(r, rcpPdf);\r\n}\r\nvec3 ComputeBilateralWeight(float xy2, float z, float mmPerUnit, vec3 S, float rcpPdf) {\r\n    float r = sqrt(xy2 + (z * mmPerUnit) * (z * mmPerUnit));\r\n    float area = rcpPdf;\r\n    return EvalBurleyDiffusionProfile(r, S) * area;\r\n}\r\nvoid EvaluateSample(int i, int n, vec3 S, float d, vec3 centerPosVS, float mmPerUnit, float pixelsPerMm, float phase, inout vec3 totalIrradiance, inout vec3 totalWeight) {\r\n    float scale = rcp(float(n));\r\n    float offset = rcp(float(n)) * 0.5f;\r\n    float sinPhase, cosPhase;\r\n    sinPhase = sin(phase);\r\n    cosPhase = cos(phase);\r\n    vec2 bdp = SampleBurleyDiffusionProfile(float(i) * scale + offset, d);\r\n    float r = bdp.x;\r\n    float rcpPdf = bdp.y;\r\n    float phi = SampleDiskGolden(i, n).y;\r\n    float sinPhi, cosPhi;\r\n    sinPhi = sin(phi);\r\n    cosPhi = cos(phi);\r\n    float sinPsi = cosPhase * sinPhi + sinPhase * cosPhi;\r\n    float cosPsi = cosPhase * cosPhi - sinPhase * sinPhi;\r\n    vec2 vec = r * vec2(cosPsi, sinPsi);\r\n    vec2 position;\r\n    float xy2;\r\n    vec2 texelSize = 1.0 / vec2(textureSize(depthSampler, 0));\r\n    position = uv + round((pixelsPerMm * r) * vec2(cosPsi, sinPsi)) * texelSize;\r\n    xy2 = r * r;\r\n    vec4 textureSample = texture(irradianceSampler, position);\r\n    float viewZ = texture(depthSampler, position).r;\r\n    vec3 irradiance = textureSample.rgb;\r\n    //if(testLightingForSSS(textureSample.a)) {\r\n        float relZ = viewZ - centerPosVS.z;\r\n        vec3 weight = ComputeBilateralWeight(xy2, relZ, mmPerUnit, S, rcpPdf);\r\n        totalIrradiance += weight * irradiance;\r\n        totalWeight += weight;\r\n    // } else {\r\n\r\n    // }\r\n}\r\n\r\nvoid main(void) {\r\n    vec4 irradianceAndDiffusionProfile = texture(irradianceSampler, uv);\r\n    vec3 centerIrradiance = irradianceAndDiffusionProfile.rgb;\r\n    int diffusionProfileIndex = int(round(irradianceAndDiffusionProfile.a * 255.f));\r\n    float centerDepth = 0.f;\r\n    vec4 inputColor = texture(textureSampler, uv);\r\n    bool passedStencilTest = testLightingForSSS(irradianceAndDiffusionProfile.a);\r\n    //if(passedStencilTest) {\r\n        centerDepth = texture(depthSampler, uv).r;\r\n    //}\r\n    if(!passedStencilTest) {\r\n        color = inputColor;\r\n        //return;\r\n    }\r\n    float distScale = 1.f;\r\n    vec3 S = diffusionS;\r\n    float d = diffusionD;\r\n    float filterRadius = filterRadii;\r\n    vec2 centerPosNDC = uv;\r\n    vec2 viewportSize = vec2(0.6520661863788713, 0.5773502691896256);\r\n    vec2 texelSize = 1.0 / vec2(textureSize(depthSampler, 0));\r\n    vec2 cornerPosNDC = uv + 0.5f * texelSize;\r\n    vec3 centerPosVS = vec3(centerPosNDC * viewportSize, 1.0f) * centerDepth;\r\n    vec3 cornerPosVS = vec3(cornerPosNDC * viewportSize, 1.0f) * centerDepth;\r\n    float mmPerUnit = 1000.f * (metersPerUnit * rcp(distScale));\r\n    float unitsPerMm = rcp(mmPerUnit);\r\n    float unitsPerPixel = 2.f * abs(cornerPosVS.x - centerPosVS.x);\r\n    float pixelsPerMm = rcp(unitsPerPixel) * unitsPerMm;\r\n    float filterArea = PI * Sq(filterRadius * pixelsPerMm);\r\n    int sampleCount = int(filterArea * rcp(SSS_PIXELS_PER_SAMPLE));\r\n    int sampleBudget = _SssSampleBudget;\r\n    int texturingMode = 0;\r\n    vec3 albedo = texture(albedoSampler, uv).rgb;\r\n    if(distScale == 0.f || sampleCount < 1) {\r\n        color = vec4(inputColor.rgb + albedo * centerIrradiance, 1.0f);\r\n        //return;\r\n    }\r\n    float phase = 0.f;\r\n    int n = min(sampleCount, sampleBudget);\r\n    vec3 centerWeight = vec3(0.f);\r\n    vec3 totalIrradiance = vec3(0.f);\r\n    vec3 totalWeight = vec3(0.f);\r\n    for(int i = 0; i < n; i++) {\r\n        EvaluateSample(i, n, S, d, centerPosVS, mmPerUnit, pixelsPerMm, phase, totalIrradiance, totalWeight);\r\n    }\r\n    totalWeight = max(totalWeight, HALF_MIN);\r\n    color = vec4(inputColor.rgb + albedo * max(totalIrradiance / totalWeight, vec3(0.0f)), 1.f);\r\n    //color = vec4(inputColor.rgb, 1.f);\r\n}\r\n"),{name:"SCATTERING"}}buildScreenBufferWebGPU(e){const r=[{binding:4,resource:e.depthTexture.sampler},{binding:5,resource:e.screenTexture.sampler},{binding:0,resource:e.screenTexture.view},{binding:1,resource:e.depthTexture.view},{binding:2,resource:e.albedoTexture.view},{binding:3,resource:e.irradianceTexture.view}];return this.pipeline=e.buildPipeline(Se,"#version 460\r\nlayout (location = 0) in vec2 pos;\r\n\r\nlayout (location = 0) out vec2 uv;\r\n\r\nvoid main() {\r\n    uv = pos * 0.5 + 0.5;\r\n    uv.y = 1.0 - uv.y;\r\n    gl_Position = vec4(pos, 0.0, 1.0); \r\n}\r\n","#version 460\r\nprecision highp float;\r\n\r\n#define DISABLE_UNIFORMITY_ANALYSIS\r\n\r\n#extension GL_EXT_samplerless_texture_functions:require\r\n\r\nlayout(location = 0) in vec2 inuv;\r\nlayout(location = 0) out vec4 color;\r\n\r\n#define rcp(x) 1./x\r\n#define GOLDEN_RATIO 1.618033988749895\r\n#define TWO_PI 6.2831855\r\nvec2 Golden2dSeq(int i, float n) {\r\n    return vec2(float(i) / n + (0.5f / n), fract(float(i) * rcp(GOLDEN_RATIO)));\r\n}\r\nvec2 SampleDiskGolden(int i, int sampleCount) {\r\n    vec2 f = Golden2dSeq(i, float(sampleCount));\r\n    return vec2(sqrt(f.x), TWO_PI * f.y);\r\n}\r\nconst float PI = 3.1415926535897932384626433832795f;\r\nconst float RECIPROCAL_PI = 0.3183098861837907f;\r\nconst float RECIPROCAL_PI2 = 0.15915494309189535f;\r\nconst float HALF_MIN = 5.96046448e-08f;\r\nconst float LinearEncodePowerApprox = 2.2f;\r\nconst float GammaEncodePowerApprox = 1.0f / LinearEncodePowerApprox;\r\nconst vec3 LuminanceEncodeApprox = vec3(0.2126f, 0.7152f, 0.0722f);\r\nconst float Epsilon = 0.0000001f;\r\n#define saturate(x) clamp(x, 0.0, 1.0)\r\n#define absEps(x) abs(x)+Epsilon\r\n#define maxEps(x) max(x, Epsilon)\r\n#define saturateEps(x) clamp(x, Epsilon, 1.0)\r\nmat3 transposeMat3(mat3 inMatrix) {\r\n    vec3 i0 = inMatrix[0];\r\n    vec3 i1 = inMatrix[1];\r\n    vec3 i2 = inMatrix[2];\r\n    mat3 outMatrix = mat3(vec3(i0.x, i1.x, i2.x), vec3(i0.y, i1.y, i2.y), vec3(i0.z, i1.z, i2.z));\r\n    return outMatrix;\r\n}\r\nmat3 inverseMat3(mat3 inMatrix) {\r\n    float a00 = inMatrix[0][0], a01 = inMatrix[0][1], a02 = inMatrix[0][2];\r\n    float a10 = inMatrix[1][0], a11 = inMatrix[1][1], a12 = inMatrix[1][2];\r\n    float a20 = inMatrix[2][0], a21 = inMatrix[2][1], a22 = inMatrix[2][2];\r\n    float b01 = a22 * a11 - a12 * a21;\r\n    float b11 = -a22 * a10 + a12 * a20;\r\n    float b21 = a21 * a10 - a11 * a20;\r\n    float det = a00 * b01 + a01 * b11 + a02 * b21;\r\n    return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11), b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10), b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\r\n}\r\nfloat toLinearSpace(float color) {\r\n    return pow(color, LinearEncodePowerApprox);\r\n}\r\nvec3 toLinearSpace(vec3 color) {\r\n    return pow(color, vec3(LinearEncodePowerApprox));\r\n}\r\nvec4 toLinearSpace(vec4 color) {\r\n    return vec4(pow(color.rgb, vec3(LinearEncodePowerApprox)), color.a);\r\n}\r\nfloat toGammaSpace(float color) {\r\n    return pow(color, GammaEncodePowerApprox);\r\n}\r\nvec3 toGammaSpace(vec3 color) {\r\n    return pow(color, vec3(GammaEncodePowerApprox));\r\n}\r\nvec4 toGammaSpace(vec4 color) {\r\n    return vec4(pow(color.rgb, vec3(GammaEncodePowerApprox)), color.a);\r\n}\r\nfloat square(float value) {\r\n    return value * value;\r\n}\r\nvec3 square(vec3 value) {\r\n    return value * value;\r\n}\r\nfloat pow5(float value) {\r\n    float sq = value * value;\r\n    return sq * sq * value;\r\n}\r\nfloat getLuminance(vec3 color) {\r\n    return clamp(dot(color, LuminanceEncodeApprox), 0.f, 1.f);\r\n}\r\nfloat getRand(vec2 seed) {\r\n    return fract(sin(dot(seed.xy, vec2(12.9898f, 78.233f))) * 43758.5453f);\r\n}\r\nfloat dither(vec2 seed, float varianceAmount) {\r\n    float rand = getRand(seed);\r\n    float normVariance = varianceAmount / 255.0f;\r\n    float dither = mix(-normVariance, normVariance, rand);\r\n    return dither;\r\n}\r\nconst float rgbdMaxRange = 255.0f;\r\nvec4 toRGBD(vec3 color) {\r\n    float maxRGB = maxEps(max(color.r, max(color.g, color.b)));\r\n    float D = max(rgbdMaxRange / maxRGB, 1.f);\r\n    D = clamp(floor(D) / 255.0f, 0.f, 1.f);\r\n    vec3 rgb = color.rgb * D;\r\n    rgb = toGammaSpace(rgb);\r\n    return vec4(clamp(rgb, 0.f, 1.f), D);\r\n}\r\nvec3 fromRGBD(vec4 rgbd) {\r\n    rgbd.rgb = toLinearSpace(rgbd.rgb);\r\n    return rgbd.rgb / rgbd.a;\r\n}\r\nvec3 parallaxCorrectNormal(vec3 vertexPos, vec3 origVec, vec3 cubeSize, vec3 cubePos) {\r\n    vec3 invOrigVec = vec3(1.0f, 1.0f, 1.0f) / origVec;\r\n    vec3 halfSize = cubeSize * 0.5f;\r\n    vec3 intersecAtMaxPlane = (cubePos + halfSize - vertexPos) * invOrigVec;\r\n    vec3 intersecAtMinPlane = (cubePos - halfSize - vertexPos) * invOrigVec;\r\n    vec3 largestIntersec = max(intersecAtMaxPlane, intersecAtMinPlane);\r\n    float distance = min(min(largestIntersec.x, largestIntersec.y), largestIntersec.z);\r\n    vec3 intersectPositionWS = vertexPos + origVec * distance;\r\n    return intersectPositionWS - cubePos;\r\n}\r\nbool testLightingForSSS(float diffusionProfile) {\r\n    return diffusionProfile < 1.f;\r\n}\r\n\r\nconst vec3 diffusionS = vec3(1.0);\r\nconst float diffusionD = 1.0;\r\nconst float filterRadii = 16.5644;\r\n\r\nlayout(set = 0, binding = 0) uniform texture2D textureSampler;\r\nlayout(set = 0, binding = 3) uniform texture2D irradianceSampler;\r\nlayout(set = 0, binding = 1) uniform texture2D depthSampler;\r\nlayout(set = 0, binding = 2) uniform texture2D albedoSampler;\r\nlayout(set = 0, binding = 4) uniform sampler baseSampler2;\r\nlayout(set = 0, binding = 5) uniform sampler baseSampler;\r\nconst float metersPerUnit = 0.1;\r\n\r\nconst float LOG2_E = 1.4426950408889634f;\r\nconst float SSS_PIXELS_PER_SAMPLE = 4.f;\r\nconst int _SssSampleBudget = 40;\r\n#define rcp(x) 1./x\r\n#define Sq(x) x*x\r\n#define SSS_BILATERAL_FILTER true\r\nvec3 EvalBurleyDiffusionProfile(float r, vec3 S) {\r\n    vec3 exp_13 = exp2(((LOG2_E * (-1.0f / 3.0f)) * r) * S);\r\n    vec3 expSum = exp_13 * (1.f + exp_13 * exp_13);\r\n    return (S * rcp(8.f * PI)) * expSum;\r\n}\r\nvec2 SampleBurleyDiffusionProfile(float u, float rcpS) {\r\n    u = 1.f - u;\r\n    float g = 1.f + (4.f * u) * (2.f * u + sqrt(1.f + (4.f * u) * u));\r\n    float n = exp2(log2(g) * (-1.0f / 3.0f));\r\n    float p = (g * n) * n;\r\n    float c = 1.f + p + n;\r\n    float d = (3.f / LOG2_E * 2.f) + (3.f / LOG2_E) * log2(u);\r\n    float x = (3.f / LOG2_E) * log2(c) - d;\r\n    float rcpExp = ((c * c) * c) * rcp((4.f * u) * ((c * c) + (4.f * u) * (4.f * u)));\r\n    float r = x * rcpS;\r\n    float rcpPdf = (8.f * PI * rcpS) * rcpExp;\r\n    return vec2(r, rcpPdf);\r\n}\r\nvec3 ComputeBilateralWeight(float xy2, float z, float mmPerUnit, vec3 S, float rcpPdf) {\r\n    float r = sqrt(xy2 + (z * mmPerUnit) * (z * mmPerUnit));\r\n    float area = rcpPdf;\r\n    return EvalBurleyDiffusionProfile(r, S) * area;\r\n}\r\n\r\nvoid main(void) {\r\n    vec2 uv = inuv;\r\n    uv.y = 1.0 - inuv.y;\r\n    vec4 irradianceAndDiffusionProfile = texture(sampler2D(irradianceSampler, baseSampler), uv);\r\n    vec3 centerIrradiance = irradianceAndDiffusionProfile.rgb;\r\n    int diffusionProfileIndex = int(round(irradianceAndDiffusionProfile.a * 255.f));\r\n    float centerDepth = 0.f;\r\n    vec4 inputColor = texture(sampler2D(textureSampler, baseSampler), uv);\r\n    bool passedStencilTest = testLightingForSSS(irradianceAndDiffusionProfile.a);\r\n    //if(passedStencilTest) {\r\n        centerDepth = texture(sampler2D(depthSampler, baseSampler2), uv).x;\r\n    //}\r\n    if(!passedStencilTest) {\r\n        color = inputColor;\r\n        //return;\r\n    }\r\n    float distScale = 1.f;\r\n    vec3 S = diffusionS;\r\n    float d = diffusionD;\r\n    float filterRadius = filterRadii;\r\n    vec2 centerPosNDC = uv;\r\n    vec2 viewportSize = vec2(0.6520661863788713, 0.5773502691896256);\r\n    vec2 texelSize = 1.0 / vec2(textureSize(depthSampler, 0));\r\n    vec2 cornerPosNDC = uv + 0.5f * texelSize;\r\n    vec3 centerPosVS = vec3(centerPosNDC * viewportSize, 1.0f) * centerDepth;\r\n    vec3 cornerPosVS = vec3(cornerPosNDC * viewportSize, 1.0f) * centerDepth;\r\n    float mmPerUnit = 1000.f * (metersPerUnit * rcp(distScale));\r\n    float unitsPerMm = rcp(mmPerUnit);\r\n    float unitsPerPixel = 2.f * abs(cornerPosVS.x - centerPosVS.x);\r\n    float pixelsPerMm = rcp(unitsPerPixel) * unitsPerMm;\r\n    float filterArea = PI * Sq(filterRadius * pixelsPerMm);\r\n    int sampleCount = int(filterArea * rcp(SSS_PIXELS_PER_SAMPLE));\r\n    int sampleBudget = _SssSampleBudget;\r\n    int texturingMode = 0;\r\n    vec3 albedo = texture(sampler2D(albedoSampler, baseSampler), uv).rgb;\r\n    if(distScale == 0.f || sampleCount < 1) {\r\n        color = vec4(inputColor.rgb + albedo * centerIrradiance, 1.0f);\r\n        //return;\r\n    }\r\n    float phase = 0.f;\r\n    int n = min(sampleCount, sampleBudget);\r\n    vec3 centerWeight = vec3(0.f);\r\n    vec3 totalIrradiance = vec3(0.f);\r\n    vec3 totalWeight = vec3(0.f);\r\n    for(int i = 0; i < n; i++) {\r\n        float scale = rcp(float(n));\r\n        float offset = rcp(float(n)) * 0.5f;\r\n        float sinPhase, cosPhase;\r\n        sinPhase = sin(phase);\r\n        cosPhase = cos(phase);\r\n        vec2 bdp = SampleBurleyDiffusionProfile(float(i) * scale + offset, d);\r\n        float r = bdp.x;\r\n        float rcpPdf = bdp.y;\r\n        float phi = SampleDiskGolden(i, n).y;\r\n        float sinPhi, cosPhi;\r\n        sinPhi = sin(phi);\r\n        cosPhi = cos(phi);\r\n        float sinPsi = cosPhase * sinPhi + sinPhase * cosPhi;\r\n        float cosPsi = cosPhase * cosPhi - sinPhase * sinPhi;\r\n        vec2 vec = r * vec2(cosPsi, sinPsi);\r\n        vec2 position;\r\n        float xy2;\r\n        vec2 texelSize = 1.0 / vec2(textureSize(depthSampler, 0));\r\n        position = uv + round((pixelsPerMm * r) * vec2(cosPsi, sinPsi)) * texelSize;\r\n        xy2 = r * r;\r\n        vec3 irradiance = texture(sampler2D(irradianceSampler, baseSampler), position).rgb;\r\n        float viewZ = texture(sampler2D(depthSampler, baseSampler2), position).r;\r\n        //if(testLightingForSSS(textureSample.a)) {\r\n            float relZ = viewZ - centerPosVS.z;\r\n            vec3 weight = ComputeBilateralWeight(xy2, relZ, mmPerUnit, S, rcpPdf);\r\n            totalIrradiance += weight * irradiance;\r\n            totalWeight += weight;\r\n        // } else {\r\n\r\n        // }\r\n    }\r\n    totalWeight = max(totalWeight, HALF_MIN);\r\n    color = vec4(inputColor.rgb + albedo * max(totalIrradiance / totalWeight, vec3(0.0f)), 1.f);\r\n    //color = vec4(inputColor.rgb, 1.f);\r\n}\r\n",2,[{binding:4,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"non-filtering"}},{binding:5,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"unfilterable-float"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:3,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{}}],!1,"scaterring"),this.bindGroup=Se.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:r}),this.output=e.createDefaultTexture(),{name:"SCATTERING"}}preProcessing(){}preProcessingWebGPU(){}}};class Me{screenTexture;normalTexture;irradianceTexture;specTexture;albedoTexture;depthTexture;preDepthTexture;fakeDepth;camera;renderer;canvas;framebuffer;preframebuffer;postprocessors;VAO;program;renderframebuffer;MSAA;renderScene;hasPostPass=!1;hasPrePass=!1;constructor(e,r){this.renderScene=r,this.postprocessors=e.map(e=>new Ue[e])}add(e){const r=new Ue[e];r.setGL(be),this.postprocessors.push(r),this.hasPostPass=!0}addPrepass(e){const r=new Ue[e];r.setGL(be),this.postprocessors.push(r),this.hasPrePass=!0}setCamera(e){this.camera=e,this.postprocessors.forEach(r=>{r.setCamera(e)})}setLight(e){this.postprocessors.forEach(r=>{r.light=e})}setGl(e){e&&(be=e,this.MSAA=be.getParameter(be.MAX_SAMPLES),this.postprocessors.forEach(e=>{e.setGL(be)}),this.fakeDepth=this.createNoiceTexture(1,new Float32Array([1,1,0])))}setCanvas(e){this.canvas=e,this.postprocessors.forEach(r=>{r.setCanvas(e)})}get width(){return this.canvas.offsetWidth*devicePixelRatio}get height(){return this.canvas.offsetHeight*devicePixelRatio}bindPrePass(){be.bindFramebuffer(be.FRAMEBUFFER,this.preframebuffer)}bindPostPass(){be.bindFramebuffer(be.FRAMEBUFFER,this.framebuffer)}preProcessing(){this.postprocessors.forEach(e=>e.preProcessing(this))}postProcessing(){be.bindVertexArray(this.VAO),this.postprocessors.forEach(e=>e.postProcessing(this)),be.bindFramebuffer(be.FRAMEBUFFER,null),be.useProgram(this.program),this.postprocessors.forEach(e=>{e.attachUniform(this.program)}),be.uniform1i(be.getUniformLocation(this.program,"original"),this.screenTexture.index),be.uniform1i(be.getUniformLocation(this.program,"normal"),this.normalTexture.index),be.uniform1i(be.getUniformLocation(this.program,"depth"),this.depthTexture.index),be.uniform1i(be.getUniformLocation(this.program,"preDepth"),this.preDepthTexture.index),be.uniform1i(be.getUniformLocation(this.program,"spec"),this.specTexture.index),be.drawArrays(be.TRIANGLE_STRIP,0,4)}createByteTexture(){const e=b();return be.texParameteri(be.TEXTURE_2D,be.TEXTURE_MAG_FILTER,be.NEAREST),be.texParameteri(be.TEXTURE_2D,be.TEXTURE_MIN_FILTER,be.NEAREST),be.texImage2D(be.TEXTURE_2D,0,be.RGBA,this.width,this.height,0,be.RGBA,be.UNSIGNED_BYTE,null),e}createDefaultTexture(e=1,r=!1){const t=b();return be.texParameteri(be.TEXTURE_2D,be.TEXTURE_MAG_FILTER,be.LINEAR),r?be.texParameteri(be.TEXTURE_2D,be.TEXTURE_MIN_FILTER,be.LINEAR_MIPMAP_LINEAR):be.texParameteri(be.TEXTURE_2D,be.TEXTURE_MIN_FILTER,be.LINEAR),be.texImage2D(be.TEXTURE_2D,0,be.RGBA,this.width/e,this.height/e,0,be.RGBA,be.UNSIGNED_BYTE,null),t}createOneChannelTexture(e=1){const r=b();return be.texParameteri(be.TEXTURE_2D,be.TEXTURE_MAG_FILTER,be.LINEAR),be.texParameteri(be.TEXTURE_2D,be.TEXTURE_MIN_FILTER,be.LINEAR),be.texImage2D(be.TEXTURE_2D,0,be.R8,this.width/e,this.height/e,0,be.RED,be.UNSIGNED_BYTE,null),r}createDepthTexture(){const e=b();return be.texParameteri(be.TEXTURE_2D,be.TEXTURE_MAG_FILTER,be.NEAREST),be.texParameteri(be.TEXTURE_2D,be.TEXTURE_MIN_FILTER,be.NEAREST),be.texImage2D(be.TEXTURE_2D,0,be.DEPTH_COMPONENT24,this.width,this.height,0,be.DEPTH_COMPONENT,be.UNSIGNED_INT,null),e}createNoiceTexture(e,r){const t=b();return be.texParameteri(be.TEXTURE_2D,be.TEXTURE_MAG_FILTER,be.NEAREST),be.texParameteri(be.TEXTURE_2D,be.TEXTURE_MIN_FILTER,be.NEAREST),be.texParameteri(be.TEXTURE_2D,be.TEXTURE_WRAP_S,be.REPEAT),be.texParameteri(be.TEXTURE_2D,be.TEXTURE_WRAP_T,be.REPEAT),be.texImage2D(be.TEXTURE_2D,0,be.RGB16F,e,e,0,be.RGB,be.FLOAT,r),t}buildScreenBuffer(){if(0===this.postprocessors.length)return!0;this.VAO=be.createVertexArray(),be.bindVertexArray(this.VAO);const e=be.createBuffer();be.bindBuffer(be.ARRAY_BUFFER,e),be.bufferData(be.ARRAY_BUFFER,new Float32Array(j),be.STATIC_DRAW),be.enableVertexAttribArray(0),be.vertexAttribPointer(0,2,be.FLOAT,!1,0,0),be.bindVertexArray(null),this.framebuffer=be.createFramebuffer(),be.bindFramebuffer(be.FRAMEBUFFER,this.framebuffer),this.screenTexture=this.createDefaultTexture(),this.normalTexture=this.createDefaultTexture(),this.irradianceTexture=this.createDefaultTexture(),this.specTexture=this.createDefaultTexture(),this.albedoTexture=this.createDefaultTexture(),this.depthTexture=this.createDepthTexture(),be.framebufferTexture2D(be.FRAMEBUFFER,be.COLOR_ATTACHMENT0,be.TEXTURE_2D,this.screenTexture,0),be.framebufferTexture2D(be.FRAMEBUFFER,be.COLOR_ATTACHMENT1,be.TEXTURE_2D,this.normalTexture,0),be.framebufferTexture2D(be.FRAMEBUFFER,be.COLOR_ATTACHMENT2,be.TEXTURE_2D,this.irradianceTexture,0),be.framebufferTexture2D(be.FRAMEBUFFER,be.COLOR_ATTACHMENT3,be.TEXTURE_2D,this.albedoTexture,0),be.framebufferTexture2D(be.FRAMEBUFFER,be.COLOR_ATTACHMENT4,be.TEXTURE_2D,this.specTexture,0),be.framebufferTexture2D(be.FRAMEBUFFER,be.DEPTH_ATTACHMENT,be.TEXTURE_2D,this.depthTexture,0),be.drawBuffers([be.COLOR_ATTACHMENT0,be.COLOR_ATTACHMENT1,be.COLOR_ATTACHMENT2,be.COLOR_ATTACHMENT3,be.COLOR_ATTACHMENT4]),be.bindFramebuffer(be.FRAMEBUFFER,null),this.preframebuffer=be.createFramebuffer(),be.bindFramebuffer(be.FRAMEBUFFER,this.preframebuffer),this.preDepthTexture=this.createDepthTexture(),be.framebufferTexture2D(be.FRAMEBUFFER,be.DEPTH_ATTACHMENT,be.TEXTURE_2D,this.preDepthTexture,0),be.bindFramebuffer(be.FRAMEBUFFER,null);const r=this.postprocessors.map(e=>e.buildScreenBuffer(this)).map(e=>`#define ${e.name} ${e.value??1}\n`).join("");this.program=S(re.replace(/\n/,`\n${r}`),"#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\nout vec4 color;\r\n\r\nuniform sampler2D original;\r\nuniform sampler2D position;\r\nuniform sampler2D normal;\r\nuniform sampler2D ssao;\r\nuniform sampler2D bloom;\r\nuniform sampler2D depth;\r\nuniform sampler2D preDepth;\r\nuniform sampler2D light;\r\nuniform sampler2D scattering;\r\nuniform sampler2D spec;\r\n\r\nconst float gamma = 2.2;\r\n\r\nvoid main() {\r\n    vec3 c = texture(original, uv).rgb;\r\n    #ifdef BLOOM\r\n        c += texture(bloom, uv).rgb;\r\n    #endif\r\n    #ifdef SSAO\r\n        c *= texture(ssao, uv).r;\r\n    #endif\r\n    #ifdef LIGHT\r\n        c += texture(light, uv).r;\r\n    #endif\r\n    #ifdef SCATTERING\r\n        c = texture(scattering, uv).rgb;\r\n        c += texture(spec, uv).rgb;\r\n    #endif\r\n\r\n    c.rgb = c.rgb / (c.rgb + vec3(1.0));\r\n    c.rgb = pow(c.rgb, vec3(1.0 / gamma));\r\n\r\n    color = vec4(c, 1.0);\r\n}\r\n".replace(/\n/,`\n${r}`))}clear(){console.error("implement")}}function Ie(e,r,t){this.x=e,this.y=r,this.z=t}Ie.prototype.dot2=function(e,r){return this.x*e+this.y*r},Ie.prototype.dot3=function(e,r,t){return this.x*e+this.y*r+this.z*t};var Ne=[new Ie(1,1,0),new Ie(-1,1,0),new Ie(1,-1,0),new Ie(-1,-1,0),new Ie(1,0,1),new Ie(-1,0,1),new Ie(1,0,-1),new Ie(-1,0,-1),new Ie(0,1,1),new Ie(0,-1,1),new Ie(0,1,-1),new Ie(0,-1,-1)],Pe=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],Oe=new Array(512),Ce=new Array(512);function Le(e){return e*e*e*(e*(6*e-15)+10)}function Be(e,r,t){return(1-t)*e+t*r}function ye(e,r,t){var n=Math.floor(e),i=Math.floor(r),s=Math.floor(t);e-=n,r-=i,t-=s;var o=Ce[(n&=255)+Oe[(i&=255)+Oe[s&=255]]].dot3(e,r,t),a=Ce[n+Oe[i+Oe[s+1]]].dot3(e,r,t-1),c=Ce[n+Oe[i+1+Oe[s]]].dot3(e,r-1,t),l=Ce[n+Oe[i+1+Oe[s+1]]].dot3(e,r-1,t-1),u=Ce[n+1+Oe[i+Oe[s]]].dot3(e-1,r,t),f=Ce[n+1+Oe[i+Oe[s+1]]].dot3(e-1,r,t-1),h=Ce[n+1+Oe[i+1+Oe[s]]].dot3(e-1,r-1,t),m=Ce[n+1+Oe[i+1+Oe[s+1]]].dot3(e-1,r-1,t-1),T=Le(e),d=Le(r),E=Le(t);return Be(Be(Be(o,u,T),Be(a,f,T),E),Be(Be(c,h,T),Be(l,m,T),E),d)}let De;!function(e){e>0&&e<1&&(e*=65536),(e=Math.floor(e))<256&&(e|=e<<8);for(var r=0;r<256;r++){var t;t=1&r?Pe[r]^255&e:Pe[r]^e>>8&255,Oe[r]=Oe[r+256]=t,Ce[r]=Ce[r+256]=Ne[t%12]}}(0),Math.sqrt(3),Math.sqrt(3);const we=1e3;class Ge{currentSourceIdx;program;program2;VAO;TFO;texture3d;camera;getLight;constructor(e){this.getLight=e}setGl(e){De=e}setCamera(e){this.camera=e}build(){this.currentSourceIdx=0;const e=De.createProgram();v(De.VERTEX_SHADER,"#version 300 es\r\nprecision highp float;\r\nprecision highp sampler3D;\r\n\r\nlayout(location = 0) in vec3 a_position;\r\nlayout(location = 1) in vec3 a_velocity;\r\nlayout(location = 2) in float a_spawntime;\r\nlayout(location = 3) in float a_lifetime;\r\n\r\nout vec3 v_position;\r\nout vec3 v_velocity;\r\nout float v_spawntime;\r\nout float v_lifetime;\r\n\r\nuniform float u_time;\r\nuniform sampler3D noize;\r\nuniform float count;\r\n\r\nfloat rand(vec3 co) {\r\n    return texture(noize, co).r;\r\n}\r\n\r\nvec3 snoiseVec3( vec3 x ) {\r\n  float s  = rand(vec3( x ));\r\n  float s1 = rand(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\r\n  float s2 = rand(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\r\n  vec3 c = vec3( s , s1 , s2 );\r\n  return c;\r\n}\r\n\r\nvec3 curlNoise( vec3 p ) {\r\n  const float e = .1;\r\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\r\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\r\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\r\n\r\n  vec3 p_x0 = snoiseVec3( p - dx );\r\n  vec3 p_x1 = snoiseVec3( p + dx );\r\n  vec3 p_y0 = snoiseVec3( p - dy );\r\n  vec3 p_y1 = snoiseVec3( p + dy );\r\n  vec3 p_z0 = snoiseVec3( p - dz );\r\n  vec3 p_z1 = snoiseVec3( p + dz );\r\n\r\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\r\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\r\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\r\n\r\n  const float divisor = 1.0 / ( 2.0 * e );\r\n  return normalize( vec3( x , y , z ) * divisor );\r\n}\r\n\r\nconst float lifetime = 15000.0;\r\nconst vec3 center = vec3(0.5, 0.5, 0.5);\r\nfloat acceleration = 2.0;\r\n\r\nvoid main() {\r\n    if (a_spawntime == 0.0 || (u_time - a_spawntime) > a_lifetime) {\r\n        float x = float(gl_InstanceID) / count;\r\n        float t = u_time/1000.0 * x;\r\n        v_position = center - vec3(\r\n            rand(vec3(x, x, t)),\r\n            rand(vec3(1.0 - x, 1.0 - x, t)),\r\n            rand(vec3(x, 0.5, t))\r\n        );\r\n        v_velocity = center- vec3(\r\n            rand(vec3(x, x, t)),\r\n            rand(vec3(1.0 - x, 1.0 - x, t)),\r\n            rand(vec3(x, 0.5, t))\r\n        );\r\n        v_spawntime = u_time;\r\n        v_lifetime = rand(vec3(x, 0.5, t)) * lifetime;\r\n    } else {\r\n        vec3 curlVelocity = curlNoise(a_position) - a_velocity;\r\n        v_velocity = a_velocity + 0.01 * curlVelocity;\r\n        v_position = a_position + 0.01 * v_velocity * acceleration;\r\n        v_spawntime = a_spawntime;\r\n        v_lifetime = a_lifetime;\r\n    }\r\n}\r\n",e),v(De.FRAGMENT_SHADER,"#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) out vec4 color;\r\n\r\nvoid main() {\r\n    color = vec4(1.0, 1.0, 1.0, 1.0);\r\n}\r\n",e),De.transformFeedbackVaryings(e,["v_position","v_velocity","v_spawntime","v_lifetime"],De.SEPARATE_ATTRIBS),De.linkProgram(e),this.program=e;const r=S("#version 300 es\r\nprecision highp float;\r\nprecision highp sampler3D;\r\n\r\nlayout(location = 0) in vec3 a_position;\r\nlayout(location = 1) in vec3 a_velocity;\r\nlayout(location = 2) in float a_spawntime;\r\nlayout(location = 3) in float a_lifetime;\r\nout float depth;\r\n\r\nuniform sampler2D light;\r\nuniform mat4 MVPMatrix;\r\nuniform float u_time;\r\n\r\nout float alpha;\r\n\r\nvoid main() {\r\n    gl_PointSize = 2.0;\r\n    vec4 point = vec4(a_position, 1.0);\r\n    vec2 uv = (point.xy / point.w) * 0.5 + 0.5;\r\n    float life = a_lifetime - (u_time - a_spawntime);\r\n    alpha = 1.0;\r\n    if (life < 1000.0) {\r\n        alpha = life / 1000.0;\r\n    }\r\n    depth = texture(light, uv).r;\r\n    gl_Position = point;\r\n}\r\n","#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) out vec4 color;\r\nin float depth;\r\nin float alpha;\r\n\r\nvoid main() {\r\n    //color = vec4(0.0, 0.0, 0.8, 1.0) * texture( image, gl_PointCoord );\r\n    if (depth < 0.05) {\r\n        discard;\r\n    }\r\n    color = vec4(1.0, 1.0, 1.0, alpha);\r\n}\r\n");this.program2=r;const t=[De.createVertexArray(),De.createVertexArray()],n=[De.createTransformFeedback(),De.createTransformFeedback()];this.VAO=t,this.TFO=n;for(const e of[0,1]){De.bindVertexArray(t[e]);const r=[];{const e=new Float32Array(3e3);for(let r=0;r<we;r++)e[3*r]=0,e[3*r+1]=0,e[3*r+2]=0;const t=De.createBuffer();De.bindBuffer(De.ARRAY_BUFFER,t),De.bufferData(De.ARRAY_BUFFER,e,De.STREAM_COPY),De.enableVertexAttribArray(0),De.vertexAttribPointer(0,3,De.FLOAT,!1,0,0),De.vertexAttribDivisor(0,1),r.push(t)}{const e=new Float32Array(3e3);for(let r=0;r<we;r++)e[3*r]=0,e[3*r+1]=0,e[3*r+2]=0;const t=De.createBuffer();De.bindBuffer(De.ARRAY_BUFFER,t),De.bufferData(De.ARRAY_BUFFER,e,De.STREAM_COPY),De.enableVertexAttribArray(1),De.vertexAttribPointer(1,3,De.FLOAT,!1,0,0),De.vertexAttribDivisor(1,1),r.push(t)}{const e=new Float32Array(1e3);for(let r=0;r<we;r++)e[2*r]=0;const t=De.createBuffer();De.bindBuffer(De.ARRAY_BUFFER,t),De.bufferData(De.ARRAY_BUFFER,e,De.STREAM_COPY),De.enableVertexAttribArray(2),De.vertexAttribPointer(2,1,De.FLOAT,!1,0,0),De.vertexAttribDivisor(2,1),r.push(t)}{const e=new Float32Array(1e3);for(let r=0;r<we;r++)e[2*r]=0;const t=De.createBuffer();De.bindBuffer(De.ARRAY_BUFFER,t),De.bufferData(De.ARRAY_BUFFER,e,De.STREAM_COPY),De.enableVertexAttribArray(3),De.vertexAttribPointer(3,1,De.FLOAT,!1,0,0),De.vertexAttribDivisor(3,1),r.push(t)}De.bindBuffer(De.ARRAY_BUFFER,null),De.bindTransformFeedback(De.TRANSFORM_FEEDBACK,n[e]);let i=0;for(const e of r)De.bindBufferBase(De.TRANSFORM_FEEDBACK_BUFFER,i,e),i++}const i=128,s=new Uint8Array(2097152);for(let e=0;e<i;++e)for(let r=0;r<i;++r)for(let t=0;t<i;++t){let n=ye(t/8,r/8,e/8);n=128*(1+n),s[t+r*i+e*i*i]=n}this.texture3d=b(De.TEXTURE_3D),De.texParameteri(De.TEXTURE_3D,De.TEXTURE_BASE_LEVEL,0),De.texParameteri(De.TEXTURE_3D,De.TEXTURE_MAX_LEVEL,Math.log2(i)),De.texParameteri(De.TEXTURE_3D,De.TEXTURE_MIN_FILTER,De.LINEAR_MIPMAP_LINEAR),De.texParameteri(De.TEXTURE_3D,De.TEXTURE_MAG_FILTER,De.LINEAR),De.texImage3D(De.TEXTURE_3D,0,De.R8,i,i,i,0,De.RED,De.UNSIGNED_BYTE,s),De.generateMipmap(De.TEXTURE_3D)}draw(e){De.enable(De.BLEND),De.blendFunc(De.SRC_ALPHA,De.ONE_MINUS_SRC_ALPHA);const t=(this.currentSourceIdx+1)%2;De.useProgram(this.program),De.bindVertexArray(this.VAO[this.currentSourceIdx]),De.bindTransformFeedback(De.TRANSFORM_FEEDBACK,this.TFO[t]);const n=new r;n.multiply(this.camera.projection),n.multiply(this.camera.matrixWorldInvert),De.uniform1f(De.getUniformLocation(this.program,"u_time"),e+5e3),De.uniform1f(De.getUniformLocation(this.program,"count"),we),De.uniform1i(De.getUniformLocation(this.program,"noize"),this.texture3d.index),De.enable(De.RASTERIZER_DISCARD),De.beginTransformFeedback(De.POINTS),De.drawArraysInstanced(De.POINTS,0,1,we),De.endTransformFeedback(),De.disable(De.RASTERIZER_DISCARD),De.bindTransformFeedback(De.TRANSFORM_FEEDBACK,null),De.bindBuffer(De.TRANSFORM_FEEDBACK_BUFFER,null);const i=De.fenceSync(De.SYNC_GPU_COMMANDS_COMPLETE,0);De.waitSync(i,0,De.TIMEOUT_IGNORED),De.deleteSync(i),De.useProgram(this.program2),De.bindVertexArray(this.VAO[t]),De.uniform1f(De.getUniformLocation(this.program2,"u_time"),e+5e3),De.uniformMatrix4fv(De.getUniformLocation(this.program2,"MVPMatrix"),!1,n.elements),De.uniform1i(De.getUniformLocation(this.program2,"light"),this.getLight()),De.drawArraysInstanced(De.POINTS,0,1,we),De.disable(De.BLEND),this.currentSourceIdx=(this.currentSourceIdx+1)%2}}var Ve;let Xe;Ve=function(){const e=5121,r=5126,t=5131,n=36193;let i;function s(e,r,t){return function(n,i,s){return((n+e-1)/e|0)*((i+r-1)/r|0)*t*s}}function o(e,r,t){return function(n,i,s){return(Math.max(n,e)*Math.max(i,r)/t|0)*s}}const a=new Map([[33776,s(4,4,8)],[33777,s(4,4,8)],[33778,s(4,4,16)],[33779,s(4,4,16)],[36196,s(4,4,8)],[35840,o(8,8,2)],[35842,o(8,8,2)],[35841,o(16,8,4)],[35843,o(16,8,4)],[37488,s(4,4,8)],[37489,s(4,4,8)],[37492,s(4,4,8)],[37493,s(4,4,8)],[37494,s(4,4,8)],[37495,s(4,4,8)],[37490,s(4,4,16)],[37491,s(4,4,16)],[37496,s(4,4,16)],[37497,s(4,4,16)],[37808,s(4,4,16)],[37840,s(4,4,16)],[37809,s(5,4,16)],[37841,s(5,4,16)],[37810,s(5,5,16)],[37842,s(5,5,16)],[37811,s(6,5,16)],[37843,s(6,5,16)],[37812,s(6,6,16)],[37844,s(6,6,16)],[37813,s(8,5,16)],[37845,s(8,5,16)],[37814,s(8,6,16)],[37846,s(8,6,16)],[37815,s(8,8,16)],[37847,s(8,8,16)],[37816,s(10,5,16)],[37848,s(10,5,16)],[37817,s(10,6,16)],[37849,s(10,6,16)],[37818,s(10,8,16)],[37850,s(10,8,16)],[37819,s(10,10,16)],[37851,s(10,10,16)],[37820,s(12,10,16)],[37852,s(12,10,16)],[37821,s(12,12,16)],[37853,s(12,12,16)],[35916,s(4,4,8)],[35917,s(4,4,8)],[35918,s(4,4,16)],[35919,s(4,4,16)],[36492,s(4,4,16)],[36493,s(4,4,16)],[36494,s(4,4,16)],[36495,s(4,4,16)],[36283,s(4,4,8)],[36284,s(4,4,8)],[36285,s(4,4,16)],[36286,s(4,4,16)]]);function c(s,o,c,l,u){const f=a.get(s);return f?f(o,c,l):function(s,o,a,c,l){return o*a*c*function(s,o){const a=function(s){if(!i){const s={};s[6406]={bytesPerElement:[1,2,2,4],type:[e,t,n,r]},s[6409]={bytesPerElement:[1,2,2,4],type:[e,t,n,r]},s[6410]={bytesPerElement:[2,4,4,8],type:[e,t,n,r]},s[6407]={bytesPerElement:[3,6,6,12,2],type:[e,t,n,r,33635]},s[6408]={bytesPerElement:[4,8,8,16,2,2],type:[e,t,n,r,32819,32820]},s[35906]={bytesPerElement:[4,8,8,16,2,2],type:[e,t,n,r,32819,32820]},s[6402]={bytesPerElement:[2,4],type:[5125,5123]},s[34041]={bytesPerElement:[4]},s[33321]={bytesPerElement:[1]},s[36756]={bytesPerElement:[1]},s[33325]={bytesPerElement:[2]},s[33326]={bytesPerElement:[4]},s[33330]={bytesPerElement:[1]},s[33329]={bytesPerElement:[1]},s[33332]={bytesPerElement:[2]},s[33331]={bytesPerElement:[2]},s[33334]={bytesPerElement:[4]},s[33333]={bytesPerElement:[4]},s[33323]={bytesPerElement:[2]},s[36757]={bytesPerElement:[2]},s[33327]={bytesPerElement:[4]},s[33328]={bytesPerElement:[8]},s[33336]={bytesPerElement:[2]},s[33335]={bytesPerElement:[2]},s[33338]={bytesPerElement:[4]},s[33337]={bytesPerElement:[4]},s[33340]={bytesPerElement:[8]},s[33339]={bytesPerElement:[8]},s[32849]={bytesPerElement:[3]},s[35905]={bytesPerElement:[3]},s[36194]={bytesPerElement:[2]},s[36758]={bytesPerElement:[3]},s[35898]={bytesPerElement:[4]},s[35901]={bytesPerElement:[4]},s[34843]={bytesPerElement:[6]},s[34837]={bytesPerElement:[12]},s[36221]={bytesPerElement:[3]},s[36239]={bytesPerElement:[3]},s[36215]={bytesPerElement:[6]},s[36233]={bytesPerElement:[6]},s[36209]={bytesPerElement:[12]},s[36227]={bytesPerElement:[12]},s[32856]={bytesPerElement:[4]},s[35907]={bytesPerElement:[4]},s[36759]={bytesPerElement:[4]},s[32855]={bytesPerElement:[2]},s[32854]={bytesPerElement:[2]},s[32857]={bytesPerElement:[4]},s[34842]={bytesPerElement:[8]},s[34836]={bytesPerElement:[16]},s[36220]={bytesPerElement:[4]},s[36238]={bytesPerElement:[4]},s[36975]={bytesPerElement:[4]},s[36214]={bytesPerElement:[8]},s[36232]={bytesPerElement:[8]},s[36226]={bytesPerElement:[16]},s[36208]={bytesPerElement:[16]},s[33189]={bytesPerElement:[2]},s[33190]={bytesPerElement:[4]},s[36012]={bytesPerElement:[4]},s[35056]={bytesPerElement:[4]},s[36013]={bytesPerElement:[4]},s[36168]={bytesPerElement:[1]},i=s}return i[s]}(s);if(!a)throw"unknown internal format";if(a.type){const e=a.type.indexOf(o);if(e<0)throw new Error(`unsupported type ${o} for internalformat ${s}`);return a.bytesPerElement[e]}return a.bytesPerElement[0]}(s,l)}(s,o,c,l,u)}function l(){return(new Error).stack.split("\n").slice(2).filter(e=>!e.includes("webgl-memory.js")).join("\n")}const u=new Set;function f(e,r,t={}){if(u.has(e))return e;u.add(e);const n=t.origGLErrorFn||e.getError,i=t.sharedState||function(e){const r=function(e){return{samples:e.getParameter(e.SAMPLES)||1,depthBits:e.getParameter(e.DEPTH_BITS),stencilBits:e.getParameter(e.STENCIL_BITS),contextAttributes:e.getContextAttributes()}}(e),n={baseContext:e,config:t,apis:{gman_webgl_memory:{ctx:{getMemoryInfo(){const t=function(e,r){if(e.isContextLost())return 0;const{samples:t}=r,n=e.drawingBufferWidth*e.drawingBufferHeight,i=function(e){const{depthBits:r,stencilBits:t}=e,n=(r+t+7)/8|0;return 3===n?4:n}(r);return 4*n+n*t*4+n*i}(e,r);return{memory:{...a,drawingbuffer:t,total:t+a.buffer+a.texture+a.renderbuffer},resources:{...h}}},getResourcesInfo:e=>function(e,r){return[...e.webglObjectToMemory.keys()].filter(e=>e instanceof r).map(r=>e.webglObjectToMemory.get(r))}(n,e)}}},resources:{},memory:{texture:0,buffer:0,renderbuffer:0},bindings:new Map,defaultVertexArray:{},webglObjectToMemory:new Map},i=new Set(["webgl","webgl2","webgl_lose_context"]);function o(){n.bindings.clear(),n.webglObjectToMemory.clear(),n.webglObjectToMemory.set(n.defaultVertexArray,{}),n.currentVertexArray=n.defaultVertexArray,[n.resources,n.memory].forEach(function(e){for(const r in e)e[r]=0})}return e.canvas&&(e.canvas.addEventListener("webglcontextlost",function(){o(),n.isContextLost=!0;for(const[e,{ctx:r,origFuncs:t}]of[...Object.entries(n.apis)])if(!i.has(e)&&t){u.delete(r);for(const[e,n]of Object.entries(t))r[e]=n;delete s[e]}}),e.canvas.addEventListener("webglcontextrestored",function(){n.isContextLost=!1})),o(),n}(e);t.sharedState=i;const{apis:s,bindings:o,memory:a,resources:h,webglObjectToMemory:m}=i,T={};function d(){}function E(e,r,t){return e[t||`create${r[0].toUpperCase()}${r.substr(1)}`]?(h[r]=0,function(e,t,n,s){i.isContextLost||(++h[r],m.set(s,{size:0,stackCreated:l()}))}):null}function p(r,t=d,n){const s=n||`delete${r[0].toUpperCase()}${r.substr(1)}`;return e[s]?function(e,n,s){if(i.isContextLost)return;const[o]=s,a=m.get(o);a&&(--h[r],t(o,a),m.delete(o))}:null}function R(e,r,t,n,s){if(i.isContextLost)return;const u=o.get(e);if(!u)throw new Error(`no renderbuffer bound to ${e}`);const f=m.get(u);if(!f)throw new Error(`unknown renderbuffer ${u}`);const h=c(t,n,s,1)*r;a.renderbuffer-=f.size,f.size=h,f.stackUpdated=l(),a.renderbuffer+=h}const x=5121,_=34067,A=35866,g=34069,v=new Set([g,34070,34071,34072,34073,34074]);function S(e){return v.has(e)}function b(e){e=S(e)?_:e;const r=o.get(e);if(!r)throw new Error(`no texture bound to ${e}`);const t=m.get(r);if(!t)throw new Error(`unknown texture ${r}`);return t}function F(e,r,t,n,i,s,o,u){const f=e.size,h=c(n,i,s,o,u),m=S(r)?r-g:0;e.mips=e.mips||[],e.mips[t]=e.mips[t]||[];const T=e.mips[t][m]||{};e.size-=T.size||0,T.size=h,T.internalFormat=n,T.type=u,T.width=i,T.height=s,T.depth=o,e.mips[t][m]=T,e.size+=h,a.texture-=f,a.texture+=e.size,e.stackUpdated=l()}function U(e,r,t,n,i,s){const o=b(e),a=e===_?6:1,c=e===_?g:e;for(let l=0;l<r;++l){for(let e=0;e<a;++e)F(o,c+e,l,t,n,i,s);n=Math.ceil(Math.max(n/2,1)),i=Math.ceil(Math.max(i/2,1)),s=e===A?s:Math.ceil(Math.max(s/2,1))}}function M(e,r,t){if(i.isContextLost)return;const[n]=t;i.currentVertexArray=n||i.defaultVertexArray}function I(e,r){i.isContextLost||(34963===e?m.get(i.currentVertexArray).elementArrayBuffer=r:o.set(e,r))}const N={},P={bufferData(e,r,t){if(i.isContextLost)return;const[n,s,,,c]=t;let u;if(u=34963===n?m.get(i.currentVertexArray).elementArrayBuffer:o.get(n),!u)throw new Error(`no buffer bound to ${n}`);let f=0;if(void 0!==c)f=c*s.BYTES_PER_ELEMENT;else if(function(e){return e&&e.buffer&&e.buffer instanceof ArrayBuffer}(h=s)||h instanceof ArrayBuffer)f=s.byteLength;else{if("number"!=typeof s)throw new Error(`unsupported bufferData src type ${s}`);f=s}var h;const T=m.get(u);if(!T)throw new Error(`unknown buffer ${u}`);a.buffer-=T.size,T.size=f,T.stackUpdated=l(),a.buffer+=f},bindVertexArray:M,bindVertexArrayOES:M,bindBuffer(e,r,t){const[n,i]=t;I(n,i)},bindBufferBase(e,r,t){const[n,,i]=t;I(n,i)},bindBufferRange(e,r,t){const[n,,i,,]=t;I(n,i)},bindRenderbuffer(e,r,t){if(i.isContextLost)return;const[n,s]=t;o.set(n,s)},bindTexture(e,r,t){if(i.isContextLost)return;const[n,s]=t;o.set(n,s)},copyTexImage2D(e,r,t){if(i.isContextLost)return;const[n,s,o,,,a,c]=t;F(b(n),n,s,o,a,c,1,x)},createBuffer:E(e,"buffer"),createFramebuffer:E(e,"framebuffer"),createRenderbuffer:E(e,"renderbuffer"),createProgram:E(e,"program"),createQuery:E(e,"query"),createShader:E(e,"shader"),createSampler:E(e,"sampler"),createTexture:E(e,"texture"),createTransformFeedback:E(e,"transformFeedback"),createVertexArray:E(e,"vertexArray"),createVertexArrayOES:E(e,"vertexArray","createVertexArrayOES"),compressedTexImage2D(e,r,t){if(i.isContextLost)return;const[n,s,o,a,c]=t;F(b(n),n,s,o,a,c,1,x)},compressedTexImage3D(e,r,t){if(i.isContextLost)return;const[n,s,o,a,c,l]=t;F(b(n),n,s,o,a,c,l,x)},deleteBuffer:p("buffer",function(e,r){a.buffer-=r.size}),deleteFramebuffer:p("framebuffer"),deleteProgram:p("program"),deleteQuery:p("query"),deleteRenderbuffer:p("renderbuffer",function(e,r){a.renderbuffer-=r.size}),deleteSampler:p("sampler"),deleteShader:p("shader"),deleteSync:p("sync"),deleteTexture:p("texture",function(e,r){a.texture-=r.size}),deleteTransformFeedback:p("transformFeedback"),deleteVertexArray:p("vertexArray"),deleteVertexArrayOES:p("vertexArray",d,"deleteVertexArrayOES"),fenceSync:function(e){if(!i.isContextLost&&e.fenceSync)return h.sync=0,function(e,r,t,n){++h.sync,m.set(n,{size:0})}}(e),generateMipmap(e,r,t){if(i.isContextLost)return;const[n]=t,s=b(n),o=s.parameters&&s.parameters.get(33084)||0,a=s.parameters&&s.parameters.get(33085)||1024,c=s.mips[o][0];let{width:l,height:u,depth:f}=c;const{internalFormat:h,type:m}=c;let T=o+1;const d=n===_?6:1,E=n===_?g:n;for(;T<=a&&(1!==l||1!==u||1!==f&&n!==A);){l=Math.ceil(Math.max(l/2,1)),u=Math.ceil(Math.max(u/2,1)),f=n===A?f:Math.ceil(Math.max(f/2,1));for(let e=0;e<d;++e)F(s,E+e,T,h,l,u,f,m);++T}},getSupportedExtensions(e,r,t,n){i.isContextLost||n.push("GMAN_webgl_memory")},renderbufferStorage(e,r,t){const[n,i,s,o]=t;R(n,1,i,s,o)},renderbufferStorageMultisample(e,r,t){const[n,i,s,o,a]=t;R(n,i,s,o,a)},texImage2D(e,r,t){if(i.isContextLost)return;const[n,s,o]=t;let a,c,l;if(6===t.length){const e=t[5];a=e.width,c=e.height,l=t[4]}else a=t[3],c=t[4],l=t[7];F(b(n),n,s,o,a,c,1,l)},texImage3D(e,r,t){if(i.isContextLost)return;const[n,s,o,a,c,l,,,u]=t;F(b(n),n,s,o,a,c,l,u)},texParameteri(e,r,t){if(i.isContextLost)return;const[n,s,o]=t,a=b(n);a.parameters=a.parameters||new Map,a.parameters.set(s,o)},texStorage2D(e,r,t){const[n,i,s,o,a]=t;U(n,i,s,o,a,1)},texStorage3D(e,r,t){const[n,i,s,o,a,c]=t;U(n,i,s,o,a,c)}},O={getExtension(e,r){if(i.isContextLost)return;const o=e[r];e[r]=function(...r){const i=r[0].toLowerCase(),a=s[i];if(a)return a.ctx;const c=o.call(e,...r);return c&&f(c,i,{...t,origGLErrorFn:n}),c}}};function C(e,r){const t=e[r],i=N[r]||d,s=P[r]||d;if(i===d&&P===d)return;e[r]=function(...n){i(e,r,n);const o=t.call(e,...n);return s(e,r,n,o),o};const o=O[r];o&&o(e,r,n)}for(const r in e)"function"==typeof e[r]&&(T[r]=e[r],C(e,r));s[r.toLowerCase()]={ctx:e,origFuncs:T}}function h(e){const r=e.prototype.getContext;e.prototype.getContext=function(e,...t){const n=r.call(this,e,...t);return n&&n.bindTexture&&(f(n,e,{}),n.getExtension("GMAN_webgl_memory")),n}}"undefined"!=typeof HTMLCanvasElement&&h(HTMLCanvasElement),"undefined"!=typeof OffscreenCanvas&&h(OffscreenCanvas)},"function"==typeof define&&define.amd?define(Ve):Ve();class He{gl;canvas;events;processors;ioc;renderState={};isIBL=!0;isDefaultLight=!0;stateBuffer;cameraBuffer;lightPosBuffer;storage2;storage;lightUBO1;lightUBO2;lightUBO3;lightUBO4;UBO;constructor(r,t,n=[],i="env",s="pbr"){if(!r||!t)throw new Error("Url or Canvas not found");this.canvas=t,this.processors=n;const o=[];0===this.processors.length&&o.push({name:"TONE"}),this.processors.some(e=>"shadow"===e)&&o.push({name:"SHADOWMAP"}),"pbr"===s&&o.push({name:"USE_PBR"}),this.ioc=new e,this.ioc.register("env",ae,["camera","canvas","gl"],i),this.ioc.register("camera",y,[],{type:"perspective",isInitial:!0,zoom:1,aspect:this.canvas.offsetWidth/this.canvas.offsetHeight,perspective:{yfov:60*Math.PI/180}},"perspective"),this.ioc.register("canvas",t),this.ioc.register("scene",u),this.ioc.register("light",D,[],{type:"directional",intensity:5,color:[1,1,1],isInitial:!0,spot:{}}),this.ioc.register("pp",Me,["light","camera","canvas","gl"],this.processors,this.renderScene.bind(this)),this.ioc.register("parser",Re,["scene","light","camera","canvas","gl"],r,o,this.resize.bind(this)),this.ioc.register("particles",Ge,["camera","gl"],()=>{const e=this.PP.postprocessors.find(e=>e instanceof q);return e.texture.index}),this.ioc.register("renderer",Z,["gl","parser","pp","scene","camera","particles","env"],this.getState.bind(this)),this.events=new $(t,this.redraw.bind(this))}get renderer(){return this.ioc.get("renderer")}get scene(){return this.ioc.get("scene")}get camera(){return this.ioc.get("camera")}get light(){return this.ioc.get("light")}get env(){return this.ioc.get("env")}get PP(){return this.ioc.get("pp")}get Particles(){return this.ioc.get("particles")}get parse(){return this.ioc.get("parser")}setVariant(e){this.scene.meshes.forEach(r=>{e&&r.variants.length&&(r.material=r.variants.find(r=>r.variants.includes(Number(e))).m)}),this.renderer.reflow=!0,this.renderer.needUpdateView=!0,this.renderer.needUpdateProjection=!0}async init(e){await this.parse.getJson(),this.glInit(),await this.parse.getBuffer(),await this.parse.initTextures(!1),this.parse.buildSkin(),await this.parse.buildMesh(),this.parse.createSamplers(),this.parse.createTexturesWebGL(),this.parse.cameras.push(this.camera),this.parse.calculateFov(this.camera.props.isInitial);const r=l(this.camera.getViewProjMatrix()),t=await this.parse.getEnv(!1);await this.env.createEnvironmentBuffer(t);const{renderState:i,isIBL:s,isDefaultLight:o,lights:a}=this.getState(),c=new w;c.add("isTone",i.isprerefraction?0:1),c.add("isIBL",s?1:0),c.add("isDefaultLight",o||a.some(e=>!e.isInitial)?1:0),c.done(),this.stateBuffer=c;const u=Xe.createBuffer();Xe.bindBuffer(Xe.UNIFORM_BUFFER,u),Xe.bufferData(Xe.UNIFORM_BUFFER,c.store,Xe.STATIC_DRAW);const f=new w;f.add("view",this.camera.matrixWorldInvert.elements),f.add("projection",this.camera.projection.elements),f.add("light",this.light.matrixWorldInvert.elements),f.add("isShadow",0),f.done(),this.cameraBuffer=f;const h=Xe.createBuffer();Xe.bindBuffer(Xe.UNIFORM_BUFFER,h),Xe.bufferData(Xe.UNIFORM_BUFFER,f.store,Xe.DYNAMIC_DRAW),this.UBO=h;const m={directional:0,point:1,spot:2},T=new Float32Array(4*this.parse.lights.length),d=new Float32Array(4*this.parse.lights.length),E=new Float32Array(4*this.parse.lights.length),p=new Float32Array(4*this.parse.lights.length);this.parse.lights.forEach((e,r)=>{T.set(new n([e.matrixWorld.elements[8],e.matrixWorld.elements[9],e.matrixWorld.elements[10]]).normalize().elements,4*r),d.set(e.getPosition(),4*r),E.set(e.color.elements,4*r),p.set([e.intensity,e.spot.innerConeAngle??0,e.spot.outerConeAngle??0,m[e.type]],4*r)});const R=new w;R.add("lightPos",d),R.done(),this.lightPosBuffer=R;const x=new w;x.add("lightColor",E),x.done();const _=new w;_.add("spotdir",T),_.done();const A=new w;A.add("lightIntensity",p),A.done();const g=Xe.createBuffer();Xe.bindBuffer(Xe.UNIFORM_BUFFER,g),Xe.bufferData(Xe.UNIFORM_BUFFER,R.store,Xe.DYNAMIC_DRAW);const v=Xe.createBuffer();Xe.bindBuffer(Xe.UNIFORM_BUFFER,v),Xe.bufferData(Xe.UNIFORM_BUFFER,x.store,Xe.DYNAMIC_DRAW);const S=Xe.createBuffer();Xe.bindBuffer(Xe.UNIFORM_BUFFER,S),Xe.bufferData(Xe.UNIFORM_BUFFER,_.store,Xe.DYNAMIC_DRAW);const b=Xe.createBuffer();Xe.bindBuffer(Xe.UNIFORM_BUFFER,b),Xe.bufferData(Xe.UNIFORM_BUFFER,A.store,Xe.DYNAMIC_DRAW),this.lightUBO1=g,this.lightUBO2=v,this.lightUBO3=S,this.lightUBO4=b,this.scene.meshes.forEach(e=>{e.geometry.createUniforms(e.matrixWorld)}),this.scene.meshes.forEach((e,r)=>{e.order=r,e.reflow=!0,e.repaint=!0}),this.scene.meshes.forEach(e=>{e.material.createUniforms(this.camera,this.parse.lights)}),Xe.activeTexture(Xe.TEXTURE31);const U=Xe.createTexture();Xe.bindTexture(Xe.TEXTURE_2D,U),Xe.texImage2D(Xe.TEXTURE_2D,0,Xe.RGBA32F,this.scene.meshes[0].geometry.uniformBuffer.store.length/Float32Array.BYTES_PER_ELEMENT,this.scene.meshes.length,0,Xe.RGBA,Xe.FLOAT,null),Xe.texParameteri(Xe.TEXTURE_2D,Xe.TEXTURE_MIN_FILTER,Xe.NEAREST),Xe.texParameteri(Xe.TEXTURE_2D,Xe.TEXTURE_MAG_FILTER,Xe.NEAREST),this.storage2={texture:U},Xe.activeTexture(Xe.TEXTURE30);const M=Xe.createTexture();Xe.bindTexture(Xe.TEXTURE_2D,M),Xe.texImage2D(Xe.TEXTURE_2D,0,Xe.RGBA32F,this.scene.meshes[0].material.materialUniformBuffer.store.length/Float32Array.BYTES_PER_ELEMENT,this.scene.meshes.length,0,Xe.RGBA,Xe.FLOAT,null),Xe.texParameteri(Xe.TEXTURE_2D,Xe.TEXTURE_MIN_FILTER,Xe.NEAREST),Xe.texParameteri(Xe.TEXTURE_2D,Xe.TEXTURE_MAG_FILTER,Xe.NEAREST),this.storage={texture2:M};const I=this.parse.json.extensionsUsed&&this.parse.json.extensionsUsed.includes("KHR_materials_transmission");this.scene.meshes.forEach(e=>{e.geometry.createGeometryForWebGl(Xe,e.defines,e.order);const t=this.parse.createProgram(e.defines);[e.material,...e.variants.map(e=>e.m)].forEach(e=>e.updateUniformsWebgl(Xe,t)),e.material.setHarmonics(this.env.updateUniform(Xe,t)),e.setProgram(t),Xe.bindBufferBase(Xe.UNIFORM_BUFFER,3,this.lightUBO1),Xe.bindBufferBase(Xe.UNIFORM_BUFFER,4,this.lightUBO2),Xe.bindBufferBase(Xe.UNIFORM_BUFFER,5,this.lightUBO3),Xe.bindBufferBase(Xe.UNIFORM_BUFFER,6,this.lightUBO4),Xe.activeTexture(Xe.TEXTURE31);let n=Xe.getUniformLocation(t,"uTransformTex");if(Xe.uniform1i(n,31),Xe.activeTexture(Xe.TEXTURE30),n=Xe.getUniformLocation(t,"uMaterialTex"),Xe.uniform1i(n,30),e.geometry.updateUniformsWebGl(Xe,e.program),e.visible=e.isVisible(r),e instanceof L){for(const r of this.parse.skins[e.skin].jointNames)F(this.scene,this.buildBones.bind(this,r,this.parse.skins[e.skin]));e.setSkin(Xe,this.parse.skins[e.skin])}}),I&&this.PP.addPrepass("refraction"),this.PP.postprocessors.some(e=>e instanceof q)&&this.Particles.build(),(this.PP.hasPostPass||this.PP.hasPrePass)&&this.PP.buildScreenBuffer(),this.resize(null),this.parse.buildAnimation(),this.initialDraw();const N=Xe.getExtension("GMAN_webgl_memory");if(N){const e=N.getMemoryInfo(),r=N.getResourcesInfo(WebGLTexture),t=N.getResourcesInfo(WebGLBuffer);console.log(e,r,t)}e()}buildBones(e,r,t){t.name===e&&r.bones.push(t)}renderScene(e){this.renderState=e,this.renderer.renderScene(),this.renderState=this.PP.hasPostPass?{isprerefraction:!0}:{}}redraw(e,r,t){"zoom"===e&&(this.camera.zoom(r),this.renderer.needUpdateView=!0,this.renderer.needUpdateProjection=!0),"rotate"===e&&(this.camera.rotate(r,t),this.renderer.needUpdateView=!0),"pan"===e&&(this.camera.pan(r,t,this.canvas.offsetWidth,this.canvas.offsetHeight),this.renderer.needUpdateView=!0),"resize"===e&&(this.resize(e),this.renderer.needUpdateProjection=!0),this.renderer.reflow=!0}resize(e){this.camera.props.aspect=this.canvas.offsetWidth/this.canvas.offsetHeight,this.canvas.width=this.canvas.offsetWidth*devicePixelRatio,this.canvas.height=this.canvas.offsetHeight*devicePixelRatio,Xe.viewport(0,0,this.canvas.offsetWidth*devicePixelRatio,this.canvas.offsetHeight*devicePixelRatio);const r=this.camera.modelSize;this.camera.props.isInitial&&this.camera.setZ(r),(this.light.isInitial||"directional"===this.light.type)&&this.light.setZ(r),this.renderer.needUpdateView=!0,this.camera.updateNF(),e&&(this.PP.clear(),this.PP.buildScreenBuffer())}glInit(){if(Xe=this.canvas.getContext("webgl2",{antialias:!window.__FORCE_DETERMINISTIC__}),this.gl=Xe,!Xe)throw new Error("Webgl 2 doesnt support");m=Xe,this.ioc.register("gl",Xe);let e=Xe.getExtension("EXT_color_buffer_float");e=Xe.getExtension("OES_texture_float_linear"),e=Xe.getExtension("OES_texture_buffer"),console.log(e)}draw(){this.renderer.reflow=!0}initialDraw(){Xe.clearColor(...d),Xe.enable(Xe.DEPTH_TEST),Xe.enable(Xe.CULL_FACE),this.renderer.reflow=!0,this.renderer.render(),window.__TEST_READY__=!0}getState(){const e=this.PP.postprocessors.find(e=>e instanceof Fe);return{storage:this.storage,storage2:this.storage2,UBO:this.UBO,cameraBuffer:this.cameraBuffer,lightUBO1:this.lightUBO1,lightUBO2:this.lightUBO2,lightUBO3:this.lightUBO3,lightUBO4:this.lightUBO4,lightPosBuffer:this.lightPosBuffer,isIBL:this.isIBL,isDefaultLight:this.isDefaultLight,renderState:this.renderState,lights:this.parse.lights,camera:this.camera,light:this.light,preDepthTexture:this.PP.preDepthTexture,colorTexture:e?e.texture:this.PP.fakeDepth,fakeDepth:this.PP.fakeDepth,needUpdateView:this.renderer.needUpdateView,needUpdateProjection:this.renderer.needUpdateProjection,irradiancemap:this.env.irradiancemap,Sheen_E:this.env.Sheen_E,prefilterMap:this.env.prefilterMap,charlieMap:this.env.charlieMap,brdfLUT:this.env.brdfLUTTexture}}}})(),s})());