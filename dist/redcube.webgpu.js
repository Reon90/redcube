var redcube = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/parse-hdr/index.js
  var require_parse_hdr = __commonJS({
    "node_modules/parse-hdr/index.js"(exports2, module2) {
      var radiancePattern = "#\\?RADIANCE";
      var commentPattern = "#.*";
      var exposurePattern = "EXPOSURE=\\s*([0-9]*[.][0-9]*)";
      var formatPattern = "FORMAT=32-bit_rle_rgbe";
      var widthHeightPattern = "-Y ([0-9]+) \\+X ([0-9]+)";
      function readPixelsRawRLE(buffer, data, offset, fileOffset, scanline_width, num_scanlines) {
        var rgbe = new Array(4);
        var scanline_buffer = null;
        var ptr;
        var ptr_end;
        var count;
        var buf = new Array(2);
        var bufferLength = buffer.length;
        function readBuf(buf2) {
          var bytesRead = 0;
          do {
            buf2[bytesRead++] = buffer[fileOffset];
          } while (++fileOffset < bufferLength && bytesRead < buf2.length);
          return bytesRead;
        }
        function readBufOffset(buf2, offset2, length) {
          var bytesRead = 0;
          do {
            buf2[offset2 + bytesRead++] = buffer[fileOffset];
          } while (++fileOffset < bufferLength && bytesRead < length);
          return bytesRead;
        }
        function readPixelsRaw(buffer2, data2, offset2, numpixels) {
          var numExpected = 4 * numpixels;
          var numRead = readBufOffset(data2, offset2, numExpected);
          if (numRead < numExpected) {
            throw new Error("Error reading raw pixels: got " + numRead + " bytes, expected " + numExpected);
          }
        }
        while (num_scanlines > 0) {
          if (readBuf(rgbe) < rgbe.length) {
            throw new Error("Error reading bytes: expected " + rgbe.length);
          }
          if (rgbe[0] != 2 || rgbe[1] != 2 || (rgbe[2] & 128) != 0) {
            data[offset++] = rgbe[0];
            data[offset++] = rgbe[1];
            data[offset++] = rgbe[2];
            data[offset++] = rgbe[3];
            readPixelsRaw(buffer, data, offset, scanline_width * num_scanlines - 1);
            return;
          }
          if (((rgbe[2] & 255) << 8 | rgbe[3] & 255) != scanline_width) {
            throw new Error("Wrong scanline width " + ((rgbe[2] & 255) << 8 | rgbe[3] & 255) + ", expected " + scanline_width);
          }
          if (scanline_buffer == null) {
            scanline_buffer = new Array(4 * scanline_width);
          }
          ptr = 0;
          for (var i = 0; i < 4; i++) {
            ptr_end = (i + 1) * scanline_width;
            while (ptr < ptr_end) {
              if (readBuf(buf) < buf.length) {
                throw new Error("Error reading 2-byte buffer");
              }
              if ((buf[0] & 255) > 128) {
                count = (buf[0] & 255) - 128;
                if (count == 0 || count > ptr_end - ptr) {
                  throw new Error("Bad scanline data");
                }
                while (count-- > 0)
                  scanline_buffer[ptr++] = buf[1];
              } else {
                count = buf[0] & 255;
                if (count == 0 || count > ptr_end - ptr) {
                  throw new Error("Bad scanline data");
                }
                scanline_buffer[ptr++] = buf[1];
                if (--count > 0) {
                  if (readBufOffset(scanline_buffer, ptr, count) < count) {
                    throw new Error("Error reading non-run data");
                  }
                  ptr += count;
                }
              }
            }
          }
          for (var i = 0; i < scanline_width; i++) {
            data[offset + 0] = scanline_buffer[i];
            data[offset + 1] = scanline_buffer[i + scanline_width];
            data[offset + 2] = scanline_buffer[i + 2 * scanline_width];
            data[offset + 3] = scanline_buffer[i + 3 * scanline_width];
            offset += 4;
          }
          num_scanlines--;
        }
      }
      function parseHdr(buffer) {
        if (buffer instanceof ArrayBuffer) {
          buffer = new Uint8Array(buffer);
        }
        var fileOffset = 0;
        var bufferLength = buffer.length;
        var NEW_LINE = 10;
        function readLine() {
          var buf = "";
          do {
            var b2 = buffer[fileOffset];
            if (b2 == NEW_LINE) {
              ++fileOffset;
              break;
            }
            buf += String.fromCharCode(b2);
          } while (++fileOffset < bufferLength);
          return buf;
        }
        var width = 0;
        var height = 0;
        var exposure = 1;
        var gamma = 1;
        var rle = false;
        for (var i = 0; i < 20; i++) {
          var line = readLine();
          var match;
          if (match = line.match(radiancePattern)) {
          } else if (match = line.match(formatPattern)) {
            rle = true;
          } else if (match = line.match(exposurePattern)) {
            exposure = Number(match[1]);
          } else if (match = line.match(commentPattern)) {
          } else if (match = line.match(widthHeightPattern)) {
            height = Number(match[1]);
            width = Number(match[2]);
            break;
          }
        }
        if (!rle) {
          throw new Error("File is not run length encoded!");
        }
        var data = new Uint8Array(width * height * 4);
        var scanline_width = width;
        var num_scanlines = height;
        readPixelsRawRLE(buffer, data, 0, fileOffset, scanline_width, num_scanlines);
        var floatData = new Float32Array(width * height * 4);
        for (var offset = 0; offset < data.length; offset += 4) {
          var r = data[offset + 0] / 255;
          var g = data[offset + 1] / 255;
          var b = data[offset + 2] / 255;
          var e = data[offset + 3];
          var f = Math.pow(2, e - 128);
          r *= f;
          g *= f;
          b *= f;
          var floatOffset = offset;
          floatData[floatOffset + 0] = r;
          floatData[floatOffset + 1] = g;
          floatData[floatOffset + 2] = b;
          floatData[floatOffset + 3] = 1;
        }
        return {
          shape: [width, height],
          exposure,
          gamma,
          data: floatData
        };
      }
      module2.exports = parseHdr;
    }
  });

  // node-builtins-ns:fs
  var fs_exports = {};
  __export(fs_exports, {
    default: () => fs_default
  });
  var fs_default;
  var init_fs = __esm({
    "node-builtins-ns:fs"() {
      fs_default = {};
    }
  });

  // node-builtins-ns:path
  var path_exports = {};
  __export(path_exports, {
    default: () => path_default
  });
  var path_default;
  var init_path = __esm({
    "node-builtins-ns:path"() {
      path_default = {};
    }
  });

  // node_modules/draco3d/draco_encoder_nodejs.js
  var require_draco_encoder_nodejs = __commonJS({
    "node_modules/draco3d/draco_encoder_nodejs.js"(exports2, module2) {
      var $jscomp = $jscomp || {};
      $jscomp.scope = {};
      $jscomp.arrayIteratorImpl = function(l) {
        var p = 0;
        return function() {
          return p < l.length ? { done: false, value: l[p++] } : { done: true };
        };
      };
      $jscomp.arrayIterator = function(l) {
        return { next: $jscomp.arrayIteratorImpl(l) };
      };
      $jscomp.makeIterator = function(l) {
        var p = "undefined" != typeof Symbol && Symbol.iterator && l[Symbol.iterator];
        return p ? p.call(l) : $jscomp.arrayIterator(l);
      };
      $jscomp.ASSUME_ES5 = false;
      $jscomp.ASSUME_NO_NATIVE_MAP = false;
      $jscomp.ASSUME_NO_NATIVE_SET = false;
      $jscomp.SIMPLE_FROUND_POLYFILL = false;
      $jscomp.ISOLATE_POLYFILLS = false;
      $jscomp.FORCE_POLYFILL_PROMISE = false;
      $jscomp.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION = false;
      $jscomp.getGlobal = function(l) {
        l = ["object" == typeof globalThis && globalThis, l, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global];
        for (var p = 0; p < l.length; ++p) {
          var m = l[p];
          if (m && m.Math == Math) return m;
        }
        throw Error("Cannot find global object");
      };
      $jscomp.global = $jscomp.getGlobal(exports2);
      $jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(l, p, m) {
        if (l == Array.prototype || l == Object.prototype) return l;
        l[p] = m.value;
        return l;
      };
      $jscomp.IS_SYMBOL_NATIVE = "function" === typeof Symbol && "symbol" === typeof Symbol("x");
      $jscomp.TRUST_ES6_POLYFILLS = !$jscomp.ISOLATE_POLYFILLS || $jscomp.IS_SYMBOL_NATIVE;
      $jscomp.polyfills = {};
      $jscomp.propertyToPolyfillSymbol = {};
      $jscomp.POLYFILL_PREFIX = "$jscp$";
      $jscomp.polyfill = function(l, p, m, r) {
        p && ($jscomp.ISOLATE_POLYFILLS ? $jscomp.polyfillIsolated(l, p, m, r) : $jscomp.polyfillUnisolated(l, p, m, r));
      };
      $jscomp.polyfillUnisolated = function(l, p, m, r) {
        m = $jscomp.global;
        l = l.split(".");
        for (r = 0; r < l.length - 1; r++) {
          var k = l[r];
          if (!(k in m)) return;
          m = m[k];
        }
        l = l[l.length - 1];
        r = m[l];
        p = p(r);
        p != r && null != p && $jscomp.defineProperty(m, l, { configurable: true, writable: true, value: p });
      };
      $jscomp.polyfillIsolated = function(l, p, m, r) {
        var k = l.split(".");
        l = 1 === k.length;
        r = k[0];
        r = !l && r in $jscomp.polyfills ? $jscomp.polyfills : $jscomp.global;
        for (var C = 0; C < k.length - 1; C++) {
          var h = k[C];
          if (!(h in r)) return;
          r = r[h];
        }
        k = k[k.length - 1];
        m = $jscomp.IS_SYMBOL_NATIVE && "es6" === m ? r[k] : null;
        p = p(m);
        null != p && (l ? $jscomp.defineProperty($jscomp.polyfills, k, { configurable: true, writable: true, value: p }) : p !== m && (void 0 === $jscomp.propertyToPolyfillSymbol[k] && (m = 1e9 * Math.random() >>> 0, $jscomp.propertyToPolyfillSymbol[k] = $jscomp.IS_SYMBOL_NATIVE ? $jscomp.global.Symbol(k) : $jscomp.POLYFILL_PREFIX + m + "$" + k), $jscomp.defineProperty(r, $jscomp.propertyToPolyfillSymbol[k], { configurable: true, writable: true, value: p })));
      };
      $jscomp.polyfill("Promise", function(l) {
        function p() {
          this.batch_ = null;
        }
        function m(h) {
          return h instanceof k ? h : new k(function(q, w) {
            q(h);
          });
        }
        if (l && (!($jscomp.FORCE_POLYFILL_PROMISE || $jscomp.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION && "undefined" === typeof $jscomp.global.PromiseRejectionEvent) || !$jscomp.global.Promise || -1 === $jscomp.global.Promise.toString().indexOf("[native code]"))) return l;
        p.prototype.asyncExecute = function(h) {
          if (null == this.batch_) {
            this.batch_ = [];
            var q = this;
            this.asyncExecuteFunction(function() {
              q.executeBatch_();
            });
          }
          this.batch_.push(h);
        };
        var r = $jscomp.global.setTimeout;
        p.prototype.asyncExecuteFunction = function(h) {
          r(h, 0);
        };
        p.prototype.executeBatch_ = function() {
          for (; this.batch_ && this.batch_.length; ) {
            var h = this.batch_;
            this.batch_ = [];
            for (var q = 0; q < h.length; ++q) {
              var w = h[q];
              h[q] = null;
              try {
                w();
              } catch (B) {
                this.asyncThrow_(B);
              }
            }
          }
          this.batch_ = null;
        };
        p.prototype.asyncThrow_ = function(h) {
          this.asyncExecuteFunction(function() {
            throw h;
          });
        };
        var k = function(h) {
          this.state_ = 0;
          this.result_ = void 0;
          this.onSettledCallbacks_ = [];
          this.isRejectionHandled_ = false;
          var q = this.createResolveAndReject_();
          try {
            h(q.resolve, q.reject);
          } catch (w) {
            q.reject(w);
          }
        };
        k.prototype.createResolveAndReject_ = function() {
          function h(B) {
            return function(v) {
              w || (w = true, B.call(q, v));
            };
          }
          var q = this, w = false;
          return { resolve: h(this.resolveTo_), reject: h(this.reject_) };
        };
        k.prototype.resolveTo_ = function(h) {
          if (h === this) this.reject_(new TypeError("A Promise cannot resolve to itself"));
          else if (h instanceof k) this.settleSameAsPromise_(h);
          else {
            a: switch (typeof h) {
              case "object":
                var q = null != h;
                break a;
              case "function":
                q = true;
                break a;
              default:
                q = false;
            }
            q ? this.resolveToNonPromiseObj_(h) : this.fulfill_(h);
          }
        };
        k.prototype.resolveToNonPromiseObj_ = function(h) {
          var q = void 0;
          try {
            q = h.then;
          } catch (w) {
            this.reject_(w);
            return;
          }
          "function" == typeof q ? this.settleSameAsThenable_(q, h) : this.fulfill_(h);
        };
        k.prototype.reject_ = function(h) {
          this.settle_(2, h);
        };
        k.prototype.fulfill_ = function(h) {
          this.settle_(1, h);
        };
        k.prototype.settle_ = function(h, q) {
          if (0 != this.state_) throw Error("Cannot settle(" + h + ", " + q + "): Promise already settled in state" + this.state_);
          this.state_ = h;
          this.result_ = q;
          2 === this.state_ && this.scheduleUnhandledRejectionCheck_();
          this.executeOnSettledCallbacks_();
        };
        k.prototype.scheduleUnhandledRejectionCheck_ = function() {
          var h = this;
          r(function() {
            if (h.notifyUnhandledRejection_()) {
              var q = $jscomp.global.console;
              "undefined" !== typeof q && q.error(h.result_);
            }
          }, 1);
        };
        k.prototype.notifyUnhandledRejection_ = function() {
          if (this.isRejectionHandled_) return false;
          var h = $jscomp.global.CustomEvent, q = $jscomp.global.Event, w = $jscomp.global.dispatchEvent;
          if ("undefined" === typeof w) return true;
          "function" === typeof h ? h = new h("unhandledrejection", { cancelable: true }) : "function" === typeof q ? h = new q("unhandledrejection", { cancelable: true }) : (h = $jscomp.global.document.createEvent("CustomEvent"), h.initCustomEvent("unhandledrejection", false, true, h));
          h.promise = this;
          h.reason = this.result_;
          return w(h);
        };
        k.prototype.executeOnSettledCallbacks_ = function() {
          if (null != this.onSettledCallbacks_) {
            for (var h = 0; h < this.onSettledCallbacks_.length; ++h) C.asyncExecute(this.onSettledCallbacks_[h]);
            this.onSettledCallbacks_ = null;
          }
        };
        var C = new p();
        k.prototype.settleSameAsPromise_ = function(h) {
          var q = this.createResolveAndReject_();
          h.callWhenSettled_(q.resolve, q.reject);
        };
        k.prototype.settleSameAsThenable_ = function(h, q) {
          var w = this.createResolveAndReject_();
          try {
            h.call(q, w.resolve, w.reject);
          } catch (B) {
            w.reject(B);
          }
        };
        k.prototype.then = function(h, q) {
          function w(I, J) {
            return "function" == typeof I ? function(Q) {
              try {
                B(I(Q));
              } catch (R) {
                v(R);
              }
            } : J;
          }
          var B, v, D = new k(function(I, J) {
            B = I;
            v = J;
          });
          this.callWhenSettled_(w(h, B), w(q, v));
          return D;
        };
        k.prototype.catch = function(h) {
          return this.then(void 0, h);
        };
        k.prototype.callWhenSettled_ = function(h, q) {
          function w() {
            switch (B.state_) {
              case 1:
                h(B.result_);
                break;
              case 2:
                q(B.result_);
                break;
              default:
                throw Error("Unexpected state: " + B.state_);
            }
          }
          var B = this;
          null == this.onSettledCallbacks_ ? C.asyncExecute(w) : this.onSettledCallbacks_.push(w);
          this.isRejectionHandled_ = true;
        };
        k.resolve = m;
        k.reject = function(h) {
          return new k(function(q, w) {
            w(h);
          });
        };
        k.race = function(h) {
          return new k(function(q, w) {
            for (var B = $jscomp.makeIterator(h), v = B.next(); !v.done; v = B.next()) m(v.value).callWhenSettled_(q, w);
          });
        };
        k.all = function(h) {
          var q = $jscomp.makeIterator(h), w = q.next();
          return w.done ? m([]) : new k(function(B, v) {
            function D(Q) {
              return function(R) {
                I[Q] = R;
                J--;
                0 == J && B(I);
              };
            }
            var I = [], J = 0;
            do
              I.push(void 0), J++, m(w.value).callWhenSettled_(D(I.length - 1), v), w = q.next();
            while (!w.done);
          });
        };
        return k;
      }, "es6", "es3");
      $jscomp.owns = function(l, p) {
        return Object.prototype.hasOwnProperty.call(l, p);
      };
      $jscomp.assign = $jscomp.TRUST_ES6_POLYFILLS && "function" == typeof Object.assign ? Object.assign : function(l, p) {
        for (var m = 1; m < arguments.length; m++) {
          var r = arguments[m];
          if (r) for (var k in r) $jscomp.owns(r, k) && (l[k] = r[k]);
        }
        return l;
      };
      $jscomp.polyfill("Object.assign", function(l) {
        return l || $jscomp.assign;
      }, "es6", "es3");
      $jscomp.checkStringArgs = function(l, p, m) {
        if (null == l) throw new TypeError("The 'this' value for String.prototype." + m + " must not be null or undefined");
        if (p instanceof RegExp) throw new TypeError("First argument to String.prototype." + m + " must not be a regular expression");
        return l + "";
      };
      $jscomp.polyfill("String.prototype.startsWith", function(l) {
        return l ? l : function(p, m) {
          var r = $jscomp.checkStringArgs(this, p, "startsWith");
          p += "";
          var k = r.length, C = p.length;
          m = Math.max(0, Math.min(m | 0, r.length));
          for (var h = 0; h < C && m < k; ) if (r[m++] != p[h++]) return false;
          return h >= C;
        };
      }, "es6", "es3");
      $jscomp.polyfill("Array.prototype.copyWithin", function(l) {
        function p(m) {
          m = Number(m);
          return Infinity === m || -Infinity === m ? m : m | 0;
        }
        return l ? l : function(m, r, k) {
          var C = this.length;
          m = p(m);
          r = p(r);
          k = void 0 === k ? C : p(k);
          m = 0 > m ? Math.max(C + m, 0) : Math.min(m, C);
          r = 0 > r ? Math.max(C + r, 0) : Math.min(r, C);
          k = 0 > k ? Math.max(C + k, 0) : Math.min(k, C);
          if (m < r) for (; r < k; ) r in this ? this[m++] = this[r++] : (delete this[m++], r++);
          else for (k = Math.min(k, C + r - m), m += k - r; k > r; ) --k in this ? this[--m] = this[k] : delete this[--m];
          return this;
        };
      }, "es6", "es3");
      $jscomp.typedArrayCopyWithin = function(l) {
        return l ? l : Array.prototype.copyWithin;
      };
      $jscomp.polyfill("Int8Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5");
      $jscomp.polyfill("Uint8Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5");
      $jscomp.polyfill("Uint8ClampedArray.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5");
      $jscomp.polyfill("Int16Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5");
      $jscomp.polyfill("Uint16Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5");
      $jscomp.polyfill("Int32Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5");
      $jscomp.polyfill("Uint32Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5");
      $jscomp.polyfill("Float32Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5");
      $jscomp.polyfill("Float64Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5");
      var DracoEncoderModule = (function() {
        var l = "undefined" !== typeof document && document.currentScript ? document.currentScript.src : void 0;
        "undefined" !== typeof __filename && (l = l || __filename);
        return function(p) {
          function m(f) {
            return a.locateFile ? a.locateFile(f, L) : L + f;
          }
          function r() {
            var f = ba.buffer;
            a.HEAP8 = O = new Int8Array(f);
            a.HEAP16 = ea = new Int16Array(f);
            a.HEAP32 = S = new Int32Array(f);
            a.HEAPU8 = fa = new Uint8Array(f);
            a.HEAPU16 = new Uint16Array(f);
            a.HEAPU32 = T = new Uint32Array(f);
            a.HEAPF32 = ha = new Float32Array(f);
            a.HEAPF64 = new Float64Array(f);
          }
          function k(f) {
            if (a.onAbort) a.onAbort(f);
            f = "Aborted(" + f + ")";
            W(f);
            na = true;
            f = new WebAssembly.RuntimeError(f + ". Build with -sASSERTIONS for more info.");
            ca(f);
            throw f;
          }
          function C(f) {
            try {
              if (f == K && X) return new Uint8Array(X);
              if (ia) return ia(f);
              throw "both async and sync fetching of the wasm failed";
            } catch (b) {
              k(b);
            }
          }
          function h() {
            if (!X && (oa || Y)) {
              if ("function" == typeof fetch && !K.startsWith("file://")) return fetch(K, { credentials: "same-origin" }).then(function(f) {
                if (!f.ok) throw "failed to load wasm binary file at '" + K + "'";
                return f.arrayBuffer();
              }).catch(function() {
                return C(K);
              });
              if (ja) return new Promise(function(f, b) {
                ja(K, function(c) {
                  f(new Uint8Array(c));
                }, b);
              });
            }
            return Promise.resolve().then(function() {
              return C(K);
            });
          }
          function q(f) {
            for (; 0 < f.length; ) f.shift()(a);
          }
          function w(f) {
            this.excPtr = f;
            this.ptr = f - 24;
            this.set_type = function(b) {
              T[this.ptr + 4 >> 2] = b;
            };
            this.get_type = function() {
              return T[this.ptr + 4 >> 2];
            };
            this.set_destructor = function(b) {
              T[this.ptr + 8 >> 2] = b;
            };
            this.get_destructor = function() {
              return T[this.ptr + 8 >> 2];
            };
            this.set_refcount = function(b) {
              S[this.ptr >> 2] = b;
            };
            this.set_caught = function(b) {
              O[this.ptr + 12 >> 0] = b ? 1 : 0;
            };
            this.get_caught = function() {
              return 0 != O[this.ptr + 12 >> 0];
            };
            this.set_rethrown = function(b) {
              O[this.ptr + 13 >> 0] = b ? 1 : 0;
            };
            this.get_rethrown = function() {
              return 0 != O[this.ptr + 13 >> 0];
            };
            this.init = function(b, c) {
              this.set_adjusted_ptr(0);
              this.set_type(b);
              this.set_destructor(c);
              this.set_refcount(0);
              this.set_caught(false);
              this.set_rethrown(false);
            };
            this.add_ref = function() {
              S[this.ptr >> 2] += 1;
            };
            this.release_ref = function() {
              var b = S[this.ptr >> 2];
              S[this.ptr >> 2] = b - 1;
              return 1 === b;
            };
            this.set_adjusted_ptr = function(b) {
              T[this.ptr + 16 >> 2] = b;
            };
            this.get_adjusted_ptr = function() {
              return T[this.ptr + 16 >> 2];
            };
            this.get_exception_ptr = function() {
              if (pa(this.get_type())) return T[this.excPtr >> 2];
              var b = this.get_adjusted_ptr();
              return 0 !== b ? b : this.excPtr;
            };
          }
          function B() {
            function f() {
              if (!da && (da = true, a.calledRun = true, !na)) {
                qa = true;
                q(ka);
                ra(a);
                if (a.onRuntimeInitialized) a.onRuntimeInitialized();
                if (a.postRun) for ("function" == typeof a.postRun && (a.postRun = [a.postRun]); a.postRun.length; ) sa.unshift(a.postRun.shift());
                q(sa);
              }
            }
            if (!(0 < U)) {
              if (a.preRun) for ("function" == typeof a.preRun && (a.preRun = [a.preRun]); a.preRun.length; ) ta.unshift(a.preRun.shift());
              q(ta);
              0 < U || (a.setStatus ? (a.setStatus("Running..."), setTimeout(function() {
                setTimeout(function() {
                  a.setStatus("");
                }, 1);
                f();
              }, 1)) : f());
            }
          }
          function v() {
          }
          function D(f) {
            return (f || v).__cache__;
          }
          function I(f, b) {
            var c = D(b), d = c[f];
            if (d) return d;
            d = Object.create((b || v).prototype);
            d.ptr = f;
            return c[f] = d;
          }
          function J(f) {
            if ("string" === typeof f) {
              for (var b = 0, c = 0; c < f.length; ++c) {
                var d = f.charCodeAt(c);
                127 >= d ? b++ : 2047 >= d ? b += 2 : 55296 <= d && 57343 >= d ? (b += 4, ++c) : b += 3;
              }
              b = Array(b + 1);
              c = 0;
              d = b.length;
              if (0 < d) {
                d = c + d - 1;
                for (var e = 0; e < f.length; ++e) {
                  var g = f.charCodeAt(e);
                  if (55296 <= g && 57343 >= g) {
                    var t = f.charCodeAt(++e);
                    g = 65536 + ((g & 1023) << 10) | t & 1023;
                  }
                  if (127 >= g) {
                    if (c >= d) break;
                    b[c++] = g;
                  } else {
                    if (2047 >= g) {
                      if (c + 1 >= d) break;
                      b[c++] = 192 | g >> 6;
                    } else {
                      if (65535 >= g) {
                        if (c + 2 >= d) break;
                        b[c++] = 224 | g >> 12;
                      } else {
                        if (c + 3 >= d) break;
                        b[c++] = 240 | g >> 18;
                        b[c++] = 128 | g >> 12 & 63;
                      }
                      b[c++] = 128 | g >> 6 & 63;
                    }
                    b[c++] = 128 | g & 63;
                  }
                }
                b[c] = 0;
              }
              f = n.alloc(b, O);
              n.copy(b, O, f);
              return f;
            }
            return f;
          }
          function Q(f) {
            if ("object" === typeof f) {
              var b = n.alloc(f, O);
              n.copy(f, O, b);
              return b;
            }
            return f;
          }
          function R(f) {
            if ("object" === typeof f) {
              var b = n.alloc(f, ea);
              n.copy(f, ea, b);
              return b;
            }
            return f;
          }
          function V(f) {
            if ("object" === typeof f) {
              var b = n.alloc(f, S);
              n.copy(f, S, b);
              return b;
            }
            return f;
          }
          function Z(f) {
            if ("object" === typeof f) {
              var b = n.alloc(f, ha);
              n.copy(f, ha, b);
              return b;
            }
            return f;
          }
          function P() {
            throw "cannot construct a VoidPtr, no constructor in IDL";
          }
          function M() {
            this.ptr = ua();
            D(M)[this.ptr] = this;
          }
          function z() {
            this.ptr = va();
            D(z)[this.ptr] = this;
          }
          function G() {
            this.ptr = wa();
            D(G)[this.ptr] = this;
          }
          function E() {
            this.ptr = xa();
            D(E)[this.ptr] = this;
          }
          function N() {
            this.ptr = ya();
            D(N)[this.ptr] = this;
          }
          function H() {
            this.ptr = za();
            D(H)[this.ptr] = this;
          }
          function F() {
            this.ptr = Aa();
            D(F)[this.ptr] = this;
          }
          function x() {
            this.ptr = Ba();
            D(x)[this.ptr] = this;
          }
          function u() {
            this.ptr = Ca();
            D(u)[this.ptr] = this;
          }
          function y() {
            this.ptr = Da();
            D(y)[this.ptr] = this;
          }
          function A(f) {
            f && "object" === typeof f && (f = f.ptr);
            this.ptr = Ea(f);
            D(A)[this.ptr] = this;
          }
          p = void 0 === p ? {} : p;
          var a = "undefined" != typeof p ? p : {}, ra, ca;
          a.ready = new Promise(function(f, b) {
            ra = f;
            ca = b;
          });
          var Fa = false, Ga = false;
          a.onRuntimeInitialized = function() {
            Fa = true;
            if (Ga && "function" === typeof a.onModuleLoaded) a.onModuleLoaded(a);
          };
          a.onModuleParsed = function() {
            Ga = true;
            if (Fa && "function" === typeof a.onModuleLoaded) a.onModuleLoaded(a);
          };
          a.isVersionSupported = function(f) {
            if ("string" !== typeof f) return false;
            f = f.split(".");
            return 2 > f.length || 3 < f.length ? false : 1 == f[0] && 0 <= f[1] && 5 >= f[1] ? true : 0 != f[0] || 10 < f[1] ? false : true;
          };
          var Ha = Object.assign({}, a), oa = "object" == typeof window, Y = "function" == typeof importScripts, Ia = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, L = "";
          if (Ia) {
            var Ja = (init_fs(), __toCommonJS(fs_exports)), la = (init_path(), __toCommonJS(path_exports));
            L = Y ? la.dirname(L) + "/" : __dirname + "/";
            var Ka = function(f, b) {
              f = f.startsWith("file://") ? new URL(f) : la.normalize(f);
              return Ja.readFileSync(f, b ? void 0 : "utf8");
            };
            var ia = function(f) {
              f = Ka(f, true);
              f.buffer || (f = new Uint8Array(f));
              return f;
            };
            var ja = function(f, b, c) {
              f = f.startsWith("file://") ? new URL(f) : la.normalize(f);
              Ja.readFile(f, function(d, e) {
                d ? c(d) : b(e.buffer);
              });
            };
            1 < process.argv.length && process.argv[1].replace(/\\/g, "/");
            process.argv.slice(2);
            a.inspect = function() {
              return "[Emscripten Module object]";
            };
          } else if (oa || Y) Y ? L = self.location.href : "undefined" != typeof document && document.currentScript && (L = document.currentScript.src), l && (L = l), L = 0 !== L.indexOf("blob:") ? L.substr(0, L.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", Ka = function(f) {
            var b = new XMLHttpRequest();
            b.open("GET", f, false);
            b.send(null);
            return b.responseText;
          }, Y && (ia = function(f) {
            var b = new XMLHttpRequest();
            b.open("GET", f, false);
            b.responseType = "arraybuffer";
            b.send(null);
            return new Uint8Array(b.response);
          }), ja = function(f, b, c) {
            var d = new XMLHttpRequest();
            d.open("GET", f, true);
            d.responseType = "arraybuffer";
            d.onload = function() {
              200 == d.status || 0 == d.status && d.response ? b(d.response) : c();
            };
            d.onerror = c;
            d.send(null);
          };
          a.print || console.log.bind(console);
          var W = a.printErr || console.warn.bind(console);
          Object.assign(a, Ha);
          Ha = null;
          var X;
          a.wasmBinary && (X = a.wasmBinary);
          "object" != typeof WebAssembly && k("no native wasm support detected");
          var ba, na = false, O, fa, ea, S, T, ha, ta = [], ka = [], sa = [], qa = false, U = 0, ma = null, aa = null;
          var K = "draco_encoder.wasm";
          K.startsWith("data:application/octet-stream;base64,") || (K = m(K));
          var pc = 0, qc = { b: function(f, b, c) {
            new w(f).init(b, c);
            pc++;
            throw f;
          }, a: function() {
            k("");
          }, d: function(f, b, c) {
            fa.copyWithin(f, b, b + c);
          }, c: function(f) {
            var b = fa.length;
            f >>>= 0;
            if (2147483648 < f) return false;
            for (var c = 1; 4 >= c; c *= 2) {
              var d = b * (1 + 0.2 / c);
              d = Math.min(d, f + 100663296);
              var e = Math;
              d = Math.max(f, d);
              e = e.min.call(
                e,
                2147483648,
                d + (65536 - d % 65536) % 65536
              );
              a: {
                d = ba.buffer;
                try {
                  ba.grow(e - d.byteLength + 65535 >>> 16);
                  r();
                  var g = 1;
                  break a;
                } catch (t) {
                }
                g = void 0;
              }
              if (g) return true;
            }
            return false;
          } };
          (function() {
            function f(e, g) {
              a.asm = e.exports;
              ba = a.asm.e;
              r();
              ka.unshift(a.asm.f);
              U--;
              a.monitorRunDependencies && a.monitorRunDependencies(U);
              0 == U && (null !== ma && (clearInterval(ma), ma = null), aa && (e = aa, aa = null, e()));
            }
            function b(e) {
              f(e.instance);
            }
            function c(e) {
              return h().then(function(g) {
                return WebAssembly.instantiate(g, d);
              }).then(function(g) {
                return g;
              }).then(e, function(g) {
                W("failed to asynchronously prepare wasm: " + g);
                k(g);
              });
            }
            var d = { a: qc };
            U++;
            a.monitorRunDependencies && a.monitorRunDependencies(U);
            if (a.instantiateWasm) try {
              return a.instantiateWasm(d, f);
            } catch (e) {
              W("Module.instantiateWasm callback failed with error: " + e), ca(e);
            }
            (function() {
              return X || "function" != typeof WebAssembly.instantiateStreaming || K.startsWith("data:application/octet-stream;base64,") || K.startsWith("file://") || Ia || "function" != typeof fetch ? c(b) : fetch(K, { credentials: "same-origin" }).then(function(e) {
                return WebAssembly.instantiateStreaming(e, d).then(
                  b,
                  function(g) {
                    W("wasm streaming compile failed: " + g);
                    W("falling back to ArrayBuffer instantiation");
                    return c(b);
                  }
                );
              });
            })().catch(ca);
            return {};
          })();
          var La = a._emscripten_bind_VoidPtr___destroy___0 = function() {
            return (La = a._emscripten_bind_VoidPtr___destroy___0 = a.asm.h).apply(null, arguments);
          }, ua = a._emscripten_bind_GeometryAttribute_GeometryAttribute_0 = function() {
            return (ua = a._emscripten_bind_GeometryAttribute_GeometryAttribute_0 = a.asm.i).apply(null, arguments);
          }, Ma = a._emscripten_bind_GeometryAttribute___destroy___0 = function() {
            return (Ma = a._emscripten_bind_GeometryAttribute___destroy___0 = a.asm.j).apply(null, arguments);
          }, va = a._emscripten_bind_PointAttribute_PointAttribute_0 = function() {
            return (va = a._emscripten_bind_PointAttribute_PointAttribute_0 = a.asm.k).apply(null, arguments);
          }, Na = a._emscripten_bind_PointAttribute_size_0 = function() {
            return (Na = a._emscripten_bind_PointAttribute_size_0 = a.asm.l).apply(null, arguments);
          }, Oa = a._emscripten_bind_PointAttribute_attribute_type_0 = function() {
            return (Oa = a._emscripten_bind_PointAttribute_attribute_type_0 = a.asm.m).apply(null, arguments);
          }, Pa = a._emscripten_bind_PointAttribute_data_type_0 = function() {
            return (Pa = a._emscripten_bind_PointAttribute_data_type_0 = a.asm.n).apply(null, arguments);
          }, Qa = a._emscripten_bind_PointAttribute_num_components_0 = function() {
            return (Qa = a._emscripten_bind_PointAttribute_num_components_0 = a.asm.o).apply(null, arguments);
          }, Ra = a._emscripten_bind_PointAttribute_normalized_0 = function() {
            return (Ra = a._emscripten_bind_PointAttribute_normalized_0 = a.asm.p).apply(null, arguments);
          }, Sa = a._emscripten_bind_PointAttribute_byte_stride_0 = function() {
            return (Sa = a._emscripten_bind_PointAttribute_byte_stride_0 = a.asm.q).apply(null, arguments);
          }, Ta = a._emscripten_bind_PointAttribute_byte_offset_0 = function() {
            return (Ta = a._emscripten_bind_PointAttribute_byte_offset_0 = a.asm.r).apply(null, arguments);
          }, Ua = a._emscripten_bind_PointAttribute_unique_id_0 = function() {
            return (Ua = a._emscripten_bind_PointAttribute_unique_id_0 = a.asm.s).apply(null, arguments);
          }, Va = a._emscripten_bind_PointAttribute___destroy___0 = function() {
            return (Va = a._emscripten_bind_PointAttribute___destroy___0 = a.asm.t).apply(null, arguments);
          }, wa = a._emscripten_bind_PointCloud_PointCloud_0 = function() {
            return (wa = a._emscripten_bind_PointCloud_PointCloud_0 = a.asm.u).apply(null, arguments);
          }, Wa = a._emscripten_bind_PointCloud_num_attributes_0 = function() {
            return (Wa = a._emscripten_bind_PointCloud_num_attributes_0 = a.asm.v).apply(null, arguments);
          }, Xa = a._emscripten_bind_PointCloud_num_points_0 = function() {
            return (Xa = a._emscripten_bind_PointCloud_num_points_0 = a.asm.w).apply(null, arguments);
          }, Ya = a._emscripten_bind_PointCloud___destroy___0 = function() {
            return (Ya = a._emscripten_bind_PointCloud___destroy___0 = a.asm.x).apply(null, arguments);
          }, xa = a._emscripten_bind_Mesh_Mesh_0 = function() {
            return (xa = a._emscripten_bind_Mesh_Mesh_0 = a.asm.y).apply(null, arguments);
          }, Za = a._emscripten_bind_Mesh_num_faces_0 = function() {
            return (Za = a._emscripten_bind_Mesh_num_faces_0 = a.asm.z).apply(null, arguments);
          }, $a = a._emscripten_bind_Mesh_num_attributes_0 = function() {
            return ($a = a._emscripten_bind_Mesh_num_attributes_0 = a.asm.A).apply(null, arguments);
          }, ab = a._emscripten_bind_Mesh_num_points_0 = function() {
            return (ab = a._emscripten_bind_Mesh_num_points_0 = a.asm.B).apply(null, arguments);
          }, bb = a._emscripten_bind_Mesh_set_num_points_1 = function() {
            return (bb = a._emscripten_bind_Mesh_set_num_points_1 = a.asm.C).apply(null, arguments);
          }, cb = a._emscripten_bind_Mesh___destroy___0 = function() {
            return (cb = a._emscripten_bind_Mesh___destroy___0 = a.asm.D).apply(null, arguments);
          }, ya = a._emscripten_bind_Metadata_Metadata_0 = function() {
            return (ya = a._emscripten_bind_Metadata_Metadata_0 = a.asm.E).apply(null, arguments);
          }, db = a._emscripten_bind_Metadata___destroy___0 = function() {
            return (db = a._emscripten_bind_Metadata___destroy___0 = a.asm.F).apply(null, arguments);
          }, za = a._emscripten_bind_DracoInt8Array_DracoInt8Array_0 = function() {
            return (za = a._emscripten_bind_DracoInt8Array_DracoInt8Array_0 = a.asm.G).apply(null, arguments);
          }, eb = a._emscripten_bind_DracoInt8Array_GetValue_1 = function() {
            return (eb = a._emscripten_bind_DracoInt8Array_GetValue_1 = a.asm.H).apply(null, arguments);
          }, fb = a._emscripten_bind_DracoInt8Array_size_0 = function() {
            return (fb = a._emscripten_bind_DracoInt8Array_size_0 = a.asm.I).apply(null, arguments);
          }, gb = a._emscripten_bind_DracoInt8Array___destroy___0 = function() {
            return (gb = a._emscripten_bind_DracoInt8Array___destroy___0 = a.asm.J).apply(null, arguments);
          }, Aa = a._emscripten_bind_MetadataBuilder_MetadataBuilder_0 = function() {
            return (Aa = a._emscripten_bind_MetadataBuilder_MetadataBuilder_0 = a.asm.K).apply(null, arguments);
          }, hb = a._emscripten_bind_MetadataBuilder_AddStringEntry_3 = function() {
            return (hb = a._emscripten_bind_MetadataBuilder_AddStringEntry_3 = a.asm.L).apply(null, arguments);
          }, ib = a._emscripten_bind_MetadataBuilder_AddIntEntry_3 = function() {
            return (ib = a._emscripten_bind_MetadataBuilder_AddIntEntry_3 = a.asm.M).apply(null, arguments);
          }, jb = a._emscripten_bind_MetadataBuilder_AddIntEntryArray_4 = function() {
            return (jb = a._emscripten_bind_MetadataBuilder_AddIntEntryArray_4 = a.asm.N).apply(null, arguments);
          }, kb = a._emscripten_bind_MetadataBuilder_AddDoubleEntry_3 = function() {
            return (kb = a._emscripten_bind_MetadataBuilder_AddDoubleEntry_3 = a.asm.O).apply(null, arguments);
          }, lb = a._emscripten_bind_MetadataBuilder___destroy___0 = function() {
            return (lb = a._emscripten_bind_MetadataBuilder___destroy___0 = a.asm.P).apply(null, arguments);
          }, Ba = a._emscripten_bind_PointCloudBuilder_PointCloudBuilder_0 = function() {
            return (Ba = a._emscripten_bind_PointCloudBuilder_PointCloudBuilder_0 = a.asm.Q).apply(null, arguments);
          }, mb = a._emscripten_bind_PointCloudBuilder_AddFloatAttribute_5 = function() {
            return (mb = a._emscripten_bind_PointCloudBuilder_AddFloatAttribute_5 = a.asm.R).apply(null, arguments);
          }, nb = a._emscripten_bind_PointCloudBuilder_AddInt8Attribute_5 = function() {
            return (nb = a._emscripten_bind_PointCloudBuilder_AddInt8Attribute_5 = a.asm.S).apply(null, arguments);
          }, ob = a._emscripten_bind_PointCloudBuilder_AddUInt8Attribute_5 = function() {
            return (ob = a._emscripten_bind_PointCloudBuilder_AddUInt8Attribute_5 = a.asm.T).apply(null, arguments);
          }, pb = a._emscripten_bind_PointCloudBuilder_AddInt16Attribute_5 = function() {
            return (pb = a._emscripten_bind_PointCloudBuilder_AddInt16Attribute_5 = a.asm.U).apply(null, arguments);
          }, qb = a._emscripten_bind_PointCloudBuilder_AddUInt16Attribute_5 = function() {
            return (qb = a._emscripten_bind_PointCloudBuilder_AddUInt16Attribute_5 = a.asm.V).apply(null, arguments);
          }, rb = a._emscripten_bind_PointCloudBuilder_AddInt32Attribute_5 = function() {
            return (rb = a._emscripten_bind_PointCloudBuilder_AddInt32Attribute_5 = a.asm.W).apply(null, arguments);
          }, sb = a._emscripten_bind_PointCloudBuilder_AddUInt32Attribute_5 = function() {
            return (sb = a._emscripten_bind_PointCloudBuilder_AddUInt32Attribute_5 = a.asm.X).apply(null, arguments);
          }, tb = a._emscripten_bind_PointCloudBuilder_AddMetadata_2 = function() {
            return (tb = a._emscripten_bind_PointCloudBuilder_AddMetadata_2 = a.asm.Y).apply(null, arguments);
          }, ub = a._emscripten_bind_PointCloudBuilder_SetMetadataForAttribute_3 = function() {
            return (ub = a._emscripten_bind_PointCloudBuilder_SetMetadataForAttribute_3 = a.asm.Z).apply(null, arguments);
          }, vb = a._emscripten_bind_PointCloudBuilder_SetNormalizedFlagForAttribute_3 = function() {
            return (vb = a._emscripten_bind_PointCloudBuilder_SetNormalizedFlagForAttribute_3 = a.asm._).apply(null, arguments);
          }, wb = a._emscripten_bind_PointCloudBuilder___destroy___0 = function() {
            return (wb = a._emscripten_bind_PointCloudBuilder___destroy___0 = a.asm.$).apply(null, arguments);
          }, Ca = a._emscripten_bind_MeshBuilder_MeshBuilder_0 = function() {
            return (Ca = a._emscripten_bind_MeshBuilder_MeshBuilder_0 = a.asm.aa).apply(null, arguments);
          }, xb = a._emscripten_bind_MeshBuilder_AddFacesToMesh_3 = function() {
            return (xb = a._emscripten_bind_MeshBuilder_AddFacesToMesh_3 = a.asm.ba).apply(null, arguments);
          }, yb = a._emscripten_bind_MeshBuilder_AddFloatAttributeToMesh_5 = function() {
            return (yb = a._emscripten_bind_MeshBuilder_AddFloatAttributeToMesh_5 = a.asm.ca).apply(null, arguments);
          }, zb = a._emscripten_bind_MeshBuilder_AddInt32AttributeToMesh_5 = function() {
            return (zb = a._emscripten_bind_MeshBuilder_AddInt32AttributeToMesh_5 = a.asm.da).apply(null, arguments);
          }, Ab = a._emscripten_bind_MeshBuilder_AddMetadataToMesh_2 = function() {
            return (Ab = a._emscripten_bind_MeshBuilder_AddMetadataToMesh_2 = a.asm.ea).apply(null, arguments);
          }, Bb = a._emscripten_bind_MeshBuilder_AddFloatAttribute_5 = function() {
            return (Bb = a._emscripten_bind_MeshBuilder_AddFloatAttribute_5 = a.asm.fa).apply(
              null,
              arguments
            );
          }, Cb = a._emscripten_bind_MeshBuilder_AddInt8Attribute_5 = function() {
            return (Cb = a._emscripten_bind_MeshBuilder_AddInt8Attribute_5 = a.asm.ga).apply(null, arguments);
          }, Db = a._emscripten_bind_MeshBuilder_AddUInt8Attribute_5 = function() {
            return (Db = a._emscripten_bind_MeshBuilder_AddUInt8Attribute_5 = a.asm.ha).apply(null, arguments);
          }, Eb = a._emscripten_bind_MeshBuilder_AddInt16Attribute_5 = function() {
            return (Eb = a._emscripten_bind_MeshBuilder_AddInt16Attribute_5 = a.asm.ia).apply(null, arguments);
          }, Fb = a._emscripten_bind_MeshBuilder_AddUInt16Attribute_5 = function() {
            return (Fb = a._emscripten_bind_MeshBuilder_AddUInt16Attribute_5 = a.asm.ja).apply(null, arguments);
          }, Gb = a._emscripten_bind_MeshBuilder_AddInt32Attribute_5 = function() {
            return (Gb = a._emscripten_bind_MeshBuilder_AddInt32Attribute_5 = a.asm.ka).apply(null, arguments);
          }, Hb = a._emscripten_bind_MeshBuilder_AddUInt32Attribute_5 = function() {
            return (Hb = a._emscripten_bind_MeshBuilder_AddUInt32Attribute_5 = a.asm.la).apply(null, arguments);
          }, Ib = a._emscripten_bind_MeshBuilder_AddMetadata_2 = function() {
            return (Ib = a._emscripten_bind_MeshBuilder_AddMetadata_2 = a.asm.ma).apply(null, arguments);
          }, Jb = a._emscripten_bind_MeshBuilder_SetMetadataForAttribute_3 = function() {
            return (Jb = a._emscripten_bind_MeshBuilder_SetMetadataForAttribute_3 = a.asm.na).apply(null, arguments);
          }, Kb = a._emscripten_bind_MeshBuilder_SetNormalizedFlagForAttribute_3 = function() {
            return (Kb = a._emscripten_bind_MeshBuilder_SetNormalizedFlagForAttribute_3 = a.asm.oa).apply(null, arguments);
          }, Lb = a._emscripten_bind_MeshBuilder___destroy___0 = function() {
            return (Lb = a._emscripten_bind_MeshBuilder___destroy___0 = a.asm.pa).apply(null, arguments);
          }, Da = a._emscripten_bind_Encoder_Encoder_0 = function() {
            return (Da = a._emscripten_bind_Encoder_Encoder_0 = a.asm.qa).apply(null, arguments);
          }, Mb = a._emscripten_bind_Encoder_SetEncodingMethod_1 = function() {
            return (Mb = a._emscripten_bind_Encoder_SetEncodingMethod_1 = a.asm.ra).apply(null, arguments);
          }, Nb = a._emscripten_bind_Encoder_SetAttributeQuantization_2 = function() {
            return (Nb = a._emscripten_bind_Encoder_SetAttributeQuantization_2 = a.asm.sa).apply(null, arguments);
          }, Ob = a._emscripten_bind_Encoder_SetAttributeExplicitQuantization_5 = function() {
            return (Ob = a._emscripten_bind_Encoder_SetAttributeExplicitQuantization_5 = a.asm.ta).apply(null, arguments);
          }, Pb = a._emscripten_bind_Encoder_SetSpeedOptions_2 = function() {
            return (Pb = a._emscripten_bind_Encoder_SetSpeedOptions_2 = a.asm.ua).apply(null, arguments);
          }, Qb = a._emscripten_bind_Encoder_SetTrackEncodedProperties_1 = function() {
            return (Qb = a._emscripten_bind_Encoder_SetTrackEncodedProperties_1 = a.asm.va).apply(null, arguments);
          }, Rb = a._emscripten_bind_Encoder_EncodeMeshToDracoBuffer_2 = function() {
            return (Rb = a._emscripten_bind_Encoder_EncodeMeshToDracoBuffer_2 = a.asm.wa).apply(null, arguments);
          }, Sb = a._emscripten_bind_Encoder_EncodePointCloudToDracoBuffer_3 = function() {
            return (Sb = a._emscripten_bind_Encoder_EncodePointCloudToDracoBuffer_3 = a.asm.xa).apply(null, arguments);
          }, Tb = a._emscripten_bind_Encoder_GetNumberOfEncodedPoints_0 = function() {
            return (Tb = a._emscripten_bind_Encoder_GetNumberOfEncodedPoints_0 = a.asm.ya).apply(null, arguments);
          }, Ub = a._emscripten_bind_Encoder_GetNumberOfEncodedFaces_0 = function() {
            return (Ub = a._emscripten_bind_Encoder_GetNumberOfEncodedFaces_0 = a.asm.za).apply(null, arguments);
          }, Vb = a._emscripten_bind_Encoder___destroy___0 = function() {
            return (Vb = a._emscripten_bind_Encoder___destroy___0 = a.asm.Aa).apply(null, arguments);
          }, Ea = a._emscripten_bind_ExpertEncoder_ExpertEncoder_1 = function() {
            return (Ea = a._emscripten_bind_ExpertEncoder_ExpertEncoder_1 = a.asm.Ba).apply(null, arguments);
          }, Wb = a._emscripten_bind_ExpertEncoder_SetEncodingMethod_1 = function() {
            return (Wb = a._emscripten_bind_ExpertEncoder_SetEncodingMethod_1 = a.asm.Ca).apply(null, arguments);
          }, Xb = a._emscripten_bind_ExpertEncoder_SetAttributeQuantization_2 = function() {
            return (Xb = a._emscripten_bind_ExpertEncoder_SetAttributeQuantization_2 = a.asm.Da).apply(null, arguments);
          }, Yb = a._emscripten_bind_ExpertEncoder_SetAttributeExplicitQuantization_5 = function() {
            return (Yb = a._emscripten_bind_ExpertEncoder_SetAttributeExplicitQuantization_5 = a.asm.Ea).apply(null, arguments);
          }, Zb = a._emscripten_bind_ExpertEncoder_SetSpeedOptions_2 = function() {
            return (Zb = a._emscripten_bind_ExpertEncoder_SetSpeedOptions_2 = a.asm.Fa).apply(null, arguments);
          }, $b = a._emscripten_bind_ExpertEncoder_SetTrackEncodedProperties_1 = function() {
            return ($b = a._emscripten_bind_ExpertEncoder_SetTrackEncodedProperties_1 = a.asm.Ga).apply(null, arguments);
          }, ac = a._emscripten_bind_ExpertEncoder_EncodeToDracoBuffer_2 = function() {
            return (ac = a._emscripten_bind_ExpertEncoder_EncodeToDracoBuffer_2 = a.asm.Ha).apply(null, arguments);
          }, bc = a._emscripten_bind_ExpertEncoder_GetNumberOfEncodedPoints_0 = function() {
            return (bc = a._emscripten_bind_ExpertEncoder_GetNumberOfEncodedPoints_0 = a.asm.Ia).apply(null, arguments);
          }, cc = a._emscripten_bind_ExpertEncoder_GetNumberOfEncodedFaces_0 = function() {
            return (cc = a._emscripten_bind_ExpertEncoder_GetNumberOfEncodedFaces_0 = a.asm.Ja).apply(null, arguments);
          }, dc = a._emscripten_bind_ExpertEncoder___destroy___0 = function() {
            return (dc = a._emscripten_bind_ExpertEncoder___destroy___0 = a.asm.Ka).apply(null, arguments);
          }, ec = a._emscripten_enum_draco_GeometryAttribute_Type_INVALID = function() {
            return (ec = a._emscripten_enum_draco_GeometryAttribute_Type_INVALID = a.asm.La).apply(
              null,
              arguments
            );
          }, fc = a._emscripten_enum_draco_GeometryAttribute_Type_POSITION = function() {
            return (fc = a._emscripten_enum_draco_GeometryAttribute_Type_POSITION = a.asm.Ma).apply(null, arguments);
          }, gc = a._emscripten_enum_draco_GeometryAttribute_Type_NORMAL = function() {
            return (gc = a._emscripten_enum_draco_GeometryAttribute_Type_NORMAL = a.asm.Na).apply(null, arguments);
          }, hc = a._emscripten_enum_draco_GeometryAttribute_Type_COLOR = function() {
            return (hc = a._emscripten_enum_draco_GeometryAttribute_Type_COLOR = a.asm.Oa).apply(
              null,
              arguments
            );
          }, ic = a._emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD = function() {
            return (ic = a._emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD = a.asm.Pa).apply(null, arguments);
          }, jc = a._emscripten_enum_draco_GeometryAttribute_Type_GENERIC = function() {
            return (jc = a._emscripten_enum_draco_GeometryAttribute_Type_GENERIC = a.asm.Qa).apply(null, arguments);
          }, kc = a._emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE = function() {
            return (kc = a._emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE = a.asm.Ra).apply(null, arguments);
          }, lc = a._emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD = function() {
            return (lc = a._emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD = a.asm.Sa).apply(null, arguments);
          }, mc = a._emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH = function() {
            return (mc = a._emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH = a.asm.Ta).apply(null, arguments);
          }, nc = a._emscripten_enum_draco_MeshEncoderMethod_MESH_SEQUENTIAL_ENCODING = function() {
            return (nc = a._emscripten_enum_draco_MeshEncoderMethod_MESH_SEQUENTIAL_ENCODING = a.asm.Ua).apply(null, arguments);
          }, oc = a._emscripten_enum_draco_MeshEncoderMethod_MESH_EDGEBREAKER_ENCODING = function() {
            return (oc = a._emscripten_enum_draco_MeshEncoderMethod_MESH_EDGEBREAKER_ENCODING = a.asm.Va).apply(null, arguments);
          };
          a._malloc = function() {
            return (a._malloc = a.asm.Wa).apply(null, arguments);
          };
          a._free = function() {
            return (a._free = a.asm.Xa).apply(null, arguments);
          };
          var pa = function() {
            return (pa = a.asm.Ya).apply(null, arguments);
          };
          a.___start_em_js = 19116;
          a.___stop_em_js = 19214;
          var da;
          aa = function b() {
            da || B();
            da || (aa = b);
          };
          if (a.preInit) for ("function" == typeof a.preInit && (a.preInit = [a.preInit]); 0 < a.preInit.length; ) a.preInit.pop()();
          B();
          v.prototype = Object.create(v.prototype);
          v.prototype.constructor = v;
          v.prototype.__class__ = v;
          v.__cache__ = {};
          a.WrapperObject = v;
          a.getCache = D;
          a.wrapPointer = I;
          a.castObject = function(b, c) {
            return I(b.ptr, c);
          };
          a.NULL = I(0);
          a.destroy = function(b) {
            if (!b.__destroy__) throw "Error: Cannot destroy object. (Did you create it yourself?)";
            b.__destroy__();
            delete D(b.__class__)[b.ptr];
          };
          a.compare = function(b, c) {
            return b.ptr === c.ptr;
          };
          a.getPointer = function(b) {
            return b.ptr;
          };
          a.getClass = function(b) {
            return b.__class__;
          };
          var n = { buffer: 0, size: 0, pos: 0, temps: [], needed: 0, prepare: function() {
            if (n.needed) {
              for (var b = 0; b < n.temps.length; b++) a._free(n.temps[b]);
              n.temps.length = 0;
              a._free(n.buffer);
              n.buffer = 0;
              n.size += n.needed;
              n.needed = 0;
            }
            n.buffer || (n.size += 128, n.buffer = a._malloc(n.size), n.buffer || k(void 0));
            n.pos = 0;
          }, alloc: function(b, c) {
            n.buffer || k(void 0);
            b = b.length * c.BYTES_PER_ELEMENT;
            b = b + 7 & -8;
            n.pos + b >= n.size ? (0 < b || k(void 0), n.needed += b, c = a._malloc(b), n.temps.push(c)) : (c = n.buffer + n.pos, n.pos += b);
            return c;
          }, copy: function(b, c, d) {
            d >>>= 0;
            switch (c.BYTES_PER_ELEMENT) {
              case 2:
                d >>>= 1;
                break;
              case 4:
                d >>>= 2;
                break;
              case 8:
                d >>>= 3;
            }
            for (var e = 0; e < b.length; e++) c[d + e] = b[e];
          } };
          P.prototype = Object.create(v.prototype);
          P.prototype.constructor = P;
          P.prototype.__class__ = P;
          P.__cache__ = {};
          a.VoidPtr = P;
          P.prototype.__destroy__ = P.prototype.__destroy__ = function() {
            La(this.ptr);
          };
          M.prototype = Object.create(v.prototype);
          M.prototype.constructor = M;
          M.prototype.__class__ = M;
          M.__cache__ = {};
          a.GeometryAttribute = M;
          M.prototype.__destroy__ = M.prototype.__destroy__ = function() {
            Ma(this.ptr);
          };
          z.prototype = Object.create(v.prototype);
          z.prototype.constructor = z;
          z.prototype.__class__ = z;
          z.__cache__ = {};
          a.PointAttribute = z;
          z.prototype.size = z.prototype.size = function() {
            return Na(this.ptr);
          };
          z.prototype.attribute_type = z.prototype.attribute_type = function() {
            return Oa(this.ptr);
          };
          z.prototype.data_type = z.prototype.data_type = function() {
            return Pa(this.ptr);
          };
          z.prototype.num_components = z.prototype.num_components = function() {
            return Qa(this.ptr);
          };
          z.prototype.normalized = z.prototype.normalized = function() {
            return !!Ra(this.ptr);
          };
          z.prototype.byte_stride = z.prototype.byte_stride = function() {
            return Sa(this.ptr);
          };
          z.prototype.byte_offset = z.prototype.byte_offset = function() {
            return Ta(this.ptr);
          };
          z.prototype.unique_id = z.prototype.unique_id = function() {
            return Ua(this.ptr);
          };
          z.prototype.__destroy__ = z.prototype.__destroy__ = function() {
            Va(this.ptr);
          };
          G.prototype = Object.create(v.prototype);
          G.prototype.constructor = G;
          G.prototype.__class__ = G;
          G.__cache__ = {};
          a.PointCloud = G;
          G.prototype.num_attributes = G.prototype.num_attributes = function() {
            return Wa(this.ptr);
          };
          G.prototype.num_points = G.prototype.num_points = function() {
            return Xa(this.ptr);
          };
          G.prototype.__destroy__ = G.prototype.__destroy__ = function() {
            Ya(this.ptr);
          };
          E.prototype = Object.create(v.prototype);
          E.prototype.constructor = E;
          E.prototype.__class__ = E;
          E.__cache__ = {};
          a.Mesh = E;
          E.prototype.num_faces = E.prototype.num_faces = function() {
            return Za(this.ptr);
          };
          E.prototype.num_attributes = E.prototype.num_attributes = function() {
            return $a(this.ptr);
          };
          E.prototype.num_points = E.prototype.num_points = function() {
            return ab(this.ptr);
          };
          E.prototype.set_num_points = E.prototype.set_num_points = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            bb(c, b);
          };
          E.prototype.__destroy__ = E.prototype.__destroy__ = function() {
            cb(this.ptr);
          };
          N.prototype = Object.create(v.prototype);
          N.prototype.constructor = N;
          N.prototype.__class__ = N;
          N.__cache__ = {};
          a.Metadata = N;
          N.prototype.__destroy__ = N.prototype.__destroy__ = function() {
            db(this.ptr);
          };
          H.prototype = Object.create(v.prototype);
          H.prototype.constructor = H;
          H.prototype.__class__ = H;
          H.__cache__ = {};
          a.DracoInt8Array = H;
          H.prototype.GetValue = H.prototype.GetValue = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            return eb(c, b);
          };
          H.prototype.size = H.prototype.size = function() {
            return fb(this.ptr);
          };
          H.prototype.__destroy__ = H.prototype.__destroy__ = function() {
            gb(this.ptr);
          };
          F.prototype = Object.create(v.prototype);
          F.prototype.constructor = F;
          F.prototype.__class__ = F;
          F.__cache__ = {};
          a.MetadataBuilder = F;
          F.prototype.AddStringEntry = F.prototype.AddStringEntry = function(b, c, d) {
            var e = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c = c && "object" === typeof c ? c.ptr : J(c);
            d = d && "object" === typeof d ? d.ptr : J(d);
            return !!hb(e, b, c, d);
          };
          F.prototype.AddIntEntry = F.prototype.AddIntEntry = function(b, c, d) {
            var e = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c = c && "object" === typeof c ? c.ptr : J(c);
            d && "object" === typeof d && (d = d.ptr);
            return !!ib(e, b, c, d);
          };
          F.prototype.AddIntEntryArray = F.prototype.AddIntEntryArray = function(b, c, d, e) {
            var g = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c = c && "object" === typeof c ? c.ptr : J(c);
            "object" == typeof d && (d = V(d));
            e && "object" === typeof e && (e = e.ptr);
            return !!jb(g, b, c, d, e);
          };
          F.prototype.AddDoubleEntry = F.prototype.AddDoubleEntry = function(b, c, d) {
            var e = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c = c && "object" === typeof c ? c.ptr : J(c);
            d && "object" === typeof d && (d = d.ptr);
            return !!kb(e, b, c, d);
          };
          F.prototype.__destroy__ = F.prototype.__destroy__ = function() {
            lb(this.ptr);
          };
          x.prototype = Object.create(v.prototype);
          x.prototype.constructor = x;
          x.prototype.__class__ = x;
          x.__cache__ = {};
          a.PointCloudBuilder = x;
          x.prototype.AddFloatAttribute = x.prototype.AddFloatAttribute = function(b, c, d, e, g) {
            var t = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            e && "object" === typeof e && (e = e.ptr);
            "object" == typeof g && (g = Z(g));
            return mb(t, b, c, d, e, g);
          };
          x.prototype.AddInt8Attribute = x.prototype.AddInt8Attribute = function(b, c, d, e, g) {
            var t = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            e && "object" === typeof e && (e = e.ptr);
            "object" == typeof g && (g = Q(g));
            return nb(t, b, c, d, e, g);
          };
          x.prototype.AddUInt8Attribute = x.prototype.AddUInt8Attribute = function(b, c, d, e, g) {
            var t = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            e && "object" === typeof e && (e = e.ptr);
            "object" == typeof g && (g = Q(g));
            return ob(t, b, c, d, e, g);
          };
          x.prototype.AddInt16Attribute = x.prototype.AddInt16Attribute = function(b, c, d, e, g) {
            var t = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            e && "object" === typeof e && (e = e.ptr);
            "object" == typeof g && (g = R(g));
            return pb(t, b, c, d, e, g);
          };
          x.prototype.AddUInt16Attribute = x.prototype.AddUInt16Attribute = function(b, c, d, e, g) {
            var t = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            e && "object" === typeof e && (e = e.ptr);
            "object" == typeof g && (g = R(g));
            return qb(t, b, c, d, e, g);
          };
          x.prototype.AddInt32Attribute = x.prototype.AddInt32Attribute = function(b, c, d, e, g) {
            var t = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            e && "object" === typeof e && (e = e.ptr);
            "object" == typeof g && (g = V(g));
            return rb(t, b, c, d, e, g);
          };
          x.prototype.AddUInt32Attribute = x.prototype.AddUInt32Attribute = function(b, c, d, e, g) {
            var t = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            e && "object" === typeof e && (e = e.ptr);
            "object" == typeof g && (g = V(g));
            return sb(t, b, c, d, e, g);
          };
          x.prototype.AddMetadata = x.prototype.AddMetadata = function(b, c) {
            var d = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            return !!tb(d, b, c);
          };
          x.prototype.SetMetadataForAttribute = x.prototype.SetMetadataForAttribute = function(b, c, d) {
            var e = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            return !!ub(e, b, c, d);
          };
          x.prototype.SetNormalizedFlagForAttribute = x.prototype.SetNormalizedFlagForAttribute = function(b, c, d) {
            var e = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            return !!vb(e, b, c, d);
          };
          x.prototype.__destroy__ = x.prototype.__destroy__ = function() {
            wb(this.ptr);
          };
          u.prototype = Object.create(v.prototype);
          u.prototype.constructor = u;
          u.prototype.__class__ = u;
          u.__cache__ = {};
          a.MeshBuilder = u;
          u.prototype.AddFacesToMesh = u.prototype.AddFacesToMesh = function(b, c, d) {
            var e = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            "object" == typeof d && (d = V(d));
            return !!xb(e, b, c, d);
          };
          u.prototype.AddFloatAttributeToMesh = u.prototype.AddFloatAttributeToMesh = function(b, c, d, e, g) {
            var t = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            e && "object" === typeof e && (e = e.ptr);
            "object" == typeof g && (g = Z(g));
            return yb(t, b, c, d, e, g);
          };
          u.prototype.AddInt32AttributeToMesh = u.prototype.AddInt32AttributeToMesh = function(b, c, d, e, g) {
            var t = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            e && "object" === typeof e && (e = e.ptr);
            "object" == typeof g && (g = V(g));
            return zb(t, b, c, d, e, g);
          };
          u.prototype.AddMetadataToMesh = u.prototype.AddMetadataToMesh = function(b, c) {
            var d = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            return !!Ab(d, b, c);
          };
          u.prototype.AddFloatAttribute = u.prototype.AddFloatAttribute = function(b, c, d, e, g) {
            var t = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            e && "object" === typeof e && (e = e.ptr);
            "object" == typeof g && (g = Z(g));
            return Bb(t, b, c, d, e, g);
          };
          u.prototype.AddInt8Attribute = u.prototype.AddInt8Attribute = function(b, c, d, e, g) {
            var t = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            e && "object" === typeof e && (e = e.ptr);
            "object" == typeof g && (g = Q(g));
            return Cb(t, b, c, d, e, g);
          };
          u.prototype.AddUInt8Attribute = u.prototype.AddUInt8Attribute = function(b, c, d, e, g) {
            var t = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            e && "object" === typeof e && (e = e.ptr);
            "object" == typeof g && (g = Q(g));
            return Db(t, b, c, d, e, g);
          };
          u.prototype.AddInt16Attribute = u.prototype.AddInt16Attribute = function(b, c, d, e, g) {
            var t = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            e && "object" === typeof e && (e = e.ptr);
            "object" == typeof g && (g = R(g));
            return Eb(t, b, c, d, e, g);
          };
          u.prototype.AddUInt16Attribute = u.prototype.AddUInt16Attribute = function(b, c, d, e, g) {
            var t = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            e && "object" === typeof e && (e = e.ptr);
            "object" == typeof g && (g = R(g));
            return Fb(t, b, c, d, e, g);
          };
          u.prototype.AddInt32Attribute = u.prototype.AddInt32Attribute = function(b, c, d, e, g) {
            var t = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            e && "object" === typeof e && (e = e.ptr);
            "object" == typeof g && (g = V(g));
            return Gb(t, b, c, d, e, g);
          };
          u.prototype.AddUInt32Attribute = u.prototype.AddUInt32Attribute = function(b, c, d, e, g) {
            var t = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            e && "object" === typeof e && (e = e.ptr);
            "object" == typeof g && (g = V(g));
            return Hb(t, b, c, d, e, g);
          };
          u.prototype.AddMetadata = u.prototype.AddMetadata = function(b, c) {
            var d = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            return !!Ib(d, b, c);
          };
          u.prototype.SetMetadataForAttribute = u.prototype.SetMetadataForAttribute = function(b, c, d) {
            var e = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            return !!Jb(e, b, c, d);
          };
          u.prototype.SetNormalizedFlagForAttribute = u.prototype.SetNormalizedFlagForAttribute = function(b, c, d) {
            var e = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            return !!Kb(e, b, c, d);
          };
          u.prototype.__destroy__ = u.prototype.__destroy__ = function() {
            Lb(this.ptr);
          };
          y.prototype = Object.create(v.prototype);
          y.prototype.constructor = y;
          y.prototype.__class__ = y;
          y.__cache__ = {};
          a.Encoder = y;
          y.prototype.SetEncodingMethod = y.prototype.SetEncodingMethod = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            Mb(c, b);
          };
          y.prototype.SetAttributeQuantization = y.prototype.SetAttributeQuantization = function(b, c) {
            var d = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            Nb(d, b, c);
          };
          y.prototype.SetAttributeExplicitQuantization = y.prototype.SetAttributeExplicitQuantization = function(b, c, d, e, g) {
            var t = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            "object" == typeof e && (e = Z(e));
            g && "object" === typeof g && (g = g.ptr);
            Ob(t, b, c, d, e, g);
          };
          y.prototype.SetSpeedOptions = y.prototype.SetSpeedOptions = function(b, c) {
            var d = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            Pb(d, b, c);
          };
          y.prototype.SetTrackEncodedProperties = y.prototype.SetTrackEncodedProperties = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            Qb(c, b);
          };
          y.prototype.EncodeMeshToDracoBuffer = y.prototype.EncodeMeshToDracoBuffer = function(b, c) {
            var d = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            return Rb(d, b, c);
          };
          y.prototype.EncodePointCloudToDracoBuffer = y.prototype.EncodePointCloudToDracoBuffer = function(b, c, d) {
            var e = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            return Sb(e, b, c, d);
          };
          y.prototype.GetNumberOfEncodedPoints = y.prototype.GetNumberOfEncodedPoints = function() {
            return Tb(this.ptr);
          };
          y.prototype.GetNumberOfEncodedFaces = y.prototype.GetNumberOfEncodedFaces = function() {
            return Ub(this.ptr);
          };
          y.prototype.__destroy__ = y.prototype.__destroy__ = function() {
            Vb(this.ptr);
          };
          A.prototype = Object.create(v.prototype);
          A.prototype.constructor = A;
          A.prototype.__class__ = A;
          A.__cache__ = {};
          a.ExpertEncoder = A;
          A.prototype.SetEncodingMethod = A.prototype.SetEncodingMethod = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            Wb(c, b);
          };
          A.prototype.SetAttributeQuantization = A.prototype.SetAttributeQuantization = function(b, c) {
            var d = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            Xb(d, b, c);
          };
          A.prototype.SetAttributeExplicitQuantization = A.prototype.SetAttributeExplicitQuantization = function(b, c, d, e, g) {
            var t = this.ptr;
            n.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            "object" == typeof e && (e = Z(e));
            g && "object" === typeof g && (g = g.ptr);
            Yb(t, b, c, d, e, g);
          };
          A.prototype.SetSpeedOptions = A.prototype.SetSpeedOptions = function(b, c) {
            var d = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            Zb(d, b, c);
          };
          A.prototype.SetTrackEncodedProperties = A.prototype.SetTrackEncodedProperties = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            $b(c, b);
          };
          A.prototype.EncodeToDracoBuffer = A.prototype.EncodeToDracoBuffer = function(b, c) {
            var d = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            return ac(d, b, c);
          };
          A.prototype.GetNumberOfEncodedPoints = A.prototype.GetNumberOfEncodedPoints = function() {
            return bc(this.ptr);
          };
          A.prototype.GetNumberOfEncodedFaces = A.prototype.GetNumberOfEncodedFaces = function() {
            return cc(this.ptr);
          };
          A.prototype.__destroy__ = A.prototype.__destroy__ = function() {
            dc(this.ptr);
          };
          (function() {
            function b() {
              a.INVALID = ec();
              a.POSITION = fc();
              a.NORMAL = gc();
              a.COLOR = hc();
              a.TEX_COORD = ic();
              a.GENERIC = jc();
              a.INVALID_GEOMETRY_TYPE = kc();
              a.POINT_CLOUD = lc();
              a.TRIANGULAR_MESH = mc();
              a.MESH_SEQUENTIAL_ENCODING = nc();
              a.MESH_EDGEBREAKER_ENCODING = oc();
            }
            qa ? b() : ka.unshift(b);
          })();
          if ("function" === typeof a.onModuleParsed) a.onModuleParsed();
          return p.ready;
        };
      })();
      "object" === typeof exports2 && "object" === typeof module2 ? module2.exports = DracoEncoderModule : "function" === typeof define && define.amd ? define([], function() {
        return DracoEncoderModule;
      }) : "object" === typeof exports2 && (exports2.DracoEncoderModule = DracoEncoderModule);
    }
  });

  // node_modules/draco3d/draco_decoder_nodejs.js
  var require_draco_decoder_nodejs = __commonJS({
    "node_modules/draco3d/draco_decoder_nodejs.js"(exports2, module2) {
      var $jscomp = $jscomp || {};
      $jscomp.scope = {};
      $jscomp.arrayIteratorImpl = function(k) {
        var n = 0;
        return function() {
          return n < k.length ? { done: false, value: k[n++] } : { done: true };
        };
      };
      $jscomp.arrayIterator = function(k) {
        return { next: $jscomp.arrayIteratorImpl(k) };
      };
      $jscomp.makeIterator = function(k) {
        var n = "undefined" != typeof Symbol && Symbol.iterator && k[Symbol.iterator];
        return n ? n.call(k) : $jscomp.arrayIterator(k);
      };
      $jscomp.ASSUME_ES5 = false;
      $jscomp.ASSUME_NO_NATIVE_MAP = false;
      $jscomp.ASSUME_NO_NATIVE_SET = false;
      $jscomp.SIMPLE_FROUND_POLYFILL = false;
      $jscomp.ISOLATE_POLYFILLS = false;
      $jscomp.FORCE_POLYFILL_PROMISE = false;
      $jscomp.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION = false;
      $jscomp.getGlobal = function(k) {
        k = ["object" == typeof globalThis && globalThis, k, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global];
        for (var n = 0; n < k.length; ++n) {
          var l = k[n];
          if (l && l.Math == Math) return l;
        }
        throw Error("Cannot find global object");
      };
      $jscomp.global = $jscomp.getGlobal(exports2);
      $jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(k, n, l) {
        if (k == Array.prototype || k == Object.prototype) return k;
        k[n] = l.value;
        return k;
      };
      $jscomp.IS_SYMBOL_NATIVE = "function" === typeof Symbol && "symbol" === typeof Symbol("x");
      $jscomp.TRUST_ES6_POLYFILLS = !$jscomp.ISOLATE_POLYFILLS || $jscomp.IS_SYMBOL_NATIVE;
      $jscomp.polyfills = {};
      $jscomp.propertyToPolyfillSymbol = {};
      $jscomp.POLYFILL_PREFIX = "$jscp$";
      $jscomp.polyfill = function(k, n, l, p) {
        n && ($jscomp.ISOLATE_POLYFILLS ? $jscomp.polyfillIsolated(k, n, l, p) : $jscomp.polyfillUnisolated(k, n, l, p));
      };
      $jscomp.polyfillUnisolated = function(k, n, l, p) {
        l = $jscomp.global;
        k = k.split(".");
        for (p = 0; p < k.length - 1; p++) {
          var h = k[p];
          if (!(h in l)) return;
          l = l[h];
        }
        k = k[k.length - 1];
        p = l[k];
        n = n(p);
        n != p && null != n && $jscomp.defineProperty(l, k, { configurable: true, writable: true, value: n });
      };
      $jscomp.polyfillIsolated = function(k, n, l, p) {
        var h = k.split(".");
        k = 1 === h.length;
        p = h[0];
        p = !k && p in $jscomp.polyfills ? $jscomp.polyfills : $jscomp.global;
        for (var A = 0; A < h.length - 1; A++) {
          var f = h[A];
          if (!(f in p)) return;
          p = p[f];
        }
        h = h[h.length - 1];
        l = $jscomp.IS_SYMBOL_NATIVE && "es6" === l ? p[h] : null;
        n = n(l);
        null != n && (k ? $jscomp.defineProperty($jscomp.polyfills, h, { configurable: true, writable: true, value: n }) : n !== l && (void 0 === $jscomp.propertyToPolyfillSymbol[h] && (l = 1e9 * Math.random() >>> 0, $jscomp.propertyToPolyfillSymbol[h] = $jscomp.IS_SYMBOL_NATIVE ? $jscomp.global.Symbol(h) : $jscomp.POLYFILL_PREFIX + l + "$" + h), $jscomp.defineProperty(p, $jscomp.propertyToPolyfillSymbol[h], { configurable: true, writable: true, value: n })));
      };
      $jscomp.polyfill("Promise", function(k) {
        function n() {
          this.batch_ = null;
        }
        function l(f) {
          return f instanceof h ? f : new h(function(q, v) {
            q(f);
          });
        }
        if (k && (!($jscomp.FORCE_POLYFILL_PROMISE || $jscomp.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION && "undefined" === typeof $jscomp.global.PromiseRejectionEvent) || !$jscomp.global.Promise || -1 === $jscomp.global.Promise.toString().indexOf("[native code]"))) return k;
        n.prototype.asyncExecute = function(f) {
          if (null == this.batch_) {
            this.batch_ = [];
            var q = this;
            this.asyncExecuteFunction(function() {
              q.executeBatch_();
            });
          }
          this.batch_.push(f);
        };
        var p = $jscomp.global.setTimeout;
        n.prototype.asyncExecuteFunction = function(f) {
          p(f, 0);
        };
        n.prototype.executeBatch_ = function() {
          for (; this.batch_ && this.batch_.length; ) {
            var f = this.batch_;
            this.batch_ = [];
            for (var q = 0; q < f.length; ++q) {
              var v = f[q];
              f[q] = null;
              try {
                v();
              } catch (z) {
                this.asyncThrow_(z);
              }
            }
          }
          this.batch_ = null;
        };
        n.prototype.asyncThrow_ = function(f) {
          this.asyncExecuteFunction(function() {
            throw f;
          });
        };
        var h = function(f) {
          this.state_ = 0;
          this.result_ = void 0;
          this.onSettledCallbacks_ = [];
          this.isRejectionHandled_ = false;
          var q = this.createResolveAndReject_();
          try {
            f(q.resolve, q.reject);
          } catch (v) {
            q.reject(v);
          }
        };
        h.prototype.createResolveAndReject_ = function() {
          function f(z) {
            return function(O) {
              v || (v = true, z.call(q, O));
            };
          }
          var q = this, v = false;
          return { resolve: f(this.resolveTo_), reject: f(this.reject_) };
        };
        h.prototype.resolveTo_ = function(f) {
          if (f === this) this.reject_(new TypeError("A Promise cannot resolve to itself"));
          else if (f instanceof h) this.settleSameAsPromise_(f);
          else {
            a: switch (typeof f) {
              case "object":
                var q = null != f;
                break a;
              case "function":
                q = true;
                break a;
              default:
                q = false;
            }
            q ? this.resolveToNonPromiseObj_(f) : this.fulfill_(f);
          }
        };
        h.prototype.resolveToNonPromiseObj_ = function(f) {
          var q = void 0;
          try {
            q = f.then;
          } catch (v) {
            this.reject_(v);
            return;
          }
          "function" == typeof q ? this.settleSameAsThenable_(q, f) : this.fulfill_(f);
        };
        h.prototype.reject_ = function(f) {
          this.settle_(2, f);
        };
        h.prototype.fulfill_ = function(f) {
          this.settle_(1, f);
        };
        h.prototype.settle_ = function(f, q) {
          if (0 != this.state_) throw Error("Cannot settle(" + f + ", " + q + "): Promise already settled in state" + this.state_);
          this.state_ = f;
          this.result_ = q;
          2 === this.state_ && this.scheduleUnhandledRejectionCheck_();
          this.executeOnSettledCallbacks_();
        };
        h.prototype.scheduleUnhandledRejectionCheck_ = function() {
          var f = this;
          p(function() {
            if (f.notifyUnhandledRejection_()) {
              var q = $jscomp.global.console;
              "undefined" !== typeof q && q.error(f.result_);
            }
          }, 1);
        };
        h.prototype.notifyUnhandledRejection_ = function() {
          if (this.isRejectionHandled_) return false;
          var f = $jscomp.global.CustomEvent, q = $jscomp.global.Event, v = $jscomp.global.dispatchEvent;
          if ("undefined" === typeof v) return true;
          "function" === typeof f ? f = new f("unhandledrejection", { cancelable: true }) : "function" === typeof q ? f = new q("unhandledrejection", { cancelable: true }) : (f = $jscomp.global.document.createEvent("CustomEvent"), f.initCustomEvent("unhandledrejection", false, true, f));
          f.promise = this;
          f.reason = this.result_;
          return v(f);
        };
        h.prototype.executeOnSettledCallbacks_ = function() {
          if (null != this.onSettledCallbacks_) {
            for (var f = 0; f < this.onSettledCallbacks_.length; ++f) A.asyncExecute(this.onSettledCallbacks_[f]);
            this.onSettledCallbacks_ = null;
          }
        };
        var A = new n();
        h.prototype.settleSameAsPromise_ = function(f) {
          var q = this.createResolveAndReject_();
          f.callWhenSettled_(q.resolve, q.reject);
        };
        h.prototype.settleSameAsThenable_ = function(f, q) {
          var v = this.createResolveAndReject_();
          try {
            f.call(q, v.resolve, v.reject);
          } catch (z) {
            v.reject(z);
          }
        };
        h.prototype.then = function(f, q) {
          function v(t, x) {
            return "function" == typeof t ? function(D) {
              try {
                z(t(D));
              } catch (R) {
                O(R);
              }
            } : x;
          }
          var z, O, ba = new h(function(t, x) {
            z = t;
            O = x;
          });
          this.callWhenSettled_(v(f, z), v(q, O));
          return ba;
        };
        h.prototype.catch = function(f) {
          return this.then(void 0, f);
        };
        h.prototype.callWhenSettled_ = function(f, q) {
          function v() {
            switch (z.state_) {
              case 1:
                f(z.result_);
                break;
              case 2:
                q(z.result_);
                break;
              default:
                throw Error("Unexpected state: " + z.state_);
            }
          }
          var z = this;
          null == this.onSettledCallbacks_ ? A.asyncExecute(v) : this.onSettledCallbacks_.push(v);
          this.isRejectionHandled_ = true;
        };
        h.resolve = l;
        h.reject = function(f) {
          return new h(function(q, v) {
            v(f);
          });
        };
        h.race = function(f) {
          return new h(function(q, v) {
            for (var z = $jscomp.makeIterator(f), O = z.next(); !O.done; O = z.next()) l(O.value).callWhenSettled_(q, v);
          });
        };
        h.all = function(f) {
          var q = $jscomp.makeIterator(f), v = q.next();
          return v.done ? l([]) : new h(function(z, O) {
            function ba(D) {
              return function(R) {
                t[D] = R;
                x--;
                0 == x && z(t);
              };
            }
            var t = [], x = 0;
            do
              t.push(void 0), x++, l(v.value).callWhenSettled_(ba(t.length - 1), O), v = q.next();
            while (!v.done);
          });
        };
        return h;
      }, "es6", "es3");
      $jscomp.owns = function(k, n) {
        return Object.prototype.hasOwnProperty.call(k, n);
      };
      $jscomp.assign = $jscomp.TRUST_ES6_POLYFILLS && "function" == typeof Object.assign ? Object.assign : function(k, n) {
        for (var l = 1; l < arguments.length; l++) {
          var p = arguments[l];
          if (p) for (var h in p) $jscomp.owns(p, h) && (k[h] = p[h]);
        }
        return k;
      };
      $jscomp.polyfill("Object.assign", function(k) {
        return k || $jscomp.assign;
      }, "es6", "es3");
      $jscomp.checkStringArgs = function(k, n, l) {
        if (null == k) throw new TypeError("The 'this' value for String.prototype." + l + " must not be null or undefined");
        if (n instanceof RegExp) throw new TypeError("First argument to String.prototype." + l + " must not be a regular expression");
        return k + "";
      };
      $jscomp.polyfill("String.prototype.startsWith", function(k) {
        return k ? k : function(n, l) {
          var p = $jscomp.checkStringArgs(this, n, "startsWith");
          n += "";
          var h = p.length, A = n.length;
          l = Math.max(0, Math.min(l | 0, p.length));
          for (var f = 0; f < A && l < h; ) if (p[l++] != n[f++]) return false;
          return f >= A;
        };
      }, "es6", "es3");
      $jscomp.polyfill("Array.prototype.copyWithin", function(k) {
        function n(l) {
          l = Number(l);
          return Infinity === l || -Infinity === l ? l : l | 0;
        }
        return k ? k : function(l, p, h) {
          var A = this.length;
          l = n(l);
          p = n(p);
          h = void 0 === h ? A : n(h);
          l = 0 > l ? Math.max(A + l, 0) : Math.min(l, A);
          p = 0 > p ? Math.max(A + p, 0) : Math.min(p, A);
          h = 0 > h ? Math.max(A + h, 0) : Math.min(h, A);
          if (l < p) for (; p < h; ) p in this ? this[l++] = this[p++] : (delete this[l++], p++);
          else for (h = Math.min(h, A + p - l), l += h - p; h > p; ) --h in this ? this[--l] = this[h] : delete this[--l];
          return this;
        };
      }, "es6", "es3");
      $jscomp.typedArrayCopyWithin = function(k) {
        return k ? k : Array.prototype.copyWithin;
      };
      $jscomp.polyfill("Int8Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5");
      $jscomp.polyfill("Uint8Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5");
      $jscomp.polyfill("Uint8ClampedArray.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5");
      $jscomp.polyfill("Int16Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5");
      $jscomp.polyfill("Uint16Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5");
      $jscomp.polyfill("Int32Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5");
      $jscomp.polyfill("Uint32Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5");
      $jscomp.polyfill("Float32Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5");
      $jscomp.polyfill("Float64Array.prototype.copyWithin", $jscomp.typedArrayCopyWithin, "es6", "es5");
      var DracoDecoderModule = (function() {
        var k = "undefined" !== typeof document && document.currentScript ? document.currentScript.src : void 0;
        "undefined" !== typeof __filename && (k = k || __filename);
        return function(n) {
          function l(e) {
            return a.locateFile ? a.locateFile(e, U) : U + e;
          }
          function p(e, b, c) {
            var d = b + c;
            for (c = b; e[c] && !(c >= d); ) ++c;
            if (16 < c - b && e.buffer && va) return va.decode(e.subarray(b, c));
            for (d = ""; b < c; ) {
              var g = e[b++];
              if (g & 128) {
                var u = e[b++] & 63;
                if (192 == (g & 224)) d += String.fromCharCode((g & 31) << 6 | u);
                else {
                  var X = e[b++] & 63;
                  g = 224 == (g & 240) ? (g & 15) << 12 | u << 6 | X : (g & 7) << 18 | u << 12 | X << 6 | e[b++] & 63;
                  65536 > g ? d += String.fromCharCode(g) : (g -= 65536, d += String.fromCharCode(55296 | g >> 10, 56320 | g & 1023));
                }
              } else d += String.fromCharCode(g);
            }
            return d;
          }
          function h(e, b) {
            return e ? p(ea, e, b) : "";
          }
          function A() {
            var e = ja.buffer;
            a.HEAP8 = Y = new Int8Array(e);
            a.HEAP16 = new Int16Array(e);
            a.HEAP32 = ca = new Int32Array(e);
            a.HEAPU8 = ea = new Uint8Array(e);
            a.HEAPU16 = new Uint16Array(e);
            a.HEAPU32 = V = new Uint32Array(e);
            a.HEAPF32 = new Float32Array(e);
            a.HEAPF64 = new Float64Array(e);
          }
          function f(e) {
            if (a.onAbort) a.onAbort(e);
            e = "Aborted(" + e + ")";
            da(e);
            wa = true;
            e = new WebAssembly.RuntimeError(e + ". Build with -sASSERTIONS for more info.");
            ka(e);
            throw e;
          }
          function q(e) {
            try {
              if (e == P && fa) return new Uint8Array(fa);
              if (ma) return ma(e);
              throw "both async and sync fetching of the wasm failed";
            } catch (b) {
              f(b);
            }
          }
          function v() {
            if (!fa && (xa || ha)) {
              if ("function" == typeof fetch && !P.startsWith("file://")) return fetch(P, { credentials: "same-origin" }).then(function(e) {
                if (!e.ok) throw "failed to load wasm binary file at '" + P + "'";
                return e.arrayBuffer();
              }).catch(function() {
                return q(P);
              });
              if (na) return new Promise(function(e, b) {
                na(P, function(c) {
                  e(new Uint8Array(c));
                }, b);
              });
            }
            return Promise.resolve().then(function() {
              return q(P);
            });
          }
          function z(e) {
            for (; 0 < e.length; ) e.shift()(a);
          }
          function O(e) {
            this.excPtr = e;
            this.ptr = e - 24;
            this.set_type = function(b) {
              V[this.ptr + 4 >> 2] = b;
            };
            this.get_type = function() {
              return V[this.ptr + 4 >> 2];
            };
            this.set_destructor = function(b) {
              V[this.ptr + 8 >> 2] = b;
            };
            this.get_destructor = function() {
              return V[this.ptr + 8 >> 2];
            };
            this.set_refcount = function(b) {
              ca[this.ptr >> 2] = b;
            };
            this.set_caught = function(b) {
              Y[this.ptr + 12 >> 0] = b ? 1 : 0;
            };
            this.get_caught = function() {
              return 0 != Y[this.ptr + 12 >> 0];
            };
            this.set_rethrown = function(b) {
              Y[this.ptr + 13 >> 0] = b ? 1 : 0;
            };
            this.get_rethrown = function() {
              return 0 != Y[this.ptr + 13 >> 0];
            };
            this.init = function(b, c) {
              this.set_adjusted_ptr(0);
              this.set_type(b);
              this.set_destructor(c);
              this.set_refcount(0);
              this.set_caught(false);
              this.set_rethrown(false);
            };
            this.add_ref = function() {
              ca[this.ptr >> 2] += 1;
            };
            this.release_ref = function() {
              var b = ca[this.ptr >> 2];
              ca[this.ptr >> 2] = b - 1;
              return 1 === b;
            };
            this.set_adjusted_ptr = function(b) {
              V[this.ptr + 16 >> 2] = b;
            };
            this.get_adjusted_ptr = function() {
              return V[this.ptr + 16 >> 2];
            };
            this.get_exception_ptr = function() {
              if (ya(this.get_type())) return V[this.excPtr >> 2];
              var b = this.get_adjusted_ptr();
              return 0 !== b ? b : this.excPtr;
            };
          }
          function ba() {
            function e() {
              if (!la && (la = true, a.calledRun = true, !wa)) {
                za = true;
                z(oa);
                Aa(a);
                if (a.onRuntimeInitialized) a.onRuntimeInitialized();
                if (a.postRun) for ("function" == typeof a.postRun && (a.postRun = [a.postRun]); a.postRun.length; ) Ba.unshift(a.postRun.shift());
                z(Ba);
              }
            }
            if (!(0 < aa)) {
              if (a.preRun) for ("function" == typeof a.preRun && (a.preRun = [a.preRun]); a.preRun.length; ) Ca.unshift(a.preRun.shift());
              z(Ca);
              0 < aa || (a.setStatus ? (a.setStatus("Running..."), setTimeout(function() {
                setTimeout(function() {
                  a.setStatus("");
                }, 1);
                e();
              }, 1)) : e());
            }
          }
          function t() {
          }
          function x(e) {
            return (e || t).__cache__;
          }
          function D(e, b) {
            var c = x(b), d = c[e];
            if (d) return d;
            d = Object.create((b || t).prototype);
            d.ptr = e;
            return c[e] = d;
          }
          function R(e) {
            if ("string" === typeof e) {
              for (var b = 0, c = 0; c < e.length; ++c) {
                var d = e.charCodeAt(c);
                127 >= d ? b++ : 2047 >= d ? b += 2 : 55296 <= d && 57343 >= d ? (b += 4, ++c) : b += 3;
              }
              b = Array(b + 1);
              c = 0;
              d = b.length;
              if (0 < d) {
                d = c + d - 1;
                for (var g = 0; g < e.length; ++g) {
                  var u = e.charCodeAt(g);
                  if (55296 <= u && 57343 >= u) {
                    var X = e.charCodeAt(++g);
                    u = 65536 + ((u & 1023) << 10) | X & 1023;
                  }
                  if (127 >= u) {
                    if (c >= d) break;
                    b[c++] = u;
                  } else {
                    if (2047 >= u) {
                      if (c + 1 >= d) break;
                      b[c++] = 192 | u >> 6;
                    } else {
                      if (65535 >= u) {
                        if (c + 2 >= d) break;
                        b[c++] = 224 | u >> 12;
                      } else {
                        if (c + 3 >= d) break;
                        b[c++] = 240 | u >> 18;
                        b[c++] = 128 | u >> 12 & 63;
                      }
                      b[c++] = 128 | u >> 6 & 63;
                    }
                    b[c++] = 128 | u & 63;
                  }
                }
                b[c] = 0;
              }
              e = r.alloc(b, Y);
              r.copy(b, Y, e);
              return e;
            }
            return e;
          }
          function pa(e) {
            if ("object" === typeof e) {
              var b = r.alloc(e, Y);
              r.copy(e, Y, b);
              return b;
            }
            return e;
          }
          function Z() {
            throw "cannot construct a VoidPtr, no constructor in IDL";
          }
          function S() {
            this.ptr = Da();
            x(S)[this.ptr] = this;
          }
          function Q() {
            this.ptr = Ea();
            x(Q)[this.ptr] = this;
          }
          function W() {
            this.ptr = Fa();
            x(W)[this.ptr] = this;
          }
          function w() {
            this.ptr = Ga();
            x(w)[this.ptr] = this;
          }
          function C() {
            this.ptr = Ha();
            x(C)[this.ptr] = this;
          }
          function F() {
            this.ptr = Ia();
            x(F)[this.ptr] = this;
          }
          function G() {
            this.ptr = Ja();
            x(G)[this.ptr] = this;
          }
          function E() {
            this.ptr = Ka();
            x(E)[this.ptr] = this;
          }
          function T() {
            this.ptr = La();
            x(T)[this.ptr] = this;
          }
          function B() {
            throw "cannot construct a Status, no constructor in IDL";
          }
          function H() {
            this.ptr = Ma();
            x(H)[this.ptr] = this;
          }
          function I() {
            this.ptr = Na();
            x(I)[this.ptr] = this;
          }
          function J() {
            this.ptr = Oa();
            x(J)[this.ptr] = this;
          }
          function K() {
            this.ptr = Pa();
            x(K)[this.ptr] = this;
          }
          function L() {
            this.ptr = Qa();
            x(L)[this.ptr] = this;
          }
          function M() {
            this.ptr = Ra();
            x(M)[this.ptr] = this;
          }
          function N() {
            this.ptr = Sa();
            x(N)[this.ptr] = this;
          }
          function y() {
            this.ptr = Ta();
            x(y)[this.ptr] = this;
          }
          function m() {
            this.ptr = Ua();
            x(m)[this.ptr] = this;
          }
          n = void 0 === n ? {} : n;
          var a = "undefined" != typeof n ? n : {}, Aa, ka;
          a.ready = new Promise(function(e, b) {
            Aa = e;
            ka = b;
          });
          var Va = false, Wa = false;
          a.onRuntimeInitialized = function() {
            Va = true;
            if (Wa && "function" === typeof a.onModuleLoaded) a.onModuleLoaded(a);
          };
          a.onModuleParsed = function() {
            Wa = true;
            if (Va && "function" === typeof a.onModuleLoaded) a.onModuleLoaded(a);
          };
          a.isVersionSupported = function(e) {
            if ("string" !== typeof e) return false;
            e = e.split(".");
            return 2 > e.length || 3 < e.length ? false : 1 == e[0] && 0 <= e[1] && 5 >= e[1] ? true : 0 != e[0] || 10 < e[1] ? false : true;
          };
          var Xa = Object.assign({}, a), xa = "object" == typeof window, ha = "function" == typeof importScripts, Ya = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, U = "";
          if (Ya) {
            var Za = (init_fs(), __toCommonJS(fs_exports)), qa = (init_path(), __toCommonJS(path_exports));
            U = ha ? qa.dirname(U) + "/" : __dirname + "/";
            var $a = function(e, b) {
              e = e.startsWith("file://") ? new URL(e) : qa.normalize(e);
              return Za.readFileSync(e, b ? void 0 : "utf8");
            };
            var ma = function(e) {
              e = $a(e, true);
              e.buffer || (e = new Uint8Array(e));
              return e;
            };
            var na = function(e, b, c) {
              e = e.startsWith("file://") ? new URL(e) : qa.normalize(e);
              Za.readFile(e, function(d, g) {
                d ? c(d) : b(g.buffer);
              });
            };
            1 < process.argv.length && process.argv[1].replace(/\\/g, "/");
            process.argv.slice(2);
            a.inspect = function() {
              return "[Emscripten Module object]";
            };
          } else if (xa || ha) ha ? U = self.location.href : "undefined" != typeof document && document.currentScript && (U = document.currentScript.src), k && (U = k), U = 0 !== U.indexOf("blob:") ? U.substr(0, U.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", $a = function(e) {
            var b = new XMLHttpRequest();
            b.open("GET", e, false);
            b.send(null);
            return b.responseText;
          }, ha && (ma = function(e) {
            var b = new XMLHttpRequest();
            b.open("GET", e, false);
            b.responseType = "arraybuffer";
            b.send(null);
            return new Uint8Array(b.response);
          }), na = function(e, b, c) {
            var d = new XMLHttpRequest();
            d.open("GET", e, true);
            d.responseType = "arraybuffer";
            d.onload = function() {
              200 == d.status || 0 == d.status && d.response ? b(d.response) : c();
            };
            d.onerror = c;
            d.send(null);
          };
          var ud = a.print || console.log.bind(console), da = a.printErr || console.warn.bind(console);
          Object.assign(a, Xa);
          Xa = null;
          var fa;
          a.wasmBinary && (fa = a.wasmBinary);
          "object" != typeof WebAssembly && f("no native wasm support detected");
          var ja, wa = false, va = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, Y, ea, ca, V, Ca = [], oa = [], Ba = [], za = false, aa = 0, ra = null, ia = null;
          var P = "draco_decoder.wasm";
          P.startsWith("data:application/octet-stream;base64,") || (P = l(P));
          var vd = 0, wd = [null, [], []], xd = { b: function(e, b, c) {
            new O(e).init(b, c);
            vd++;
            throw e;
          }, a: function() {
            f("");
          }, g: function(e, b, c) {
            ea.copyWithin(e, b, b + c);
          }, e: function(e) {
            var b = ea.length;
            e >>>= 0;
            if (2147483648 < e) return false;
            for (var c = 1; 4 >= c; c *= 2) {
              var d = b * (1 + 0.2 / c);
              d = Math.min(d, e + 100663296);
              var g = Math;
              d = Math.max(e, d);
              g = g.min.call(g, 2147483648, d + (65536 - d % 65536) % 65536);
              a: {
                d = ja.buffer;
                try {
                  ja.grow(g - d.byteLength + 65535 >>> 16);
                  A();
                  var u = 1;
                  break a;
                } catch (X) {
                }
                u = void 0;
              }
              if (u) return true;
            }
            return false;
          }, f: function(e) {
            return 52;
          }, d: function(e, b, c, d, g) {
            return 70;
          }, c: function(e, b, c, d) {
            for (var g = 0, u = 0; u < c; u++) {
              var X = V[b >> 2], ab = V[b + 4 >> 2];
              b += 8;
              for (var sa = 0; sa < ab; sa++) {
                var ta = ea[X + sa], ua = wd[e];
                0 === ta || 10 === ta ? ((1 === e ? ud : da)(p(ua, 0)), ua.length = 0) : ua.push(ta);
              }
              g += ab;
            }
            V[d >> 2] = g;
            return 0;
          } };
          (function() {
            function e(g, u) {
              a.asm = g.exports;
              ja = a.asm.h;
              A();
              oa.unshift(a.asm.i);
              aa--;
              a.monitorRunDependencies && a.monitorRunDependencies(aa);
              0 == aa && (null !== ra && (clearInterval(ra), ra = null), ia && (g = ia, ia = null, g()));
            }
            function b(g) {
              e(g.instance);
            }
            function c(g) {
              return v().then(function(u) {
                return WebAssembly.instantiate(u, d);
              }).then(function(u) {
                return u;
              }).then(g, function(u) {
                da("failed to asynchronously prepare wasm: " + u);
                f(u);
              });
            }
            var d = { a: xd };
            aa++;
            a.monitorRunDependencies && a.monitorRunDependencies(aa);
            if (a.instantiateWasm) try {
              return a.instantiateWasm(d, e);
            } catch (g) {
              da("Module.instantiateWasm callback failed with error: " + g), ka(g);
            }
            (function() {
              return fa || "function" != typeof WebAssembly.instantiateStreaming || P.startsWith("data:application/octet-stream;base64,") || P.startsWith("file://") || Ya || "function" != typeof fetch ? c(b) : fetch(P, { credentials: "same-origin" }).then(function(g) {
                return WebAssembly.instantiateStreaming(g, d).then(b, function(u) {
                  da("wasm streaming compile failed: " + u);
                  da("falling back to ArrayBuffer instantiation");
                  return c(b);
                });
              });
            })().catch(ka);
            return {};
          })();
          var bb = a._emscripten_bind_VoidPtr___destroy___0 = function() {
            return (bb = a._emscripten_bind_VoidPtr___destroy___0 = a.asm.k).apply(null, arguments);
          }, Da = a._emscripten_bind_DecoderBuffer_DecoderBuffer_0 = function() {
            return (Da = a._emscripten_bind_DecoderBuffer_DecoderBuffer_0 = a.asm.l).apply(null, arguments);
          }, cb = a._emscripten_bind_DecoderBuffer_Init_2 = function() {
            return (cb = a._emscripten_bind_DecoderBuffer_Init_2 = a.asm.m).apply(null, arguments);
          }, db = a._emscripten_bind_DecoderBuffer___destroy___0 = function() {
            return (db = a._emscripten_bind_DecoderBuffer___destroy___0 = a.asm.n).apply(null, arguments);
          }, Ea = a._emscripten_bind_AttributeTransformData_AttributeTransformData_0 = function() {
            return (Ea = a._emscripten_bind_AttributeTransformData_AttributeTransformData_0 = a.asm.o).apply(null, arguments);
          }, eb = a._emscripten_bind_AttributeTransformData_transform_type_0 = function() {
            return (eb = a._emscripten_bind_AttributeTransformData_transform_type_0 = a.asm.p).apply(null, arguments);
          }, fb = a._emscripten_bind_AttributeTransformData___destroy___0 = function() {
            return (fb = a._emscripten_bind_AttributeTransformData___destroy___0 = a.asm.q).apply(null, arguments);
          }, Fa = a._emscripten_bind_GeometryAttribute_GeometryAttribute_0 = function() {
            return (Fa = a._emscripten_bind_GeometryAttribute_GeometryAttribute_0 = a.asm.r).apply(null, arguments);
          }, gb = a._emscripten_bind_GeometryAttribute___destroy___0 = function() {
            return (gb = a._emscripten_bind_GeometryAttribute___destroy___0 = a.asm.s).apply(null, arguments);
          }, Ga = a._emscripten_bind_PointAttribute_PointAttribute_0 = function() {
            return (Ga = a._emscripten_bind_PointAttribute_PointAttribute_0 = a.asm.t).apply(null, arguments);
          }, hb = a._emscripten_bind_PointAttribute_size_0 = function() {
            return (hb = a._emscripten_bind_PointAttribute_size_0 = a.asm.u).apply(null, arguments);
          }, ib = a._emscripten_bind_PointAttribute_GetAttributeTransformData_0 = function() {
            return (ib = a._emscripten_bind_PointAttribute_GetAttributeTransformData_0 = a.asm.v).apply(null, arguments);
          }, jb = a._emscripten_bind_PointAttribute_attribute_type_0 = function() {
            return (jb = a._emscripten_bind_PointAttribute_attribute_type_0 = a.asm.w).apply(null, arguments);
          }, kb = a._emscripten_bind_PointAttribute_data_type_0 = function() {
            return (kb = a._emscripten_bind_PointAttribute_data_type_0 = a.asm.x).apply(null, arguments);
          }, lb = a._emscripten_bind_PointAttribute_num_components_0 = function() {
            return (lb = a._emscripten_bind_PointAttribute_num_components_0 = a.asm.y).apply(null, arguments);
          }, mb = a._emscripten_bind_PointAttribute_normalized_0 = function() {
            return (mb = a._emscripten_bind_PointAttribute_normalized_0 = a.asm.z).apply(null, arguments);
          }, nb = a._emscripten_bind_PointAttribute_byte_stride_0 = function() {
            return (nb = a._emscripten_bind_PointAttribute_byte_stride_0 = a.asm.A).apply(null, arguments);
          }, ob = a._emscripten_bind_PointAttribute_byte_offset_0 = function() {
            return (ob = a._emscripten_bind_PointAttribute_byte_offset_0 = a.asm.B).apply(null, arguments);
          }, pb = a._emscripten_bind_PointAttribute_unique_id_0 = function() {
            return (pb = a._emscripten_bind_PointAttribute_unique_id_0 = a.asm.C).apply(null, arguments);
          }, qb = a._emscripten_bind_PointAttribute___destroy___0 = function() {
            return (qb = a._emscripten_bind_PointAttribute___destroy___0 = a.asm.D).apply(null, arguments);
          }, Ha = a._emscripten_bind_AttributeQuantizationTransform_AttributeQuantizationTransform_0 = function() {
            return (Ha = a._emscripten_bind_AttributeQuantizationTransform_AttributeQuantizationTransform_0 = a.asm.E).apply(null, arguments);
          }, rb = a._emscripten_bind_AttributeQuantizationTransform_InitFromAttribute_1 = function() {
            return (rb = a._emscripten_bind_AttributeQuantizationTransform_InitFromAttribute_1 = a.asm.F).apply(null, arguments);
          }, sb = a._emscripten_bind_AttributeQuantizationTransform_quantization_bits_0 = function() {
            return (sb = a._emscripten_bind_AttributeQuantizationTransform_quantization_bits_0 = a.asm.G).apply(null, arguments);
          }, tb = a._emscripten_bind_AttributeQuantizationTransform_min_value_1 = function() {
            return (tb = a._emscripten_bind_AttributeQuantizationTransform_min_value_1 = a.asm.H).apply(null, arguments);
          }, ub = a._emscripten_bind_AttributeQuantizationTransform_range_0 = function() {
            return (ub = a._emscripten_bind_AttributeQuantizationTransform_range_0 = a.asm.I).apply(null, arguments);
          }, vb = a._emscripten_bind_AttributeQuantizationTransform___destroy___0 = function() {
            return (vb = a._emscripten_bind_AttributeQuantizationTransform___destroy___0 = a.asm.J).apply(null, arguments);
          }, Ia = a._emscripten_bind_AttributeOctahedronTransform_AttributeOctahedronTransform_0 = function() {
            return (Ia = a._emscripten_bind_AttributeOctahedronTransform_AttributeOctahedronTransform_0 = a.asm.K).apply(null, arguments);
          }, wb = a._emscripten_bind_AttributeOctahedronTransform_InitFromAttribute_1 = function() {
            return (wb = a._emscripten_bind_AttributeOctahedronTransform_InitFromAttribute_1 = a.asm.L).apply(
              null,
              arguments
            );
          }, xb = a._emscripten_bind_AttributeOctahedronTransform_quantization_bits_0 = function() {
            return (xb = a._emscripten_bind_AttributeOctahedronTransform_quantization_bits_0 = a.asm.M).apply(null, arguments);
          }, yb = a._emscripten_bind_AttributeOctahedronTransform___destroy___0 = function() {
            return (yb = a._emscripten_bind_AttributeOctahedronTransform___destroy___0 = a.asm.N).apply(null, arguments);
          }, Ja = a._emscripten_bind_PointCloud_PointCloud_0 = function() {
            return (Ja = a._emscripten_bind_PointCloud_PointCloud_0 = a.asm.O).apply(
              null,
              arguments
            );
          }, zb = a._emscripten_bind_PointCloud_num_attributes_0 = function() {
            return (zb = a._emscripten_bind_PointCloud_num_attributes_0 = a.asm.P).apply(null, arguments);
          }, Ab = a._emscripten_bind_PointCloud_num_points_0 = function() {
            return (Ab = a._emscripten_bind_PointCloud_num_points_0 = a.asm.Q).apply(null, arguments);
          }, Bb = a._emscripten_bind_PointCloud___destroy___0 = function() {
            return (Bb = a._emscripten_bind_PointCloud___destroy___0 = a.asm.R).apply(null, arguments);
          }, Ka = a._emscripten_bind_Mesh_Mesh_0 = function() {
            return (Ka = a._emscripten_bind_Mesh_Mesh_0 = a.asm.S).apply(null, arguments);
          }, Cb = a._emscripten_bind_Mesh_num_faces_0 = function() {
            return (Cb = a._emscripten_bind_Mesh_num_faces_0 = a.asm.T).apply(null, arguments);
          }, Db = a._emscripten_bind_Mesh_num_attributes_0 = function() {
            return (Db = a._emscripten_bind_Mesh_num_attributes_0 = a.asm.U).apply(null, arguments);
          }, Eb = a._emscripten_bind_Mesh_num_points_0 = function() {
            return (Eb = a._emscripten_bind_Mesh_num_points_0 = a.asm.V).apply(null, arguments);
          }, Fb = a._emscripten_bind_Mesh___destroy___0 = function() {
            return (Fb = a._emscripten_bind_Mesh___destroy___0 = a.asm.W).apply(null, arguments);
          }, La = a._emscripten_bind_Metadata_Metadata_0 = function() {
            return (La = a._emscripten_bind_Metadata_Metadata_0 = a.asm.X).apply(null, arguments);
          }, Gb = a._emscripten_bind_Metadata___destroy___0 = function() {
            return (Gb = a._emscripten_bind_Metadata___destroy___0 = a.asm.Y).apply(null, arguments);
          }, Hb = a._emscripten_bind_Status_code_0 = function() {
            return (Hb = a._emscripten_bind_Status_code_0 = a.asm.Z).apply(null, arguments);
          }, Ib = a._emscripten_bind_Status_ok_0 = function() {
            return (Ib = a._emscripten_bind_Status_ok_0 = a.asm._).apply(null, arguments);
          }, Jb = a._emscripten_bind_Status_error_msg_0 = function() {
            return (Jb = a._emscripten_bind_Status_error_msg_0 = a.asm.$).apply(null, arguments);
          }, Kb = a._emscripten_bind_Status___destroy___0 = function() {
            return (Kb = a._emscripten_bind_Status___destroy___0 = a.asm.aa).apply(null, arguments);
          }, Ma = a._emscripten_bind_DracoFloat32Array_DracoFloat32Array_0 = function() {
            return (Ma = a._emscripten_bind_DracoFloat32Array_DracoFloat32Array_0 = a.asm.ba).apply(null, arguments);
          }, Lb = a._emscripten_bind_DracoFloat32Array_GetValue_1 = function() {
            return (Lb = a._emscripten_bind_DracoFloat32Array_GetValue_1 = a.asm.ca).apply(null, arguments);
          }, Mb = a._emscripten_bind_DracoFloat32Array_size_0 = function() {
            return (Mb = a._emscripten_bind_DracoFloat32Array_size_0 = a.asm.da).apply(null, arguments);
          }, Nb = a._emscripten_bind_DracoFloat32Array___destroy___0 = function() {
            return (Nb = a._emscripten_bind_DracoFloat32Array___destroy___0 = a.asm.ea).apply(null, arguments);
          }, Na = a._emscripten_bind_DracoInt8Array_DracoInt8Array_0 = function() {
            return (Na = a._emscripten_bind_DracoInt8Array_DracoInt8Array_0 = a.asm.fa).apply(null, arguments);
          }, Ob = a._emscripten_bind_DracoInt8Array_GetValue_1 = function() {
            return (Ob = a._emscripten_bind_DracoInt8Array_GetValue_1 = a.asm.ga).apply(null, arguments);
          }, Pb = a._emscripten_bind_DracoInt8Array_size_0 = function() {
            return (Pb = a._emscripten_bind_DracoInt8Array_size_0 = a.asm.ha).apply(null, arguments);
          }, Qb = a._emscripten_bind_DracoInt8Array___destroy___0 = function() {
            return (Qb = a._emscripten_bind_DracoInt8Array___destroy___0 = a.asm.ia).apply(null, arguments);
          }, Oa = a._emscripten_bind_DracoUInt8Array_DracoUInt8Array_0 = function() {
            return (Oa = a._emscripten_bind_DracoUInt8Array_DracoUInt8Array_0 = a.asm.ja).apply(null, arguments);
          }, Rb = a._emscripten_bind_DracoUInt8Array_GetValue_1 = function() {
            return (Rb = a._emscripten_bind_DracoUInt8Array_GetValue_1 = a.asm.ka).apply(null, arguments);
          }, Sb = a._emscripten_bind_DracoUInt8Array_size_0 = function() {
            return (Sb = a._emscripten_bind_DracoUInt8Array_size_0 = a.asm.la).apply(null, arguments);
          }, Tb = a._emscripten_bind_DracoUInt8Array___destroy___0 = function() {
            return (Tb = a._emscripten_bind_DracoUInt8Array___destroy___0 = a.asm.ma).apply(null, arguments);
          }, Pa = a._emscripten_bind_DracoInt16Array_DracoInt16Array_0 = function() {
            return (Pa = a._emscripten_bind_DracoInt16Array_DracoInt16Array_0 = a.asm.na).apply(null, arguments);
          }, Ub = a._emscripten_bind_DracoInt16Array_GetValue_1 = function() {
            return (Ub = a._emscripten_bind_DracoInt16Array_GetValue_1 = a.asm.oa).apply(null, arguments);
          }, Vb = a._emscripten_bind_DracoInt16Array_size_0 = function() {
            return (Vb = a._emscripten_bind_DracoInt16Array_size_0 = a.asm.pa).apply(null, arguments);
          }, Wb = a._emscripten_bind_DracoInt16Array___destroy___0 = function() {
            return (Wb = a._emscripten_bind_DracoInt16Array___destroy___0 = a.asm.qa).apply(null, arguments);
          }, Qa = a._emscripten_bind_DracoUInt16Array_DracoUInt16Array_0 = function() {
            return (Qa = a._emscripten_bind_DracoUInt16Array_DracoUInt16Array_0 = a.asm.ra).apply(null, arguments);
          }, Xb = a._emscripten_bind_DracoUInt16Array_GetValue_1 = function() {
            return (Xb = a._emscripten_bind_DracoUInt16Array_GetValue_1 = a.asm.sa).apply(null, arguments);
          }, Yb = a._emscripten_bind_DracoUInt16Array_size_0 = function() {
            return (Yb = a._emscripten_bind_DracoUInt16Array_size_0 = a.asm.ta).apply(null, arguments);
          }, Zb = a._emscripten_bind_DracoUInt16Array___destroy___0 = function() {
            return (Zb = a._emscripten_bind_DracoUInt16Array___destroy___0 = a.asm.ua).apply(null, arguments);
          }, Ra = a._emscripten_bind_DracoInt32Array_DracoInt32Array_0 = function() {
            return (Ra = a._emscripten_bind_DracoInt32Array_DracoInt32Array_0 = a.asm.va).apply(null, arguments);
          }, $b = a._emscripten_bind_DracoInt32Array_GetValue_1 = function() {
            return ($b = a._emscripten_bind_DracoInt32Array_GetValue_1 = a.asm.wa).apply(null, arguments);
          }, ac = a._emscripten_bind_DracoInt32Array_size_0 = function() {
            return (ac = a._emscripten_bind_DracoInt32Array_size_0 = a.asm.xa).apply(null, arguments);
          }, bc = a._emscripten_bind_DracoInt32Array___destroy___0 = function() {
            return (bc = a._emscripten_bind_DracoInt32Array___destroy___0 = a.asm.ya).apply(null, arguments);
          }, Sa = a._emscripten_bind_DracoUInt32Array_DracoUInt32Array_0 = function() {
            return (Sa = a._emscripten_bind_DracoUInt32Array_DracoUInt32Array_0 = a.asm.za).apply(null, arguments);
          }, cc = a._emscripten_bind_DracoUInt32Array_GetValue_1 = function() {
            return (cc = a._emscripten_bind_DracoUInt32Array_GetValue_1 = a.asm.Aa).apply(null, arguments);
          }, dc = a._emscripten_bind_DracoUInt32Array_size_0 = function() {
            return (dc = a._emscripten_bind_DracoUInt32Array_size_0 = a.asm.Ba).apply(null, arguments);
          }, ec = a._emscripten_bind_DracoUInt32Array___destroy___0 = function() {
            return (ec = a._emscripten_bind_DracoUInt32Array___destroy___0 = a.asm.Ca).apply(null, arguments);
          }, Ta = a._emscripten_bind_MetadataQuerier_MetadataQuerier_0 = function() {
            return (Ta = a._emscripten_bind_MetadataQuerier_MetadataQuerier_0 = a.asm.Da).apply(null, arguments);
          }, fc = a._emscripten_bind_MetadataQuerier_HasEntry_2 = function() {
            return (fc = a._emscripten_bind_MetadataQuerier_HasEntry_2 = a.asm.Ea).apply(null, arguments);
          }, gc = a._emscripten_bind_MetadataQuerier_GetIntEntry_2 = function() {
            return (gc = a._emscripten_bind_MetadataQuerier_GetIntEntry_2 = a.asm.Fa).apply(null, arguments);
          }, hc = a._emscripten_bind_MetadataQuerier_GetIntEntryArray_3 = function() {
            return (hc = a._emscripten_bind_MetadataQuerier_GetIntEntryArray_3 = a.asm.Ga).apply(null, arguments);
          }, ic = a._emscripten_bind_MetadataQuerier_GetDoubleEntry_2 = function() {
            return (ic = a._emscripten_bind_MetadataQuerier_GetDoubleEntry_2 = a.asm.Ha).apply(null, arguments);
          }, jc = a._emscripten_bind_MetadataQuerier_GetStringEntry_2 = function() {
            return (jc = a._emscripten_bind_MetadataQuerier_GetStringEntry_2 = a.asm.Ia).apply(null, arguments);
          }, kc = a._emscripten_bind_MetadataQuerier_NumEntries_1 = function() {
            return (kc = a._emscripten_bind_MetadataQuerier_NumEntries_1 = a.asm.Ja).apply(null, arguments);
          }, lc = a._emscripten_bind_MetadataQuerier_GetEntryName_2 = function() {
            return (lc = a._emscripten_bind_MetadataQuerier_GetEntryName_2 = a.asm.Ka).apply(null, arguments);
          }, mc = a._emscripten_bind_MetadataQuerier___destroy___0 = function() {
            return (mc = a._emscripten_bind_MetadataQuerier___destroy___0 = a.asm.La).apply(null, arguments);
          }, Ua = a._emscripten_bind_Decoder_Decoder_0 = function() {
            return (Ua = a._emscripten_bind_Decoder_Decoder_0 = a.asm.Ma).apply(null, arguments);
          }, nc = a._emscripten_bind_Decoder_DecodeArrayToPointCloud_3 = function() {
            return (nc = a._emscripten_bind_Decoder_DecodeArrayToPointCloud_3 = a.asm.Na).apply(null, arguments);
          }, oc = a._emscripten_bind_Decoder_DecodeArrayToMesh_3 = function() {
            return (oc = a._emscripten_bind_Decoder_DecodeArrayToMesh_3 = a.asm.Oa).apply(null, arguments);
          }, pc = a._emscripten_bind_Decoder_GetAttributeId_2 = function() {
            return (pc = a._emscripten_bind_Decoder_GetAttributeId_2 = a.asm.Pa).apply(null, arguments);
          }, qc = a._emscripten_bind_Decoder_GetAttributeIdByName_2 = function() {
            return (qc = a._emscripten_bind_Decoder_GetAttributeIdByName_2 = a.asm.Qa).apply(null, arguments);
          }, rc = a._emscripten_bind_Decoder_GetAttributeIdByMetadataEntry_3 = function() {
            return (rc = a._emscripten_bind_Decoder_GetAttributeIdByMetadataEntry_3 = a.asm.Ra).apply(null, arguments);
          }, sc = a._emscripten_bind_Decoder_GetAttribute_2 = function() {
            return (sc = a._emscripten_bind_Decoder_GetAttribute_2 = a.asm.Sa).apply(null, arguments);
          }, tc = a._emscripten_bind_Decoder_GetAttributeByUniqueId_2 = function() {
            return (tc = a._emscripten_bind_Decoder_GetAttributeByUniqueId_2 = a.asm.Ta).apply(null, arguments);
          }, uc = a._emscripten_bind_Decoder_GetMetadata_1 = function() {
            return (uc = a._emscripten_bind_Decoder_GetMetadata_1 = a.asm.Ua).apply(null, arguments);
          }, vc = a._emscripten_bind_Decoder_GetAttributeMetadata_2 = function() {
            return (vc = a._emscripten_bind_Decoder_GetAttributeMetadata_2 = a.asm.Va).apply(null, arguments);
          }, wc = a._emscripten_bind_Decoder_GetFaceFromMesh_3 = function() {
            return (wc = a._emscripten_bind_Decoder_GetFaceFromMesh_3 = a.asm.Wa).apply(null, arguments);
          }, xc = a._emscripten_bind_Decoder_GetTriangleStripsFromMesh_2 = function() {
            return (xc = a._emscripten_bind_Decoder_GetTriangleStripsFromMesh_2 = a.asm.Xa).apply(null, arguments);
          }, yc = a._emscripten_bind_Decoder_GetTrianglesUInt16Array_3 = function() {
            return (yc = a._emscripten_bind_Decoder_GetTrianglesUInt16Array_3 = a.asm.Ya).apply(null, arguments);
          }, zc = a._emscripten_bind_Decoder_GetTrianglesUInt32Array_3 = function() {
            return (zc = a._emscripten_bind_Decoder_GetTrianglesUInt32Array_3 = a.asm.Za).apply(null, arguments);
          }, Ac = a._emscripten_bind_Decoder_GetAttributeFloat_3 = function() {
            return (Ac = a._emscripten_bind_Decoder_GetAttributeFloat_3 = a.asm._a).apply(null, arguments);
          }, Bc = a._emscripten_bind_Decoder_GetAttributeFloatForAllPoints_3 = function() {
            return (Bc = a._emscripten_bind_Decoder_GetAttributeFloatForAllPoints_3 = a.asm.$a).apply(null, arguments);
          }, Cc = a._emscripten_bind_Decoder_GetAttributeIntForAllPoints_3 = function() {
            return (Cc = a._emscripten_bind_Decoder_GetAttributeIntForAllPoints_3 = a.asm.ab).apply(null, arguments);
          }, Dc = a._emscripten_bind_Decoder_GetAttributeInt8ForAllPoints_3 = function() {
            return (Dc = a._emscripten_bind_Decoder_GetAttributeInt8ForAllPoints_3 = a.asm.bb).apply(null, arguments);
          }, Ec = a._emscripten_bind_Decoder_GetAttributeUInt8ForAllPoints_3 = function() {
            return (Ec = a._emscripten_bind_Decoder_GetAttributeUInt8ForAllPoints_3 = a.asm.cb).apply(null, arguments);
          }, Fc = a._emscripten_bind_Decoder_GetAttributeInt16ForAllPoints_3 = function() {
            return (Fc = a._emscripten_bind_Decoder_GetAttributeInt16ForAllPoints_3 = a.asm.db).apply(null, arguments);
          }, Gc = a._emscripten_bind_Decoder_GetAttributeUInt16ForAllPoints_3 = function() {
            return (Gc = a._emscripten_bind_Decoder_GetAttributeUInt16ForAllPoints_3 = a.asm.eb).apply(null, arguments);
          }, Hc = a._emscripten_bind_Decoder_GetAttributeInt32ForAllPoints_3 = function() {
            return (Hc = a._emscripten_bind_Decoder_GetAttributeInt32ForAllPoints_3 = a.asm.fb).apply(null, arguments);
          }, Ic = a._emscripten_bind_Decoder_GetAttributeUInt32ForAllPoints_3 = function() {
            return (Ic = a._emscripten_bind_Decoder_GetAttributeUInt32ForAllPoints_3 = a.asm.gb).apply(null, arguments);
          }, Jc = a._emscripten_bind_Decoder_GetAttributeDataArrayForAllPoints_5 = function() {
            return (Jc = a._emscripten_bind_Decoder_GetAttributeDataArrayForAllPoints_5 = a.asm.hb).apply(null, arguments);
          }, Kc = a._emscripten_bind_Decoder_SkipAttributeTransform_1 = function() {
            return (Kc = a._emscripten_bind_Decoder_SkipAttributeTransform_1 = a.asm.ib).apply(null, arguments);
          }, Lc = a._emscripten_bind_Decoder_GetEncodedGeometryType_Deprecated_1 = function() {
            return (Lc = a._emscripten_bind_Decoder_GetEncodedGeometryType_Deprecated_1 = a.asm.jb).apply(null, arguments);
          }, Mc = a._emscripten_bind_Decoder_DecodeBufferToPointCloud_2 = function() {
            return (Mc = a._emscripten_bind_Decoder_DecodeBufferToPointCloud_2 = a.asm.kb).apply(null, arguments);
          }, Nc = a._emscripten_bind_Decoder_DecodeBufferToMesh_2 = function() {
            return (Nc = a._emscripten_bind_Decoder_DecodeBufferToMesh_2 = a.asm.lb).apply(null, arguments);
          }, Oc = a._emscripten_bind_Decoder___destroy___0 = function() {
            return (Oc = a._emscripten_bind_Decoder___destroy___0 = a.asm.mb).apply(null, arguments);
          }, Pc = a._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_INVALID_TRANSFORM = function() {
            return (Pc = a._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_INVALID_TRANSFORM = a.asm.nb).apply(null, arguments);
          }, Qc = a._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_NO_TRANSFORM = function() {
            return (Qc = a._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_NO_TRANSFORM = a.asm.ob).apply(null, arguments);
          }, Rc = a._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_QUANTIZATION_TRANSFORM = function() {
            return (Rc = a._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_QUANTIZATION_TRANSFORM = a.asm.pb).apply(null, arguments);
          }, Sc = a._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_OCTAHEDRON_TRANSFORM = function() {
            return (Sc = a._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_OCTAHEDRON_TRANSFORM = a.asm.qb).apply(null, arguments);
          }, Tc = a._emscripten_enum_draco_GeometryAttribute_Type_INVALID = function() {
            return (Tc = a._emscripten_enum_draco_GeometryAttribute_Type_INVALID = a.asm.rb).apply(null, arguments);
          }, Uc = a._emscripten_enum_draco_GeometryAttribute_Type_POSITION = function() {
            return (Uc = a._emscripten_enum_draco_GeometryAttribute_Type_POSITION = a.asm.sb).apply(null, arguments);
          }, Vc = a._emscripten_enum_draco_GeometryAttribute_Type_NORMAL = function() {
            return (Vc = a._emscripten_enum_draco_GeometryAttribute_Type_NORMAL = a.asm.tb).apply(null, arguments);
          }, Wc = a._emscripten_enum_draco_GeometryAttribute_Type_COLOR = function() {
            return (Wc = a._emscripten_enum_draco_GeometryAttribute_Type_COLOR = a.asm.ub).apply(null, arguments);
          }, Xc = a._emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD = function() {
            return (Xc = a._emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD = a.asm.vb).apply(null, arguments);
          }, Yc = a._emscripten_enum_draco_GeometryAttribute_Type_GENERIC = function() {
            return (Yc = a._emscripten_enum_draco_GeometryAttribute_Type_GENERIC = a.asm.wb).apply(null, arguments);
          }, Zc = a._emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE = function() {
            return (Zc = a._emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE = a.asm.xb).apply(null, arguments);
          }, $c = a._emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD = function() {
            return ($c = a._emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD = a.asm.yb).apply(null, arguments);
          }, ad = a._emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH = function() {
            return (ad = a._emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH = a.asm.zb).apply(null, arguments);
          }, bd = a._emscripten_enum_draco_DataType_DT_INVALID = function() {
            return (bd = a._emscripten_enum_draco_DataType_DT_INVALID = a.asm.Ab).apply(null, arguments);
          }, cd = a._emscripten_enum_draco_DataType_DT_INT8 = function() {
            return (cd = a._emscripten_enum_draco_DataType_DT_INT8 = a.asm.Bb).apply(null, arguments);
          }, dd = a._emscripten_enum_draco_DataType_DT_UINT8 = function() {
            return (dd = a._emscripten_enum_draco_DataType_DT_UINT8 = a.asm.Cb).apply(null, arguments);
          }, ed = a._emscripten_enum_draco_DataType_DT_INT16 = function() {
            return (ed = a._emscripten_enum_draco_DataType_DT_INT16 = a.asm.Db).apply(null, arguments);
          }, fd = a._emscripten_enum_draco_DataType_DT_UINT16 = function() {
            return (fd = a._emscripten_enum_draco_DataType_DT_UINT16 = a.asm.Eb).apply(null, arguments);
          }, gd = a._emscripten_enum_draco_DataType_DT_INT32 = function() {
            return (gd = a._emscripten_enum_draco_DataType_DT_INT32 = a.asm.Fb).apply(null, arguments);
          }, hd = a._emscripten_enum_draco_DataType_DT_UINT32 = function() {
            return (hd = a._emscripten_enum_draco_DataType_DT_UINT32 = a.asm.Gb).apply(null, arguments);
          }, id = a._emscripten_enum_draco_DataType_DT_INT64 = function() {
            return (id = a._emscripten_enum_draco_DataType_DT_INT64 = a.asm.Hb).apply(null, arguments);
          }, jd = a._emscripten_enum_draco_DataType_DT_UINT64 = function() {
            return (jd = a._emscripten_enum_draco_DataType_DT_UINT64 = a.asm.Ib).apply(null, arguments);
          }, kd = a._emscripten_enum_draco_DataType_DT_FLOAT32 = function() {
            return (kd = a._emscripten_enum_draco_DataType_DT_FLOAT32 = a.asm.Jb).apply(
              null,
              arguments
            );
          }, ld = a._emscripten_enum_draco_DataType_DT_FLOAT64 = function() {
            return (ld = a._emscripten_enum_draco_DataType_DT_FLOAT64 = a.asm.Kb).apply(null, arguments);
          }, md = a._emscripten_enum_draco_DataType_DT_BOOL = function() {
            return (md = a._emscripten_enum_draco_DataType_DT_BOOL = a.asm.Lb).apply(null, arguments);
          }, nd = a._emscripten_enum_draco_DataType_DT_TYPES_COUNT = function() {
            return (nd = a._emscripten_enum_draco_DataType_DT_TYPES_COUNT = a.asm.Mb).apply(null, arguments);
          }, od = a._emscripten_enum_draco_StatusCode_OK = function() {
            return (od = a._emscripten_enum_draco_StatusCode_OK = a.asm.Nb).apply(null, arguments);
          }, pd = a._emscripten_enum_draco_StatusCode_DRACO_ERROR = function() {
            return (pd = a._emscripten_enum_draco_StatusCode_DRACO_ERROR = a.asm.Ob).apply(null, arguments);
          }, qd = a._emscripten_enum_draco_StatusCode_IO_ERROR = function() {
            return (qd = a._emscripten_enum_draco_StatusCode_IO_ERROR = a.asm.Pb).apply(null, arguments);
          }, rd = a._emscripten_enum_draco_StatusCode_INVALID_PARAMETER = function() {
            return (rd = a._emscripten_enum_draco_StatusCode_INVALID_PARAMETER = a.asm.Qb).apply(null, arguments);
          }, sd = a._emscripten_enum_draco_StatusCode_UNSUPPORTED_VERSION = function() {
            return (sd = a._emscripten_enum_draco_StatusCode_UNSUPPORTED_VERSION = a.asm.Rb).apply(null, arguments);
          }, td = a._emscripten_enum_draco_StatusCode_UNKNOWN_VERSION = function() {
            return (td = a._emscripten_enum_draco_StatusCode_UNKNOWN_VERSION = a.asm.Sb).apply(null, arguments);
          };
          a._malloc = function() {
            return (a._malloc = a.asm.Tb).apply(null, arguments);
          };
          a._free = function() {
            return (a._free = a.asm.Ub).apply(null, arguments);
          };
          var ya = function() {
            return (ya = a.asm.Vb).apply(null, arguments);
          };
          a.___start_em_js = 15856;
          a.___stop_em_js = 15954;
          var la;
          ia = function b() {
            la || ba();
            la || (ia = b);
          };
          if (a.preInit) for ("function" == typeof a.preInit && (a.preInit = [a.preInit]); 0 < a.preInit.length; ) a.preInit.pop()();
          ba();
          t.prototype = Object.create(t.prototype);
          t.prototype.constructor = t;
          t.prototype.__class__ = t;
          t.__cache__ = {};
          a.WrapperObject = t;
          a.getCache = x;
          a.wrapPointer = D;
          a.castObject = function(b, c) {
            return D(b.ptr, c);
          };
          a.NULL = D(0);
          a.destroy = function(b) {
            if (!b.__destroy__) throw "Error: Cannot destroy object. (Did you create it yourself?)";
            b.__destroy__();
            delete x(b.__class__)[b.ptr];
          };
          a.compare = function(b, c) {
            return b.ptr === c.ptr;
          };
          a.getPointer = function(b) {
            return b.ptr;
          };
          a.getClass = function(b) {
            return b.__class__;
          };
          var r = { buffer: 0, size: 0, pos: 0, temps: [], needed: 0, prepare: function() {
            if (r.needed) {
              for (var b = 0; b < r.temps.length; b++) a._free(r.temps[b]);
              r.temps.length = 0;
              a._free(r.buffer);
              r.buffer = 0;
              r.size += r.needed;
              r.needed = 0;
            }
            r.buffer || (r.size += 128, r.buffer = a._malloc(r.size), r.buffer || f(void 0));
            r.pos = 0;
          }, alloc: function(b, c) {
            r.buffer || f(void 0);
            b = b.length * c.BYTES_PER_ELEMENT;
            b = b + 7 & -8;
            r.pos + b >= r.size ? (0 < b || f(void 0), r.needed += b, c = a._malloc(b), r.temps.push(c)) : (c = r.buffer + r.pos, r.pos += b);
            return c;
          }, copy: function(b, c, d) {
            d >>>= 0;
            switch (c.BYTES_PER_ELEMENT) {
              case 2:
                d >>>= 1;
                break;
              case 4:
                d >>>= 2;
                break;
              case 8:
                d >>>= 3;
            }
            for (var g = 0; g < b.length; g++) c[d + g] = b[g];
          } };
          Z.prototype = Object.create(t.prototype);
          Z.prototype.constructor = Z;
          Z.prototype.__class__ = Z;
          Z.__cache__ = {};
          a.VoidPtr = Z;
          Z.prototype.__destroy__ = Z.prototype.__destroy__ = function() {
            bb(this.ptr);
          };
          S.prototype = Object.create(t.prototype);
          S.prototype.constructor = S;
          S.prototype.__class__ = S;
          S.__cache__ = {};
          a.DecoderBuffer = S;
          S.prototype.Init = S.prototype.Init = function(b, c) {
            var d = this.ptr;
            r.prepare();
            "object" == typeof b && (b = pa(b));
            c && "object" === typeof c && (c = c.ptr);
            cb(d, b, c);
          };
          S.prototype.__destroy__ = S.prototype.__destroy__ = function() {
            db(this.ptr);
          };
          Q.prototype = Object.create(t.prototype);
          Q.prototype.constructor = Q;
          Q.prototype.__class__ = Q;
          Q.__cache__ = {};
          a.AttributeTransformData = Q;
          Q.prototype.transform_type = Q.prototype.transform_type = function() {
            return eb(this.ptr);
          };
          Q.prototype.__destroy__ = Q.prototype.__destroy__ = function() {
            fb(this.ptr);
          };
          W.prototype = Object.create(t.prototype);
          W.prototype.constructor = W;
          W.prototype.__class__ = W;
          W.__cache__ = {};
          a.GeometryAttribute = W;
          W.prototype.__destroy__ = W.prototype.__destroy__ = function() {
            gb(this.ptr);
          };
          w.prototype = Object.create(t.prototype);
          w.prototype.constructor = w;
          w.prototype.__class__ = w;
          w.__cache__ = {};
          a.PointAttribute = w;
          w.prototype.size = w.prototype.size = function() {
            return hb(this.ptr);
          };
          w.prototype.GetAttributeTransformData = w.prototype.GetAttributeTransformData = function() {
            return D(ib(this.ptr), Q);
          };
          w.prototype.attribute_type = w.prototype.attribute_type = function() {
            return jb(this.ptr);
          };
          w.prototype.data_type = w.prototype.data_type = function() {
            return kb(this.ptr);
          };
          w.prototype.num_components = w.prototype.num_components = function() {
            return lb(this.ptr);
          };
          w.prototype.normalized = w.prototype.normalized = function() {
            return !!mb(this.ptr);
          };
          w.prototype.byte_stride = w.prototype.byte_stride = function() {
            return nb(this.ptr);
          };
          w.prototype.byte_offset = w.prototype.byte_offset = function() {
            return ob(this.ptr);
          };
          w.prototype.unique_id = w.prototype.unique_id = function() {
            return pb(this.ptr);
          };
          w.prototype.__destroy__ = w.prototype.__destroy__ = function() {
            qb(this.ptr);
          };
          C.prototype = Object.create(t.prototype);
          C.prototype.constructor = C;
          C.prototype.__class__ = C;
          C.__cache__ = {};
          a.AttributeQuantizationTransform = C;
          C.prototype.InitFromAttribute = C.prototype.InitFromAttribute = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            return !!rb(c, b);
          };
          C.prototype.quantization_bits = C.prototype.quantization_bits = function() {
            return sb(this.ptr);
          };
          C.prototype.min_value = C.prototype.min_value = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            return tb(c, b);
          };
          C.prototype.range = C.prototype.range = function() {
            return ub(this.ptr);
          };
          C.prototype.__destroy__ = C.prototype.__destroy__ = function() {
            vb(this.ptr);
          };
          F.prototype = Object.create(t.prototype);
          F.prototype.constructor = F;
          F.prototype.__class__ = F;
          F.__cache__ = {};
          a.AttributeOctahedronTransform = F;
          F.prototype.InitFromAttribute = F.prototype.InitFromAttribute = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            return !!wb(c, b);
          };
          F.prototype.quantization_bits = F.prototype.quantization_bits = function() {
            return xb(this.ptr);
          };
          F.prototype.__destroy__ = F.prototype.__destroy__ = function() {
            yb(this.ptr);
          };
          G.prototype = Object.create(t.prototype);
          G.prototype.constructor = G;
          G.prototype.__class__ = G;
          G.__cache__ = {};
          a.PointCloud = G;
          G.prototype.num_attributes = G.prototype.num_attributes = function() {
            return zb(this.ptr);
          };
          G.prototype.num_points = G.prototype.num_points = function() {
            return Ab(this.ptr);
          };
          G.prototype.__destroy__ = G.prototype.__destroy__ = function() {
            Bb(this.ptr);
          };
          E.prototype = Object.create(t.prototype);
          E.prototype.constructor = E;
          E.prototype.__class__ = E;
          E.__cache__ = {};
          a.Mesh = E;
          E.prototype.num_faces = E.prototype.num_faces = function() {
            return Cb(this.ptr);
          };
          E.prototype.num_attributes = E.prototype.num_attributes = function() {
            return Db(this.ptr);
          };
          E.prototype.num_points = E.prototype.num_points = function() {
            return Eb(this.ptr);
          };
          E.prototype.__destroy__ = E.prototype.__destroy__ = function() {
            Fb(this.ptr);
          };
          T.prototype = Object.create(t.prototype);
          T.prototype.constructor = T;
          T.prototype.__class__ = T;
          T.__cache__ = {};
          a.Metadata = T;
          T.prototype.__destroy__ = T.prototype.__destroy__ = function() {
            Gb(this.ptr);
          };
          B.prototype = Object.create(t.prototype);
          B.prototype.constructor = B;
          B.prototype.__class__ = B;
          B.__cache__ = {};
          a.Status = B;
          B.prototype.code = B.prototype.code = function() {
            return Hb(this.ptr);
          };
          B.prototype.ok = B.prototype.ok = function() {
            return !!Ib(this.ptr);
          };
          B.prototype.error_msg = B.prototype.error_msg = function() {
            return h(Jb(this.ptr));
          };
          B.prototype.__destroy__ = B.prototype.__destroy__ = function() {
            Kb(this.ptr);
          };
          H.prototype = Object.create(t.prototype);
          H.prototype.constructor = H;
          H.prototype.__class__ = H;
          H.__cache__ = {};
          a.DracoFloat32Array = H;
          H.prototype.GetValue = H.prototype.GetValue = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            return Lb(c, b);
          };
          H.prototype.size = H.prototype.size = function() {
            return Mb(this.ptr);
          };
          H.prototype.__destroy__ = H.prototype.__destroy__ = function() {
            Nb(this.ptr);
          };
          I.prototype = Object.create(t.prototype);
          I.prototype.constructor = I;
          I.prototype.__class__ = I;
          I.__cache__ = {};
          a.DracoInt8Array = I;
          I.prototype.GetValue = I.prototype.GetValue = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            return Ob(c, b);
          };
          I.prototype.size = I.prototype.size = function() {
            return Pb(this.ptr);
          };
          I.prototype.__destroy__ = I.prototype.__destroy__ = function() {
            Qb(this.ptr);
          };
          J.prototype = Object.create(t.prototype);
          J.prototype.constructor = J;
          J.prototype.__class__ = J;
          J.__cache__ = {};
          a.DracoUInt8Array = J;
          J.prototype.GetValue = J.prototype.GetValue = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            return Rb(c, b);
          };
          J.prototype.size = J.prototype.size = function() {
            return Sb(this.ptr);
          };
          J.prototype.__destroy__ = J.prototype.__destroy__ = function() {
            Tb(this.ptr);
          };
          K.prototype = Object.create(t.prototype);
          K.prototype.constructor = K;
          K.prototype.__class__ = K;
          K.__cache__ = {};
          a.DracoInt16Array = K;
          K.prototype.GetValue = K.prototype.GetValue = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            return Ub(c, b);
          };
          K.prototype.size = K.prototype.size = function() {
            return Vb(this.ptr);
          };
          K.prototype.__destroy__ = K.prototype.__destroy__ = function() {
            Wb(this.ptr);
          };
          L.prototype = Object.create(t.prototype);
          L.prototype.constructor = L;
          L.prototype.__class__ = L;
          L.__cache__ = {};
          a.DracoUInt16Array = L;
          L.prototype.GetValue = L.prototype.GetValue = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            return Xb(c, b);
          };
          L.prototype.size = L.prototype.size = function() {
            return Yb(this.ptr);
          };
          L.prototype.__destroy__ = L.prototype.__destroy__ = function() {
            Zb(this.ptr);
          };
          M.prototype = Object.create(t.prototype);
          M.prototype.constructor = M;
          M.prototype.__class__ = M;
          M.__cache__ = {};
          a.DracoInt32Array = M;
          M.prototype.GetValue = M.prototype.GetValue = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            return $b(c, b);
          };
          M.prototype.size = M.prototype.size = function() {
            return ac(this.ptr);
          };
          M.prototype.__destroy__ = M.prototype.__destroy__ = function() {
            bc(this.ptr);
          };
          N.prototype = Object.create(t.prototype);
          N.prototype.constructor = N;
          N.prototype.__class__ = N;
          N.__cache__ = {};
          a.DracoUInt32Array = N;
          N.prototype.GetValue = N.prototype.GetValue = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            return cc(c, b);
          };
          N.prototype.size = N.prototype.size = function() {
            return dc(this.ptr);
          };
          N.prototype.__destroy__ = N.prototype.__destroy__ = function() {
            ec(this.ptr);
          };
          y.prototype = Object.create(t.prototype);
          y.prototype.constructor = y;
          y.prototype.__class__ = y;
          y.__cache__ = {};
          a.MetadataQuerier = y;
          y.prototype.HasEntry = y.prototype.HasEntry = function(b, c) {
            var d = this.ptr;
            r.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c = c && "object" === typeof c ? c.ptr : R(c);
            return !!fc(d, b, c);
          };
          y.prototype.GetIntEntry = y.prototype.GetIntEntry = function(b, c) {
            var d = this.ptr;
            r.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c = c && "object" === typeof c ? c.ptr : R(c);
            return gc(d, b, c);
          };
          y.prototype.GetIntEntryArray = y.prototype.GetIntEntryArray = function(b, c, d) {
            var g = this.ptr;
            r.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c = c && "object" === typeof c ? c.ptr : R(c);
            d && "object" === typeof d && (d = d.ptr);
            hc(g, b, c, d);
          };
          y.prototype.GetDoubleEntry = y.prototype.GetDoubleEntry = function(b, c) {
            var d = this.ptr;
            r.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c = c && "object" === typeof c ? c.ptr : R(c);
            return ic(d, b, c);
          };
          y.prototype.GetStringEntry = y.prototype.GetStringEntry = function(b, c) {
            var d = this.ptr;
            r.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c = c && "object" === typeof c ? c.ptr : R(c);
            return h(jc(d, b, c));
          };
          y.prototype.NumEntries = y.prototype.NumEntries = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            return kc(c, b);
          };
          y.prototype.GetEntryName = y.prototype.GetEntryName = function(b, c) {
            var d = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            return h(lc(d, b, c));
          };
          y.prototype.__destroy__ = y.prototype.__destroy__ = function() {
            mc(this.ptr);
          };
          m.prototype = Object.create(t.prototype);
          m.prototype.constructor = m;
          m.prototype.__class__ = m;
          m.__cache__ = {};
          a.Decoder = m;
          m.prototype.DecodeArrayToPointCloud = m.prototype.DecodeArrayToPointCloud = function(b, c, d) {
            var g = this.ptr;
            r.prepare();
            "object" == typeof b && (b = pa(b));
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            return D(nc(g, b, c, d), B);
          };
          m.prototype.DecodeArrayToMesh = m.prototype.DecodeArrayToMesh = function(b, c, d) {
            var g = this.ptr;
            r.prepare();
            "object" == typeof b && (b = pa(b));
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            return D(oc(g, b, c, d), B);
          };
          m.prototype.GetAttributeId = m.prototype.GetAttributeId = function(b, c) {
            var d = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            return pc(d, b, c);
          };
          m.prototype.GetAttributeIdByName = m.prototype.GetAttributeIdByName = function(b, c) {
            var d = this.ptr;
            r.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c = c && "object" === typeof c ? c.ptr : R(c);
            return qc(d, b, c);
          };
          m.prototype.GetAttributeIdByMetadataEntry = m.prototype.GetAttributeIdByMetadataEntry = function(b, c, d) {
            var g = this.ptr;
            r.prepare();
            b && "object" === typeof b && (b = b.ptr);
            c = c && "object" === typeof c ? c.ptr : R(c);
            d = d && "object" === typeof d ? d.ptr : R(d);
            return rc(g, b, c, d);
          };
          m.prototype.GetAttribute = m.prototype.GetAttribute = function(b, c) {
            var d = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            return D(sc(d, b, c), w);
          };
          m.prototype.GetAttributeByUniqueId = m.prototype.GetAttributeByUniqueId = function(b, c) {
            var d = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            return D(tc(d, b, c), w);
          };
          m.prototype.GetMetadata = m.prototype.GetMetadata = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            return D(uc(c, b), T);
          };
          m.prototype.GetAttributeMetadata = m.prototype.GetAttributeMetadata = function(b, c) {
            var d = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            return D(vc(d, b, c), T);
          };
          m.prototype.GetFaceFromMesh = m.prototype.GetFaceFromMesh = function(b, c, d) {
            var g = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            return !!wc(g, b, c, d);
          };
          m.prototype.GetTriangleStripsFromMesh = m.prototype.GetTriangleStripsFromMesh = function(b, c) {
            var d = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            return xc(d, b, c);
          };
          m.prototype.GetTrianglesUInt16Array = m.prototype.GetTrianglesUInt16Array = function(b, c, d) {
            var g = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            return !!yc(g, b, c, d);
          };
          m.prototype.GetTrianglesUInt32Array = m.prototype.GetTrianglesUInt32Array = function(b, c, d) {
            var g = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            return !!zc(g, b, c, d);
          };
          m.prototype.GetAttributeFloat = m.prototype.GetAttributeFloat = function(b, c, d) {
            var g = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            return !!Ac(g, b, c, d);
          };
          m.prototype.GetAttributeFloatForAllPoints = m.prototype.GetAttributeFloatForAllPoints = function(b, c, d) {
            var g = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            return !!Bc(g, b, c, d);
          };
          m.prototype.GetAttributeIntForAllPoints = m.prototype.GetAttributeIntForAllPoints = function(b, c, d) {
            var g = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            return !!Cc(g, b, c, d);
          };
          m.prototype.GetAttributeInt8ForAllPoints = m.prototype.GetAttributeInt8ForAllPoints = function(b, c, d) {
            var g = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            return !!Dc(g, b, c, d);
          };
          m.prototype.GetAttributeUInt8ForAllPoints = m.prototype.GetAttributeUInt8ForAllPoints = function(b, c, d) {
            var g = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            return !!Ec(g, b, c, d);
          };
          m.prototype.GetAttributeInt16ForAllPoints = m.prototype.GetAttributeInt16ForAllPoints = function(b, c, d) {
            var g = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            return !!Fc(g, b, c, d);
          };
          m.prototype.GetAttributeUInt16ForAllPoints = m.prototype.GetAttributeUInt16ForAllPoints = function(b, c, d) {
            var g = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            return !!Gc(g, b, c, d);
          };
          m.prototype.GetAttributeInt32ForAllPoints = m.prototype.GetAttributeInt32ForAllPoints = function(b, c, d) {
            var g = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            return !!Hc(g, b, c, d);
          };
          m.prototype.GetAttributeUInt32ForAllPoints = m.prototype.GetAttributeUInt32ForAllPoints = function(b, c, d) {
            var g = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            return !!Ic(g, b, c, d);
          };
          m.prototype.GetAttributeDataArrayForAllPoints = m.prototype.GetAttributeDataArrayForAllPoints = function(b, c, d, g, u) {
            var X = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            d && "object" === typeof d && (d = d.ptr);
            g && "object" === typeof g && (g = g.ptr);
            u && "object" === typeof u && (u = u.ptr);
            return !!Jc(X, b, c, d, g, u);
          };
          m.prototype.SkipAttributeTransform = m.prototype.SkipAttributeTransform = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            Kc(c, b);
          };
          m.prototype.GetEncodedGeometryType_Deprecated = m.prototype.GetEncodedGeometryType_Deprecated = function(b) {
            var c = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            return Lc(c, b);
          };
          m.prototype.DecodeBufferToPointCloud = m.prototype.DecodeBufferToPointCloud = function(b, c) {
            var d = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            return D(Mc(d, b, c), B);
          };
          m.prototype.DecodeBufferToMesh = m.prototype.DecodeBufferToMesh = function(b, c) {
            var d = this.ptr;
            b && "object" === typeof b && (b = b.ptr);
            c && "object" === typeof c && (c = c.ptr);
            return D(Nc(d, b, c), B);
          };
          m.prototype.__destroy__ = m.prototype.__destroy__ = function() {
            Oc(this.ptr);
          };
          (function() {
            function b() {
              a.ATTRIBUTE_INVALID_TRANSFORM = Pc();
              a.ATTRIBUTE_NO_TRANSFORM = Qc();
              a.ATTRIBUTE_QUANTIZATION_TRANSFORM = Rc();
              a.ATTRIBUTE_OCTAHEDRON_TRANSFORM = Sc();
              a.INVALID = Tc();
              a.POSITION = Uc();
              a.NORMAL = Vc();
              a.COLOR = Wc();
              a.TEX_COORD = Xc();
              a.GENERIC = Yc();
              a.INVALID_GEOMETRY_TYPE = Zc();
              a.POINT_CLOUD = $c();
              a.TRIANGULAR_MESH = ad();
              a.DT_INVALID = bd();
              a.DT_INT8 = cd();
              a.DT_UINT8 = dd();
              a.DT_INT16 = ed();
              a.DT_UINT16 = fd();
              a.DT_INT32 = gd();
              a.DT_UINT32 = hd();
              a.DT_INT64 = id();
              a.DT_UINT64 = jd();
              a.DT_FLOAT32 = kd();
              a.DT_FLOAT64 = ld();
              a.DT_BOOL = md();
              a.DT_TYPES_COUNT = nd();
              a.OK = od();
              a.DRACO_ERROR = pd();
              a.IO_ERROR = qd();
              a.INVALID_PARAMETER = rd();
              a.UNSUPPORTED_VERSION = sd();
              a.UNKNOWN_VERSION = td();
            }
            za ? b() : oa.unshift(b);
          })();
          if ("function" === typeof a.onModuleParsed) a.onModuleParsed();
          a.Decoder.prototype.GetEncodedGeometryType = function(b) {
            if (b.__class__ && b.__class__ === a.DecoderBuffer) return a.Decoder.prototype.GetEncodedGeometryType_Deprecated(b);
            if (8 > b.byteLength) return a.INVALID_GEOMETRY_TYPE;
            switch (b[7]) {
              case 0:
                return a.POINT_CLOUD;
              case 1:
                return a.TRIANGULAR_MESH;
              default:
                return a.INVALID_GEOMETRY_TYPE;
            }
          };
          return n.ready;
        };
      })();
      "object" === typeof exports2 && "object" === typeof module2 ? module2.exports = DracoDecoderModule : "function" === typeof define && define.amd ? define([], function() {
        return DracoDecoderModule;
      }) : "object" === typeof exports2 && (exports2.DracoDecoderModule = DracoDecoderModule);
    }
  });

  // node_modules/draco3d/draco3d.js
  var require_draco3d = __commonJS({
    "node_modules/draco3d/draco3d.js"(exports2, module2) {
      var createEncoderModule = require_draco_encoder_nodejs();
      var createDecoderModule = require_draco_decoder_nodejs();
      module2.exports = {
        createEncoderModule,
        createDecoderModule
      };
    }
  });

  // node-builtins-ns:crypto
  var crypto_exports = {};
  __export(crypto_exports, {
    default: () => crypto_default
  });
  var crypto_default;
  var init_crypto = __esm({
    "node-builtins-ns:crypto"() {
      crypto_default = {};
    }
  });

  // libktx.js
  var libktx_exports = {};
  var init_libktx = __esm({
    "libktx.js"() {
      window.LIBKTX = (function() {
        var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
        return (function(LIBKTX2) {
          LIBKTX2 = LIBKTX2 || {};
          var Module2 = typeof LIBKTX2 !== "undefined" ? LIBKTX2 : {};
          var moduleOverrides = {};
          var key;
          for (key in Module2) {
            if (Module2.hasOwnProperty(key)) {
              moduleOverrides[key] = Module2[key];
            }
          }
          var arguments_ = [];
          var thisProgram = "./this.program";
          var quit_ = function(status, toThrow) {
            throw toThrow;
          };
          var ENVIRONMENT_IS_WEB = false;
          var ENVIRONMENT_IS_WORKER = false;
          var ENVIRONMENT_IS_NODE = false;
          var ENVIRONMENT_HAS_NODE = false;
          var ENVIRONMENT_IS_SHELL = false;
          ENVIRONMENT_IS_WEB = typeof window === "object";
          ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
          ENVIRONMENT_HAS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
          ENVIRONMENT_IS_NODE = ENVIRONMENT_HAS_NODE && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
          ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
          var scriptDirectory = "";
          function locateFile(path) {
            if (Module2["locateFile"]) {
              return Module2["locateFile"](path, scriptDirectory);
            }
            return scriptDirectory + path;
          }
          var read_, readAsync, readBinary, setWindowTitle;
          if (ENVIRONMENT_IS_NODE) {
            scriptDirectory = __dirname + "/";
            var nodeFS;
            var nodePath;
            read_ = function shell_read(filename, binary) {
              var ret;
              if (!nodeFS) nodeFS = (init_fs(), __toCommonJS(fs_exports));
              if (!nodePath) nodePath = (init_path(), __toCommonJS(path_exports));
              filename = nodePath["normalize"](filename);
              ret = nodeFS["readFileSync"](filename);
              return binary ? ret : ret.toString();
            };
            readBinary = function readBinary2(filename) {
              var ret = read_(filename, true);
              if (!ret.buffer) {
                ret = new Uint8Array(ret);
              }
              assert(ret.buffer);
              return ret;
            };
            if (process["argv"].length > 1) {
              thisProgram = process["argv"][1].replace(/\\/g, "/");
            }
            arguments_ = process["argv"].slice(2);
            process["on"]("uncaughtException", function(ex) {
              if (!(ex instanceof ExitStatus)) {
                throw ex;
              }
            });
            process["on"]("unhandledRejection", abort);
            quit_ = function(status) {
              process["exit"](status);
            };
            Module2["inspect"] = function() {
              return "[Emscripten Module object]";
            };
          } else if (ENVIRONMENT_IS_SHELL) {
            if (typeof read != "undefined") {
              read_ = function shell_read(f) {
                return read(f);
              };
            }
            readBinary = function readBinary2(f) {
              var data;
              if (typeof readbuffer === "function") {
                return new Uint8Array(readbuffer(f));
              }
              data = read(f, "binary");
              assert(typeof data === "object");
              return data;
            };
            if (typeof scriptArgs != "undefined") {
              arguments_ = scriptArgs;
            } else if (typeof arguments != "undefined") {
              arguments_ = arguments;
            }
            if (typeof quit === "function") {
              quit_ = function(status) {
                quit(status);
              };
            }
            if (typeof print !== "undefined") {
              if (typeof console === "undefined") console = {};
              console.log = print;
              console.warn = console.error = typeof printErr !== "undefined" ? printErr : print;
            }
          } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
            if (ENVIRONMENT_IS_WORKER) {
              scriptDirectory = self.location.href;
            } else if (document.currentScript) {
              scriptDirectory = document.currentScript.src;
            }
            if (_scriptDir) {
              scriptDirectory = _scriptDir;
            }
            if (scriptDirectory.indexOf("blob:") !== 0) {
              scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
            } else {
              scriptDirectory = "";
            }
            read_ = function shell_read(url) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.send(null);
              return xhr.responseText;
            };
            if (ENVIRONMENT_IS_WORKER) {
              readBinary = function readBinary2(url) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(xhr.response);
              };
            }
            readAsync = function readAsync2(url, onload, onerror) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = function xhr_onload() {
                if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                  onload(xhr.response);
                  return;
                }
                onerror();
              };
              xhr.onerror = onerror;
              xhr.send(null);
            };
            setWindowTitle = function(title) {
              document.title = title;
            };
          } else {
          }
          var out = Module2["print"] || console.log.bind(console);
          var err = Module2["printErr"] || console.warn.bind(console);
          for (key in moduleOverrides) {
            if (moduleOverrides.hasOwnProperty(key)) {
              Module2[key] = moduleOverrides[key];
            }
          }
          moduleOverrides = null;
          if (Module2["arguments"]) arguments_ = Module2["arguments"];
          if (Module2["thisProgram"]) thisProgram = Module2["thisProgram"];
          if (Module2["quit"]) quit_ = Module2["quit"];
          function dynamicAlloc(size) {
            var ret = HEAP32[DYNAMICTOP_PTR >> 2];
            var end = ret + size + 15 & -16;
            if (end > _emscripten_get_heap_size()) {
              abort();
            }
            HEAP32[DYNAMICTOP_PTR >> 2] = end;
            return ret;
          }
          function getNativeTypeSize(type) {
            switch (type) {
              case "i1":
              case "i8":
                return 1;
              case "i16":
                return 2;
              case "i32":
                return 4;
              case "i64":
                return 8;
              case "float":
                return 4;
              case "double":
                return 8;
              default: {
                if (type[type.length - 1] === "*") {
                  return 4;
                } else if (type[0] === "i") {
                  var bits = parseInt(type.substr(1));
                  assert(bits % 8 === 0, "getNativeTypeSize invalid bits " + bits + ", type " + type);
                  return bits / 8;
                } else {
                  return 0;
                }
              }
            }
          }
          var asm2wasmImports = { "f64-rem": function(x, y) {
            return x % y;
          }, "debugger": function() {
          } };
          var functionPointers = new Array(0);
          var tempRet0 = 0;
          var setTempRet0 = function(value) {
            tempRet0 = value;
          };
          var wasmBinary;
          if (Module2["wasmBinary"]) wasmBinary = Module2["wasmBinary"];
          var noExitRuntime;
          if (Module2["noExitRuntime"]) noExitRuntime = Module2["noExitRuntime"];
          if (typeof WebAssembly !== "object") {
            err("no native wasm support detected");
          }
          function setValue(ptr, value, type, noSafe) {
            type = type || "i8";
            if (type.charAt(type.length - 1) === "*") type = "i32";
            switch (type) {
              case "i1":
                HEAP8[ptr >> 0] = value;
                break;
              case "i8":
                HEAP8[ptr >> 0] = value;
                break;
              case "i16":
                HEAP16[ptr >> 1] = value;
                break;
              case "i32":
                HEAP32[ptr >> 2] = value;
                break;
              case "i64":
                tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
                break;
              case "float":
                HEAPF32[ptr >> 2] = value;
                break;
              case "double":
                HEAPF64[ptr >> 3] = value;
                break;
              default:
                abort("invalid type for setValue: " + type);
            }
          }
          var wasmMemory;
          var wasmTable;
          var ABORT = false;
          var EXITSTATUS = 0;
          function assert(condition, text) {
            if (!condition) {
              abort("Assertion failed: " + text);
            }
          }
          var ALLOC_NONE = 3;
          function allocate(slab, types, allocator, ptr) {
            var zeroinit, size;
            if (typeof slab === "number") {
              zeroinit = true;
              size = slab;
            } else {
              zeroinit = false;
              size = slab.length;
            }
            var singleType = typeof types === "string" ? types : null;
            var ret;
            if (allocator == ALLOC_NONE) {
              ret = ptr;
            } else {
              ret = [_malloc, stackAlloc, dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));
            }
            if (zeroinit) {
              var stop;
              ptr = ret;
              assert((ret & 3) == 0);
              stop = ret + (size & ~3);
              for (; ptr < stop; ptr += 4) {
                HEAP32[ptr >> 2] = 0;
              }
              stop = ret + size;
              while (ptr < stop) {
                HEAP8[ptr++ >> 0] = 0;
              }
              return ret;
            }
            if (singleType === "i8") {
              if (slab.subarray || slab.slice) {
                HEAPU8.set(slab, ret);
              } else {
                HEAPU8.set(new Uint8Array(slab), ret);
              }
              return ret;
            }
            var i2 = 0, type, typeSize, previousType;
            while (i2 < size) {
              var curr = slab[i2];
              type = singleType || types[i2];
              if (type === 0) {
                i2++;
                continue;
              }
              if (type == "i64") type = "i32";
              setValue(ret + i2, curr, type);
              if (previousType !== type) {
                typeSize = getNativeTypeSize(type);
                previousType = type;
              }
              i2 += typeSize;
            }
            return ret;
          }
          var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
          function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {
            var endIdx = idx + maxBytesToRead;
            var endPtr = idx;
            while (u8Array[endPtr] && !(endPtr >= endIdx)) ++endPtr;
            if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
              return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
            } else {
              var str = "";
              while (idx < endPtr) {
                var u0 = u8Array[idx++];
                if (!(u0 & 128)) {
                  str += String.fromCharCode(u0);
                  continue;
                }
                var u1 = u8Array[idx++] & 63;
                if ((u0 & 224) == 192) {
                  str += String.fromCharCode((u0 & 31) << 6 | u1);
                  continue;
                }
                var u2 = u8Array[idx++] & 63;
                if ((u0 & 240) == 224) {
                  u0 = (u0 & 15) << 12 | u1 << 6 | u2;
                } else {
                  u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63;
                }
                if (u0 < 65536) {
                  str += String.fromCharCode(u0);
                } else {
                  var ch = u0 - 65536;
                  str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
                }
              }
            }
            return str;
          }
          function UTF8ToString(ptr, maxBytesToRead) {
            return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
          }
          function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
            if (!(maxBytesToWrite > 0)) return 0;
            var startIdx = outIdx;
            var endIdx = outIdx + maxBytesToWrite - 1;
            for (var i2 = 0; i2 < str.length; ++i2) {
              var u = str.charCodeAt(i2);
              if (u >= 55296 && u <= 57343) {
                var u1 = str.charCodeAt(++i2);
                u = 65536 + ((u & 1023) << 10) | u1 & 1023;
              }
              if (u <= 127) {
                if (outIdx >= endIdx) break;
                outU8Array[outIdx++] = u;
              } else if (u <= 2047) {
                if (outIdx + 1 >= endIdx) break;
                outU8Array[outIdx++] = 192 | u >> 6;
                outU8Array[outIdx++] = 128 | u & 63;
              } else if (u <= 65535) {
                if (outIdx + 2 >= endIdx) break;
                outU8Array[outIdx++] = 224 | u >> 12;
                outU8Array[outIdx++] = 128 | u >> 6 & 63;
                outU8Array[outIdx++] = 128 | u & 63;
              } else {
                if (outIdx + 3 >= endIdx) break;
                outU8Array[outIdx++] = 240 | u >> 18;
                outU8Array[outIdx++] = 128 | u >> 12 & 63;
                outU8Array[outIdx++] = 128 | u >> 6 & 63;
                outU8Array[outIdx++] = 128 | u & 63;
              }
            }
            outU8Array[outIdx] = 0;
            return outIdx - startIdx;
          }
          function stringToUTF8(str, outPtr, maxBytesToWrite) {
            return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
          }
          function lengthBytesUTF8(str) {
            var len = 0;
            for (var i2 = 0; i2 < str.length; ++i2) {
              var u = str.charCodeAt(i2);
              if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i2) & 1023;
              if (u <= 127) ++len;
              else if (u <= 2047) len += 2;
              else if (u <= 65535) len += 3;
              else len += 4;
            }
            return len;
          }
          var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
          function allocateUTF8(str) {
            var size = lengthBytesUTF8(str) + 1;
            var ret = _malloc(size);
            if (ret) stringToUTF8Array(str, HEAP8, ret, size);
            return ret;
          }
          function writeArrayToMemory(array, buffer2) {
            HEAP8.set(array, buffer2);
          }
          var WASM_PAGE_SIZE = 65536;
          function alignUp(x, multiple) {
            if (x % multiple > 0) {
              x += multiple - x % multiple;
            }
            return x;
          }
          var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
          function updateGlobalBufferAndViews(buf) {
            buffer = buf;
            Module2["HEAP8"] = HEAP8 = new Int8Array(buf);
            Module2["HEAP16"] = HEAP16 = new Int16Array(buf);
            Module2["HEAP32"] = HEAP32 = new Int32Array(buf);
            Module2["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
            Module2["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
            Module2["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
            Module2["HEAPF32"] = HEAPF32 = new Float32Array(buf);
            Module2["HEAPF64"] = HEAPF64 = new Float64Array(buf);
          }
          var DYNAMIC_BASE = 5615952, DYNAMICTOP_PTR = 373040;
          var INITIAL_TOTAL_MEMORY = Module2["TOTAL_MEMORY"] || 16777216;
          if (Module2["wasmMemory"]) {
            wasmMemory = Module2["wasmMemory"];
          } else {
            wasmMemory = new WebAssembly.Memory({ "initial": INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE });
          }
          if (wasmMemory) {
            buffer = wasmMemory.buffer;
          }
          INITIAL_TOTAL_MEMORY = buffer.byteLength;
          updateGlobalBufferAndViews(buffer);
          HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
          function callRuntimeCallbacks(callbacks) {
            while (callbacks.length > 0) {
              var callback = callbacks.shift();
              if (typeof callback == "function") {
                callback();
                continue;
              }
              var func = callback.func;
              if (typeof func === "number") {
                if (callback.arg === void 0) {
                  Module2["dynCall_v"](func);
                } else {
                  Module2["dynCall_vi"](func, callback.arg);
                }
              } else {
                func(callback.arg === void 0 ? null : callback.arg);
              }
            }
          }
          var __ATPRERUN__ = [];
          var __ATINIT__ = [];
          var __ATMAIN__ = [];
          var __ATPOSTRUN__ = [];
          var runtimeInitialized = false;
          var runtimeExited = false;
          function preRun() {
            if (Module2["preRun"]) {
              if (typeof Module2["preRun"] == "function") Module2["preRun"] = [Module2["preRun"]];
              while (Module2["preRun"].length) {
                addOnPreRun(Module2["preRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPRERUN__);
          }
          function initRuntime() {
            runtimeInitialized = true;
            if (!Module2["noFSInit"] && !FS.init.initialized) FS.init();
            TTY.init();
            callRuntimeCallbacks(__ATINIT__);
          }
          function preMain() {
            FS.ignorePermissions = false;
            callRuntimeCallbacks(__ATMAIN__);
          }
          function exitRuntime() {
            runtimeExited = true;
          }
          function postRun() {
            if (Module2["postRun"]) {
              if (typeof Module2["postRun"] == "function") Module2["postRun"] = [Module2["postRun"]];
              while (Module2["postRun"].length) {
                addOnPostRun(Module2["postRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPOSTRUN__);
          }
          function addOnPreRun(cb) {
            __ATPRERUN__.unshift(cb);
          }
          function addOnPostRun(cb) {
            __ATPOSTRUN__.unshift(cb);
          }
          var Math_abs = Math.abs;
          var Math_ceil = Math.ceil;
          var Math_floor = Math.floor;
          var Math_min = Math.min;
          var runDependencies = 0;
          var runDependencyWatcher = null;
          var dependenciesFulfilled = null;
          function getUniqueRunDependency(id) {
            return id;
          }
          function addRunDependency(id) {
            runDependencies++;
            if (Module2["monitorRunDependencies"]) {
              Module2["monitorRunDependencies"](runDependencies);
            }
          }
          function removeRunDependency(id) {
            runDependencies--;
            if (Module2["monitorRunDependencies"]) {
              Module2["monitorRunDependencies"](runDependencies);
            }
            if (runDependencies == 0) {
              if (runDependencyWatcher !== null) {
                clearInterval(runDependencyWatcher);
                runDependencyWatcher = null;
              }
              if (dependenciesFulfilled) {
                var callback = dependenciesFulfilled;
                dependenciesFulfilled = null;
                callback();
              }
            }
          }
          Module2["preloadedImages"] = {};
          Module2["preloadedAudios"] = {};
          var dataURIPrefix = "data:application/octet-stream;base64,";
          function isDataURI(filename) {
            return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;
          }
          var wasmBinaryFile = "libktx.wasm";
          if (!isDataURI(wasmBinaryFile)) {
            wasmBinaryFile = locateFile(wasmBinaryFile);
          }
          function getBinary() {
            try {
              if (wasmBinary) {
                return new Uint8Array(wasmBinary);
              }
              if (readBinary) {
                return readBinary(wasmBinaryFile);
              } else {
                throw "both async and sync fetching of the wasm failed";
              }
            } catch (err2) {
              abort(err2);
            }
          }
          function getBinaryPromise() {
            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function") {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                if (!response["ok"]) {
                  throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                }
                return response["arrayBuffer"]();
              }).catch(function() {
                return getBinary();
              });
            }
            return new Promise(function(resolve, reject) {
              resolve(getBinary());
            });
          }
          function createWasm(env) {
            var info = { "env": env, "global": { "NaN": NaN, Infinity: Infinity }, "global.Math": Math, "asm2wasm": asm2wasmImports };
            function receiveInstance(instance, module2) {
              var exports3 = instance.exports;
              Module2["asm"] = exports3;
              removeRunDependency("wasm-instantiate");
            }
            addRunDependency("wasm-instantiate");
            function receiveInstantiatedSource(output) {
              receiveInstance(output["instance"]);
            }
            function instantiateArrayBuffer(receiver) {
              return getBinaryPromise().then(function(binary) {
                return WebAssembly.instantiate(binary, info);
              }).then(receiver, function(reason) {
                err("failed to asynchronously prepare wasm: " + reason);
                abort(reason);
              });
            }
            function instantiateAsync() {
              if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && typeof fetch === "function") {
                fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                  var result = WebAssembly.instantiateStreaming(response, info);
                  return result.then(receiveInstantiatedSource, function(reason) {
                    err("wasm streaming compile failed: " + reason);
                    err("falling back to ArrayBuffer instantiation");
                    instantiateArrayBuffer(receiveInstantiatedSource);
                  });
                });
              } else {
                return instantiateArrayBuffer(receiveInstantiatedSource);
              }
            }
            if (Module2["instantiateWasm"]) {
              try {
                var exports2 = Module2["instantiateWasm"](info, receiveInstance);
                return exports2;
              } catch (e) {
                err("Module.instantiateWasm callback failed with error: " + e);
                return false;
              }
            }
            instantiateAsync();
            return {};
          }
          Module2["asm"] = function(global2, env, providedBuffer) {
            env["memory"] = wasmMemory;
            env["table"] = wasmTable = new WebAssembly.Table({ "initial": 1167, "maximum": 1167, "element": "anyfunc" });
            env["__memory_base"] = 1024;
            env["__table_base"] = 0;
            var exports2 = createWasm(env);
            return exports2;
          };
          var tempDouble;
          var tempI64;
          __ATINIT__.push({ func: function() {
            globalCtors();
          } });
          function demangle(func) {
            return func;
          }
          function demangleAll(text) {
            var regex = /\b__Z[\w\d_]+/g;
            return text.replace(regex, function(x) {
              var y = demangle(x);
              return x === y ? x : y + " [" + x + "]";
            });
          }
          function jsStackTrace() {
            var err2 = new Error();
            if (!err2.stack) {
              try {
                throw new Error(0);
              } catch (e) {
                err2 = e;
              }
              if (!err2.stack) {
                return "(no stack trace available)";
              }
            }
            return err2.stack.toString();
          }
          function stackTrace() {
            var js = jsStackTrace();
            if (Module2["extraStackTrace"]) js += "\n" + Module2["extraStackTrace"]();
            return demangleAll(js);
          }
          function ___assert_fail(condition, filename, line, func) {
            abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
          }
          function ___cxa_allocate_exception(size) {
            return _malloc(size);
          }
          var ___exception_infos = {};
          function ___cxa_pure_virtual() {
            ABORT = true;
            throw "Pure virtual function called!";
          }
          var ___exception_last = 0;
          function ___cxa_throw(ptr, type, destructor) {
            ___exception_infos[ptr] = { ptr, adjusted: [ptr], type, destructor, refcount: 0, caught: false, rethrown: false };
            ___exception_last = ptr;
            if (!("uncaught_exception" in __ZSt18uncaught_exceptionv)) {
              __ZSt18uncaught_exceptionv.uncaught_exceptions = 1;
            } else {
              __ZSt18uncaught_exceptionv.uncaught_exceptions++;
            }
            throw ptr;
          }
          function ___cxa_uncaught_exceptions() {
            return __ZSt18uncaught_exceptionv.uncaught_exceptions;
          }
          function ___lock() {
          }
          function ___setErrNo(value) {
            if (Module2["___errno_location"]) HEAP32[Module2["___errno_location"]() >> 2] = value;
            return value;
          }
          function ___map_file(pathname, size) {
            ___setErrNo(1);
            return -1;
          }
          var PATH = { splitPath: function(filename) {
            var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
            return splitPathRe.exec(filename).slice(1);
          }, normalizeArray: function(parts, allowAboveRoot) {
            var up = 0;
            for (var i2 = parts.length - 1; i2 >= 0; i2--) {
              var last = parts[i2];
              if (last === ".") {
                parts.splice(i2, 1);
              } else if (last === "..") {
                parts.splice(i2, 1);
                up++;
              } else if (up) {
                parts.splice(i2, 1);
                up--;
              }
            }
            if (allowAboveRoot) {
              for (; up; up--) {
                parts.unshift("..");
              }
            }
            return parts;
          }, normalize: function(path) {
            var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
            path = PATH.normalizeArray(path.split("/").filter(function(p) {
              return !!p;
            }), !isAbsolute).join("/");
            if (!path && !isAbsolute) {
              path = ".";
            }
            if (path && trailingSlash) {
              path += "/";
            }
            return (isAbsolute ? "/" : "") + path;
          }, dirname: function(path) {
            var result = PATH.splitPath(path), root = result[0], dir = result[1];
            if (!root && !dir) {
              return ".";
            }
            if (dir) {
              dir = dir.substr(0, dir.length - 1);
            }
            return root + dir;
          }, basename: function(path) {
            if (path === "/") return "/";
            var lastSlash = path.lastIndexOf("/");
            if (lastSlash === -1) return path;
            return path.substr(lastSlash + 1);
          }, extname: function(path) {
            return PATH.splitPath(path)[3];
          }, join: function() {
            var paths = Array.prototype.slice.call(arguments, 0);
            return PATH.normalize(paths.join("/"));
          }, join2: function(l, r) {
            return PATH.normalize(l + "/" + r);
          } };
          var PATH_FS = { resolve: function() {
            var resolvedPath = "", resolvedAbsolute = false;
            for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
              var path = i2 >= 0 ? arguments[i2] : FS.cwd();
              if (typeof path !== "string") {
                throw new TypeError("Arguments to path.resolve must be strings");
              } else if (!path) {
                return "";
              }
              resolvedPath = path + "/" + resolvedPath;
              resolvedAbsolute = path.charAt(0) === "/";
            }
            resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function(p) {
              return !!p;
            }), !resolvedAbsolute).join("/");
            return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
          }, relative: function(from, to) {
            from = PATH_FS.resolve(from).substr(1);
            to = PATH_FS.resolve(to).substr(1);
            function trim(arr) {
              var start = 0;
              for (; start < arr.length; start++) {
                if (arr[start] !== "") break;
              }
              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== "") break;
              }
              if (start > end) return [];
              return arr.slice(start, end - start + 1);
            }
            var fromParts = trim(from.split("/"));
            var toParts = trim(to.split("/"));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i2 = 0; i2 < length; i2++) {
              if (fromParts[i2] !== toParts[i2]) {
                samePartsLength = i2;
                break;
              }
            }
            var outputParts = [];
            for (var i2 = samePartsLength; i2 < fromParts.length; i2++) {
              outputParts.push("..");
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join("/");
          } };
          var TTY = { ttys: [], init: function() {
          }, shutdown: function() {
          }, register: function(dev, ops) {
            TTY.ttys[dev] = { input: [], output: [], ops };
            FS.registerDevice(dev, TTY.stream_ops);
          }, stream_ops: { open: function(stream) {
            var tty = TTY.ttys[stream.node.rdev];
            if (!tty) {
              throw new FS.ErrnoError(19);
            }
            stream.tty = tty;
            stream.seekable = false;
          }, close: function(stream) {
            stream.tty.ops.flush(stream.tty);
          }, flush: function(stream) {
            stream.tty.ops.flush(stream.tty);
          }, read: function(stream, buffer2, offset, length, pos) {
            if (!stream.tty || !stream.tty.ops.get_char) {
              throw new FS.ErrnoError(6);
            }
            var bytesRead = 0;
            for (var i2 = 0; i2 < length; i2++) {
              var result;
              try {
                result = stream.tty.ops.get_char(stream.tty);
              } catch (e) {
                throw new FS.ErrnoError(5);
              }
              if (result === void 0 && bytesRead === 0) {
                throw new FS.ErrnoError(11);
              }
              if (result === null || result === void 0) break;
              bytesRead++;
              buffer2[offset + i2] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          }, write: function(stream, buffer2, offset, length, pos) {
            if (!stream.tty || !stream.tty.ops.put_char) {
              throw new FS.ErrnoError(6);
            }
            try {
              for (var i2 = 0; i2 < length; i2++) {
                stream.tty.ops.put_char(stream.tty, buffer2[offset + i2]);
              }
            } catch (e) {
              throw new FS.ErrnoError(5);
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i2;
          } }, default_tty_ops: { get_char: function(tty) {
            if (!tty.input.length) {
              var result = null;
              if (ENVIRONMENT_IS_NODE) {
                var BUFSIZE = 256;
                var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);
                var bytesRead = 0;
                var isPosixPlatform = process.platform != "win32";
                var fd = process.stdin.fd;
                if (isPosixPlatform) {
                  var usingDevice = false;
                  try {
                    fd = fs.openSync("/dev/stdin", "r");
                    usingDevice = true;
                  } catch (e) {
                  }
                }
                try {
                  bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, null);
                } catch (e) {
                  if (e.toString().indexOf("EOF") != -1) bytesRead = 0;
                  else throw e;
                }
                if (usingDevice) {
                  fs.closeSync(fd);
                }
                if (bytesRead > 0) {
                  result = buf.slice(0, bytesRead).toString("utf-8");
                } else {
                  result = null;
                }
              } else if (typeof window != "undefined" && typeof window.prompt == "function") {
                result = window.prompt("Input: ");
                if (result !== null) {
                  result += "\n";
                }
              } else if (typeof readline == "function") {
                result = readline();
                if (result !== null) {
                  result += "\n";
                }
              }
              if (!result) {
                return null;
              }
              tty.input = intArrayFromString(result, true);
            }
            return tty.input.shift();
          }, put_char: function(tty, val) {
            if (val === null || val === 10) {
              out(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            } else {
              if (val != 0) tty.output.push(val);
            }
          }, flush: function(tty) {
            if (tty.output && tty.output.length > 0) {
              out(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            }
          } }, default_tty1_ops: { put_char: function(tty, val) {
            if (val === null || val === 10) {
              err(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            } else {
              if (val != 0) tty.output.push(val);
            }
          }, flush: function(tty) {
            if (tty.output && tty.output.length > 0) {
              err(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            }
          } } };
          var MEMFS = { ops_table: null, mount: function(mount) {
            return MEMFS.createNode(null, "/", 16384 | 511, 0);
          }, createNode: function(parent, name, mode, dev) {
            if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
              throw new FS.ErrnoError(1);
            }
            if (!MEMFS.ops_table) {
              MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } };
            }
            var node = FS.createNode(parent, name, mode, dev);
            if (FS.isDir(node.mode)) {
              node.node_ops = MEMFS.ops_table.dir.node;
              node.stream_ops = MEMFS.ops_table.dir.stream;
              node.contents = {};
            } else if (FS.isFile(node.mode)) {
              node.node_ops = MEMFS.ops_table.file.node;
              node.stream_ops = MEMFS.ops_table.file.stream;
              node.usedBytes = 0;
              node.contents = null;
            } else if (FS.isLink(node.mode)) {
              node.node_ops = MEMFS.ops_table.link.node;
              node.stream_ops = MEMFS.ops_table.link.stream;
            } else if (FS.isChrdev(node.mode)) {
              node.node_ops = MEMFS.ops_table.chrdev.node;
              node.stream_ops = MEMFS.ops_table.chrdev.stream;
            }
            node.timestamp = Date.now();
            if (parent) {
              parent.contents[name] = node;
            }
            return node;
          }, getFileDataAsRegularArray: function(node) {
            if (node.contents && node.contents.subarray) {
              var arr = [];
              for (var i2 = 0; i2 < node.usedBytes; ++i2) arr.push(node.contents[i2]);
              return arr;
            }
            return node.contents;
          }, getFileDataAsTypedArray: function(node) {
            if (!node.contents) return new Uint8Array();
            if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);
            return new Uint8Array(node.contents);
          }, expandFileStorage: function(node, newCapacity) {
            var prevCapacity = node.contents ? node.contents.length : 0;
            if (prevCapacity >= newCapacity) return;
            var CAPACITY_DOUBLING_MAX = 1024 * 1024;
            newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) | 0);
            if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
            var oldContents = node.contents;
            node.contents = new Uint8Array(newCapacity);
            if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
            return;
          }, resizeFileStorage: function(node, newSize) {
            if (node.usedBytes == newSize) return;
            if (newSize == 0) {
              node.contents = null;
              node.usedBytes = 0;
              return;
            }
            if (!node.contents || node.contents.subarray) {
              var oldContents = node.contents;
              node.contents = new Uint8Array(new ArrayBuffer(newSize));
              if (oldContents) {
                node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
              }
              node.usedBytes = newSize;
              return;
            }
            if (!node.contents) node.contents = [];
            if (node.contents.length > newSize) node.contents.length = newSize;
            else while (node.contents.length < newSize) node.contents.push(0);
            node.usedBytes = newSize;
          }, node_ops: { getattr: function(node) {
            var attr = {};
            attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
            attr.ino = node.id;
            attr.mode = node.mode;
            attr.nlink = 1;
            attr.uid = 0;
            attr.gid = 0;
            attr.rdev = node.rdev;
            if (FS.isDir(node.mode)) {
              attr.size = 4096;
            } else if (FS.isFile(node.mode)) {
              attr.size = node.usedBytes;
            } else if (FS.isLink(node.mode)) {
              attr.size = node.link.length;
            } else {
              attr.size = 0;
            }
            attr.atime = new Date(node.timestamp);
            attr.mtime = new Date(node.timestamp);
            attr.ctime = new Date(node.timestamp);
            attr.blksize = 4096;
            attr.blocks = Math.ceil(attr.size / attr.blksize);
            return attr;
          }, setattr: function(node, attr) {
            if (attr.mode !== void 0) {
              node.mode = attr.mode;
            }
            if (attr.timestamp !== void 0) {
              node.timestamp = attr.timestamp;
            }
            if (attr.size !== void 0) {
              MEMFS.resizeFileStorage(node, attr.size);
            }
          }, lookup: function(parent, name) {
            throw FS.genericErrors[2];
          }, mknod: function(parent, name, mode, dev) {
            return MEMFS.createNode(parent, name, mode, dev);
          }, rename: function(old_node, new_dir, new_name) {
            if (FS.isDir(old_node.mode)) {
              var new_node;
              try {
                new_node = FS.lookupNode(new_dir, new_name);
              } catch (e) {
              }
              if (new_node) {
                for (var i2 in new_node.contents) {
                  throw new FS.ErrnoError(39);
                }
              }
            }
            delete old_node.parent.contents[old_node.name];
            old_node.name = new_name;
            new_dir.contents[new_name] = old_node;
            old_node.parent = new_dir;
          }, unlink: function(parent, name) {
            delete parent.contents[name];
          }, rmdir: function(parent, name) {
            var node = FS.lookupNode(parent, name);
            for (var i2 in node.contents) {
              throw new FS.ErrnoError(39);
            }
            delete parent.contents[name];
          }, readdir: function(node) {
            var entries = [".", ".."];
            for (var key2 in node.contents) {
              if (!node.contents.hasOwnProperty(key2)) {
                continue;
              }
              entries.push(key2);
            }
            return entries;
          }, symlink: function(parent, newname, oldpath) {
            var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
            node.link = oldpath;
            return node;
          }, readlink: function(node) {
            if (!FS.isLink(node.mode)) {
              throw new FS.ErrnoError(22);
            }
            return node.link;
          } }, stream_ops: { read: function(stream, buffer2, offset, length, position) {
            var contents = stream.node.contents;
            if (position >= stream.node.usedBytes) return 0;
            var size = Math.min(stream.node.usedBytes - position, length);
            if (size > 8 && contents.subarray) {
              buffer2.set(contents.subarray(position, position + size), offset);
            } else {
              for (var i2 = 0; i2 < size; i2++) buffer2[offset + i2] = contents[position + i2];
            }
            return size;
          }, write: function(stream, buffer2, offset, length, position, canOwn) {
            canOwn = false;
            if (!length) return 0;
            var node = stream.node;
            node.timestamp = Date.now();
            if (buffer2.subarray && (!node.contents || node.contents.subarray)) {
              if (canOwn) {
                node.contents = buffer2.subarray(offset, offset + length);
                node.usedBytes = length;
                return length;
              } else if (node.usedBytes === 0 && position === 0) {
                node.contents = new Uint8Array(buffer2.subarray(offset, offset + length));
                node.usedBytes = length;
                return length;
              } else if (position + length <= node.usedBytes) {
                node.contents.set(buffer2.subarray(offset, offset + length), position);
                return length;
              }
            }
            MEMFS.expandFileStorage(node, position + length);
            if (node.contents.subarray && buffer2.subarray) node.contents.set(buffer2.subarray(offset, offset + length), position);
            else {
              for (var i2 = 0; i2 < length; i2++) {
                node.contents[position + i2] = buffer2[offset + i2];
              }
            }
            node.usedBytes = Math.max(node.usedBytes, position + length);
            return length;
          }, llseek: function(stream, offset, whence) {
            var position = offset;
            if (whence === 1) {
              position += stream.position;
            } else if (whence === 2) {
              if (FS.isFile(stream.node.mode)) {
                position += stream.node.usedBytes;
              }
            }
            if (position < 0) {
              throw new FS.ErrnoError(22);
            }
            return position;
          }, allocate: function(stream, offset, length) {
            MEMFS.expandFileStorage(stream.node, offset + length);
            stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
          }, mmap: function(stream, buffer2, offset, length, position, prot, flags) {
            if (!FS.isFile(stream.node.mode)) {
              throw new FS.ErrnoError(19);
            }
            var ptr;
            var allocated;
            var contents = stream.node.contents;
            if (!(flags & 2) && (contents.buffer === buffer2 || contents.buffer === buffer2.buffer)) {
              allocated = false;
              ptr = contents.byteOffset;
            } else {
              if (position > 0 || position + length < stream.node.usedBytes) {
                if (contents.subarray) {
                  contents = contents.subarray(position, position + length);
                } else {
                  contents = Array.prototype.slice.call(contents, position, position + length);
                }
              }
              allocated = true;
              var fromHeap = buffer2.buffer == HEAP8.buffer;
              ptr = _malloc(length);
              if (!ptr) {
                throw new FS.ErrnoError(12);
              }
              (fromHeap ? HEAP8 : buffer2).set(contents, ptr);
            }
            return { ptr, allocated };
          }, msync: function(stream, buffer2, offset, length, mmapFlags) {
            if (!FS.isFile(stream.node.mode)) {
              throw new FS.ErrnoError(19);
            }
            if (mmapFlags & 2) {
              return 0;
            }
            var bytesWritten = MEMFS.stream_ops.write(stream, buffer2, 0, length, offset, false);
            return 0;
          } } };
          var IDBFS = { dbs: {}, indexedDB: function() {
            if (typeof indexedDB !== "undefined") return indexedDB;
            var ret = null;
            if (typeof window === "object") ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
            assert(ret, "IDBFS used, but indexedDB not supported");
            return ret;
          }, DB_VERSION: 21, DB_STORE_NAME: "FILE_DATA", mount: function(mount) {
            return MEMFS.mount.apply(null, arguments);
          }, syncfs: function(mount, populate, callback) {
            IDBFS.getLocalSet(mount, function(err2, local) {
              if (err2) return callback(err2);
              IDBFS.getRemoteSet(mount, function(err3, remote) {
                if (err3) return callback(err3);
                var src = populate ? remote : local;
                var dst = populate ? local : remote;
                IDBFS.reconcile(src, dst, callback);
              });
            });
          }, getDB: function(name, callback) {
            var db = IDBFS.dbs[name];
            if (db) {
              return callback(null, db);
            }
            var req;
            try {
              req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);
            } catch (e) {
              return callback(e);
            }
            if (!req) {
              return callback("Unable to connect to IndexedDB");
            }
            req.onupgradeneeded = function(e) {
              var db2 = e.target.result;
              var transaction = e.target.transaction;
              var fileStore;
              if (db2.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {
                fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);
              } else {
                fileStore = db2.createObjectStore(IDBFS.DB_STORE_NAME);
              }
              if (!fileStore.indexNames.contains("timestamp")) {
                fileStore.createIndex("timestamp", "timestamp", { unique: false });
              }
            };
            req.onsuccess = function() {
              db = req.result;
              IDBFS.dbs[name] = db;
              callback(null, db);
            };
            req.onerror = function(e) {
              callback(this.error);
              e.preventDefault();
            };
          }, getLocalSet: function(mount, callback) {
            var entries = {};
            function isRealDir(p) {
              return p !== "." && p !== "..";
            }
            function toAbsolute(root) {
              return function(p) {
                return PATH.join2(root, p);
              };
            }
            var check2 = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));
            while (check2.length) {
              var path = check2.pop();
              var stat;
              try {
                stat = FS.stat(path);
              } catch (e) {
                return callback(e);
              }
              if (FS.isDir(stat.mode)) {
                check2.push.apply(check2, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));
              }
              entries[path] = { timestamp: stat.mtime };
            }
            return callback(null, { type: "local", entries });
          }, getRemoteSet: function(mount, callback) {
            var entries = {};
            IDBFS.getDB(mount.mountpoint, function(err2, db) {
              if (err2) return callback(err2);
              try {
                var transaction = db.transaction([IDBFS.DB_STORE_NAME], "readonly");
                transaction.onerror = function(e) {
                  callback(this.error);
                  e.preventDefault();
                };
                var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
                var index = store.index("timestamp");
                index.openKeyCursor().onsuccess = function(event) {
                  var cursor = event.target.result;
                  if (!cursor) {
                    return callback(null, { type: "remote", db, entries });
                  }
                  entries[cursor.primaryKey] = { timestamp: cursor.key };
                  cursor.continue();
                };
              } catch (e) {
                return callback(e);
              }
            });
          }, loadLocalEntry: function(path, callback) {
            var stat, node;
            try {
              var lookup = FS.lookupPath(path);
              node = lookup.node;
              stat = FS.stat(path);
            } catch (e) {
              return callback(e);
            }
            if (FS.isDir(stat.mode)) {
              return callback(null, { timestamp: stat.mtime, mode: stat.mode });
            } else if (FS.isFile(stat.mode)) {
              node.contents = MEMFS.getFileDataAsTypedArray(node);
              return callback(null, { timestamp: stat.mtime, mode: stat.mode, contents: node.contents });
            } else {
              return callback(new Error("node type not supported"));
            }
          }, storeLocalEntry: function(path, entry, callback) {
            try {
              if (FS.isDir(entry.mode)) {
                FS.mkdir(path, entry.mode);
              } else if (FS.isFile(entry.mode)) {
                FS.writeFile(path, entry.contents, { canOwn: true });
              } else {
                return callback(new Error("node type not supported"));
              }
              FS.chmod(path, entry.mode);
              FS.utime(path, entry.timestamp, entry.timestamp);
            } catch (e) {
              return callback(e);
            }
            callback(null);
          }, removeLocalEntry: function(path, callback) {
            try {
              var lookup = FS.lookupPath(path);
              var stat = FS.stat(path);
              if (FS.isDir(stat.mode)) {
                FS.rmdir(path);
              } else if (FS.isFile(stat.mode)) {
                FS.unlink(path);
              }
            } catch (e) {
              return callback(e);
            }
            callback(null);
          }, loadRemoteEntry: function(store, path, callback) {
            var req = store.get(path);
            req.onsuccess = function(event) {
              callback(null, event.target.result);
            };
            req.onerror = function(e) {
              callback(this.error);
              e.preventDefault();
            };
          }, storeRemoteEntry: function(store, path, entry, callback) {
            var req = store.put(entry, path);
            req.onsuccess = function() {
              callback(null);
            };
            req.onerror = function(e) {
              callback(this.error);
              e.preventDefault();
            };
          }, removeRemoteEntry: function(store, path, callback) {
            var req = store.delete(path);
            req.onsuccess = function() {
              callback(null);
            };
            req.onerror = function(e) {
              callback(this.error);
              e.preventDefault();
            };
          }, reconcile: function(src, dst, callback) {
            var total = 0;
            var create2 = [];
            Object.keys(src.entries).forEach(function(key2) {
              var e = src.entries[key2];
              var e2 = dst.entries[key2];
              if (!e2 || e.timestamp > e2.timestamp) {
                create2.push(key2);
                total++;
              }
            });
            var remove = [];
            Object.keys(dst.entries).forEach(function(key2) {
              var e = dst.entries[key2];
              var e2 = src.entries[key2];
              if (!e2) {
                remove.push(key2);
                total++;
              }
            });
            if (!total) {
              return callback(null);
            }
            var errored = false;
            var db = src.type === "remote" ? src.db : dst.db;
            var transaction = db.transaction([IDBFS.DB_STORE_NAME], "readwrite");
            var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
            function done(err2) {
              if (err2 && !errored) {
                errored = true;
                return callback(err2);
              }
            }
            transaction.onerror = function(e) {
              done(this.error);
              e.preventDefault();
            };
            transaction.oncomplete = function(e) {
              if (!errored) {
                callback(null);
              }
            };
            create2.sort().forEach(function(path) {
              if (dst.type === "local") {
                IDBFS.loadRemoteEntry(store, path, function(err2, entry) {
                  if (err2) return done(err2);
                  IDBFS.storeLocalEntry(path, entry, done);
                });
              } else {
                IDBFS.loadLocalEntry(path, function(err2, entry) {
                  if (err2) return done(err2);
                  IDBFS.storeRemoteEntry(store, path, entry, done);
                });
              }
            });
            remove.sort().reverse().forEach(function(path) {
              if (dst.type === "local") {
                IDBFS.removeLocalEntry(path, done);
              } else {
                IDBFS.removeRemoteEntry(store, path, done);
              }
            });
          } };
          var NODEFS = { isWindows: false, staticInit: function() {
            NODEFS.isWindows = !!process.platform.match(/^win/);
            var flags = process["binding"]("constants");
            if (flags["fs"]) {
              flags = flags["fs"];
            }
            NODEFS.flagsForNodeMap = { 1024: flags["O_APPEND"], 64: flags["O_CREAT"], 128: flags["O_EXCL"], 0: flags["O_RDONLY"], 2: flags["O_RDWR"], 4096: flags["O_SYNC"], 512: flags["O_TRUNC"], 1: flags["O_WRONLY"] };
          }, bufferFrom: function(arrayBuffer) {
            return Buffer.alloc ? Buffer.from(arrayBuffer) : new Buffer(arrayBuffer);
          }, mount: function(mount) {
            assert(ENVIRONMENT_HAS_NODE);
            return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0);
          }, createNode: function(parent, name, mode, dev) {
            if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
              throw new FS.ErrnoError(22);
            }
            var node = FS.createNode(parent, name, mode);
            node.node_ops = NODEFS.node_ops;
            node.stream_ops = NODEFS.stream_ops;
            return node;
          }, getMode: function(path) {
            var stat;
            try {
              stat = fs.lstatSync(path);
              if (NODEFS.isWindows) {
                stat.mode = stat.mode | (stat.mode & 292) >> 2;
              }
            } catch (e) {
              if (!e.code) throw e;
              throw new FS.ErrnoError(-e.errno);
            }
            return stat.mode;
          }, realPath: function(node) {
            var parts = [];
            while (node.parent !== node) {
              parts.push(node.name);
              node = node.parent;
            }
            parts.push(node.mount.opts.root);
            parts.reverse();
            return PATH.join.apply(null, parts);
          }, flagsForNode: function(flags) {
            flags &= ~2097152;
            flags &= ~2048;
            flags &= ~32768;
            flags &= ~524288;
            var newFlags = 0;
            for (var k in NODEFS.flagsForNodeMap) {
              if (flags & k) {
                newFlags |= NODEFS.flagsForNodeMap[k];
                flags ^= k;
              }
            }
            if (!flags) {
              return newFlags;
            } else {
              throw new FS.ErrnoError(22);
            }
          }, node_ops: { getattr: function(node) {
            var path = NODEFS.realPath(node);
            var stat;
            try {
              stat = fs.lstatSync(path);
            } catch (e) {
              if (!e.code) throw e;
              throw new FS.ErrnoError(-e.errno);
            }
            if (NODEFS.isWindows && !stat.blksize) {
              stat.blksize = 4096;
            }
            if (NODEFS.isWindows && !stat.blocks) {
              stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0;
            }
            return { dev: stat.dev, ino: stat.ino, mode: stat.mode, nlink: stat.nlink, uid: stat.uid, gid: stat.gid, rdev: stat.rdev, size: stat.size, atime: stat.atime, mtime: stat.mtime, ctime: stat.ctime, blksize: stat.blksize, blocks: stat.blocks };
          }, setattr: function(node, attr) {
            var path = NODEFS.realPath(node);
            try {
              if (attr.mode !== void 0) {
                fs.chmodSync(path, attr.mode);
                node.mode = attr.mode;
              }
              if (attr.timestamp !== void 0) {
                var date = new Date(attr.timestamp);
                fs.utimesSync(path, date, date);
              }
              if (attr.size !== void 0) {
                fs.truncateSync(path, attr.size);
              }
            } catch (e) {
              if (!e.code) throw e;
              throw new FS.ErrnoError(-e.errno);
            }
          }, lookup: function(parent, name) {
            var path = PATH.join2(NODEFS.realPath(parent), name);
            var mode = NODEFS.getMode(path);
            return NODEFS.createNode(parent, name, mode);
          }, mknod: function(parent, name, mode, dev) {
            var node = NODEFS.createNode(parent, name, mode, dev);
            var path = NODEFS.realPath(node);
            try {
              if (FS.isDir(node.mode)) {
                fs.mkdirSync(path, node.mode);
              } else {
                fs.writeFileSync(path, "", { mode: node.mode });
              }
            } catch (e) {
              if (!e.code) throw e;
              throw new FS.ErrnoError(-e.errno);
            }
            return node;
          }, rename: function(oldNode, newDir, newName) {
            var oldPath = NODEFS.realPath(oldNode);
            var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
            try {
              fs.renameSync(oldPath, newPath);
            } catch (e) {
              if (!e.code) throw e;
              throw new FS.ErrnoError(-e.errno);
            }
          }, unlink: function(parent, name) {
            var path = PATH.join2(NODEFS.realPath(parent), name);
            try {
              fs.unlinkSync(path);
            } catch (e) {
              if (!e.code) throw e;
              throw new FS.ErrnoError(-e.errno);
            }
          }, rmdir: function(parent, name) {
            var path = PATH.join2(NODEFS.realPath(parent), name);
            try {
              fs.rmdirSync(path);
            } catch (e) {
              if (!e.code) throw e;
              throw new FS.ErrnoError(-e.errno);
            }
          }, readdir: function(node) {
            var path = NODEFS.realPath(node);
            try {
              return fs.readdirSync(path);
            } catch (e) {
              if (!e.code) throw e;
              throw new FS.ErrnoError(-e.errno);
            }
          }, symlink: function(parent, newName, oldPath) {
            var newPath = PATH.join2(NODEFS.realPath(parent), newName);
            try {
              fs.symlinkSync(oldPath, newPath);
            } catch (e) {
              if (!e.code) throw e;
              throw new FS.ErrnoError(-e.errno);
            }
          }, readlink: function(node) {
            var path = NODEFS.realPath(node);
            try {
              path = fs.readlinkSync(path);
              path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);
              return path;
            } catch (e) {
              if (!e.code) throw e;
              throw new FS.ErrnoError(-e.errno);
            }
          } }, stream_ops: { open: function(stream) {
            var path = NODEFS.realPath(stream.node);
            try {
              if (FS.isFile(stream.node.mode)) {
                stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
              }
            } catch (e) {
              if (!e.code) throw e;
              throw new FS.ErrnoError(-e.errno);
            }
          }, close: function(stream) {
            try {
              if (FS.isFile(stream.node.mode) && stream.nfd) {
                fs.closeSync(stream.nfd);
              }
            } catch (e) {
              if (!e.code) throw e;
              throw new FS.ErrnoError(-e.errno);
            }
          }, read: function(stream, buffer2, offset, length, position) {
            if (length === 0) return 0;
            try {
              return fs.readSync(stream.nfd, NODEFS.bufferFrom(buffer2.buffer), offset, length, position);
            } catch (e) {
              throw new FS.ErrnoError(-e.errno);
            }
          }, write: function(stream, buffer2, offset, length, position) {
            try {
              return fs.writeSync(stream.nfd, NODEFS.bufferFrom(buffer2.buffer), offset, length, position);
            } catch (e) {
              throw new FS.ErrnoError(-e.errno);
            }
          }, llseek: function(stream, offset, whence) {
            var position = offset;
            if (whence === 1) {
              position += stream.position;
            } else if (whence === 2) {
              if (FS.isFile(stream.node.mode)) {
                try {
                  var stat = fs.fstatSync(stream.nfd);
                  position += stat.size;
                } catch (e) {
                  throw new FS.ErrnoError(-e.errno);
                }
              }
            }
            if (position < 0) {
              throw new FS.ErrnoError(22);
            }
            return position;
          } } };
          var WORKERFS = { DIR_MODE: 16895, FILE_MODE: 33279, reader: null, mount: function(mount) {
            assert(ENVIRONMENT_IS_WORKER);
            if (!WORKERFS.reader) WORKERFS.reader = new FileReaderSync();
            var root = WORKERFS.createNode(null, "/", WORKERFS.DIR_MODE, 0);
            var createdParents = {};
            function ensureParent(path) {
              var parts = path.split("/");
              var parent = root;
              for (var i2 = 0; i2 < parts.length - 1; i2++) {
                var curr = parts.slice(0, i2 + 1).join("/");
                if (!createdParents[curr]) {
                  createdParents[curr] = WORKERFS.createNode(parent, parts[i2], WORKERFS.DIR_MODE, 0);
                }
                parent = createdParents[curr];
              }
              return parent;
            }
            function base(path) {
              var parts = path.split("/");
              return parts[parts.length - 1];
            }
            Array.prototype.forEach.call(mount.opts["files"] || [], function(file) {
              WORKERFS.createNode(ensureParent(file.name), base(file.name), WORKERFS.FILE_MODE, 0, file, file.lastModifiedDate);
            });
            (mount.opts["blobs"] || []).forEach(function(obj) {
              WORKERFS.createNode(ensureParent(obj["name"]), base(obj["name"]), WORKERFS.FILE_MODE, 0, obj["data"]);
            });
            (mount.opts["packages"] || []).forEach(function(pack) {
              pack["metadata"].files.forEach(function(file) {
                var name = file.filename.substr(1);
                WORKERFS.createNode(ensureParent(name), base(name), WORKERFS.FILE_MODE, 0, pack["blob"].slice(file.start, file.end));
              });
            });
            return root;
          }, createNode: function(parent, name, mode, dev, contents, mtime) {
            var node = FS.createNode(parent, name, mode);
            node.mode = mode;
            node.node_ops = WORKERFS.node_ops;
            node.stream_ops = WORKERFS.stream_ops;
            node.timestamp = (mtime || /* @__PURE__ */ new Date()).getTime();
            assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE);
            if (mode === WORKERFS.FILE_MODE) {
              node.size = contents.size;
              node.contents = contents;
            } else {
              node.size = 4096;
              node.contents = {};
            }
            if (parent) {
              parent.contents[name] = node;
            }
            return node;
          }, node_ops: { getattr: function(node) {
            return { dev: 1, ino: void 0, mode: node.mode, nlink: 1, uid: 0, gid: 0, rdev: void 0, size: node.size, atime: new Date(node.timestamp), mtime: new Date(node.timestamp), ctime: new Date(node.timestamp), blksize: 4096, blocks: Math.ceil(node.size / 4096) };
          }, setattr: function(node, attr) {
            if (attr.mode !== void 0) {
              node.mode = attr.mode;
            }
            if (attr.timestamp !== void 0) {
              node.timestamp = attr.timestamp;
            }
          }, lookup: function(parent, name) {
            throw new FS.ErrnoError(2);
          }, mknod: function(parent, name, mode, dev) {
            throw new FS.ErrnoError(1);
          }, rename: function(oldNode, newDir, newName) {
            throw new FS.ErrnoError(1);
          }, unlink: function(parent, name) {
            throw new FS.ErrnoError(1);
          }, rmdir: function(parent, name) {
            throw new FS.ErrnoError(1);
          }, readdir: function(node) {
            var entries = [".", ".."];
            for (var key2 in node.contents) {
              if (!node.contents.hasOwnProperty(key2)) {
                continue;
              }
              entries.push(key2);
            }
            return entries;
          }, symlink: function(parent, newName, oldPath) {
            throw new FS.ErrnoError(1);
          }, readlink: function(node) {
            throw new FS.ErrnoError(1);
          } }, stream_ops: { read: function(stream, buffer2, offset, length, position) {
            if (position >= stream.node.size) return 0;
            var chunk = stream.node.contents.slice(position, position + length);
            var ab = WORKERFS.reader.readAsArrayBuffer(chunk);
            buffer2.set(new Uint8Array(ab), offset);
            return chunk.size;
          }, write: function(stream, buffer2, offset, length, position) {
            throw new FS.ErrnoError(5);
          }, llseek: function(stream, offset, whence) {
            var position = offset;
            if (whence === 1) {
              position += stream.position;
            } else if (whence === 2) {
              if (FS.isFile(stream.node.mode)) {
                position += stream.node.size;
              }
            }
            if (position < 0) {
              throw new FS.ErrnoError(22);
            }
            return position;
          } } };
          var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, trackingDelegate: {}, tracking: { openFlags: { READ: 1, WRITE: 2 } }, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, handleFSError: function(e) {
            if (!(e instanceof FS.ErrnoError)) throw e + " : " + stackTrace();
            return ___setErrNo(e.errno);
          }, lookupPath: function(path, opts) {
            path = PATH_FS.resolve(FS.cwd(), path);
            opts = opts || {};
            if (!path) return { path: "", node: null };
            var defaults = { follow_mount: true, recurse_count: 0 };
            for (var key2 in defaults) {
              if (opts[key2] === void 0) {
                opts[key2] = defaults[key2];
              }
            }
            if (opts.recurse_count > 8) {
              throw new FS.ErrnoError(40);
            }
            var parts = PATH.normalizeArray(path.split("/").filter(function(p) {
              return !!p;
            }), false);
            var current = FS.root;
            var current_path = "/";
            for (var i2 = 0; i2 < parts.length; i2++) {
              var islast = i2 === parts.length - 1;
              if (islast && opts.parent) {
                break;
              }
              current = FS.lookupNode(current, parts[i2]);
              current_path = PATH.join2(current_path, parts[i2]);
              if (FS.isMountpoint(current)) {
                if (!islast || islast && opts.follow_mount) {
                  current = current.mounted.root;
                }
              }
              if (!islast || opts.follow) {
                var count = 0;
                while (FS.isLink(current.mode)) {
                  var link = FS.readlink(current_path);
                  current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                  var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
                  current = lookup.node;
                  if (count++ > 40) {
                    throw new FS.ErrnoError(40);
                  }
                }
              }
            }
            return { path: current_path, node: current };
          }, getPath: function(node) {
            var path;
            while (true) {
              if (FS.isRoot(node)) {
                var mount = node.mount.mountpoint;
                if (!path) return mount;
                return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
              }
              path = path ? node.name + "/" + path : node.name;
              node = node.parent;
            }
          }, hashName: function(parentid, name) {
            var hash = 0;
            for (var i2 = 0; i2 < name.length; i2++) {
              hash = (hash << 5) - hash + name.charCodeAt(i2) | 0;
            }
            return (parentid + hash >>> 0) % FS.nameTable.length;
          }, hashAddNode: function(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            node.name_next = FS.nameTable[hash];
            FS.nameTable[hash] = node;
          }, hashRemoveNode: function(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            if (FS.nameTable[hash] === node) {
              FS.nameTable[hash] = node.name_next;
            } else {
              var current = FS.nameTable[hash];
              while (current) {
                if (current.name_next === node) {
                  current.name_next = node.name_next;
                  break;
                }
                current = current.name_next;
              }
            }
          }, lookupNode: function(parent, name) {
            var err2 = FS.mayLookup(parent);
            if (err2) {
              throw new FS.ErrnoError(err2, parent);
            }
            var hash = FS.hashName(parent.id, name);
            for (var node = FS.nameTable[hash]; node; node = node.name_next) {
              var nodeName = node.name;
              if (node.parent.id === parent.id && nodeName === name) {
                return node;
              }
            }
            return FS.lookup(parent, name);
          }, createNode: function(parent, name, mode, rdev) {
            if (!FS.FSNode) {
              FS.FSNode = function(parent2, name2, mode2, rdev2) {
                if (!parent2) {
                  parent2 = this;
                }
                this.parent = parent2;
                this.mount = parent2.mount;
                this.mounted = null;
                this.id = FS.nextInode++;
                this.name = name2;
                this.mode = mode2;
                this.node_ops = {};
                this.stream_ops = {};
                this.rdev = rdev2;
              };
              FS.FSNode.prototype = {};
              var readMode = 292 | 73;
              var writeMode = 146;
              Object.defineProperties(FS.FSNode.prototype, { read: { get: function() {
                return (this.mode & readMode) === readMode;
              }, set: function(val) {
                val ? this.mode |= readMode : this.mode &= ~readMode;
              } }, write: { get: function() {
                return (this.mode & writeMode) === writeMode;
              }, set: function(val) {
                val ? this.mode |= writeMode : this.mode &= ~writeMode;
              } }, isFolder: { get: function() {
                return FS.isDir(this.mode);
              } }, isDevice: { get: function() {
                return FS.isChrdev(this.mode);
              } } });
            }
            var node = new FS.FSNode(parent, name, mode, rdev);
            FS.hashAddNode(node);
            return node;
          }, destroyNode: function(node) {
            FS.hashRemoveNode(node);
          }, isRoot: function(node) {
            return node === node.parent;
          }, isMountpoint: function(node) {
            return !!node.mounted;
          }, isFile: function(mode) {
            return (mode & 61440) === 32768;
          }, isDir: function(mode) {
            return (mode & 61440) === 16384;
          }, isLink: function(mode) {
            return (mode & 61440) === 40960;
          }, isChrdev: function(mode) {
            return (mode & 61440) === 8192;
          }, isBlkdev: function(mode) {
            return (mode & 61440) === 24576;
          }, isFIFO: function(mode) {
            return (mode & 61440) === 4096;
          }, isSocket: function(mode) {
            return (mode & 49152) === 49152;
          }, flagModes: { "r": 0, "rs": 1052672, "r+": 2, "w": 577, "wx": 705, "xw": 705, "w+": 578, "wx+": 706, "xw+": 706, "a": 1089, "ax": 1217, "xa": 1217, "a+": 1090, "ax+": 1218, "xa+": 1218 }, modeStringToFlags: function(str) {
            var flags = FS.flagModes[str];
            if (typeof flags === "undefined") {
              throw new Error("Unknown file open mode: " + str);
            }
            return flags;
          }, flagsToPermissionString: function(flag) {
            var perms = ["r", "w", "rw"][flag & 3];
            if (flag & 512) {
              perms += "w";
            }
            return perms;
          }, nodePermissions: function(node, perms) {
            if (FS.ignorePermissions) {
              return 0;
            }
            if (perms.indexOf("r") !== -1 && !(node.mode & 292)) {
              return 13;
            } else if (perms.indexOf("w") !== -1 && !(node.mode & 146)) {
              return 13;
            } else if (perms.indexOf("x") !== -1 && !(node.mode & 73)) {
              return 13;
            }
            return 0;
          }, mayLookup: function(dir) {
            var err2 = FS.nodePermissions(dir, "x");
            if (err2) return err2;
            if (!dir.node_ops.lookup) return 13;
            return 0;
          }, mayCreate: function(dir, name) {
            try {
              var node = FS.lookupNode(dir, name);
              return 17;
            } catch (e) {
            }
            return FS.nodePermissions(dir, "wx");
          }, mayDelete: function(dir, name, isdir) {
            var node;
            try {
              node = FS.lookupNode(dir, name);
            } catch (e) {
              return e.errno;
            }
            var err2 = FS.nodePermissions(dir, "wx");
            if (err2) {
              return err2;
            }
            if (isdir) {
              if (!FS.isDir(node.mode)) {
                return 20;
              }
              if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
                return 16;
              }
            } else {
              if (FS.isDir(node.mode)) {
                return 21;
              }
            }
            return 0;
          }, mayOpen: function(node, flags) {
            if (!node) {
              return 2;
            }
            if (FS.isLink(node.mode)) {
              return 40;
            } else if (FS.isDir(node.mode)) {
              if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
                return 21;
              }
            }
            return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
          }, MAX_OPEN_FDS: 4096, nextfd: function(fd_start, fd_end) {
            fd_start = fd_start || 0;
            fd_end = fd_end || FS.MAX_OPEN_FDS;
            for (var fd = fd_start; fd <= fd_end; fd++) {
              if (!FS.streams[fd]) {
                return fd;
              }
            }
            throw new FS.ErrnoError(24);
          }, getStream: function(fd) {
            return FS.streams[fd];
          }, createStream: function(stream, fd_start, fd_end) {
            if (!FS.FSStream) {
              FS.FSStream = function() {
              };
              FS.FSStream.prototype = {};
              Object.defineProperties(FS.FSStream.prototype, { object: { get: function() {
                return this.node;
              }, set: function(val) {
                this.node = val;
              } }, isRead: { get: function() {
                return (this.flags & 2097155) !== 1;
              } }, isWrite: { get: function() {
                return (this.flags & 2097155) !== 0;
              } }, isAppend: { get: function() {
                return this.flags & 1024;
              } } });
            }
            var newStream = new FS.FSStream();
            for (var p in stream) {
              newStream[p] = stream[p];
            }
            stream = newStream;
            var fd = FS.nextfd(fd_start, fd_end);
            stream.fd = fd;
            FS.streams[fd] = stream;
            return stream;
          }, closeStream: function(fd) {
            FS.streams[fd] = null;
          }, chrdev_stream_ops: { open: function(stream) {
            var device = FS.getDevice(stream.node.rdev);
            stream.stream_ops = device.stream_ops;
            if (stream.stream_ops.open) {
              stream.stream_ops.open(stream);
            }
          }, llseek: function() {
            throw new FS.ErrnoError(29);
          } }, major: function(dev) {
            return dev >> 8;
          }, minor: function(dev) {
            return dev & 255;
          }, makedev: function(ma, mi) {
            return ma << 8 | mi;
          }, registerDevice: function(dev, ops) {
            FS.devices[dev] = { stream_ops: ops };
          }, getDevice: function(dev) {
            return FS.devices[dev];
          }, getMounts: function(mount) {
            var mounts = [];
            var check2 = [mount];
            while (check2.length) {
              var m = check2.pop();
              mounts.push(m);
              check2.push.apply(check2, m.mounts);
            }
            return mounts;
          }, syncfs: function(populate, callback) {
            if (typeof populate === "function") {
              callback = populate;
              populate = false;
            }
            FS.syncFSRequests++;
            if (FS.syncFSRequests > 1) {
              console.log("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
            }
            var mounts = FS.getMounts(FS.root.mount);
            var completed = 0;
            function doCallback(err2) {
              FS.syncFSRequests--;
              return callback(err2);
            }
            function done(err2) {
              if (err2) {
                if (!done.errored) {
                  done.errored = true;
                  return doCallback(err2);
                }
                return;
              }
              if (++completed >= mounts.length) {
                doCallback(null);
              }
            }
            mounts.forEach(function(mount) {
              if (!mount.type.syncfs) {
                return done(null);
              }
              mount.type.syncfs(mount, populate, done);
            });
          }, mount: function(type, opts, mountpoint) {
            var root = mountpoint === "/";
            var pseudo = !mountpoint;
            var node;
            if (root && FS.root) {
              throw new FS.ErrnoError(16);
            } else if (!root && !pseudo) {
              var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
              mountpoint = lookup.path;
              node = lookup.node;
              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(16);
              }
              if (!FS.isDir(node.mode)) {
                throw new FS.ErrnoError(20);
              }
            }
            var mount = { type, opts, mountpoint, mounts: [] };
            var mountRoot = type.mount(mount);
            mountRoot.mount = mount;
            mount.root = mountRoot;
            if (root) {
              FS.root = mountRoot;
            } else if (node) {
              node.mounted = mount;
              if (node.mount) {
                node.mount.mounts.push(mount);
              }
            }
            return mountRoot;
          }, unmount: function(mountpoint) {
            var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
            if (!FS.isMountpoint(lookup.node)) {
              throw new FS.ErrnoError(22);
            }
            var node = lookup.node;
            var mount = node.mounted;
            var mounts = FS.getMounts(mount);
            Object.keys(FS.nameTable).forEach(function(hash) {
              var current = FS.nameTable[hash];
              while (current) {
                var next = current.name_next;
                if (mounts.indexOf(current.mount) !== -1) {
                  FS.destroyNode(current);
                }
                current = next;
              }
            });
            node.mounted = null;
            var idx = node.mount.mounts.indexOf(mount);
            node.mount.mounts.splice(idx, 1);
          }, lookup: function(parent, name) {
            return parent.node_ops.lookup(parent, name);
          }, mknod: function(path, mode, dev) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name = PATH.basename(path);
            if (!name || name === "." || name === "..") {
              throw new FS.ErrnoError(22);
            }
            var err2 = FS.mayCreate(parent, name);
            if (err2) {
              throw new FS.ErrnoError(err2);
            }
            if (!parent.node_ops.mknod) {
              throw new FS.ErrnoError(1);
            }
            return parent.node_ops.mknod(parent, name, mode, dev);
          }, create: function(path, mode) {
            mode = mode !== void 0 ? mode : 438;
            mode &= 4095;
            mode |= 32768;
            return FS.mknod(path, mode, 0);
          }, mkdir: function(path, mode) {
            mode = mode !== void 0 ? mode : 511;
            mode &= 511 | 512;
            mode |= 16384;
            return FS.mknod(path, mode, 0);
          }, mkdirTree: function(path, mode) {
            var dirs = path.split("/");
            var d = "";
            for (var i2 = 0; i2 < dirs.length; ++i2) {
              if (!dirs[i2]) continue;
              d += "/" + dirs[i2];
              try {
                FS.mkdir(d, mode);
              } catch (e) {
                if (e.errno != 17) throw e;
              }
            }
          }, mkdev: function(path, mode, dev) {
            if (typeof dev === "undefined") {
              dev = mode;
              mode = 438;
            }
            mode |= 8192;
            return FS.mknod(path, mode, dev);
          }, symlink: function(oldpath, newpath) {
            if (!PATH_FS.resolve(oldpath)) {
              throw new FS.ErrnoError(2);
            }
            var lookup = FS.lookupPath(newpath, { parent: true });
            var parent = lookup.node;
            if (!parent) {
              throw new FS.ErrnoError(2);
            }
            var newname = PATH.basename(newpath);
            var err2 = FS.mayCreate(parent, newname);
            if (err2) {
              throw new FS.ErrnoError(err2);
            }
            if (!parent.node_ops.symlink) {
              throw new FS.ErrnoError(1);
            }
            return parent.node_ops.symlink(parent, newname, oldpath);
          }, rename: function(old_path, new_path) {
            var old_dirname = PATH.dirname(old_path);
            var new_dirname = PATH.dirname(new_path);
            var old_name = PATH.basename(old_path);
            var new_name = PATH.basename(new_path);
            var lookup, old_dir, new_dir;
            try {
              lookup = FS.lookupPath(old_path, { parent: true });
              old_dir = lookup.node;
              lookup = FS.lookupPath(new_path, { parent: true });
              new_dir = lookup.node;
            } catch (e) {
              throw new FS.ErrnoError(16);
            }
            if (!old_dir || !new_dir) throw new FS.ErrnoError(2);
            if (old_dir.mount !== new_dir.mount) {
              throw new FS.ErrnoError(18);
            }
            var old_node = FS.lookupNode(old_dir, old_name);
            var relative = PATH_FS.relative(old_path, new_dirname);
            if (relative.charAt(0) !== ".") {
              throw new FS.ErrnoError(22);
            }
            relative = PATH_FS.relative(new_path, old_dirname);
            if (relative.charAt(0) !== ".") {
              throw new FS.ErrnoError(39);
            }
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (old_node === new_node) {
              return;
            }
            var isdir = FS.isDir(old_node.mode);
            var err2 = FS.mayDelete(old_dir, old_name, isdir);
            if (err2) {
              throw new FS.ErrnoError(err2);
            }
            err2 = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
            if (err2) {
              throw new FS.ErrnoError(err2);
            }
            if (!old_dir.node_ops.rename) {
              throw new FS.ErrnoError(1);
            }
            if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
              throw new FS.ErrnoError(16);
            }
            if (new_dir !== old_dir) {
              err2 = FS.nodePermissions(old_dir, "w");
              if (err2) {
                throw new FS.ErrnoError(err2);
              }
            }
            try {
              if (FS.trackingDelegate["willMovePath"]) {
                FS.trackingDelegate["willMovePath"](old_path, new_path);
              }
            } catch (e) {
              console.log("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
            }
            FS.hashRemoveNode(old_node);
            try {
              old_dir.node_ops.rename(old_node, new_dir, new_name);
            } catch (e) {
              throw e;
            } finally {
              FS.hashAddNode(old_node);
            }
            try {
              if (FS.trackingDelegate["onMovePath"]) FS.trackingDelegate["onMovePath"](old_path, new_path);
            } catch (e) {
              console.log("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
            }
          }, rmdir: function(path) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name = PATH.basename(path);
            var node = FS.lookupNode(parent, name);
            var err2 = FS.mayDelete(parent, name, true);
            if (err2) {
              throw new FS.ErrnoError(err2);
            }
            if (!parent.node_ops.rmdir) {
              throw new FS.ErrnoError(1);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(16);
            }
            try {
              if (FS.trackingDelegate["willDeletePath"]) {
                FS.trackingDelegate["willDeletePath"](path);
              }
            } catch (e) {
              console.log("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
            }
            parent.node_ops.rmdir(parent, name);
            FS.destroyNode(node);
            try {
              if (FS.trackingDelegate["onDeletePath"]) FS.trackingDelegate["onDeletePath"](path);
            } catch (e) {
              console.log("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
            }
          }, readdir: function(path) {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            if (!node.node_ops.readdir) {
              throw new FS.ErrnoError(20);
            }
            return node.node_ops.readdir(node);
          }, unlink: function(path) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name = PATH.basename(path);
            var node = FS.lookupNode(parent, name);
            var err2 = FS.mayDelete(parent, name, false);
            if (err2) {
              throw new FS.ErrnoError(err2);
            }
            if (!parent.node_ops.unlink) {
              throw new FS.ErrnoError(1);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(16);
            }
            try {
              if (FS.trackingDelegate["willDeletePath"]) {
                FS.trackingDelegate["willDeletePath"](path);
              }
            } catch (e) {
              console.log("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
            }
            parent.node_ops.unlink(parent, name);
            FS.destroyNode(node);
            try {
              if (FS.trackingDelegate["onDeletePath"]) FS.trackingDelegate["onDeletePath"](path);
            } catch (e) {
              console.log("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
            }
          }, readlink: function(path) {
            var lookup = FS.lookupPath(path);
            var link = lookup.node;
            if (!link) {
              throw new FS.ErrnoError(2);
            }
            if (!link.node_ops.readlink) {
              throw new FS.ErrnoError(22);
            }
            return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
          }, stat: function(path, dontFollow) {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            var node = lookup.node;
            if (!node) {
              throw new FS.ErrnoError(2);
            }
            if (!node.node_ops.getattr) {
              throw new FS.ErrnoError(1);
            }
            return node.node_ops.getattr(node);
          }, lstat: function(path) {
            return FS.stat(path, true);
          }, chmod: function(path, mode, dontFollow) {
            var node;
            if (typeof path === "string") {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(1);
            }
            node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() });
          }, lchmod: function(path, mode) {
            FS.chmod(path, mode, true);
          }, fchmod: function(fd, mode) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(9);
            }
            FS.chmod(stream.node, mode);
          }, chown: function(path, uid, gid, dontFollow) {
            var node;
            if (typeof path === "string") {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(1);
            }
            node.node_ops.setattr(node, { timestamp: Date.now() });
          }, lchown: function(path, uid, gid) {
            FS.chown(path, uid, gid, true);
          }, fchown: function(fd, uid, gid) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(9);
            }
            FS.chown(stream.node, uid, gid);
          }, truncate: function(path, len) {
            if (len < 0) {
              throw new FS.ErrnoError(22);
            }
            var node;
            if (typeof path === "string") {
              var lookup = FS.lookupPath(path, { follow: true });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(1);
            }
            if (FS.isDir(node.mode)) {
              throw new FS.ErrnoError(21);
            }
            if (!FS.isFile(node.mode)) {
              throw new FS.ErrnoError(22);
            }
            var err2 = FS.nodePermissions(node, "w");
            if (err2) {
              throw new FS.ErrnoError(err2);
            }
            node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
          }, ftruncate: function(fd, len) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(9);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(22);
            }
            FS.truncate(stream.node, len);
          }, utime: function(path, atime, mtime) {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
          }, open: function(path, flags, mode, fd_start, fd_end) {
            if (path === "") {
              throw new FS.ErrnoError(2);
            }
            flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
            mode = typeof mode === "undefined" ? 438 : mode;
            if (flags & 64) {
              mode = mode & 4095 | 32768;
            } else {
              mode = 0;
            }
            var node;
            if (typeof path === "object") {
              node = path;
            } else {
              path = PATH.normalize(path);
              try {
                var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
                node = lookup.node;
              } catch (e) {
              }
            }
            var created = false;
            if (flags & 64) {
              if (node) {
                if (flags & 128) {
                  throw new FS.ErrnoError(17);
                }
              } else {
                node = FS.mknod(path, mode, 0);
                created = true;
              }
            }
            if (!node) {
              throw new FS.ErrnoError(2);
            }
            if (FS.isChrdev(node.mode)) {
              flags &= ~512;
            }
            if (flags & 65536 && !FS.isDir(node.mode)) {
              throw new FS.ErrnoError(20);
            }
            if (!created) {
              var err2 = FS.mayOpen(node, flags);
              if (err2) {
                throw new FS.ErrnoError(err2);
              }
            }
            if (flags & 512) {
              FS.truncate(node, 0);
            }
            flags &= ~(128 | 512);
            var stream = FS.createStream({ node, path: FS.getPath(node), flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false }, fd_start, fd_end);
            if (stream.stream_ops.open) {
              stream.stream_ops.open(stream);
            }
            if (Module2["logReadFiles"] && !(flags & 1)) {
              if (!FS.readFiles) FS.readFiles = {};
              if (!(path in FS.readFiles)) {
                FS.readFiles[path] = 1;
                console.log("FS.trackingDelegate error on read file: " + path);
              }
            }
            try {
              if (FS.trackingDelegate["onOpenFile"]) {
                var trackingFlags = 0;
                if ((flags & 2097155) !== 1) {
                  trackingFlags |= FS.tracking.openFlags.READ;
                }
                if ((flags & 2097155) !== 0) {
                  trackingFlags |= FS.tracking.openFlags.WRITE;
                }
                FS.trackingDelegate["onOpenFile"](path, trackingFlags);
              }
            } catch (e) {
              console.log("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message);
            }
            return stream;
          }, close: function(stream) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(9);
            }
            if (stream.getdents) stream.getdents = null;
            try {
              if (stream.stream_ops.close) {
                stream.stream_ops.close(stream);
              }
            } catch (e) {
              throw e;
            } finally {
              FS.closeStream(stream.fd);
            }
            stream.fd = null;
          }, isClosed: function(stream) {
            return stream.fd === null;
          }, llseek: function(stream, offset, whence) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(9);
            }
            if (!stream.seekable || !stream.stream_ops.llseek) {
              throw new FS.ErrnoError(29);
            }
            if (whence != 0 && whence != 1 && whence != 2) {
              throw new FS.ErrnoError(22);
            }
            stream.position = stream.stream_ops.llseek(stream, offset, whence);
            stream.ungotten = [];
            return stream.position;
          }, read: function(stream, buffer2, offset, length, position) {
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(22);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(9);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(9);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(21);
            }
            if (!stream.stream_ops.read) {
              throw new FS.ErrnoError(22);
            }
            var seeking = typeof position !== "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(29);
            }
            var bytesRead = stream.stream_ops.read(stream, buffer2, offset, length, position);
            if (!seeking) stream.position += bytesRead;
            return bytesRead;
          }, write: function(stream, buffer2, offset, length, position, canOwn) {
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(22);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(9);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(9);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(21);
            }
            if (!stream.stream_ops.write) {
              throw new FS.ErrnoError(22);
            }
            if (stream.flags & 1024) {
              FS.llseek(stream, 0, 2);
            }
            var seeking = typeof position !== "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(29);
            }
            var bytesWritten = stream.stream_ops.write(stream, buffer2, offset, length, position, canOwn);
            if (!seeking) stream.position += bytesWritten;
            try {
              if (stream.path && FS.trackingDelegate["onWriteToFile"]) FS.trackingDelegate["onWriteToFile"](stream.path);
            } catch (e) {
              console.log("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message);
            }
            return bytesWritten;
          }, allocate: function(stream, offset, length) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(9);
            }
            if (offset < 0 || length <= 0) {
              throw new FS.ErrnoError(22);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(9);
            }
            if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(19);
            }
            if (!stream.stream_ops.allocate) {
              throw new FS.ErrnoError(95);
            }
            stream.stream_ops.allocate(stream, offset, length);
          }, mmap: function(stream, buffer2, offset, length, position, prot, flags) {
            if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
              throw new FS.ErrnoError(13);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(13);
            }
            if (!stream.stream_ops.mmap) {
              throw new FS.ErrnoError(19);
            }
            return stream.stream_ops.mmap(stream, buffer2, offset, length, position, prot, flags);
          }, msync: function(stream, buffer2, offset, length, mmapFlags) {
            if (!stream || !stream.stream_ops.msync) {
              return 0;
            }
            return stream.stream_ops.msync(stream, buffer2, offset, length, mmapFlags);
          }, munmap: function(stream) {
            return 0;
          }, ioctl: function(stream, cmd, arg) {
            if (!stream.stream_ops.ioctl) {
              throw new FS.ErrnoError(25);
            }
            return stream.stream_ops.ioctl(stream, cmd, arg);
          }, readFile: function(path, opts) {
            opts = opts || {};
            opts.flags = opts.flags || "r";
            opts.encoding = opts.encoding || "binary";
            if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
              throw new Error('Invalid encoding type "' + opts.encoding + '"');
            }
            var ret;
            var stream = FS.open(path, opts.flags);
            var stat = FS.stat(path);
            var length = stat.size;
            var buf = new Uint8Array(length);
            FS.read(stream, buf, 0, length, 0);
            if (opts.encoding === "utf8") {
              ret = UTF8ArrayToString(buf, 0);
            } else if (opts.encoding === "binary") {
              ret = buf;
            }
            FS.close(stream);
            return ret;
          }, writeFile: function(path, data, opts) {
            opts = opts || {};
            opts.flags = opts.flags || "w";
            var stream = FS.open(path, opts.flags, opts.mode);
            if (typeof data === "string") {
              var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
              var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
              FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
            } else if (ArrayBuffer.isView(data)) {
              FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
            } else {
              throw new Error("Unsupported data type");
            }
            FS.close(stream);
          }, cwd: function() {
            return FS.currentPath;
          }, chdir: function(path) {
            var lookup = FS.lookupPath(path, { follow: true });
            if (lookup.node === null) {
              throw new FS.ErrnoError(2);
            }
            if (!FS.isDir(lookup.node.mode)) {
              throw new FS.ErrnoError(20);
            }
            var err2 = FS.nodePermissions(lookup.node, "x");
            if (err2) {
              throw new FS.ErrnoError(err2);
            }
            FS.currentPath = lookup.path;
          }, createDefaultDirectories: function() {
            FS.mkdir("/tmp");
            FS.mkdir("/home");
            FS.mkdir("/home/web_user");
          }, createDefaultDevices: function() {
            FS.mkdir("/dev");
            FS.registerDevice(FS.makedev(1, 3), { read: function() {
              return 0;
            }, write: function(stream, buffer2, offset, length, pos) {
              return length;
            } });
            FS.mkdev("/dev/null", FS.makedev(1, 3));
            TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
            TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
            FS.mkdev("/dev/tty", FS.makedev(5, 0));
            FS.mkdev("/dev/tty1", FS.makedev(6, 0));
            var random_device;
            if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {
              var randomBuffer = new Uint8Array(1);
              random_device = function() {
                crypto.getRandomValues(randomBuffer);
                return randomBuffer[0];
              };
            } else if (ENVIRONMENT_IS_NODE) {
              try {
                var crypto_module = (init_crypto(), __toCommonJS(crypto_exports));
                random_device = function() {
                  return crypto_module["randomBytes"](1)[0];
                };
              } catch (e) {
              }
            } else {
            }
            if (!random_device) {
              random_device = function() {
                abort("random_device");
              };
            }
            FS.createDevice("/dev", "random", random_device);
            FS.createDevice("/dev", "urandom", random_device);
            FS.mkdir("/dev/shm");
            FS.mkdir("/dev/shm/tmp");
          }, createSpecialDirectories: function() {
            FS.mkdir("/proc");
            FS.mkdir("/proc/self");
            FS.mkdir("/proc/self/fd");
            FS.mount({ mount: function() {
              var node = FS.createNode("/proc/self", "fd", 16384 | 511, 73);
              node.node_ops = { lookup: function(parent, name) {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(9);
                var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: function() {
                  return stream.path;
                } } };
                ret.parent = ret;
                return ret;
              } };
              return node;
            } }, {}, "/proc/self/fd");
          }, createStandardStreams: function() {
            if (Module2["stdin"]) {
              FS.createDevice("/dev", "stdin", Module2["stdin"]);
            } else {
              FS.symlink("/dev/tty", "/dev/stdin");
            }
            if (Module2["stdout"]) {
              FS.createDevice("/dev", "stdout", null, Module2["stdout"]);
            } else {
              FS.symlink("/dev/tty", "/dev/stdout");
            }
            if (Module2["stderr"]) {
              FS.createDevice("/dev", "stderr", null, Module2["stderr"]);
            } else {
              FS.symlink("/dev/tty1", "/dev/stderr");
            }
            var stdin = FS.open("/dev/stdin", "r");
            var stdout = FS.open("/dev/stdout", "w");
            var stderr = FS.open("/dev/stderr", "w");
          }, ensureErrnoError: function() {
            if (FS.ErrnoError) return;
            FS.ErrnoError = function ErrnoError(errno, node) {
              this.node = node;
              this.setErrno = function(errno2) {
                this.errno = errno2;
              };
              this.setErrno(errno);
              this.message = "FS error";
            };
            FS.ErrnoError.prototype = new Error();
            FS.ErrnoError.prototype.constructor = FS.ErrnoError;
            [2].forEach(function(code) {
              FS.genericErrors[code] = new FS.ErrnoError(code);
              FS.genericErrors[code].stack = "<generic error, no stack>";
            });
          }, staticInit: function() {
            FS.ensureErrnoError();
            FS.nameTable = new Array(4096);
            FS.mount(MEMFS, {}, "/");
            FS.createDefaultDirectories();
            FS.createDefaultDevices();
            FS.createSpecialDirectories();
            FS.filesystems = { "MEMFS": MEMFS, "IDBFS": IDBFS, "NODEFS": NODEFS, "WORKERFS": WORKERFS };
          }, init: function(input, output, error) {
            FS.init.initialized = true;
            FS.ensureErrnoError();
            Module2["stdin"] = input || Module2["stdin"];
            Module2["stdout"] = output || Module2["stdout"];
            Module2["stderr"] = error || Module2["stderr"];
            FS.createStandardStreams();
          }, quit: function() {
            FS.init.initialized = false;
            var fflush = Module2["_fflush"];
            if (fflush) fflush(0);
            for (var i2 = 0; i2 < FS.streams.length; i2++) {
              var stream = FS.streams[i2];
              if (!stream) {
                continue;
              }
              FS.close(stream);
            }
          }, getMode: function(canRead, canWrite) {
            var mode = 0;
            if (canRead) mode |= 292 | 73;
            if (canWrite) mode |= 146;
            return mode;
          }, joinPath: function(parts, forceRelative) {
            var path = PATH.join.apply(null, parts);
            if (forceRelative && path[0] == "/") path = path.substr(1);
            return path;
          }, absolutePath: function(relative, base) {
            return PATH_FS.resolve(base, relative);
          }, standardizePath: function(path) {
            return PATH.normalize(path);
          }, findObject: function(path, dontResolveLastLink) {
            var ret = FS.analyzePath(path, dontResolveLastLink);
            if (ret.exists) {
              return ret.object;
            } else {
              ___setErrNo(ret.error);
              return null;
            }
          }, analyzePath: function(path, dontResolveLastLink) {
            try {
              var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              path = lookup.path;
            } catch (e) {
            }
            var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
            try {
              var lookup = FS.lookupPath(path, { parent: true });
              ret.parentExists = true;
              ret.parentPath = lookup.path;
              ret.parentObject = lookup.node;
              ret.name = PATH.basename(path);
              lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              ret.exists = true;
              ret.path = lookup.path;
              ret.object = lookup.node;
              ret.name = lookup.node.name;
              ret.isRoot = lookup.path === "/";
            } catch (e) {
              ret.error = e.errno;
            }
            return ret;
          }, createFolder: function(parent, name, canRead, canWrite) {
            var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
            var mode = FS.getMode(canRead, canWrite);
            return FS.mkdir(path, mode);
          }, createPath: function(parent, path, canRead, canWrite) {
            parent = typeof parent === "string" ? parent : FS.getPath(parent);
            var parts = path.split("/").reverse();
            while (parts.length) {
              var part = parts.pop();
              if (!part) continue;
              var current = PATH.join2(parent, part);
              try {
                FS.mkdir(current);
              } catch (e) {
              }
              parent = current;
            }
            return current;
          }, createFile: function(parent, name, properties, canRead, canWrite) {
            var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
            var mode = FS.getMode(canRead, canWrite);
            return FS.create(path, mode);
          }, createDataFile: function(parent, name, data, canRead, canWrite, canOwn) {
            var path = name ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name) : parent;
            var mode = FS.getMode(canRead, canWrite);
            var node = FS.create(path, mode);
            if (data) {
              if (typeof data === "string") {
                var arr = new Array(data.length);
                for (var i2 = 0, len = data.length; i2 < len; ++i2) arr[i2] = data.charCodeAt(i2);
                data = arr;
              }
              FS.chmod(node, mode | 146);
              var stream = FS.open(node, "w");
              FS.write(stream, data, 0, data.length, 0, canOwn);
              FS.close(stream);
              FS.chmod(node, mode);
            }
            return node;
          }, createDevice: function(parent, name, input, output) {
            var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
            var mode = FS.getMode(!!input, !!output);
            if (!FS.createDevice.major) FS.createDevice.major = 64;
            var dev = FS.makedev(FS.createDevice.major++, 0);
            FS.registerDevice(dev, { open: function(stream) {
              stream.seekable = false;
            }, close: function(stream) {
              if (output && output.buffer && output.buffer.length) {
                output(10);
              }
            }, read: function(stream, buffer2, offset, length, pos) {
              var bytesRead = 0;
              for (var i2 = 0; i2 < length; i2++) {
                var result;
                try {
                  result = input();
                } catch (e) {
                  throw new FS.ErrnoError(5);
                }
                if (result === void 0 && bytesRead === 0) {
                  throw new FS.ErrnoError(11);
                }
                if (result === null || result === void 0) break;
                bytesRead++;
                buffer2[offset + i2] = result;
              }
              if (bytesRead) {
                stream.node.timestamp = Date.now();
              }
              return bytesRead;
            }, write: function(stream, buffer2, offset, length, pos) {
              for (var i2 = 0; i2 < length; i2++) {
                try {
                  output(buffer2[offset + i2]);
                } catch (e) {
                  throw new FS.ErrnoError(5);
                }
              }
              if (length) {
                stream.node.timestamp = Date.now();
              }
              return i2;
            } });
            return FS.mkdev(path, mode, dev);
          }, createLink: function(parent, name, target, canRead, canWrite) {
            var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
            return FS.symlink(target, path);
          }, forceLoadFile: function(obj) {
            if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
            var success = true;
            if (typeof XMLHttpRequest !== "undefined") {
              throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
            } else if (read_) {
              try {
                obj.contents = intArrayFromString(read_(obj.url), true);
                obj.usedBytes = obj.contents.length;
              } catch (e) {
                success = false;
              }
            } else {
              throw new Error("Cannot load without read() or XMLHttpRequest.");
            }
            if (!success) ___setErrNo(5);
            return success;
          }, createLazyFile: function(parent, name, url, canRead, canWrite) {
            function LazyUint8Array() {
              this.lengthKnown = false;
              this.chunks = [];
            }
            LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
              if (idx > this.length - 1 || idx < 0) {
                return void 0;
              }
              var chunkOffset = idx % this.chunkSize;
              var chunkNum = idx / this.chunkSize | 0;
              return this.getter(chunkNum)[chunkOffset];
            };
            LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
              this.getter = getter;
            };
            LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
              var xhr = new XMLHttpRequest();
              xhr.open("HEAD", url, false);
              xhr.send(null);
              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
              var datalength = Number(xhr.getResponseHeader("Content-length"));
              var header;
              var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
              var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
              var chunkSize = 1024 * 1024;
              if (!hasByteServing) chunkSize = datalength;
              var doXHR = function(from, to) {
                if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
                if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!");
                var xhr2 = new XMLHttpRequest();
                xhr2.open("GET", url, false);
                if (datalength !== chunkSize) xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
                if (typeof Uint8Array != "undefined") xhr2.responseType = "arraybuffer";
                if (xhr2.overrideMimeType) {
                  xhr2.overrideMimeType("text/plain; charset=x-user-defined");
                }
                xhr2.send(null);
                if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
                if (xhr2.response !== void 0) {
                  return new Uint8Array(xhr2.response || []);
                } else {
                  return intArrayFromString(xhr2.responseText || "", true);
                }
              };
              var lazyArray2 = this;
              lazyArray2.setDataGetter(function(chunkNum) {
                var start = chunkNum * chunkSize;
                var end = (chunkNum + 1) * chunkSize - 1;
                end = Math.min(end, datalength - 1);
                if (typeof lazyArray2.chunks[chunkNum] === "undefined") {
                  lazyArray2.chunks[chunkNum] = doXHR(start, end);
                }
                if (typeof lazyArray2.chunks[chunkNum] === "undefined") throw new Error("doXHR failed!");
                return lazyArray2.chunks[chunkNum];
              });
              if (usesGzip || !datalength) {
                chunkSize = datalength = 1;
                datalength = this.getter(0).length;
                chunkSize = datalength;
                console.log("LazyFiles on gzip forces download of the whole file when length is accessed");
              }
              this._length = datalength;
              this._chunkSize = chunkSize;
              this.lengthKnown = true;
            };
            if (typeof XMLHttpRequest !== "undefined") {
              if (!ENVIRONMENT_IS_WORKER) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
              var lazyArray = new LazyUint8Array();
              Object.defineProperties(lazyArray, { length: { get: function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              } }, chunkSize: { get: function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              } } });
              var properties = { isDevice: false, contents: lazyArray };
            } else {
              var properties = { isDevice: false, url };
            }
            var node = FS.createFile(parent, name, properties, canRead, canWrite);
            if (properties.contents) {
              node.contents = properties.contents;
            } else if (properties.url) {
              node.contents = null;
              node.url = properties.url;
            }
            Object.defineProperties(node, { usedBytes: { get: function() {
              return this.contents.length;
            } } });
            var stream_ops = {};
            var keys = Object.keys(node.stream_ops);
            keys.forEach(function(key2) {
              var fn = node.stream_ops[key2];
              stream_ops[key2] = function forceLoadLazyFile() {
                if (!FS.forceLoadFile(node)) {
                  throw new FS.ErrnoError(5);
                }
                return fn.apply(null, arguments);
              };
            });
            stream_ops.read = function stream_ops_read(stream, buffer2, offset, length, position) {
              if (!FS.forceLoadFile(node)) {
                throw new FS.ErrnoError(5);
              }
              var contents = stream.node.contents;
              if (position >= contents.length) return 0;
              var size = Math.min(contents.length - position, length);
              if (contents.slice) {
                for (var i2 = 0; i2 < size; i2++) {
                  buffer2[offset + i2] = contents[position + i2];
                }
              } else {
                for (var i2 = 0; i2 < size; i2++) {
                  buffer2[offset + i2] = contents.get(position + i2);
                }
              }
              return size;
            };
            node.stream_ops = stream_ops;
            return node;
          }, createPreloadedFile: function(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
            Browser.init();
            var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
            var dep = getUniqueRunDependency("cp " + fullname);
            function processData(byteArray) {
              function finish(byteArray2) {
                if (preFinish) preFinish();
                if (!dontCreateFile) {
                  FS.createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
                }
                if (onload) onload();
                removeRunDependency(dep);
              }
              var handled = false;
              Module2["preloadPlugins"].forEach(function(plugin) {
                if (handled) return;
                if (plugin["canHandle"](fullname)) {
                  plugin["handle"](byteArray, fullname, finish, function() {
                    if (onerror) onerror();
                    removeRunDependency(dep);
                  });
                  handled = true;
                }
              });
              if (!handled) finish(byteArray);
            }
            addRunDependency(dep);
            if (typeof url == "string") {
              Browser.asyncLoad(url, function(byteArray) {
                processData(byteArray);
              }, onerror);
            } else {
              processData(url);
            }
          }, indexedDB: function() {
            return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
          }, DB_NAME: function() {
            return "EM_FS_" + window.location.pathname;
          }, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: function(paths, onload, onerror) {
            onload = onload || function() {
            };
            onerror = onerror || function() {
            };
            var indexedDB2 = FS.indexedDB();
            try {
              var openRequest = indexedDB2.open(FS.DB_NAME(), FS.DB_VERSION);
            } catch (e) {
              return onerror(e);
            }
            openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
              console.log("creating db");
              var db = openRequest.result;
              db.createObjectStore(FS.DB_STORE_NAME);
            };
            openRequest.onsuccess = function openRequest_onsuccess() {
              var db = openRequest.result;
              var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
              var files = transaction.objectStore(FS.DB_STORE_NAME);
              var ok = 0, fail = 0, total = paths.length;
              function finish() {
                if (fail == 0) onload();
                else onerror();
              }
              paths.forEach(function(path) {
                var putRequest = files.put(FS.analyzePath(path).object.contents, path);
                putRequest.onsuccess = function putRequest_onsuccess() {
                  ok++;
                  if (ok + fail == total) finish();
                };
                putRequest.onerror = function putRequest_onerror() {
                  fail++;
                  if (ok + fail == total) finish();
                };
              });
              transaction.onerror = onerror;
            };
            openRequest.onerror = onerror;
          }, loadFilesFromDB: function(paths, onload, onerror) {
            onload = onload || function() {
            };
            onerror = onerror || function() {
            };
            var indexedDB2 = FS.indexedDB();
            try {
              var openRequest = indexedDB2.open(FS.DB_NAME(), FS.DB_VERSION);
            } catch (e) {
              return onerror(e);
            }
            openRequest.onupgradeneeded = onerror;
            openRequest.onsuccess = function openRequest_onsuccess() {
              var db = openRequest.result;
              try {
                var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
              } catch (e) {
                onerror(e);
                return;
              }
              var files = transaction.objectStore(FS.DB_STORE_NAME);
              var ok = 0, fail = 0, total = paths.length;
              function finish() {
                if (fail == 0) onload();
                else onerror();
              }
              paths.forEach(function(path) {
                var getRequest = files.get(path);
                getRequest.onsuccess = function getRequest_onsuccess() {
                  if (FS.analyzePath(path).exists) {
                    FS.unlink(path);
                  }
                  FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
                  ok++;
                  if (ok + fail == total) finish();
                };
                getRequest.onerror = function getRequest_onerror() {
                  fail++;
                  if (ok + fail == total) finish();
                };
              });
              transaction.onerror = onerror;
            };
            openRequest.onerror = onerror;
          } };
          var SYSCALLS = { DEFAULT_POLLMASK: 5, mappings: {}, umask: 511, calculateAt: function(dirfd, path) {
            if (path[0] !== "/") {
              var dir;
              if (dirfd === -100) {
                dir = FS.cwd();
              } else {
                var dirstream = FS.getStream(dirfd);
                if (!dirstream) throw new FS.ErrnoError(9);
                dir = dirstream.path;
              }
              path = PATH.join2(dir, path);
            }
            return path;
          }, doStat: function(func, path, buf) {
            try {
              var stat = func(path);
            } catch (e) {
              if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
                return -20;
              }
              throw e;
            }
            HEAP32[buf >> 2] = stat.dev;
            HEAP32[buf + 4 >> 2] = 0;
            HEAP32[buf + 8 >> 2] = stat.ino;
            HEAP32[buf + 12 >> 2] = stat.mode;
            HEAP32[buf + 16 >> 2] = stat.nlink;
            HEAP32[buf + 20 >> 2] = stat.uid;
            HEAP32[buf + 24 >> 2] = stat.gid;
            HEAP32[buf + 28 >> 2] = stat.rdev;
            HEAP32[buf + 32 >> 2] = 0;
            tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
            HEAP32[buf + 48 >> 2] = 4096;
            HEAP32[buf + 52 >> 2] = stat.blocks;
            HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0;
            HEAP32[buf + 60 >> 2] = 0;
            HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0;
            HEAP32[buf + 68 >> 2] = 0;
            HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0;
            HEAP32[buf + 76 >> 2] = 0;
            tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1];
            return 0;
          }, doMsync: function(addr, stream, len, flags) {
            var buffer2 = new Uint8Array(HEAPU8.subarray(addr, addr + len));
            FS.msync(stream, buffer2, 0, len, flags);
          }, doMkdir: function(path, mode) {
            path = PATH.normalize(path);
            if (path[path.length - 1] === "/") path = path.substr(0, path.length - 1);
            FS.mkdir(path, mode, 0);
            return 0;
          }, doMknod: function(path, mode, dev) {
            switch (mode & 61440) {
              case 32768:
              case 8192:
              case 24576:
              case 4096:
              case 49152:
                break;
              default:
                return -22;
            }
            FS.mknod(path, mode, dev);
            return 0;
          }, doReadlink: function(path, buf, bufsize) {
            if (bufsize <= 0) return -22;
            var ret = FS.readlink(path);
            var len = Math.min(bufsize, lengthBytesUTF8(ret));
            var endChar = HEAP8[buf + len];
            stringToUTF8(ret, buf, bufsize + 1);
            HEAP8[buf + len] = endChar;
            return len;
          }, doAccess: function(path, amode) {
            if (amode & ~7) {
              return -22;
            }
            var node;
            var lookup = FS.lookupPath(path, { follow: true });
            node = lookup.node;
            if (!node) {
              return -2;
            }
            var perms = "";
            if (amode & 4) perms += "r";
            if (amode & 2) perms += "w";
            if (amode & 1) perms += "x";
            if (perms && FS.nodePermissions(node, perms)) {
              return -13;
            }
            return 0;
          }, doDup: function(path, flags, suggestFD) {
            var suggest = FS.getStream(suggestFD);
            if (suggest) FS.close(suggest);
            return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
          }, doReadv: function(stream, iov, iovcnt, offset) {
            var ret = 0;
            for (var i2 = 0; i2 < iovcnt; i2++) {
              var ptr = HEAP32[iov + i2 * 8 >> 2];
              var len = HEAP32[iov + (i2 * 8 + 4) >> 2];
              var curr = FS.read(stream, HEAP8, ptr, len, offset);
              if (curr < 0) return -1;
              ret += curr;
              if (curr < len) break;
            }
            return ret;
          }, doWritev: function(stream, iov, iovcnt, offset) {
            var ret = 0;
            for (var i2 = 0; i2 < iovcnt; i2++) {
              var ptr = HEAP32[iov + i2 * 8 >> 2];
              var len = HEAP32[iov + (i2 * 8 + 4) >> 2];
              var curr = FS.write(stream, HEAP8, ptr, len, offset);
              if (curr < 0) return -1;
              ret += curr;
            }
            return ret;
          }, varargs: 0, get: function(varargs) {
            SYSCALLS.varargs += 4;
            var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
            return ret;
          }, getStr: function() {
            var ret = UTF8ToString(SYSCALLS.get());
            return ret;
          }, getStreamFromFD: function() {
            var stream = FS.getStream(SYSCALLS.get());
            if (!stream) throw new FS.ErrnoError(9);
            return stream;
          }, get64: function() {
            var low = SYSCALLS.get(), high = SYSCALLS.get();
            return low;
          }, getZero: function() {
            SYSCALLS.get();
          } };
          function ___syscall140(which, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get();
              var HIGH_OFFSET = 4294967296;
              var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
              var DOUBLE_LIMIT = 9007199254740992;
              if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
                return -75;
              }
              FS.llseek(stream, offset, whence);
              tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[result >> 2] = tempI64[0], HEAP32[result + 4 >> 2] = tempI64[1];
              if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
              return -e.errno;
            }
          }
          function ___syscall145(which, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();
              return SYSCALLS.doReadv(stream, iov, iovcnt);
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
              return -e.errno;
            }
          }
          function ___syscall146(which, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();
              return SYSCALLS.doWritev(stream, iov, iovcnt);
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
              return -e.errno;
            }
          }
          function ___syscall54(which, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(), op = SYSCALLS.get();
              switch (op) {
                case 21509:
                case 21505: {
                  if (!stream.tty) return -25;
                  return 0;
                }
                case 21510:
                case 21511:
                case 21512:
                case 21506:
                case 21507:
                case 21508: {
                  if (!stream.tty) return -25;
                  return 0;
                }
                case 21519: {
                  if (!stream.tty) return -25;
                  var argp = SYSCALLS.get();
                  HEAP32[argp >> 2] = 0;
                  return 0;
                }
                case 21520: {
                  if (!stream.tty) return -25;
                  return -22;
                }
                case 21531: {
                  var argp = SYSCALLS.get();
                  return FS.ioctl(stream, op, argp);
                }
                case 21523: {
                  if (!stream.tty) return -25;
                  return 0;
                }
                case 21524: {
                  if (!stream.tty) return -25;
                  return 0;
                }
                default:
                  abort("bad ioctl syscall " + op);
              }
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
              return -e.errno;
            }
          }
          function ___syscall6(which, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD();
              FS.close(stream);
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
              return -e.errno;
            }
          }
          function __emscripten_syscall_munmap(addr, len) {
            if (addr === -1 || len === 0) {
              return -22;
            }
            var info = SYSCALLS.mappings[addr];
            if (!info) return 0;
            if (len === info.len) {
              var stream = FS.getStream(info.fd);
              SYSCALLS.doMsync(addr, stream, len, info.flags);
              FS.munmap(stream);
              SYSCALLS.mappings[addr] = null;
              if (info.allocated) {
                _free(info.malloc);
              }
            }
            return 0;
          }
          function ___syscall91(which, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var addr = SYSCALLS.get(), len = SYSCALLS.get();
              return __emscripten_syscall_munmap(addr, len);
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
              return -e.errno;
            }
          }
          function ___unlock() {
          }
          var structRegistrations = {};
          function runDestructors(destructors) {
            while (destructors.length) {
              var ptr = destructors.pop();
              var del = destructors.pop();
              del(ptr);
            }
          }
          function simpleReadValueFromPointer(pointer) {
            return this["fromWireType"](HEAPU32[pointer >> 2]);
          }
          var awaitingDependencies = {};
          var registeredTypes = {};
          var typeDependencies = {};
          var char_0 = 48;
          var char_9 = 57;
          function makeLegalFunctionName(name) {
            if (void 0 === name) {
              return "_unknown";
            }
            name = name.replace(/[^a-zA-Z0-9_]/g, "$");
            var f = name.charCodeAt(0);
            if (f >= char_0 && f <= char_9) {
              return "_" + name;
            } else {
              return name;
            }
          }
          function createNamedFunction(name, body) {
            name = makeLegalFunctionName(name);
            return new Function("body", "return function " + name + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(body);
          }
          function extendError(baseErrorType, errorName) {
            var errorClass = createNamedFunction(errorName, function(message) {
              this.name = errorName;
              this.message = message;
              var stack = new Error(message).stack;
              if (stack !== void 0) {
                this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
              }
            });
            errorClass.prototype = Object.create(baseErrorType.prototype);
            errorClass.prototype.constructor = errorClass;
            errorClass.prototype.toString = function() {
              if (this.message === void 0) {
                return this.name;
              } else {
                return this.name + ": " + this.message;
              }
            };
            return errorClass;
          }
          var InternalError = void 0;
          function throwInternalError(message) {
            throw new InternalError(message);
          }
          function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
            myTypes.forEach(function(type) {
              typeDependencies[type] = dependentTypes;
            });
            function onComplete(typeConverters2) {
              var myTypeConverters = getTypeConverters(typeConverters2);
              if (myTypeConverters.length !== myTypes.length) {
                throwInternalError("Mismatched type converter count");
              }
              for (var i2 = 0; i2 < myTypes.length; ++i2) {
                registerType(myTypes[i2], myTypeConverters[i2]);
              }
            }
            var typeConverters = new Array(dependentTypes.length);
            var unregisteredTypes = [];
            var registered = 0;
            dependentTypes.forEach(function(dt, i2) {
              if (registeredTypes.hasOwnProperty(dt)) {
                typeConverters[i2] = registeredTypes[dt];
              } else {
                unregisteredTypes.push(dt);
                if (!awaitingDependencies.hasOwnProperty(dt)) {
                  awaitingDependencies[dt] = [];
                }
                awaitingDependencies[dt].push(function() {
                  typeConverters[i2] = registeredTypes[dt];
                  ++registered;
                  if (registered === unregisteredTypes.length) {
                    onComplete(typeConverters);
                  }
                });
              }
            });
            if (0 === unregisteredTypes.length) {
              onComplete(typeConverters);
            }
          }
          function __embind_finalize_value_object(structType) {
            var reg = structRegistrations[structType];
            delete structRegistrations[structType];
            var rawConstructor = reg.rawConstructor;
            var rawDestructor = reg.rawDestructor;
            var fieldRecords = reg.fields;
            var fieldTypes = fieldRecords.map(function(field) {
              return field.getterReturnType;
            }).concat(fieldRecords.map(function(field) {
              return field.setterArgumentType;
            }));
            whenDependentTypesAreResolved([structType], fieldTypes, function(fieldTypes2) {
              var fields = {};
              fieldRecords.forEach(function(field, i2) {
                var fieldName = field.fieldName;
                var getterReturnType = fieldTypes2[i2];
                var getter = field.getter;
                var getterContext = field.getterContext;
                var setterArgumentType = fieldTypes2[i2 + fieldRecords.length];
                var setter = field.setter;
                var setterContext = field.setterContext;
                fields[fieldName] = { read: function(ptr) {
                  return getterReturnType["fromWireType"](getter(getterContext, ptr));
                }, write: function(ptr, o) {
                  var destructors = [];
                  setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                  runDestructors(destructors);
                } };
              });
              return [{ name: reg.name, "fromWireType": function(ptr) {
                var rv = {};
                for (var i2 in fields) {
                  rv[i2] = fields[i2].read(ptr);
                }
                rawDestructor(ptr);
                return rv;
              }, "toWireType": function(destructors, o) {
                for (var fieldName in fields) {
                  if (!(fieldName in o)) {
                    throw new TypeError("Missing field");
                  }
                }
                var ptr = rawConstructor();
                for (fieldName in fields) {
                  fields[fieldName].write(ptr, o[fieldName]);
                }
                if (destructors !== null) {
                  destructors.push(rawDestructor, ptr);
                }
                return ptr;
              }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
            });
          }
          function getShiftFromSize(size) {
            switch (size) {
              case 1:
                return 0;
              case 2:
                return 1;
              case 4:
                return 2;
              case 8:
                return 3;
              default:
                throw new TypeError("Unknown type size: " + size);
            }
          }
          function embind_init_charCodes() {
            var codes = new Array(256);
            for (var i2 = 0; i2 < 256; ++i2) {
              codes[i2] = String.fromCharCode(i2);
            }
            embind_charCodes = codes;
          }
          var embind_charCodes = void 0;
          function readLatin1String(ptr) {
            var ret = "";
            var c = ptr;
            while (HEAPU8[c]) {
              ret += embind_charCodes[HEAPU8[c++]];
            }
            return ret;
          }
          var BindingError = void 0;
          function throwBindingError(message) {
            throw new BindingError(message);
          }
          function registerType(rawType, registeredInstance, options) {
            options = options || {};
            if (!("argPackAdvance" in registeredInstance)) {
              throw new TypeError("registerType registeredInstance requires argPackAdvance");
            }
            var name = registeredInstance.name;
            if (!rawType) {
              throwBindingError('type "' + name + '" must have a positive integer typeid pointer');
            }
            if (registeredTypes.hasOwnProperty(rawType)) {
              if (options.ignoreDuplicateRegistrations) {
                return;
              } else {
                throwBindingError("Cannot register type '" + name + "' twice");
              }
            }
            registeredTypes[rawType] = registeredInstance;
            delete typeDependencies[rawType];
            if (awaitingDependencies.hasOwnProperty(rawType)) {
              var callbacks = awaitingDependencies[rawType];
              delete awaitingDependencies[rawType];
              callbacks.forEach(function(cb) {
                cb();
              });
            }
          }
          function __embind_register_bool(rawType, name, size, trueValue, falseValue) {
            var shift = getShiftFromSize(size);
            name = readLatin1String(name);
            registerType(rawType, { name, "fromWireType": function(wt) {
              return !!wt;
            }, "toWireType": function(destructors, o) {
              return o ? trueValue : falseValue;
            }, "argPackAdvance": 8, "readValueFromPointer": function(pointer) {
              var heap;
              if (size === 1) {
                heap = HEAP8;
              } else if (size === 2) {
                heap = HEAP16;
              } else if (size === 4) {
                heap = HEAP32;
              } else {
                throw new TypeError("Unknown boolean type size: " + name);
              }
              return this["fromWireType"](heap[pointer >> shift]);
            }, destructorFunction: null });
          }
          function ClassHandle_isAliasOf(other) {
            if (!(this instanceof ClassHandle)) {
              return false;
            }
            if (!(other instanceof ClassHandle)) {
              return false;
            }
            var leftClass = this.$$.ptrType.registeredClass;
            var left = this.$$.ptr;
            var rightClass = other.$$.ptrType.registeredClass;
            var right = other.$$.ptr;
            while (leftClass.baseClass) {
              left = leftClass.upcast(left);
              leftClass = leftClass.baseClass;
            }
            while (rightClass.baseClass) {
              right = rightClass.upcast(right);
              rightClass = rightClass.baseClass;
            }
            return leftClass === rightClass && left === right;
          }
          function shallowCopyInternalPointer(o) {
            return { count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType };
          }
          function throwInstanceAlreadyDeleted(obj) {
            function getInstanceTypeName(handle) {
              return handle.$$.ptrType.registeredClass.name;
            }
            throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
          }
          var finalizationGroup = false;
          function detachFinalizer(handle) {
          }
          function runDestructor($$) {
            if ($$.smartPtr) {
              $$.smartPtrType.rawDestructor($$.smartPtr);
            } else {
              $$.ptrType.registeredClass.rawDestructor($$.ptr);
            }
          }
          function releaseClassHandle($$) {
            $$.count.value -= 1;
            var toDelete = 0 === $$.count.value;
            if (toDelete) {
              runDestructor($$);
            }
          }
          function attachFinalizer(handle) {
            if ("undefined" === typeof FinalizationGroup) {
              attachFinalizer = function(handle2) {
                return handle2;
              };
              return handle;
            }
            finalizationGroup = new FinalizationGroup(function(iter) {
              for (var result = iter.next(); !result.done; result = iter.next()) {
                var $$ = result.value;
                if (!$$.ptr) {
                  console.warn("object already deleted: " + $$.ptr);
                } else {
                  releaseClassHandle($$);
                }
              }
            });
            attachFinalizer = function(handle2) {
              finalizationGroup.register(handle2, handle2.$$, handle2.$$);
              return handle2;
            };
            detachFinalizer = function(handle2) {
              finalizationGroup.unregister(handle2.$$);
            };
            return attachFinalizer(handle);
          }
          function ClassHandle_clone() {
            if (!this.$$.ptr) {
              throwInstanceAlreadyDeleted(this);
            }
            if (this.$$.preservePointerOnDelete) {
              this.$$.count.value += 1;
              return this;
            } else {
              var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } }));
              clone.$$.count.value += 1;
              clone.$$.deleteScheduled = false;
              return clone;
            }
          }
          function ClassHandle_delete() {
            if (!this.$$.ptr) {
              throwInstanceAlreadyDeleted(this);
            }
            if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
              throwBindingError("Object already scheduled for deletion");
            }
            detachFinalizer(this);
            releaseClassHandle(this.$$);
            if (!this.$$.preservePointerOnDelete) {
              this.$$.smartPtr = void 0;
              this.$$.ptr = void 0;
            }
          }
          function ClassHandle_isDeleted() {
            return !this.$$.ptr;
          }
          var delayFunction = void 0;
          var deletionQueue = [];
          function flushPendingDeletes() {
            while (deletionQueue.length) {
              var obj = deletionQueue.pop();
              obj.$$.deleteScheduled = false;
              obj["delete"]();
            }
          }
          function ClassHandle_deleteLater() {
            if (!this.$$.ptr) {
              throwInstanceAlreadyDeleted(this);
            }
            if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
              throwBindingError("Object already scheduled for deletion");
            }
            deletionQueue.push(this);
            if (deletionQueue.length === 1 && delayFunction) {
              delayFunction(flushPendingDeletes);
            }
            this.$$.deleteScheduled = true;
            return this;
          }
          function init_ClassHandle() {
            ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
            ClassHandle.prototype["clone"] = ClassHandle_clone;
            ClassHandle.prototype["delete"] = ClassHandle_delete;
            ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
            ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
          }
          function ClassHandle() {
          }
          var registeredPointers = {};
          function ensureOverloadTable(proto, methodName, humanName) {
            if (void 0 === proto[methodName].overloadTable) {
              var prevFunc = proto[methodName];
              proto[methodName] = function() {
                if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                  throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
                }
                return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
              };
              proto[methodName].overloadTable = [];
              proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
            }
          }
          function exposePublicSymbol(name, value, numArguments) {
            if (Module2.hasOwnProperty(name)) {
              if (void 0 === numArguments || void 0 !== Module2[name].overloadTable && void 0 !== Module2[name].overloadTable[numArguments]) {
                throwBindingError("Cannot register public name '" + name + "' twice");
              }
              ensureOverloadTable(Module2, name, name);
              if (Module2.hasOwnProperty(numArguments)) {
                throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
              }
              Module2[name].overloadTable[numArguments] = value;
            } else {
              Module2[name] = value;
              if (void 0 !== numArguments) {
                Module2[name].numArguments = numArguments;
              }
            }
          }
          function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
            this.name = name;
            this.constructor = constructor;
            this.instancePrototype = instancePrototype;
            this.rawDestructor = rawDestructor;
            this.baseClass = baseClass;
            this.getActualType = getActualType;
            this.upcast = upcast;
            this.downcast = downcast;
            this.pureVirtualFunctions = [];
          }
          function upcastPointer(ptr, ptrClass, desiredClass) {
            while (ptrClass !== desiredClass) {
              if (!ptrClass.upcast) {
                throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
              }
              ptr = ptrClass.upcast(ptr);
              ptrClass = ptrClass.baseClass;
            }
            return ptr;
          }
          function constNoSmartPtrRawPointerToWireType(destructors, handle) {
            if (handle === null) {
              if (this.isReference) {
                throwBindingError("null is not a valid " + this.name);
              }
              return 0;
            }
            if (!handle.$$) {
              throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
            }
            if (!handle.$$.ptr) {
              throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
            }
            var handleClass = handle.$$.ptrType.registeredClass;
            var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
            return ptr;
          }
          function genericPointerToWireType(destructors, handle) {
            var ptr;
            if (handle === null) {
              if (this.isReference) {
                throwBindingError("null is not a valid " + this.name);
              }
              if (this.isSmartPointer) {
                ptr = this.rawConstructor();
                if (destructors !== null) {
                  destructors.push(this.rawDestructor, ptr);
                }
                return ptr;
              } else {
                return 0;
              }
            }
            if (!handle.$$) {
              throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
            }
            if (!handle.$$.ptr) {
              throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
            }
            if (!this.isConst && handle.$$.ptrType.isConst) {
              throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
            }
            var handleClass = handle.$$.ptrType.registeredClass;
            ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
            if (this.isSmartPointer) {
              if (void 0 === handle.$$.smartPtr) {
                throwBindingError("Passing raw pointer to smart pointer is illegal");
              }
              switch (this.sharingPolicy) {
                case 0:
                  if (handle.$$.smartPtrType === this) {
                    ptr = handle.$$.smartPtr;
                  } else {
                    throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
                  }
                  break;
                case 1:
                  ptr = handle.$$.smartPtr;
                  break;
                case 2:
                  if (handle.$$.smartPtrType === this) {
                    ptr = handle.$$.smartPtr;
                  } else {
                    var clonedHandle = handle["clone"]();
                    ptr = this.rawShare(ptr, __emval_register(function() {
                      clonedHandle["delete"]();
                    }));
                    if (destructors !== null) {
                      destructors.push(this.rawDestructor, ptr);
                    }
                  }
                  break;
                default:
                  throwBindingError("Unsupporting sharing policy");
              }
            }
            return ptr;
          }
          function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
            if (handle === null) {
              if (this.isReference) {
                throwBindingError("null is not a valid " + this.name);
              }
              return 0;
            }
            if (!handle.$$) {
              throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
            }
            if (!handle.$$.ptr) {
              throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
            }
            if (handle.$$.ptrType.isConst) {
              throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
            }
            var handleClass = handle.$$.ptrType.registeredClass;
            var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
            return ptr;
          }
          function RegisteredPointer_getPointee(ptr) {
            if (this.rawGetPointee) {
              ptr = this.rawGetPointee(ptr);
            }
            return ptr;
          }
          function RegisteredPointer_destructor(ptr) {
            if (this.rawDestructor) {
              this.rawDestructor(ptr);
            }
          }
          function RegisteredPointer_deleteObject(handle) {
            if (handle !== null) {
              handle["delete"]();
            }
          }
          function downcastPointer(ptr, ptrClass, desiredClass) {
            if (ptrClass === desiredClass) {
              return ptr;
            }
            if (void 0 === desiredClass.baseClass) {
              return null;
            }
            var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
            if (rv === null) {
              return null;
            }
            return desiredClass.downcast(rv);
          }
          function getInheritedInstanceCount() {
            return Object.keys(registeredInstances).length;
          }
          function getLiveInheritedInstances() {
            var rv = [];
            for (var k in registeredInstances) {
              if (registeredInstances.hasOwnProperty(k)) {
                rv.push(registeredInstances[k]);
              }
            }
            return rv;
          }
          function setDelayFunction(fn) {
            delayFunction = fn;
            if (deletionQueue.length && delayFunction) {
              delayFunction(flushPendingDeletes);
            }
          }
          function init_embind() {
            Module2["getInheritedInstanceCount"] = getInheritedInstanceCount;
            Module2["getLiveInheritedInstances"] = getLiveInheritedInstances;
            Module2["flushPendingDeletes"] = flushPendingDeletes;
            Module2["setDelayFunction"] = setDelayFunction;
          }
          var registeredInstances = {};
          function getBasestPointer(class_, ptr) {
            if (ptr === void 0) {
              throwBindingError("ptr should not be undefined");
            }
            while (class_.baseClass) {
              ptr = class_.upcast(ptr);
              class_ = class_.baseClass;
            }
            return ptr;
          }
          function getInheritedInstance(class_, ptr) {
            ptr = getBasestPointer(class_, ptr);
            return registeredInstances[ptr];
          }
          function makeClassHandle(prototype, record) {
            if (!record.ptrType || !record.ptr) {
              throwInternalError("makeClassHandle requires ptr and ptrType");
            }
            var hasSmartPtrType = !!record.smartPtrType;
            var hasSmartPtr = !!record.smartPtr;
            if (hasSmartPtrType !== hasSmartPtr) {
              throwInternalError("Both smartPtrType and smartPtr must be specified");
            }
            record.count = { value: 1 };
            return attachFinalizer(Object.create(prototype, { $$: { value: record } }));
          }
          function RegisteredPointer_fromWireType(ptr) {
            var rawPointer = this.getPointee(ptr);
            if (!rawPointer) {
              this.destructor(ptr);
              return null;
            }
            var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
            if (void 0 !== registeredInstance) {
              if (0 === registeredInstance.$$.count.value) {
                registeredInstance.$$.ptr = rawPointer;
                registeredInstance.$$.smartPtr = ptr;
                return registeredInstance["clone"]();
              } else {
                var rv = registeredInstance["clone"]();
                this.destructor(ptr);
                return rv;
              }
            }
            function makeDefaultHandle() {
              if (this.isSmartPointer) {
                return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });
              } else {
                return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr });
              }
            }
            var actualType = this.registeredClass.getActualType(rawPointer);
            var registeredPointerRecord = registeredPointers[actualType];
            if (!registeredPointerRecord) {
              return makeDefaultHandle.call(this);
            }
            var toType;
            if (this.isConst) {
              toType = registeredPointerRecord.constPointerType;
            } else {
              toType = registeredPointerRecord.pointerType;
            }
            var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
            if (dp === null) {
              return makeDefaultHandle.call(this);
            }
            if (this.isSmartPointer) {
              return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });
            } else {
              return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });
            }
          }
          function init_RegisteredPointer() {
            RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
            RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
            RegisteredPointer.prototype["argPackAdvance"] = 8;
            RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
            RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
            RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
          }
          function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
            this.name = name;
            this.registeredClass = registeredClass;
            this.isReference = isReference;
            this.isConst = isConst;
            this.isSmartPointer = isSmartPointer;
            this.pointeeType = pointeeType;
            this.sharingPolicy = sharingPolicy;
            this.rawGetPointee = rawGetPointee;
            this.rawConstructor = rawConstructor;
            this.rawShare = rawShare;
            this.rawDestructor = rawDestructor;
            if (!isSmartPointer && registeredClass.baseClass === void 0) {
              if (isConst) {
                this["toWireType"] = constNoSmartPtrRawPointerToWireType;
                this.destructorFunction = null;
              } else {
                this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
                this.destructorFunction = null;
              }
            } else {
              this["toWireType"] = genericPointerToWireType;
            }
          }
          function replacePublicSymbol(name, value, numArguments) {
            if (!Module2.hasOwnProperty(name)) {
              throwInternalError("Replacing nonexistant public symbol");
            }
            if (void 0 !== Module2[name].overloadTable && void 0 !== numArguments) {
              Module2[name].overloadTable[numArguments] = value;
            } else {
              Module2[name] = value;
              Module2[name].argCount = numArguments;
            }
          }
          function embind__requireFunction(signature, rawFunction) {
            signature = readLatin1String(signature);
            function makeDynCaller(dynCall) {
              var args = [];
              for (var i2 = 1; i2 < signature.length; ++i2) {
                args.push("a" + i2);
              }
              var name = "dynCall_" + signature + "_" + rawFunction;
              var body = "return function " + name + "(" + args.join(", ") + ") {\n";
              body += "    return dynCall(rawFunction" + (args.length ? ", " : "") + args.join(", ") + ");\n";
              body += "};\n";
              return new Function("dynCall", "rawFunction", body)(dynCall, rawFunction);
            }
            var fp;
            if (Module2["FUNCTION_TABLE_" + signature] !== void 0) {
              fp = Module2["FUNCTION_TABLE_" + signature][rawFunction];
            } else if (typeof FUNCTION_TABLE !== "undefined") {
              fp = FUNCTION_TABLE[rawFunction];
            } else {
              var dc = Module2["dynCall_" + signature];
              if (dc === void 0) {
                dc = Module2["dynCall_" + signature.replace(/f/g, "d")];
                if (dc === void 0) {
                  throwBindingError("No dynCall invoker for signature: " + signature);
                }
              }
              fp = makeDynCaller(dc);
            }
            if (typeof fp !== "function") {
              throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
            }
            return fp;
          }
          var UnboundTypeError = void 0;
          function getTypeName(type) {
            var ptr = ___getTypeName(type);
            var rv = readLatin1String(ptr);
            _free(ptr);
            return rv;
          }
          function throwUnboundTypeError(message, types) {
            var unboundTypes = [];
            var seen = {};
            function visit(type) {
              if (seen[type]) {
                return;
              }
              if (registeredTypes[type]) {
                return;
              }
              if (typeDependencies[type]) {
                typeDependencies[type].forEach(visit);
                return;
              }
              unboundTypes.push(type);
              seen[type] = true;
            }
            types.forEach(visit);
            throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([", "]));
          }
          function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {
            name = readLatin1String(name);
            getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
            if (upcast) {
              upcast = embind__requireFunction(upcastSignature, upcast);
            }
            if (downcast) {
              downcast = embind__requireFunction(downcastSignature, downcast);
            }
            rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
            var legalFunctionName = makeLegalFunctionName(name);
            exposePublicSymbol(legalFunctionName, function() {
              throwUnboundTypeError("Cannot construct " + name + " due to unbound types", [baseClassRawType]);
            });
            whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
              base = base[0];
              var baseClass;
              var basePrototype;
              if (baseClassRawType) {
                baseClass = base.registeredClass;
                basePrototype = baseClass.instancePrototype;
              } else {
                basePrototype = ClassHandle.prototype;
              }
              var constructor = createNamedFunction(legalFunctionName, function() {
                if (Object.getPrototypeOf(this) !== instancePrototype) {
                  throw new BindingError("Use 'new' to construct " + name);
                }
                if (void 0 === registeredClass.constructor_body) {
                  throw new BindingError(name + " has no accessible constructor");
                }
                var body = registeredClass.constructor_body[arguments.length];
                if (void 0 === body) {
                  throw new BindingError("Tried to invoke ctor of " + name + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
                }
                return body.apply(this, arguments);
              });
              var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });
              constructor.prototype = instancePrototype;
              var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
              var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);
              var pointerConverter = new RegisteredPointer(name + "*", registeredClass, false, false, false);
              var constPointerConverter = new RegisteredPointer(name + " const*", registeredClass, false, true, false);
              registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };
              replacePublicSymbol(legalFunctionName, constructor);
              return [referenceConverter, pointerConverter, constPointerConverter];
            });
          }
          function heap32VectorToArray(count, firstElement) {
            var array = [];
            for (var i2 = 0; i2 < count; i2++) {
              array.push(HEAP32[(firstElement >> 2) + i2]);
            }
            return array;
          }
          function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            invoker = embind__requireFunction(invokerSignature, invoker);
            whenDependentTypesAreResolved([], [rawClassType], function(classType) {
              classType = classType[0];
              var humanName = "constructor " + classType.name;
              if (void 0 === classType.registeredClass.constructor_body) {
                classType.registeredClass.constructor_body = [];
              }
              if (void 0 !== classType.registeredClass.constructor_body[argCount - 1]) {
                throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
              }
              classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
                throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
              };
              whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
                classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
                  if (arguments.length !== argCount - 1) {
                    throwBindingError(humanName + " called with " + arguments.length + " arguments, expected " + (argCount - 1));
                  }
                  var destructors = [];
                  var args = new Array(argCount);
                  args[0] = rawConstructor;
                  for (var i2 = 1; i2 < argCount; ++i2) {
                    args[i2] = argTypes[i2]["toWireType"](destructors, arguments[i2 - 1]);
                  }
                  var ptr = invoker.apply(null, args);
                  runDestructors(destructors);
                  return argTypes[0]["fromWireType"](ptr);
                };
                return [];
              });
              return [];
            });
          }
          function new_(constructor, argumentList) {
            if (!(constructor instanceof Function)) {
              throw new TypeError("new_ called with constructor type " + typeof constructor + " which is not a function");
            }
            var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
            });
            dummy.prototype = constructor.prototype;
            var obj = new dummy();
            var r = constructor.apply(obj, argumentList);
            return r instanceof Object ? r : obj;
          }
          function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
            var argCount = argTypes.length;
            if (argCount < 2) {
              throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
            }
            var isClassMethodFunc = argTypes[1] !== null && classType !== null;
            var needsDestructorStack = false;
            for (var i2 = 1; i2 < argTypes.length; ++i2) {
              if (argTypes[i2] !== null && argTypes[i2].destructorFunction === void 0) {
                needsDestructorStack = true;
                break;
              }
            }
            var returns = argTypes[0].name !== "void";
            var argsList = "";
            var argsListWired = "";
            for (var i2 = 0; i2 < argCount - 2; ++i2) {
              argsList += (i2 !== 0 ? ", " : "") + "arg" + i2;
              argsListWired += (i2 !== 0 ? ", " : "") + "arg" + i2 + "Wired";
            }
            var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\nif (arguments.length !== " + (argCount - 2) + ") {\nthrowBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n}\n";
            if (needsDestructorStack) {
              invokerFnBody += "var destructors = [];\n";
            }
            var dtorStack = needsDestructorStack ? "destructors" : "null";
            var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
            var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
            if (isClassMethodFunc) {
              invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
            }
            for (var i2 = 0; i2 < argCount - 2; ++i2) {
              invokerFnBody += "var arg" + i2 + "Wired = argType" + i2 + ".toWireType(" + dtorStack + ", arg" + i2 + "); // " + argTypes[i2 + 2].name + "\n";
              args1.push("argType" + i2);
              args2.push(argTypes[i2 + 2]);
            }
            if (isClassMethodFunc) {
              argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
            }
            invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
            if (needsDestructorStack) {
              invokerFnBody += "runDestructors(destructors);\n";
            } else {
              for (var i2 = isClassMethodFunc ? 1 : 2; i2 < argTypes.length; ++i2) {
                var paramName = i2 === 1 ? "thisWired" : "arg" + (i2 - 2) + "Wired";
                if (argTypes[i2].destructorFunction !== null) {
                  invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i2].name + "\n";
                  args1.push(paramName + "_dtor");
                  args2.push(argTypes[i2].destructorFunction);
                }
              }
            }
            if (returns) {
              invokerFnBody += "var ret = retType.fromWireType(rv);\nreturn ret;\n";
            } else {
            }
            invokerFnBody += "}\n";
            args1.push(invokerFnBody);
            var invokerFunction = new_(Function, args1).apply(null, args2);
            return invokerFunction;
          }
          function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            methodName = readLatin1String(methodName);
            rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
            whenDependentTypesAreResolved([], [rawClassType], function(classType) {
              classType = classType[0];
              var humanName = classType.name + "." + methodName;
              if (isPureVirtual) {
                classType.registeredClass.pureVirtualFunctions.push(methodName);
              }
              function unboundTypesHandler() {
                throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
              }
              var proto = classType.registeredClass.instancePrototype;
              var method = proto[methodName];
              if (void 0 === method || void 0 === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
                unboundTypesHandler.argCount = argCount - 2;
                unboundTypesHandler.className = classType.name;
                proto[methodName] = unboundTypesHandler;
              } else {
                ensureOverloadTable(proto, methodName, humanName);
                proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
              }
              whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
                var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
                if (void 0 === proto[methodName].overloadTable) {
                  memberFunction.argCount = argCount - 2;
                  proto[methodName] = memberFunction;
                } else {
                  proto[methodName].overloadTable[argCount - 2] = memberFunction;
                }
                return [];
              });
              return [];
            });
          }
          function validateThis(this_, classType, humanName) {
            if (!(this_ instanceof Object)) {
              throwBindingError(humanName + ' with invalid "this": ' + this_);
            }
            if (!(this_ instanceof classType.registeredClass.constructor)) {
              throwBindingError(humanName + ' incompatible with "this" of type ' + this_.constructor.name);
            }
            if (!this_.$$.ptr) {
              throwBindingError("cannot call emscripten binding method " + humanName + " on deleted object");
            }
            return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);
          }
          function __embind_register_class_property(classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
            fieldName = readLatin1String(fieldName);
            getter = embind__requireFunction(getterSignature, getter);
            whenDependentTypesAreResolved([], [classType], function(classType2) {
              classType2 = classType2[0];
              var humanName = classType2.name + "." + fieldName;
              var desc = { get: function() {
                throwUnboundTypeError("Cannot access " + humanName + " due to unbound types", [getterReturnType, setterArgumentType]);
              }, enumerable: true, configurable: true };
              if (setter) {
                desc.set = function() {
                  throwUnboundTypeError("Cannot access " + humanName + " due to unbound types", [getterReturnType, setterArgumentType]);
                };
              } else {
                desc.set = function(v) {
                  throwBindingError(humanName + " is a read-only property");
                };
              }
              Object.defineProperty(classType2.registeredClass.instancePrototype, fieldName, desc);
              whenDependentTypesAreResolved([], setter ? [getterReturnType, setterArgumentType] : [getterReturnType], function(types) {
                var getterReturnType2 = types[0];
                var desc2 = { get: function() {
                  var ptr = validateThis(this, classType2, humanName + " getter");
                  return getterReturnType2["fromWireType"](getter(getterContext, ptr));
                }, enumerable: true };
                if (setter) {
                  setter = embind__requireFunction(setterSignature, setter);
                  var setterArgumentType2 = types[1];
                  desc2.set = function(v) {
                    var ptr = validateThis(this, classType2, humanName + " setter");
                    var destructors = [];
                    setter(setterContext, ptr, setterArgumentType2["toWireType"](destructors, v));
                    runDestructors(destructors);
                  };
                }
                Object.defineProperty(classType2.registeredClass.instancePrototype, fieldName, desc2);
                return [];
              });
              return [];
            });
          }
          var emval_free_list = [];
          var emval_handle_array = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
          function __emval_decref(handle) {
            if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {
              emval_handle_array[handle] = void 0;
              emval_free_list.push(handle);
            }
          }
          function count_emval_handles() {
            var count = 0;
            for (var i2 = 5; i2 < emval_handle_array.length; ++i2) {
              if (emval_handle_array[i2] !== void 0) {
                ++count;
              }
            }
            return count;
          }
          function get_first_emval() {
            for (var i2 = 5; i2 < emval_handle_array.length; ++i2) {
              if (emval_handle_array[i2] !== void 0) {
                return emval_handle_array[i2];
              }
            }
            return null;
          }
          function init_emval() {
            Module2["count_emval_handles"] = count_emval_handles;
            Module2["get_first_emval"] = get_first_emval;
          }
          function __emval_register(value) {
            switch (value) {
              case void 0: {
                return 1;
              }
              case null: {
                return 2;
              }
              case true: {
                return 3;
              }
              case false: {
                return 4;
              }
              default: {
                var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
                emval_handle_array[handle] = { refcount: 1, value };
                return handle;
              }
            }
          }
          function __embind_register_emval(rawType, name) {
            name = readLatin1String(name);
            registerType(rawType, { name, "fromWireType": function(handle) {
              var rv = emval_handle_array[handle].value;
              __emval_decref(handle);
              return rv;
            }, "toWireType": function(destructors, value) {
              return __emval_register(value);
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: null });
          }
          function enumReadValueFromPointer(name, shift, signed) {
            switch (shift) {
              case 0:
                return function(pointer) {
                  var heap = signed ? HEAP8 : HEAPU8;
                  return this["fromWireType"](heap[pointer]);
                };
              case 1:
                return function(pointer) {
                  var heap = signed ? HEAP16 : HEAPU16;
                  return this["fromWireType"](heap[pointer >> 1]);
                };
              case 2:
                return function(pointer) {
                  var heap = signed ? HEAP32 : HEAPU32;
                  return this["fromWireType"](heap[pointer >> 2]);
                };
              default:
                throw new TypeError("Unknown integer type: " + name);
            }
          }
          function __embind_register_enum(rawType, name, size, isSigned) {
            var shift = getShiftFromSize(size);
            name = readLatin1String(name);
            function ctor() {
            }
            ctor.values = {};
            registerType(rawType, { name, constructor: ctor, "fromWireType": function(c) {
              return this.constructor.values[c];
            }, "toWireType": function(destructors, c) {
              return c.value;
            }, "argPackAdvance": 8, "readValueFromPointer": enumReadValueFromPointer(name, shift, isSigned), destructorFunction: null });
            exposePublicSymbol(name, ctor);
          }
          function requireRegisteredType(rawType, humanName) {
            var impl = registeredTypes[rawType];
            if (void 0 === impl) {
              throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
            }
            return impl;
          }
          function __embind_register_enum_value(rawEnumType, name, enumValue) {
            var enumType = requireRegisteredType(rawEnumType, "enum");
            name = readLatin1String(name);
            var Enum = enumType.constructor;
            var Value = Object.create(enumType.constructor.prototype, { value: { value: enumValue }, constructor: { value: createNamedFunction(enumType.name + "_" + name, function() {
            }) } });
            Enum.values[enumValue] = Value;
            Enum[name] = Value;
          }
          function _embind_repr(v) {
            if (v === null) {
              return "null";
            }
            var t = typeof v;
            if (t === "object" || t === "array" || t === "function") {
              return v.toString();
            } else {
              return "" + v;
            }
          }
          function floatReadValueFromPointer(name, shift) {
            switch (shift) {
              case 2:
                return function(pointer) {
                  return this["fromWireType"](HEAPF32[pointer >> 2]);
                };
              case 3:
                return function(pointer) {
                  return this["fromWireType"](HEAPF64[pointer >> 3]);
                };
              default:
                throw new TypeError("Unknown float type: " + name);
            }
          }
          function __embind_register_float(rawType, name, size) {
            var shift = getShiftFromSize(size);
            name = readLatin1String(name);
            registerType(rawType, { name, "fromWireType": function(value) {
              return value;
            }, "toWireType": function(destructors, value) {
              if (typeof value !== "number" && typeof value !== "boolean") {
                throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
              }
              return value;
            }, "argPackAdvance": 8, "readValueFromPointer": floatReadValueFromPointer(name, shift), destructorFunction: null });
          }
          function integerReadValueFromPointer(name, shift, signed) {
            switch (shift) {
              case 0:
                return signed ? function readS8FromPointer(pointer) {
                  return HEAP8[pointer];
                } : function readU8FromPointer(pointer) {
                  return HEAPU8[pointer];
                };
              case 1:
                return signed ? function readS16FromPointer(pointer) {
                  return HEAP16[pointer >> 1];
                } : function readU16FromPointer(pointer) {
                  return HEAPU16[pointer >> 1];
                };
              case 2:
                return signed ? function readS32FromPointer(pointer) {
                  return HEAP32[pointer >> 2];
                } : function readU32FromPointer(pointer) {
                  return HEAPU32[pointer >> 2];
                };
              default:
                throw new TypeError("Unknown integer type: " + name);
            }
          }
          function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
            name = readLatin1String(name);
            if (maxRange === -1) {
              maxRange = 4294967295;
            }
            var shift = getShiftFromSize(size);
            var fromWireType = function(value) {
              return value;
            };
            if (minRange === 0) {
              var bitshift = 32 - 8 * size;
              fromWireType = function(value) {
                return value << bitshift >>> bitshift;
              };
            }
            var isUnsignedType = name.indexOf("unsigned") != -1;
            registerType(primitiveType, { name, "fromWireType": fromWireType, "toWireType": function(destructors, value) {
              if (typeof value !== "number" && typeof value !== "boolean") {
                throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
              }
              if (value < minRange || value > maxRange) {
                throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!");
              }
              return isUnsignedType ? value >>> 0 : value | 0;
            }, "argPackAdvance": 8, "readValueFromPointer": integerReadValueFromPointer(name, shift, minRange !== 0), destructorFunction: null });
          }
          function __embind_register_memory_view(rawType, dataTypeIndex, name) {
            var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
            var TA = typeMapping[dataTypeIndex];
            function decodeMemoryView(handle) {
              handle = handle >> 2;
              var heap = HEAPU32;
              var size = heap[handle];
              var data = heap[handle + 1];
              return new TA(heap["buffer"], data, size);
            }
            name = readLatin1String(name);
            registerType(rawType, { name, "fromWireType": decodeMemoryView, "argPackAdvance": 8, "readValueFromPointer": decodeMemoryView }, { ignoreDuplicateRegistrations: true });
          }
          function __embind_register_std_string(rawType, name) {
            name = readLatin1String(name);
            var stdStringIsUTF8 = name === "std::string";
            registerType(rawType, { name, "fromWireType": function(value) {
              var length = HEAPU32[value >> 2];
              var str;
              if (stdStringIsUTF8) {
                var endChar = HEAPU8[value + 4 + length];
                var endCharSwap = 0;
                if (endChar != 0) {
                  endCharSwap = endChar;
                  HEAPU8[value + 4 + length] = 0;
                }
                var decodeStartPtr = value + 4;
                for (var i2 = 0; i2 <= length; ++i2) {
                  var currentBytePtr = value + 4 + i2;
                  if (HEAPU8[currentBytePtr] == 0) {
                    var stringSegment = UTF8ToString(decodeStartPtr);
                    if (str === void 0) str = stringSegment;
                    else {
                      str += String.fromCharCode(0);
                      str += stringSegment;
                    }
                    decodeStartPtr = currentBytePtr + 1;
                  }
                }
                if (endCharSwap != 0) HEAPU8[value + 4 + length] = endCharSwap;
              } else {
                var a = new Array(length);
                for (var i2 = 0; i2 < length; ++i2) {
                  a[i2] = String.fromCharCode(HEAPU8[value + 4 + i2]);
                }
                str = a.join("");
              }
              _free(value);
              return str;
            }, "toWireType": function(destructors, value) {
              if (value instanceof ArrayBuffer) {
                value = new Uint8Array(value);
              }
              var getLength;
              var valueIsOfTypeString = typeof value === "string";
              if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                throwBindingError("Cannot pass non-string to std::string");
              }
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                getLength = function() {
                  return lengthBytesUTF8(value);
                };
              } else {
                getLength = function() {
                  return value.length;
                };
              }
              var length = getLength();
              var ptr = _malloc(4 + length + 1);
              HEAPU32[ptr >> 2] = length;
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                stringToUTF8(value, ptr + 4, length + 1);
              } else {
                if (valueIsOfTypeString) {
                  for (var i2 = 0; i2 < length; ++i2) {
                    var charCode = value.charCodeAt(i2);
                    if (charCode > 255) {
                      _free(ptr);
                      throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                    }
                    HEAPU8[ptr + 4 + i2] = charCode;
                  }
                } else {
                  for (var i2 = 0; i2 < length; ++i2) {
                    HEAPU8[ptr + 4 + i2] = value[i2];
                  }
                }
              }
              if (destructors !== null) {
                destructors.push(_free, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
              _free(ptr);
            } });
          }
          function __embind_register_std_wstring(rawType, charSize, name) {
            name = readLatin1String(name);
            var getHeap, shift;
            if (charSize === 2) {
              getHeap = function() {
                return HEAPU16;
              };
              shift = 1;
            } else if (charSize === 4) {
              getHeap = function() {
                return HEAPU32;
              };
              shift = 2;
            }
            registerType(rawType, { name, "fromWireType": function(value) {
              var HEAP = getHeap();
              var length = HEAPU32[value >> 2];
              var a = new Array(length);
              var start = value + 4 >> shift;
              for (var i2 = 0; i2 < length; ++i2) {
                a[i2] = String.fromCharCode(HEAP[start + i2]);
              }
              _free(value);
              return a.join("");
            }, "toWireType": function(destructors, value) {
              var HEAP = getHeap();
              var length = value.length;
              var ptr = _malloc(4 + length * charSize);
              HEAPU32[ptr >> 2] = length;
              var start = ptr + 4 >> shift;
              for (var i2 = 0; i2 < length; ++i2) {
                HEAP[start + i2] = value.charCodeAt(i2);
              }
              if (destructors !== null) {
                destructors.push(_free, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
              _free(ptr);
            } });
          }
          function __embind_register_value_object(rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
            structRegistrations[rawType] = { name: readLatin1String(name), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), fields: [] };
          }
          function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
            structRegistrations[structType].fields.push({ fieldName: readLatin1String(fieldName), getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
          }
          function __embind_register_void(rawType, name) {
            name = readLatin1String(name);
            registerType(rawType, { isVoid: true, name, "argPackAdvance": 0, "fromWireType": function() {
              return void 0;
            }, "toWireType": function(destructors, o) {
              return void 0;
            } });
          }
          function requireHandle(handle) {
            if (!handle) {
              throwBindingError("Cannot use deleted val. handle = " + handle);
            }
            return emval_handle_array[handle].value;
          }
          function __emval_as(handle, returnType, destructorsRef) {
            handle = requireHandle(handle);
            returnType = requireRegisteredType(returnType, "emval::as");
            var destructors = [];
            var rd = __emval_register(destructors);
            HEAP32[destructorsRef >> 2] = rd;
            return returnType["toWireType"](destructors, handle);
          }
          var emval_symbols = {};
          function getStringOrSymbol(address) {
            var symbol = emval_symbols[address];
            if (symbol === void 0) {
              return readLatin1String(address);
            } else {
              return symbol;
            }
          }
          var emval_methodCallers = [];
          function __emval_call_void_method(caller, handle, methodName, args) {
            caller = emval_methodCallers[caller];
            handle = requireHandle(handle);
            methodName = getStringOrSymbol(methodName);
            caller(handle, methodName, null, args);
          }
          function __emval_addMethodCaller(caller) {
            var id = emval_methodCallers.length;
            emval_methodCallers.push(caller);
            return id;
          }
          function __emval_lookupTypes(argCount, argTypes, argWireTypes) {
            var a = new Array(argCount);
            for (var i2 = 0; i2 < argCount; ++i2) {
              a[i2] = requireRegisteredType(HEAP32[(argTypes >> 2) + i2], "parameter " + i2);
            }
            return a;
          }
          function __emval_get_method_caller(argCount, argTypes) {
            var types = __emval_lookupTypes(argCount, argTypes);
            var retType = types[0];
            var signatureName = retType.name + "_$" + types.slice(1).map(function(t) {
              return t.name;
            }).join("_") + "$";
            var params = ["retType"];
            var args = [retType];
            var argsList = "";
            for (var i2 = 0; i2 < argCount - 1; ++i2) {
              argsList += (i2 !== 0 ? ", " : "") + "arg" + i2;
              params.push("argType" + i2);
              args.push(types[1 + i2]);
            }
            var functionName = makeLegalFunctionName("methodCaller_" + signatureName);
            var functionBody = "return function " + functionName + "(handle, name, destructors, args) {\n";
            var offset = 0;
            for (var i2 = 0; i2 < argCount - 1; ++i2) {
              functionBody += "    var arg" + i2 + " = argType" + i2 + ".readValueFromPointer(args" + (offset ? "+" + offset : "") + ");\n";
              offset += types[i2 + 1]["argPackAdvance"];
            }
            functionBody += "    var rv = handle[name](" + argsList + ");\n";
            for (var i2 = 0; i2 < argCount - 1; ++i2) {
              if (types[i2 + 1]["deleteObject"]) {
                functionBody += "    argType" + i2 + ".deleteObject(arg" + i2 + ");\n";
              }
            }
            if (!retType.isVoid) {
              functionBody += "    return retType.toWireType(destructors, rv);\n";
            }
            functionBody += "};\n";
            params.push(functionBody);
            var invokerFunction = new_(Function, params).apply(null, args);
            return __emval_addMethodCaller(invokerFunction);
          }
          function __emval_get_module_property(name) {
            name = getStringOrSymbol(name);
            return __emval_register(Module2[name]);
          }
          function __emval_get_property(handle, key2) {
            handle = requireHandle(handle);
            key2 = requireHandle(key2);
            return __emval_register(handle[key2]);
          }
          function __emval_incref(handle) {
            if (handle > 4) {
              emval_handle_array[handle].refcount += 1;
            }
          }
          function craftEmvalAllocator(argCount) {
            var argsList = "";
            for (var i2 = 0; i2 < argCount; ++i2) {
              argsList += (i2 !== 0 ? ", " : "") + "arg" + i2;
            }
            var functionBody = "return function emval_allocator_" + argCount + "(constructor, argTypes, args) {\n";
            for (var i2 = 0; i2 < argCount; ++i2) {
              functionBody += "var argType" + i2 + " = requireRegisteredType(Module['HEAP32'][(argTypes >> 2) + " + i2 + '], "parameter ' + i2 + '");\nvar arg' + i2 + " = argType" + i2 + ".readValueFromPointer(args);\nargs += argType" + i2 + "['argPackAdvance'];\n";
            }
            functionBody += "var obj = new constructor(" + argsList + ");\nreturn __emval_register(obj);\n}\n";
            return new Function("requireRegisteredType", "Module", "__emval_register", functionBody)(requireRegisteredType, Module2, __emval_register);
          }
          var emval_newers = {};
          function __emval_new(handle, argCount, argTypes, args) {
            handle = requireHandle(handle);
            var newer = emval_newers[argCount];
            if (!newer) {
              newer = craftEmvalAllocator(argCount);
              emval_newers[argCount] = newer;
            }
            return newer(handle, argTypes, args);
          }
          function __emval_new_cstring(v) {
            return __emval_register(getStringOrSymbol(v));
          }
          function __emval_new_object() {
            return __emval_register({});
          }
          function __emval_run_destructors(handle) {
            var destructors = emval_handle_array[handle].value;
            runDestructors(destructors);
            __emval_decref(handle);
          }
          function __emval_set_property(handle, key2, value) {
            handle = requireHandle(handle);
            key2 = requireHandle(key2);
            value = requireHandle(value);
            handle[key2] = value;
          }
          function __emval_take_value(type, argv) {
            type = requireRegisteredType(type, "_emval_take_value");
            var v = type["readValueFromPointer"](argv);
            return __emval_register(v);
          }
          function _abort() {
            Module2["abort"]();
          }
          function _emscripten_get_heap_size() {
            return HEAP8.length;
          }
          var GL = { counter: 1, lastError: 0, buffers: [], mappedBuffers: {}, programs: [], framebuffers: [], renderbuffers: [], textures: [], uniforms: [], shaders: [], vaos: [], contexts: {}, currentContext: null, offscreenCanvases: {}, timerQueriesEXT: [], programInfos: {}, stringCache: {}, unpackAlignment: 4, init: function() {
            GL.miniTempBuffer = new Float32Array(GL.MINI_TEMP_BUFFER_SIZE);
            for (var i2 = 0; i2 < GL.MINI_TEMP_BUFFER_SIZE; i2++) {
              GL.miniTempBufferViews[i2] = GL.miniTempBuffer.subarray(0, i2 + 1);
            }
          }, recordError: function recordError(errorCode) {
            if (!GL.lastError) {
              GL.lastError = errorCode;
            }
          }, getNewId: function(table) {
            var ret = GL.counter++;
            for (var i2 = table.length; i2 < ret; i2++) {
              table[i2] = null;
            }
            return ret;
          }, MINI_TEMP_BUFFER_SIZE: 256, miniTempBuffer: null, miniTempBufferViews: [0], getSource: function(shader, count, string, length) {
            var source = "";
            for (var i2 = 0; i2 < count; ++i2) {
              var len = length ? HEAP32[length + i2 * 4 >> 2] : -1;
              source += UTF8ToString(HEAP32[string + i2 * 4 >> 2], len < 0 ? void 0 : len);
            }
            return source;
          }, createContext: function(canvas, webGLContextAttributes) {
            if (Module2["preinitializedWebGLContext"]) {
              var ctx = Module2["preinitializedWebGLContext"];
              webGLContextAttributes.majorVersion = 1;
            } else {
              var ctx = canvas.getContext("webgl", webGLContextAttributes) || canvas.getContext("experimental-webgl", webGLContextAttributes);
            }
            return ctx ? GL.registerContext(ctx, webGLContextAttributes) : 0;
          }, registerContext: function(ctx, webGLContextAttributes) {
            var handle = _malloc(8);
            var context = { handle, attributes: webGLContextAttributes, version: webGLContextAttributes.majorVersion, GLctx: ctx };
            if (ctx.canvas) ctx.canvas.GLctxObject = context;
            GL.contexts[handle] = context;
            if (typeof webGLContextAttributes.enableExtensionsByDefault === "undefined" || webGLContextAttributes.enableExtensionsByDefault) {
              GL.initExtensions(context);
            }
            return handle;
          }, makeContextCurrent: function(contextHandle) {
            GL.currentContext = GL.contexts[contextHandle];
            Module2.ctx = GLctx = GL.currentContext && GL.currentContext.GLctx;
            return !(contextHandle && !GLctx);
          }, getContext: function(contextHandle) {
            return GL.contexts[contextHandle];
          }, deleteContext: function(contextHandle) {
            if (GL.currentContext === GL.contexts[contextHandle]) GL.currentContext = null;
            if (typeof JSEvents === "object") JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);
            if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas) GL.contexts[contextHandle].GLctx.canvas.GLctxObject = void 0;
            _free(GL.contexts[contextHandle]);
            GL.contexts[contextHandle] = null;
          }, acquireInstancedArraysExtension: function(ctx) {
            var ext = ctx.getExtension("ANGLE_instanced_arrays");
            if (ext) {
              ctx["vertexAttribDivisor"] = function(index, divisor) {
                ext["vertexAttribDivisorANGLE"](index, divisor);
              };
              ctx["drawArraysInstanced"] = function(mode, first, count, primcount) {
                ext["drawArraysInstancedANGLE"](mode, first, count, primcount);
              };
              ctx["drawElementsInstanced"] = function(mode, count, type, indices, primcount) {
                ext["drawElementsInstancedANGLE"](mode, count, type, indices, primcount);
              };
            }
          }, acquireVertexArrayObjectExtension: function(ctx) {
            var ext = ctx.getExtension("OES_vertex_array_object");
            if (ext) {
              ctx["createVertexArray"] = function() {
                return ext["createVertexArrayOES"]();
              };
              ctx["deleteVertexArray"] = function(vao) {
                ext["deleteVertexArrayOES"](vao);
              };
              ctx["bindVertexArray"] = function(vao) {
                ext["bindVertexArrayOES"](vao);
              };
              ctx["isVertexArray"] = function(vao) {
                return ext["isVertexArrayOES"](vao);
              };
            }
          }, acquireDrawBuffersExtension: function(ctx) {
            var ext = ctx.getExtension("WEBGL_draw_buffers");
            if (ext) {
              ctx["drawBuffers"] = function(n, bufs) {
                ext["drawBuffersWEBGL"](n, bufs);
              };
            }
          }, initExtensions: function(context) {
            if (!context) context = GL.currentContext;
            if (context.initExtensionsDone) return;
            context.initExtensionsDone = true;
            var GLctx2 = context.GLctx;
            if (context.version < 2) {
              GL.acquireInstancedArraysExtension(GLctx2);
              GL.acquireVertexArrayObjectExtension(GLctx2);
              GL.acquireDrawBuffersExtension(GLctx2);
            }
            GLctx2.disjointTimerQueryExt = GLctx2.getExtension("EXT_disjoint_timer_query");
            var automaticallyEnabledExtensions = ["OES_texture_float", "OES_texture_half_float", "OES_standard_derivatives", "OES_vertex_array_object", "WEBGL_compressed_texture_s3tc", "WEBGL_depth_texture", "OES_element_index_uint", "EXT_texture_filter_anisotropic", "EXT_frag_depth", "WEBGL_draw_buffers", "ANGLE_instanced_arrays", "OES_texture_float_linear", "OES_texture_half_float_linear", "EXT_blend_minmax", "EXT_shader_texture_lod", "WEBGL_compressed_texture_pvrtc", "EXT_color_buffer_half_float", "WEBGL_color_buffer_float", "EXT_sRGB", "WEBGL_compressed_texture_etc1", "EXT_disjoint_timer_query", "WEBGL_compressed_texture_etc", "WEBGL_compressed_texture_astc", "EXT_color_buffer_float", "WEBGL_compressed_texture_s3tc_srgb", "EXT_disjoint_timer_query_webgl2"];
            var exts = GLctx2.getSupportedExtensions() || [];
            exts.forEach(function(ext) {
              if (automaticallyEnabledExtensions.indexOf(ext) != -1) {
                GLctx2.getExtension(ext);
              }
            });
          }, populateUniformTable: function(program) {
            var p = GL.programs[program];
            var ptable = GL.programInfos[program] = { uniforms: {}, maxUniformLength: 0, maxAttributeLength: -1, maxUniformBlockNameLength: -1 };
            var utable = ptable.uniforms;
            var numUniforms = GLctx.getProgramParameter(p, 35718);
            for (var i2 = 0; i2 < numUniforms; ++i2) {
              var u = GLctx.getActiveUniform(p, i2);
              var name = u.name;
              ptable.maxUniformLength = Math.max(ptable.maxUniformLength, name.length + 1);
              if (name.slice(-1) == "]") {
                name = name.slice(0, name.lastIndexOf("["));
              }
              var loc = GLctx.getUniformLocation(p, name);
              if (loc) {
                var id = GL.getNewId(GL.uniforms);
                utable[name] = [u.size, id];
                GL.uniforms[id] = loc;
                for (var j = 1; j < u.size; ++j) {
                  var n = name + "[" + j + "]";
                  loc = GLctx.getUniformLocation(p, n);
                  id = GL.getNewId(GL.uniforms);
                  GL.uniforms[id] = loc;
                }
              }
            }
          } };
          function _emscripten_glActiveTexture(x0) {
            GLctx["activeTexture"](x0);
          }
          function _emscripten_glAttachShader(program, shader) {
            GLctx.attachShader(GL.programs[program], GL.shaders[shader]);
          }
          function _emscripten_glBeginQueryEXT(target, id) {
            GLctx.disjointTimerQueryExt["beginQueryEXT"](target, GL.timerQueriesEXT[id]);
          }
          function _emscripten_glBindAttribLocation(program, index, name) {
            GLctx.bindAttribLocation(GL.programs[program], index, UTF8ToString(name));
          }
          function _emscripten_glBindBuffer(target, buffer2) {
            GLctx.bindBuffer(target, GL.buffers[buffer2]);
          }
          function _emscripten_glBindFramebuffer(target, framebuffer) {
            GLctx.bindFramebuffer(target, GL.framebuffers[framebuffer]);
          }
          function _emscripten_glBindRenderbuffer(target, renderbuffer) {
            GLctx.bindRenderbuffer(target, GL.renderbuffers[renderbuffer]);
          }
          function _emscripten_glBindTexture(target, texture) {
            GLctx.bindTexture(target, GL.textures[texture]);
          }
          function _emscripten_glBindVertexArrayOES(vao) {
            GLctx["bindVertexArray"](GL.vaos[vao]);
          }
          function _emscripten_glBlendColor(x0, x1, x2, x3) {
            GLctx["blendColor"](x0, x1, x2, x3);
          }
          function _emscripten_glBlendEquation(x0) {
            GLctx["blendEquation"](x0);
          }
          function _emscripten_glBlendEquationSeparate(x0, x1) {
            GLctx["blendEquationSeparate"](x0, x1);
          }
          function _emscripten_glBlendFunc(x0, x1) {
            GLctx["blendFunc"](x0, x1);
          }
          function _emscripten_glBlendFuncSeparate(x0, x1, x2, x3) {
            GLctx["blendFuncSeparate"](x0, x1, x2, x3);
          }
          function _emscripten_glBufferData(target, size, data, usage) {
            GLctx.bufferData(target, data ? HEAPU8.subarray(data, data + size) : size, usage);
          }
          function _emscripten_glBufferSubData(target, offset, size, data) {
            GLctx.bufferSubData(target, offset, HEAPU8.subarray(data, data + size));
          }
          function _emscripten_glCheckFramebufferStatus(x0) {
            return GLctx["checkFramebufferStatus"](x0);
          }
          function _emscripten_glClear(x0) {
            GLctx["clear"](x0);
          }
          function _emscripten_glClearColor(x0, x1, x2, x3) {
            GLctx["clearColor"](x0, x1, x2, x3);
          }
          function _emscripten_glClearDepthf(x0) {
            GLctx["clearDepth"](x0);
          }
          function _emscripten_glClearStencil(x0) {
            GLctx["clearStencil"](x0);
          }
          function _emscripten_glColorMask(red, green, blue, alpha) {
            GLctx.colorMask(!!red, !!green, !!blue, !!alpha);
          }
          function _emscripten_glCompileShader(shader) {
            GLctx.compileShader(GL.shaders[shader]);
          }
          function _emscripten_glCompressedTexImage2D(target, level, internalFormat, width, height, border, imageSize, data) {
            GLctx["compressedTexImage2D"](target, level, internalFormat, width, height, border, data ? HEAPU8.subarray(data, data + imageSize) : null);
          }
          function _emscripten_glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data) {
            GLctx["compressedTexSubImage2D"](target, level, xoffset, yoffset, width, height, format, data ? HEAPU8.subarray(data, data + imageSize) : null);
          }
          function _emscripten_glCopyTexImage2D(x0, x1, x2, x3, x4, x5, x6, x7) {
            GLctx["copyTexImage2D"](x0, x1, x2, x3, x4, x5, x6, x7);
          }
          function _emscripten_glCopyTexSubImage2D(x0, x1, x2, x3, x4, x5, x6, x7) {
            GLctx["copyTexSubImage2D"](x0, x1, x2, x3, x4, x5, x6, x7);
          }
          function _emscripten_glCreateProgram() {
            var id = GL.getNewId(GL.programs);
            var program = GLctx.createProgram();
            program.name = id;
            GL.programs[id] = program;
            return id;
          }
          function _emscripten_glCreateShader(shaderType) {
            var id = GL.getNewId(GL.shaders);
            GL.shaders[id] = GLctx.createShader(shaderType);
            return id;
          }
          function _emscripten_glCullFace(x0) {
            GLctx["cullFace"](x0);
          }
          function _emscripten_glDeleteBuffers(n, buffers) {
            for (var i2 = 0; i2 < n; i2++) {
              var id = HEAP32[buffers + i2 * 4 >> 2];
              var buffer2 = GL.buffers[id];
              if (!buffer2) continue;
              GLctx.deleteBuffer(buffer2);
              buffer2.name = 0;
              GL.buffers[id] = null;
              if (id == GL.currArrayBuffer) GL.currArrayBuffer = 0;
              if (id == GL.currElementArrayBuffer) GL.currElementArrayBuffer = 0;
            }
          }
          function _emscripten_glDeleteFramebuffers(n, framebuffers) {
            for (var i2 = 0; i2 < n; ++i2) {
              var id = HEAP32[framebuffers + i2 * 4 >> 2];
              var framebuffer = GL.framebuffers[id];
              if (!framebuffer) continue;
              GLctx.deleteFramebuffer(framebuffer);
              framebuffer.name = 0;
              GL.framebuffers[id] = null;
            }
          }
          function _emscripten_glDeleteProgram(id) {
            if (!id) return;
            var program = GL.programs[id];
            if (!program) {
              GL.recordError(1281);
              return;
            }
            GLctx.deleteProgram(program);
            program.name = 0;
            GL.programs[id] = null;
            GL.programInfos[id] = null;
          }
          function _emscripten_glDeleteQueriesEXT(n, ids) {
            for (var i2 = 0; i2 < n; i2++) {
              var id = HEAP32[ids + i2 * 4 >> 2];
              var query = GL.timerQueriesEXT[id];
              if (!query) continue;
              GLctx.disjointTimerQueryExt["deleteQueryEXT"](query);
              GL.timerQueriesEXT[id] = null;
            }
          }
          function _emscripten_glDeleteRenderbuffers(n, renderbuffers) {
            for (var i2 = 0; i2 < n; i2++) {
              var id = HEAP32[renderbuffers + i2 * 4 >> 2];
              var renderbuffer = GL.renderbuffers[id];
              if (!renderbuffer) continue;
              GLctx.deleteRenderbuffer(renderbuffer);
              renderbuffer.name = 0;
              GL.renderbuffers[id] = null;
            }
          }
          function _emscripten_glDeleteShader(id) {
            if (!id) return;
            var shader = GL.shaders[id];
            if (!shader) {
              GL.recordError(1281);
              return;
            }
            GLctx.deleteShader(shader);
            GL.shaders[id] = null;
          }
          function _emscripten_glDeleteTextures(n, textures) {
            for (var i2 = 0; i2 < n; i2++) {
              var id = HEAP32[textures + i2 * 4 >> 2];
              var texture = GL.textures[id];
              if (!texture) continue;
              GLctx.deleteTexture(texture);
              texture.name = 0;
              GL.textures[id] = null;
            }
          }
          function _emscripten_glDeleteVertexArraysOES(n, vaos) {
            for (var i2 = 0; i2 < n; i2++) {
              var id = HEAP32[vaos + i2 * 4 >> 2];
              GLctx["deleteVertexArray"](GL.vaos[id]);
              GL.vaos[id] = null;
            }
          }
          function _emscripten_glDepthFunc(x0) {
            GLctx["depthFunc"](x0);
          }
          function _emscripten_glDepthMask(flag) {
            GLctx.depthMask(!!flag);
          }
          function _emscripten_glDepthRangef(x0, x1) {
            GLctx["depthRange"](x0, x1);
          }
          function _emscripten_glDetachShader(program, shader) {
            GLctx.detachShader(GL.programs[program], GL.shaders[shader]);
          }
          function _emscripten_glDisable(x0) {
            GLctx["disable"](x0);
          }
          function _emscripten_glDisableVertexAttribArray(index) {
            GLctx.disableVertexAttribArray(index);
          }
          function _emscripten_glDrawArrays(mode, first, count) {
            GLctx.drawArrays(mode, first, count);
          }
          function _emscripten_glDrawArraysInstancedANGLE(mode, first, count, primcount) {
            GLctx["drawArraysInstanced"](mode, first, count, primcount);
          }
          var __tempFixedLengthArray = [];
          function _emscripten_glDrawBuffersWEBGL(n, bufs) {
            var bufArray = __tempFixedLengthArray[n];
            for (var i2 = 0; i2 < n; i2++) {
              bufArray[i2] = HEAP32[bufs + i2 * 4 >> 2];
            }
            GLctx["drawBuffers"](bufArray);
          }
          function _emscripten_glDrawElements(mode, count, type, indices) {
            GLctx.drawElements(mode, count, type, indices);
          }
          function _emscripten_glDrawElementsInstancedANGLE(mode, count, type, indices, primcount) {
            GLctx["drawElementsInstanced"](mode, count, type, indices, primcount);
          }
          function _emscripten_glEnable(x0) {
            GLctx["enable"](x0);
          }
          function _emscripten_glEnableVertexAttribArray(index) {
            GLctx.enableVertexAttribArray(index);
          }
          function _emscripten_glEndQueryEXT(target) {
            GLctx.disjointTimerQueryExt["endQueryEXT"](target);
          }
          function _emscripten_glFinish() {
            GLctx["finish"]();
          }
          function _emscripten_glFlush() {
            GLctx["flush"]();
          }
          function _emscripten_glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer) {
            GLctx.framebufferRenderbuffer(target, attachment, renderbuffertarget, GL.renderbuffers[renderbuffer]);
          }
          function _emscripten_glFramebufferTexture2D(target, attachment, textarget, texture, level) {
            GLctx.framebufferTexture2D(target, attachment, textarget, GL.textures[texture], level);
          }
          function _emscripten_glFrontFace(x0) {
            GLctx["frontFace"](x0);
          }
          function __glGenObject(n, buffers, createFunction, objectTable) {
            for (var i2 = 0; i2 < n; i2++) {
              var buffer2 = GLctx[createFunction]();
              var id = buffer2 && GL.getNewId(objectTable);
              if (buffer2) {
                buffer2.name = id;
                objectTable[id] = buffer2;
              } else {
                GL.recordError(1282);
              }
              HEAP32[buffers + i2 * 4 >> 2] = id;
            }
          }
          function _emscripten_glGenBuffers(n, buffers) {
            __glGenObject(n, buffers, "createBuffer", GL.buffers);
          }
          function _emscripten_glGenFramebuffers(n, ids) {
            __glGenObject(n, ids, "createFramebuffer", GL.framebuffers);
          }
          function _emscripten_glGenQueriesEXT(n, ids) {
            for (var i2 = 0; i2 < n; i2++) {
              var query = GLctx.disjointTimerQueryExt["createQueryEXT"]();
              if (!query) {
                GL.recordError(1282);
                while (i2 < n) HEAP32[ids + i2++ * 4 >> 2] = 0;
                return;
              }
              var id = GL.getNewId(GL.timerQueriesEXT);
              query.name = id;
              GL.timerQueriesEXT[id] = query;
              HEAP32[ids + i2 * 4 >> 2] = id;
            }
          }
          function _emscripten_glGenRenderbuffers(n, renderbuffers) {
            __glGenObject(n, renderbuffers, "createRenderbuffer", GL.renderbuffers);
          }
          function _emscripten_glGenTextures(n, textures) {
            __glGenObject(n, textures, "createTexture", GL.textures);
          }
          function _emscripten_glGenVertexArraysOES(n, arrays) {
            __glGenObject(n, arrays, "createVertexArray", GL.vaos);
          }
          function _emscripten_glGenerateMipmap(x0) {
            GLctx["generateMipmap"](x0);
          }
          function _emscripten_glGetActiveAttrib(program, index, bufSize, length, size, type, name) {
            program = GL.programs[program];
            var info = GLctx.getActiveAttrib(program, index);
            if (!info) return;
            var numBytesWrittenExclNull = bufSize > 0 && name ? stringToUTF8(info.name, name, bufSize) : 0;
            if (length) HEAP32[length >> 2] = numBytesWrittenExclNull;
            if (size) HEAP32[size >> 2] = info.size;
            if (type) HEAP32[type >> 2] = info.type;
          }
          function _emscripten_glGetActiveUniform(program, index, bufSize, length, size, type, name) {
            program = GL.programs[program];
            var info = GLctx.getActiveUniform(program, index);
            if (!info) return;
            var numBytesWrittenExclNull = bufSize > 0 && name ? stringToUTF8(info.name, name, bufSize) : 0;
            if (length) HEAP32[length >> 2] = numBytesWrittenExclNull;
            if (size) HEAP32[size >> 2] = info.size;
            if (type) HEAP32[type >> 2] = info.type;
          }
          function _emscripten_glGetAttachedShaders(program, maxCount, count, shaders) {
            var result = GLctx.getAttachedShaders(GL.programs[program]);
            var len = result.length;
            if (len > maxCount) {
              len = maxCount;
            }
            HEAP32[count >> 2] = len;
            for (var i2 = 0; i2 < len; ++i2) {
              var id = GL.shaders.indexOf(result[i2]);
              HEAP32[shaders + i2 * 4 >> 2] = id;
            }
          }
          function _emscripten_glGetAttribLocation(program, name) {
            return GLctx.getAttribLocation(GL.programs[program], UTF8ToString(name));
          }
          function emscriptenWebGLGet(name_, p, type) {
            if (!p) {
              GL.recordError(1281);
              return;
            }
            var ret = void 0;
            switch (name_) {
              case 36346:
                ret = 1;
                break;
              case 36344:
                if (type != 0 && type != 1) {
                  GL.recordError(1280);
                }
                return;
              case 36345:
                ret = 0;
                break;
              case 34466:
                var formats = GLctx.getParameter(34467);
                ret = formats ? formats.length : 0;
                break;
            }
            if (ret === void 0) {
              var result = GLctx.getParameter(name_);
              switch (typeof result) {
                case "number":
                  ret = result;
                  break;
                case "boolean":
                  ret = result ? 1 : 0;
                  break;
                case "string":
                  GL.recordError(1280);
                  return;
                case "object":
                  if (result === null) {
                    switch (name_) {
                      case 34964:
                      case 35725:
                      case 34965:
                      case 36006:
                      case 36007:
                      case 32873:
                      case 34229:
                      case 34068: {
                        ret = 0;
                        break;
                      }
                      default: {
                        GL.recordError(1280);
                        return;
                      }
                    }
                  } else if (result instanceof Float32Array || result instanceof Uint32Array || result instanceof Int32Array || result instanceof Array) {
                    for (var i2 = 0; i2 < result.length; ++i2) {
                      switch (type) {
                        case 0:
                          HEAP32[p + i2 * 4 >> 2] = result[i2];
                          break;
                        case 2:
                          HEAPF32[p + i2 * 4 >> 2] = result[i2];
                          break;
                        case 4:
                          HEAP8[p + i2 >> 0] = result[i2] ? 1 : 0;
                          break;
                      }
                    }
                    return;
                  } else {
                    try {
                      ret = result.name | 0;
                    } catch (e) {
                      GL.recordError(1280);
                      err("GL_INVALID_ENUM in glGet" + type + "v: Unknown object returned from WebGL getParameter(" + name_ + ")! (error: " + e + ")");
                      return;
                    }
                  }
                  break;
                default:
                  GL.recordError(1280);
                  err("GL_INVALID_ENUM in glGet" + type + "v: Native code calling glGet" + type + "v(" + name_ + ") and it returns " + result + " of type " + typeof result + "!");
                  return;
              }
            }
            switch (type) {
              case 1:
                tempI64 = [ret >>> 0, (tempDouble = ret, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[p >> 2] = tempI64[0], HEAP32[p + 4 >> 2] = tempI64[1];
                break;
              case 0:
                HEAP32[p >> 2] = ret;
                break;
              case 2:
                HEAPF32[p >> 2] = ret;
                break;
              case 4:
                HEAP8[p >> 0] = ret ? 1 : 0;
                break;
            }
          }
          function _emscripten_glGetBooleanv(name_, p) {
            emscriptenWebGLGet(name_, p, 4);
          }
          function _emscripten_glGetBufferParameteriv(target, value, data) {
            if (!data) {
              GL.recordError(1281);
              return;
            }
            HEAP32[data >> 2] = GLctx.getBufferParameter(target, value);
          }
          function _emscripten_glGetError() {
            var error = GLctx.getError() || GL.lastError;
            GL.lastError = 0;
            return error;
          }
          function _emscripten_glGetFloatv(name_, p) {
            emscriptenWebGLGet(name_, p, 2);
          }
          function _emscripten_glGetFramebufferAttachmentParameteriv(target, attachment, pname, params) {
            var result = GLctx.getFramebufferAttachmentParameter(target, attachment, pname);
            if (result instanceof WebGLRenderbuffer || result instanceof WebGLTexture) {
              result = result.name | 0;
            }
            HEAP32[params >> 2] = result;
          }
          function _emscripten_glGetIntegerv(name_, p) {
            emscriptenWebGLGet(name_, p, 0);
          }
          function _emscripten_glGetProgramInfoLog(program, maxLength, length, infoLog) {
            var log = GLctx.getProgramInfoLog(GL.programs[program]);
            if (log === null) log = "(unknown error)";
            var numBytesWrittenExclNull = maxLength > 0 && infoLog ? stringToUTF8(log, infoLog, maxLength) : 0;
            if (length) HEAP32[length >> 2] = numBytesWrittenExclNull;
          }
          function _emscripten_glGetProgramiv(program, pname, p) {
            if (!p) {
              GL.recordError(1281);
              return;
            }
            if (program >= GL.counter) {
              GL.recordError(1281);
              return;
            }
            var ptable = GL.programInfos[program];
            if (!ptable) {
              GL.recordError(1282);
              return;
            }
            if (pname == 35716) {
              var log = GLctx.getProgramInfoLog(GL.programs[program]);
              if (log === null) log = "(unknown error)";
              HEAP32[p >> 2] = log.length + 1;
            } else if (pname == 35719) {
              HEAP32[p >> 2] = ptable.maxUniformLength;
            } else if (pname == 35722) {
              if (ptable.maxAttributeLength == -1) {
                program = GL.programs[program];
                var numAttribs = GLctx.getProgramParameter(program, 35721);
                ptable.maxAttributeLength = 0;
                for (var i2 = 0; i2 < numAttribs; ++i2) {
                  var activeAttrib = GLctx.getActiveAttrib(program, i2);
                  ptable.maxAttributeLength = Math.max(ptable.maxAttributeLength, activeAttrib.name.length + 1);
                }
              }
              HEAP32[p >> 2] = ptable.maxAttributeLength;
            } else if (pname == 35381) {
              if (ptable.maxUniformBlockNameLength == -1) {
                program = GL.programs[program];
                var numBlocks = GLctx.getProgramParameter(program, 35382);
                ptable.maxUniformBlockNameLength = 0;
                for (var i2 = 0; i2 < numBlocks; ++i2) {
                  var activeBlockName = GLctx.getActiveUniformBlockName(program, i2);
                  ptable.maxUniformBlockNameLength = Math.max(ptable.maxUniformBlockNameLength, activeBlockName.length + 1);
                }
              }
              HEAP32[p >> 2] = ptable.maxUniformBlockNameLength;
            } else {
              HEAP32[p >> 2] = GLctx.getProgramParameter(GL.programs[program], pname);
            }
          }
          function _emscripten_glGetQueryObjecti64vEXT(id, pname, params) {
            if (!params) {
              GL.recordError(1281);
              return;
            }
            var query = GL.timerQueriesEXT[id];
            var param = GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query, pname);
            var ret;
            if (typeof param == "boolean") {
              ret = param ? 1 : 0;
            } else {
              ret = param;
            }
            tempI64 = [ret >>> 0, (tempDouble = ret, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[params >> 2] = tempI64[0], HEAP32[params + 4 >> 2] = tempI64[1];
          }
          function _emscripten_glGetQueryObjectivEXT(id, pname, params) {
            if (!params) {
              GL.recordError(1281);
              return;
            }
            var query = GL.timerQueriesEXT[id];
            var param = GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query, pname);
            var ret;
            if (typeof param == "boolean") {
              ret = param ? 1 : 0;
            } else {
              ret = param;
            }
            HEAP32[params >> 2] = ret;
          }
          function _emscripten_glGetQueryObjectui64vEXT(id, pname, params) {
            if (!params) {
              GL.recordError(1281);
              return;
            }
            var query = GL.timerQueriesEXT[id];
            var param = GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query, pname);
            var ret;
            if (typeof param == "boolean") {
              ret = param ? 1 : 0;
            } else {
              ret = param;
            }
            tempI64 = [ret >>> 0, (tempDouble = ret, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[params >> 2] = tempI64[0], HEAP32[params + 4 >> 2] = tempI64[1];
          }
          function _emscripten_glGetQueryObjectuivEXT(id, pname, params) {
            if (!params) {
              GL.recordError(1281);
              return;
            }
            var query = GL.timerQueriesEXT[id];
            var param = GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query, pname);
            var ret;
            if (typeof param == "boolean") {
              ret = param ? 1 : 0;
            } else {
              ret = param;
            }
            HEAP32[params >> 2] = ret;
          }
          function _emscripten_glGetQueryivEXT(target, pname, params) {
            if (!params) {
              GL.recordError(1281);
              return;
            }
            HEAP32[params >> 2] = GLctx.disjointTimerQueryExt["getQueryEXT"](target, pname);
          }
          function _emscripten_glGetRenderbufferParameteriv(target, pname, params) {
            if (!params) {
              GL.recordError(1281);
              return;
            }
            HEAP32[params >> 2] = GLctx.getRenderbufferParameter(target, pname);
          }
          function _emscripten_glGetShaderInfoLog(shader, maxLength, length, infoLog) {
            var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
            if (log === null) log = "(unknown error)";
            var numBytesWrittenExclNull = maxLength > 0 && infoLog ? stringToUTF8(log, infoLog, maxLength) : 0;
            if (length) HEAP32[length >> 2] = numBytesWrittenExclNull;
          }
          function _emscripten_glGetShaderPrecisionFormat(shaderType, precisionType, range2, precision) {
            var result = GLctx.getShaderPrecisionFormat(shaderType, precisionType);
            HEAP32[range2 >> 2] = result.rangeMin;
            HEAP32[range2 + 4 >> 2] = result.rangeMax;
            HEAP32[precision >> 2] = result.precision;
          }
          function _emscripten_glGetShaderSource(shader, bufSize, length, source) {
            var result = GLctx.getShaderSource(GL.shaders[shader]);
            if (!result) return;
            var numBytesWrittenExclNull = bufSize > 0 && source ? stringToUTF8(result, source, bufSize) : 0;
            if (length) HEAP32[length >> 2] = numBytesWrittenExclNull;
          }
          function _emscripten_glGetShaderiv(shader, pname, p) {
            if (!p) {
              GL.recordError(1281);
              return;
            }
            if (pname == 35716) {
              var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
              if (log === null) log = "(unknown error)";
              HEAP32[p >> 2] = log.length + 1;
            } else if (pname == 35720) {
              var source = GLctx.getShaderSource(GL.shaders[shader]);
              var sourceLength = source === null || source.length == 0 ? 0 : source.length + 1;
              HEAP32[p >> 2] = sourceLength;
            } else {
              HEAP32[p >> 2] = GLctx.getShaderParameter(GL.shaders[shader], pname);
            }
          }
          function stringToNewUTF8(jsString) {
            var length = lengthBytesUTF8(jsString) + 1;
            var cString = _malloc(length);
            stringToUTF8(jsString, cString, length);
            return cString;
          }
          function _emscripten_glGetString(name_) {
            if (GL.stringCache[name_]) return GL.stringCache[name_];
            var ret;
            switch (name_) {
              case 7939:
                var exts = GLctx.getSupportedExtensions() || [];
                exts = exts.concat(exts.map(function(e) {
                  return "GL_" + e;
                }));
                ret = stringToNewUTF8(exts.join(" "));
                break;
              case 7936:
              case 7937:
              case 37445:
              case 37446:
                var s = GLctx.getParameter(name_);
                if (!s) {
                  GL.recordError(1280);
                }
                ret = stringToNewUTF8(s);
                break;
              case 7938:
                var glVersion = GLctx.getParameter(GLctx.VERSION);
                {
                  glVersion = "OpenGL ES 2.0 (" + glVersion + ")";
                }
                ret = stringToNewUTF8(glVersion);
                break;
              case 35724:
                var glslVersion = GLctx.getParameter(GLctx.SHADING_LANGUAGE_VERSION);
                var ver_re = /^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/;
                var ver_num = glslVersion.match(ver_re);
                if (ver_num !== null) {
                  if (ver_num[1].length == 3) ver_num[1] = ver_num[1] + "0";
                  glslVersion = "OpenGL ES GLSL ES " + ver_num[1] + " (" + glslVersion + ")";
                }
                ret = stringToNewUTF8(glslVersion);
                break;
              default:
                GL.recordError(1280);
                return 0;
            }
            GL.stringCache[name_] = ret;
            return ret;
          }
          function _emscripten_glGetTexParameterfv(target, pname, params) {
            if (!params) {
              GL.recordError(1281);
              return;
            }
            HEAPF32[params >> 2] = GLctx.getTexParameter(target, pname);
          }
          function _emscripten_glGetTexParameteriv(target, pname, params) {
            if (!params) {
              GL.recordError(1281);
              return;
            }
            HEAP32[params >> 2] = GLctx.getTexParameter(target, pname);
          }
          function _emscripten_glGetUniformLocation(program, name) {
            name = UTF8ToString(name);
            var arrayIndex = 0;
            if (name[name.length - 1] == "]") {
              var leftBrace = name.lastIndexOf("[");
              arrayIndex = name[leftBrace + 1] != "]" ? parseInt(name.slice(leftBrace + 1)) : 0;
              name = name.slice(0, leftBrace);
            }
            var uniformInfo = GL.programInfos[program] && GL.programInfos[program].uniforms[name];
            if (uniformInfo && arrayIndex >= 0 && arrayIndex < uniformInfo[0]) {
              return uniformInfo[1] + arrayIndex;
            } else {
              return -1;
            }
          }
          function emscriptenWebGLGetUniform(program, location, params, type) {
            if (!params) {
              GL.recordError(1281);
              return;
            }
            var data = GLctx.getUniform(GL.programs[program], GL.uniforms[location]);
            if (typeof data == "number" || typeof data == "boolean") {
              switch (type) {
                case 0:
                  HEAP32[params >> 2] = data;
                  break;
                case 2:
                  HEAPF32[params >> 2] = data;
                  break;
                default:
                  throw "internal emscriptenWebGLGetUniform() error, bad type: " + type;
              }
            } else {
              for (var i2 = 0; i2 < data.length; i2++) {
                switch (type) {
                  case 0:
                    HEAP32[params + i2 * 4 >> 2] = data[i2];
                    break;
                  case 2:
                    HEAPF32[params + i2 * 4 >> 2] = data[i2];
                    break;
                  default:
                    throw "internal emscriptenWebGLGetUniform() error, bad type: " + type;
                }
              }
            }
          }
          function _emscripten_glGetUniformfv(program, location, params) {
            emscriptenWebGLGetUniform(program, location, params, 2);
          }
          function _emscripten_glGetUniformiv(program, location, params) {
            emscriptenWebGLGetUniform(program, location, params, 0);
          }
          function _emscripten_glGetVertexAttribPointerv(index, pname, pointer) {
            if (!pointer) {
              GL.recordError(1281);
              return;
            }
            HEAP32[pointer >> 2] = GLctx.getVertexAttribOffset(index, pname);
          }
          function emscriptenWebGLGetVertexAttrib(index, pname, params, type) {
            if (!params) {
              GL.recordError(1281);
              return;
            }
            var data = GLctx.getVertexAttrib(index, pname);
            if (pname == 34975) {
              HEAP32[params >> 2] = data["name"];
            } else if (typeof data == "number" || typeof data == "boolean") {
              switch (type) {
                case 0:
                  HEAP32[params >> 2] = data;
                  break;
                case 2:
                  HEAPF32[params >> 2] = data;
                  break;
                case 5:
                  HEAP32[params >> 2] = Math.fround(data);
                  break;
                default:
                  throw "internal emscriptenWebGLGetVertexAttrib() error, bad type: " + type;
              }
            } else {
              for (var i2 = 0; i2 < data.length; i2++) {
                switch (type) {
                  case 0:
                    HEAP32[params + i2 * 4 >> 2] = data[i2];
                    break;
                  case 2:
                    HEAPF32[params + i2 * 4 >> 2] = data[i2];
                    break;
                  case 5:
                    HEAP32[params + i2 * 4 >> 2] = Math.fround(data[i2]);
                    break;
                  default:
                    throw "internal emscriptenWebGLGetVertexAttrib() error, bad type: " + type;
                }
              }
            }
          }
          function _emscripten_glGetVertexAttribfv(index, pname, params) {
            emscriptenWebGLGetVertexAttrib(index, pname, params, 2);
          }
          function _emscripten_glGetVertexAttribiv(index, pname, params) {
            emscriptenWebGLGetVertexAttrib(index, pname, params, 5);
          }
          function _emscripten_glHint(x0, x1) {
            GLctx["hint"](x0, x1);
          }
          function _emscripten_glIsBuffer(buffer2) {
            var b = GL.buffers[buffer2];
            if (!b) return 0;
            return GLctx.isBuffer(b);
          }
          function _emscripten_glIsEnabled(x0) {
            return GLctx["isEnabled"](x0);
          }
          function _emscripten_glIsFramebuffer(framebuffer) {
            var fb = GL.framebuffers[framebuffer];
            if (!fb) return 0;
            return GLctx.isFramebuffer(fb);
          }
          function _emscripten_glIsProgram(program) {
            program = GL.programs[program];
            if (!program) return 0;
            return GLctx.isProgram(program);
          }
          function _emscripten_glIsQueryEXT(id) {
            var query = GL.timerQueriesEXT[id];
            if (!query) return 0;
            return GLctx.disjointTimerQueryExt["isQueryEXT"](query);
          }
          function _emscripten_glIsRenderbuffer(renderbuffer) {
            var rb = GL.renderbuffers[renderbuffer];
            if (!rb) return 0;
            return GLctx.isRenderbuffer(rb);
          }
          function _emscripten_glIsShader(shader) {
            var s = GL.shaders[shader];
            if (!s) return 0;
            return GLctx.isShader(s);
          }
          function _emscripten_glIsTexture(id) {
            var texture = GL.textures[id];
            if (!texture) return 0;
            return GLctx.isTexture(texture);
          }
          function _emscripten_glIsVertexArrayOES(array) {
            var vao = GL.vaos[array];
            if (!vao) return 0;
            return GLctx["isVertexArray"](vao);
          }
          function _emscripten_glLineWidth(x0) {
            GLctx["lineWidth"](x0);
          }
          function _emscripten_glLinkProgram(program) {
            GLctx.linkProgram(GL.programs[program]);
            GL.populateUniformTable(program);
          }
          function _emscripten_glPixelStorei(pname, param) {
            if (pname == 3317) {
              GL.unpackAlignment = param;
            }
            GLctx.pixelStorei(pname, param);
          }
          function _emscripten_glPolygonOffset(x0, x1) {
            GLctx["polygonOffset"](x0, x1);
          }
          function _emscripten_glQueryCounterEXT(id, target) {
            GLctx.disjointTimerQueryExt["queryCounterEXT"](GL.timerQueriesEXT[id], target);
          }
          function __computeUnpackAlignedImageSize(width, height, sizePerPixel, alignment) {
            function roundedToNextMultipleOf(x, y) {
              return x + y - 1 & -y;
            }
            var plainRowSize = width * sizePerPixel;
            var alignedRowSize = roundedToNextMultipleOf(plainRowSize, alignment);
            return height * alignedRowSize;
          }
          var __colorChannelsInGlTextureFormat = { 6402: 1, 6406: 1, 6407: 3, 6408: 4, 6409: 1, 6410: 2, 35904: 3, 35906: 4 };
          var __sizeOfGlTextureElementType = { 5121: 1, 5123: 2, 5125: 4, 5126: 4, 32819: 2, 32820: 2, 33635: 2, 34042: 4, 36193: 2 };
          function emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) {
            var sizePerPixel = __colorChannelsInGlTextureFormat[format] * __sizeOfGlTextureElementType[type];
            if (!sizePerPixel) {
              GL.recordError(1280);
              return;
            }
            var bytes = __computeUnpackAlignedImageSize(width, height, sizePerPixel, GL.unpackAlignment);
            var end = pixels + bytes;
            switch (type) {
              case 5121:
                return HEAPU8.subarray(pixels, end);
              case 5126:
                return HEAPF32.subarray(pixels >> 2, end >> 2);
              case 5125:
              case 34042:
                return HEAPU32.subarray(pixels >> 2, end >> 2);
              case 5123:
              case 33635:
              case 32819:
              case 32820:
              case 36193:
                return HEAPU16.subarray(pixels >> 1, end >> 1);
              default:
                GL.recordError(1280);
            }
          }
          function _emscripten_glReadPixels(x, y, width, height, format, type, pixels) {
            var pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, format);
            if (!pixelData) {
              GL.recordError(1280);
              return;
            }
            GLctx.readPixels(x, y, width, height, format, type, pixelData);
          }
          function _emscripten_glReleaseShaderCompiler() {
          }
          function _emscripten_glRenderbufferStorage(x0, x1, x2, x3) {
            GLctx["renderbufferStorage"](x0, x1, x2, x3);
          }
          function _emscripten_glSampleCoverage(value, invert) {
            GLctx.sampleCoverage(value, !!invert);
          }
          function _emscripten_glScissor(x0, x1, x2, x3) {
            GLctx["scissor"](x0, x1, x2, x3);
          }
          function _emscripten_glShaderBinary() {
            GL.recordError(1280);
          }
          function _emscripten_glShaderSource(shader, count, string, length) {
            var source = GL.getSource(shader, count, string, length);
            GLctx.shaderSource(GL.shaders[shader], source);
          }
          function _emscripten_glStencilFunc(x0, x1, x2) {
            GLctx["stencilFunc"](x0, x1, x2);
          }
          function _emscripten_glStencilFuncSeparate(x0, x1, x2, x3) {
            GLctx["stencilFuncSeparate"](x0, x1, x2, x3);
          }
          function _emscripten_glStencilMask(x0) {
            GLctx["stencilMask"](x0);
          }
          function _emscripten_glStencilMaskSeparate(x0, x1) {
            GLctx["stencilMaskSeparate"](x0, x1);
          }
          function _emscripten_glStencilOp(x0, x1, x2) {
            GLctx["stencilOp"](x0, x1, x2);
          }
          function _emscripten_glStencilOpSeparate(x0, x1, x2, x3) {
            GLctx["stencilOpSeparate"](x0, x1, x2, x3);
          }
          function _emscripten_glTexImage2D(target, level, internalFormat, width, height, border, format, type, pixels) {
            GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels ? emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) : null);
          }
          function _emscripten_glTexParameterf(x0, x1, x2) {
            GLctx["texParameterf"](x0, x1, x2);
          }
          function _emscripten_glTexParameterfv(target, pname, params) {
            var param = HEAPF32[params >> 2];
            GLctx.texParameterf(target, pname, param);
          }
          function _emscripten_glTexParameteri(x0, x1, x2) {
            GLctx["texParameteri"](x0, x1, x2);
          }
          function _emscripten_glTexParameteriv(target, pname, params) {
            var param = HEAP32[params >> 2];
            GLctx.texParameteri(target, pname, param);
          }
          function _emscripten_glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels) {
            var pixelData = null;
            if (pixels) pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, 0);
            GLctx.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixelData);
          }
          function _emscripten_glUniform1f(location, v0) {
            GLctx.uniform1f(GL.uniforms[location], v0);
          }
          function _emscripten_glUniform1fv(location, count, value) {
            if (count <= GL.MINI_TEMP_BUFFER_SIZE) {
              var view = GL.miniTempBufferViews[count - 1];
              for (var i2 = 0; i2 < count; ++i2) {
                view[i2] = HEAPF32[value + 4 * i2 >> 2];
              }
            } else {
              var view = HEAPF32.subarray(value >> 2, value + count * 4 >> 2);
            }
            GLctx.uniform1fv(GL.uniforms[location], view);
          }
          function _emscripten_glUniform1i(location, v0) {
            GLctx.uniform1i(GL.uniforms[location], v0);
          }
          function _emscripten_glUniform1iv(location, count, value) {
            GLctx.uniform1iv(GL.uniforms[location], HEAP32.subarray(value >> 2, value + count * 4 >> 2));
          }
          function _emscripten_glUniform2f(location, v0, v1) {
            GLctx.uniform2f(GL.uniforms[location], v0, v1);
          }
          function _emscripten_glUniform2fv(location, count, value) {
            if (2 * count <= GL.MINI_TEMP_BUFFER_SIZE) {
              var view = GL.miniTempBufferViews[2 * count - 1];
              for (var i2 = 0; i2 < 2 * count; i2 += 2) {
                view[i2] = HEAPF32[value + 4 * i2 >> 2];
                view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >> 2];
              }
            } else {
              var view = HEAPF32.subarray(value >> 2, value + count * 8 >> 2);
            }
            GLctx.uniform2fv(GL.uniforms[location], view);
          }
          function _emscripten_glUniform2i(location, v0, v1) {
            GLctx.uniform2i(GL.uniforms[location], v0, v1);
          }
          function _emscripten_glUniform2iv(location, count, value) {
            GLctx.uniform2iv(GL.uniforms[location], HEAP32.subarray(value >> 2, value + count * 8 >> 2));
          }
          function _emscripten_glUniform3f(location, v0, v1, v2) {
            GLctx.uniform3f(GL.uniforms[location], v0, v1, v2);
          }
          function _emscripten_glUniform3fv(location, count, value) {
            if (3 * count <= GL.MINI_TEMP_BUFFER_SIZE) {
              var view = GL.miniTempBufferViews[3 * count - 1];
              for (var i2 = 0; i2 < 3 * count; i2 += 3) {
                view[i2] = HEAPF32[value + 4 * i2 >> 2];
                view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >> 2];
                view[i2 + 2] = HEAPF32[value + (4 * i2 + 8) >> 2];
              }
            } else {
              var view = HEAPF32.subarray(value >> 2, value + count * 12 >> 2);
            }
            GLctx.uniform3fv(GL.uniforms[location], view);
          }
          function _emscripten_glUniform3i(location, v0, v1, v2) {
            GLctx.uniform3i(GL.uniforms[location], v0, v1, v2);
          }
          function _emscripten_glUniform3iv(location, count, value) {
            GLctx.uniform3iv(GL.uniforms[location], HEAP32.subarray(value >> 2, value + count * 12 >> 2));
          }
          function _emscripten_glUniform4f(location, v0, v1, v2, v3) {
            GLctx.uniform4f(GL.uniforms[location], v0, v1, v2, v3);
          }
          function _emscripten_glUniform4fv(location, count, value) {
            if (4 * count <= GL.MINI_TEMP_BUFFER_SIZE) {
              var view = GL.miniTempBufferViews[4 * count - 1];
              for (var i2 = 0; i2 < 4 * count; i2 += 4) {
                view[i2] = HEAPF32[value + 4 * i2 >> 2];
                view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >> 2];
                view[i2 + 2] = HEAPF32[value + (4 * i2 + 8) >> 2];
                view[i2 + 3] = HEAPF32[value + (4 * i2 + 12) >> 2];
              }
            } else {
              var view = HEAPF32.subarray(value >> 2, value + count * 16 >> 2);
            }
            GLctx.uniform4fv(GL.uniforms[location], view);
          }
          function _emscripten_glUniform4i(location, v0, v1, v2, v3) {
            GLctx.uniform4i(GL.uniforms[location], v0, v1, v2, v3);
          }
          function _emscripten_glUniform4iv(location, count, value) {
            GLctx.uniform4iv(GL.uniforms[location], HEAP32.subarray(value >> 2, value + count * 16 >> 2));
          }
          function _emscripten_glUniformMatrix2fv(location, count, transpose, value) {
            if (4 * count <= GL.MINI_TEMP_BUFFER_SIZE) {
              var view = GL.miniTempBufferViews[4 * count - 1];
              for (var i2 = 0; i2 < 4 * count; i2 += 4) {
                view[i2] = HEAPF32[value + 4 * i2 >> 2];
                view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >> 2];
                view[i2 + 2] = HEAPF32[value + (4 * i2 + 8) >> 2];
                view[i2 + 3] = HEAPF32[value + (4 * i2 + 12) >> 2];
              }
            } else {
              var view = HEAPF32.subarray(value >> 2, value + count * 16 >> 2);
            }
            GLctx.uniformMatrix2fv(GL.uniforms[location], !!transpose, view);
          }
          function _emscripten_glUniformMatrix3fv(location, count, transpose, value) {
            if (9 * count <= GL.MINI_TEMP_BUFFER_SIZE) {
              var view = GL.miniTempBufferViews[9 * count - 1];
              for (var i2 = 0; i2 < 9 * count; i2 += 9) {
                view[i2] = HEAPF32[value + 4 * i2 >> 2];
                view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >> 2];
                view[i2 + 2] = HEAPF32[value + (4 * i2 + 8) >> 2];
                view[i2 + 3] = HEAPF32[value + (4 * i2 + 12) >> 2];
                view[i2 + 4] = HEAPF32[value + (4 * i2 + 16) >> 2];
                view[i2 + 5] = HEAPF32[value + (4 * i2 + 20) >> 2];
                view[i2 + 6] = HEAPF32[value + (4 * i2 + 24) >> 2];
                view[i2 + 7] = HEAPF32[value + (4 * i2 + 28) >> 2];
                view[i2 + 8] = HEAPF32[value + (4 * i2 + 32) >> 2];
              }
            } else {
              var view = HEAPF32.subarray(value >> 2, value + count * 36 >> 2);
            }
            GLctx.uniformMatrix3fv(GL.uniforms[location], !!transpose, view);
          }
          function _emscripten_glUniformMatrix4fv(location, count, transpose, value) {
            if (16 * count <= GL.MINI_TEMP_BUFFER_SIZE) {
              var view = GL.miniTempBufferViews[16 * count - 1];
              for (var i2 = 0; i2 < 16 * count; i2 += 16) {
                view[i2] = HEAPF32[value + 4 * i2 >> 2];
                view[i2 + 1] = HEAPF32[value + (4 * i2 + 4) >> 2];
                view[i2 + 2] = HEAPF32[value + (4 * i2 + 8) >> 2];
                view[i2 + 3] = HEAPF32[value + (4 * i2 + 12) >> 2];
                view[i2 + 4] = HEAPF32[value + (4 * i2 + 16) >> 2];
                view[i2 + 5] = HEAPF32[value + (4 * i2 + 20) >> 2];
                view[i2 + 6] = HEAPF32[value + (4 * i2 + 24) >> 2];
                view[i2 + 7] = HEAPF32[value + (4 * i2 + 28) >> 2];
                view[i2 + 8] = HEAPF32[value + (4 * i2 + 32) >> 2];
                view[i2 + 9] = HEAPF32[value + (4 * i2 + 36) >> 2];
                view[i2 + 10] = HEAPF32[value + (4 * i2 + 40) >> 2];
                view[i2 + 11] = HEAPF32[value + (4 * i2 + 44) >> 2];
                view[i2 + 12] = HEAPF32[value + (4 * i2 + 48) >> 2];
                view[i2 + 13] = HEAPF32[value + (4 * i2 + 52) >> 2];
                view[i2 + 14] = HEAPF32[value + (4 * i2 + 56) >> 2];
                view[i2 + 15] = HEAPF32[value + (4 * i2 + 60) >> 2];
              }
            } else {
              var view = HEAPF32.subarray(value >> 2, value + count * 64 >> 2);
            }
            GLctx.uniformMatrix4fv(GL.uniforms[location], !!transpose, view);
          }
          function _emscripten_glUseProgram(program) {
            GLctx.useProgram(GL.programs[program]);
          }
          function _emscripten_glValidateProgram(program) {
            GLctx.validateProgram(GL.programs[program]);
          }
          function _emscripten_glVertexAttrib1f(x0, x1) {
            GLctx["vertexAttrib1f"](x0, x1);
          }
          function _emscripten_glVertexAttrib1fv(index, v) {
            GLctx.vertexAttrib1f(index, HEAPF32[v >> 2]);
          }
          function _emscripten_glVertexAttrib2f(x0, x1, x2) {
            GLctx["vertexAttrib2f"](x0, x1, x2);
          }
          function _emscripten_glVertexAttrib2fv(index, v) {
            GLctx.vertexAttrib2f(index, HEAPF32[v >> 2], HEAPF32[v + 4 >> 2]);
          }
          function _emscripten_glVertexAttrib3f(x0, x1, x2, x3) {
            GLctx["vertexAttrib3f"](x0, x1, x2, x3);
          }
          function _emscripten_glVertexAttrib3fv(index, v) {
            GLctx.vertexAttrib3f(index, HEAPF32[v >> 2], HEAPF32[v + 4 >> 2], HEAPF32[v + 8 >> 2]);
          }
          function _emscripten_glVertexAttrib4f(x0, x1, x2, x3, x4) {
            GLctx["vertexAttrib4f"](x0, x1, x2, x3, x4);
          }
          function _emscripten_glVertexAttrib4fv(index, v) {
            GLctx.vertexAttrib4f(index, HEAPF32[v >> 2], HEAPF32[v + 4 >> 2], HEAPF32[v + 8 >> 2], HEAPF32[v + 12 >> 2]);
          }
          function _emscripten_glVertexAttribDivisorANGLE(index, divisor) {
            GLctx["vertexAttribDivisor"](index, divisor);
          }
          function _emscripten_glVertexAttribPointer(index, size, type, normalized, stride, ptr) {
            GLctx.vertexAttribPointer(index, size, type, !!normalized, stride, ptr);
          }
          function _emscripten_glViewport(x0, x1, x2, x3) {
            GLctx["viewport"](x0, x1, x2, x3);
          }
          function _exit(status) {
            exit(status);
          }
          var ENV = {};
          function _getenv(name) {
            if (name === 0) return 0;
            name = UTF8ToString(name);
            if (!ENV.hasOwnProperty(name)) return 0;
            if (_getenv.ret) _free(_getenv.ret);
            _getenv.ret = allocateUTF8(ENV[name]);
            return _getenv.ret;
          }
          function _llvm_stackrestore(p) {
            var self2 = _llvm_stacksave;
            var ret = self2.LLVM_SAVEDSTACKS[p];
            self2.LLVM_SAVEDSTACKS.splice(p, 1);
            stackRestore(ret);
          }
          function _llvm_stacksave() {
            var self2 = _llvm_stacksave;
            if (!self2.LLVM_SAVEDSTACKS) {
              self2.LLVM_SAVEDSTACKS = [];
            }
            self2.LLVM_SAVEDSTACKS.push(stackSave());
            return self2.LLVM_SAVEDSTACKS.length - 1;
          }
          function _llvm_trap() {
            abort("trap!");
          }
          function _emscripten_memcpy_big(dest, src, num) {
            HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
          }
          function _pthread_cond_wait() {
            return 0;
          }
          function abortOnCannotGrowMemory(requestedSize) {
            abort("OOM");
          }
          function emscripten_realloc_buffer(size) {
            try {
              wasmMemory.grow(size - buffer.byteLength + 65535 >> 16);
              updateGlobalBufferAndViews(wasmMemory.buffer);
              return 1;
            } catch (e) {
            }
          }
          function _emscripten_resize_heap(requestedSize) {
            var oldSize = _emscripten_get_heap_size();
            var PAGE_MULTIPLE = 65536;
            var LIMIT = 2147483648 - PAGE_MULTIPLE;
            if (requestedSize > LIMIT) {
              return false;
            }
            var MIN_TOTAL_MEMORY = 16777216;
            var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY);
            while (newSize < requestedSize) {
              if (newSize <= 536870912) {
                newSize = alignUp(2 * newSize, PAGE_MULTIPLE);
              } else {
                newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);
              }
            }
            var replacement = emscripten_realloc_buffer(newSize);
            if (!replacement) {
              return false;
            }
            return true;
          }
          function __isLeapYear(year) {
            return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
          }
          function __arraySum(array, index) {
            var sum = 0;
            for (var i2 = 0; i2 <= index; sum += array[i2++]) ;
            return sum;
          }
          var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          function __addDays(date, days) {
            var newDate = new Date(date.getTime());
            while (days > 0) {
              var leap = __isLeapYear(newDate.getFullYear());
              var currentMonth = newDate.getMonth();
              var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
              if (days > daysInCurrentMonth - newDate.getDate()) {
                days -= daysInCurrentMonth - newDate.getDate() + 1;
                newDate.setDate(1);
                if (currentMonth < 11) {
                  newDate.setMonth(currentMonth + 1);
                } else {
                  newDate.setMonth(0);
                  newDate.setFullYear(newDate.getFullYear() + 1);
                }
              } else {
                newDate.setDate(newDate.getDate() + days);
                return newDate;
              }
            }
            return newDate;
          }
          function _strftime(s, maxsize, format, tm) {
            var tm_zone = HEAP32[tm + 40 >> 2];
            var date = { tm_sec: HEAP32[tm >> 2], tm_min: HEAP32[tm + 4 >> 2], tm_hour: HEAP32[tm + 8 >> 2], tm_mday: HEAP32[tm + 12 >> 2], tm_mon: HEAP32[tm + 16 >> 2], tm_year: HEAP32[tm + 20 >> 2], tm_wday: HEAP32[tm + 24 >> 2], tm_yday: HEAP32[tm + 28 >> 2], tm_isdst: HEAP32[tm + 32 >> 2], tm_gmtoff: HEAP32[tm + 36 >> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" };
            var pattern = UTF8ToString(format);
            var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
            for (var rule in EXPANSION_RULES_1) {
              pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
            }
            var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
            var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            function leadingSomething(value, digits, character) {
              var str = typeof value === "number" ? value.toString() : value || "";
              while (str.length < digits) {
                str = character[0] + str;
              }
              return str;
            }
            function leadingNulls(value, digits) {
              return leadingSomething(value, digits, "0");
            }
            function compareByDay(date1, date2) {
              function sgn(value) {
                return value < 0 ? -1 : value > 0 ? 1 : 0;
              }
              var compare;
              if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
                if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                  compare = sgn(date1.getDate() - date2.getDate());
                }
              }
              return compare;
            }
            function getFirstWeekStartDate(janFourth) {
              switch (janFourth.getDay()) {
                case 0:
                  return new Date(janFourth.getFullYear() - 1, 11, 29);
                case 1:
                  return janFourth;
                case 2:
                  return new Date(janFourth.getFullYear(), 0, 3);
                case 3:
                  return new Date(janFourth.getFullYear(), 0, 2);
                case 4:
                  return new Date(janFourth.getFullYear(), 0, 1);
                case 5:
                  return new Date(janFourth.getFullYear() - 1, 11, 31);
                case 6:
                  return new Date(janFourth.getFullYear() - 1, 11, 30);
              }
            }
            function getWeekBasedYear(date2) {
              var thisDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
              var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
              var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
              var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
              var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
              if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
                if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                  return thisDate.getFullYear() + 1;
                } else {
                  return thisDate.getFullYear();
                }
              } else {
                return thisDate.getFullYear() - 1;
              }
            }
            var EXPANSION_RULES_2 = { "%a": function(date2) {
              return WEEKDAYS[date2.tm_wday].substring(0, 3);
            }, "%A": function(date2) {
              return WEEKDAYS[date2.tm_wday];
            }, "%b": function(date2) {
              return MONTHS[date2.tm_mon].substring(0, 3);
            }, "%B": function(date2) {
              return MONTHS[date2.tm_mon];
            }, "%C": function(date2) {
              var year = date2.tm_year + 1900;
              return leadingNulls(year / 100 | 0, 2);
            }, "%d": function(date2) {
              return leadingNulls(date2.tm_mday, 2);
            }, "%e": function(date2) {
              return leadingSomething(date2.tm_mday, 2, " ");
            }, "%g": function(date2) {
              return getWeekBasedYear(date2).toString().substring(2);
            }, "%G": function(date2) {
              return getWeekBasedYear(date2);
            }, "%H": function(date2) {
              return leadingNulls(date2.tm_hour, 2);
            }, "%I": function(date2) {
              var twelveHour = date2.tm_hour;
              if (twelveHour == 0) twelveHour = 12;
              else if (twelveHour > 12) twelveHour -= 12;
              return leadingNulls(twelveHour, 2);
            }, "%j": function(date2) {
              return leadingNulls(date2.tm_mday + __arraySum(__isLeapYear(date2.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
            }, "%m": function(date2) {
              return leadingNulls(date2.tm_mon + 1, 2);
            }, "%M": function(date2) {
              return leadingNulls(date2.tm_min, 2);
            }, "%n": function() {
              return "\n";
            }, "%p": function(date2) {
              if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
                return "AM";
              } else {
                return "PM";
              }
            }, "%S": function(date2) {
              return leadingNulls(date2.tm_sec, 2);
            }, "%t": function() {
              return "	";
            }, "%u": function(date2) {
              return date2.tm_wday || 7;
            }, "%U": function(date2) {
              var janFirst = new Date(date2.tm_year + 1900, 0, 1);
              var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());
              var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
              if (compareByDay(firstSunday, endDate) < 0) {
                var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
                var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();
                var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
                return leadingNulls(Math.ceil(days / 7), 2);
              }
              return compareByDay(firstSunday, janFirst) === 0 ? "01" : "00";
            }, "%V": function(date2) {
              var janFourthThisYear = new Date(date2.tm_year + 1900, 0, 4);
              var janFourthNextYear = new Date(date2.tm_year + 1901, 0, 4);
              var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
              var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
              var endDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
              if (compareByDay(endDate, firstWeekStartThisYear) < 0) {
                return "53";
              }
              if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {
                return "01";
              }
              var daysDifference;
              if (firstWeekStartThisYear.getFullYear() < date2.tm_year + 1900) {
                daysDifference = date2.tm_yday + 32 - firstWeekStartThisYear.getDate();
              } else {
                daysDifference = date2.tm_yday + 1 - firstWeekStartThisYear.getDate();
              }
              return leadingNulls(Math.ceil(daysDifference / 7), 2);
            }, "%w": function(date2) {
              return date2.tm_wday;
            }, "%W": function(date2) {
              var janFirst = new Date(date2.tm_year, 0, 1);
              var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);
              var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
              if (compareByDay(firstMonday, endDate) < 0) {
                var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
                var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();
                var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
                return leadingNulls(Math.ceil(days / 7), 2);
              }
              return compareByDay(firstMonday, janFirst) === 0 ? "01" : "00";
            }, "%y": function(date2) {
              return (date2.tm_year + 1900).toString().substring(2);
            }, "%Y": function(date2) {
              return date2.tm_year + 1900;
            }, "%z": function(date2) {
              var off = date2.tm_gmtoff;
              var ahead = off >= 0;
              off = Math.abs(off) / 60;
              off = off / 60 * 100 + off % 60;
              return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
            }, "%Z": function(date2) {
              return date2.tm_zone;
            }, "%%": function() {
              return "%";
            } };
            for (var rule in EXPANSION_RULES_2) {
              if (pattern.indexOf(rule) >= 0) {
                pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
              }
            }
            var bytes = intArrayFromString(pattern, false);
            if (bytes.length > maxsize) {
              return 0;
            }
            writeArrayToMemory(bytes, s);
            return bytes.length - 1;
          }
          function _strftime_l(s, maxsize, format, tm) {
            return _strftime(s, maxsize, format, tm);
          }
          FS.staticInit();
          if (ENVIRONMENT_HAS_NODE) {
            var fs = (init_fs(), __toCommonJS(fs_exports));
            var NODEJS_PATH = (init_path(), __toCommonJS(path_exports));
            NODEFS.staticInit();
          }
          InternalError = Module2["InternalError"] = extendError(Error, "InternalError");
          embind_init_charCodes();
          BindingError = Module2["BindingError"] = extendError(Error, "BindingError");
          init_ClassHandle();
          init_RegisteredPointer();
          init_embind();
          UnboundTypeError = Module2["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
          init_emval();
          var GLctx;
          GL.init();
          for (var i = 0; i < 32; i++) __tempFixedLengthArray.push(new Array(i));
          function intArrayFromString(stringy, dontAddNull, length) {
            var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
            var u8array = new Array(len);
            var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
            if (dontAddNull) u8array.length = numBytesWritten;
            return u8array;
          }
          var asmGlobalArg = {};
          var asmLibraryArg = { "e": abort, "Ra": setTempRet0, "b": ___assert_fail, "p": ___cxa_allocate_exception, "Oa": ___cxa_pure_virtual, "n": ___cxa_throw, "Ea": ___cxa_uncaught_exceptions, "A": ___lock, "ja": ___map_file, "z": ___setErrNo, "Q": ___syscall140, "ed": ___syscall145, "F": ___syscall146, "Lc": ___syscall54, "Ac": ___syscall6, "pc": ___syscall91, "y": ___unlock, "Wb": __embind_finalize_value_object, "Lb": __embind_register_bool, "Ab": __embind_register_class, "pb": __embind_register_class_constructor, "E": __embind_register_class_function, "l": __embind_register_class_property, "Qa": __embind_register_emval, "m": __embind_register_enum, "d": __embind_register_enum_value, "D": __embind_register_float, "h": __embind_register_integer, "g": __embind_register_memory_view, "C": __embind_register_std_string, "Pa": __embind_register_std_wstring, "Na": __embind_register_value_object, "w": __embind_register_value_object_field, "Ma": __embind_register_void, "r": __emval_as, "La": __emval_call_void_method, "f": __emval_decref, "Ka": __emval_get_method_caller, "B": __emval_get_module_property, "o": __emval_get_property, "v": __emval_incref, "Ja": __emval_new, "i": __emval_new_cstring, "Ia": __emval_new_object, "q": __emval_run_destructors, "u": __emval_set_property, "t": __emval_take_value, "c": _abort, "Ha": _emscripten_get_heap_size, "Ga": _emscripten_glActiveTexture, "Fa": _emscripten_glAttachShader, "Da": _emscripten_glBeginQueryEXT, "Ca": _emscripten_glBindAttribLocation, "Ba": _emscripten_glBindBuffer, "Aa": _emscripten_glBindFramebuffer, "za": _emscripten_glBindRenderbuffer, "ya": _emscripten_glBindTexture, "xa": _emscripten_glBindVertexArrayOES, "wa": _emscripten_glBlendColor, "va": _emscripten_glBlendEquation, "ua": _emscripten_glBlendEquationSeparate, "ta": _emscripten_glBlendFunc, "sa": _emscripten_glBlendFuncSeparate, "ra": _emscripten_glBufferData, "qa": _emscripten_glBufferSubData, "pa": _emscripten_glCheckFramebufferStatus, "oa": _emscripten_glClear, "na": _emscripten_glClearColor, "ma": _emscripten_glClearDepthf, "la": _emscripten_glClearStencil, "ka": _emscripten_glColorMask, "ia": _emscripten_glCompileShader, "ha": _emscripten_glCompressedTexImage2D, "ga": _emscripten_glCompressedTexSubImage2D, "fa": _emscripten_glCopyTexImage2D, "ea": _emscripten_glCopyTexSubImage2D, "da": _emscripten_glCreateProgram, "ca": _emscripten_glCreateShader, "ba": _emscripten_glCullFace, "aa": _emscripten_glDeleteBuffers, "$": _emscripten_glDeleteFramebuffers, "_": _emscripten_glDeleteProgram, "Z": _emscripten_glDeleteQueriesEXT, "Y": _emscripten_glDeleteRenderbuffers, "X": _emscripten_glDeleteShader, "W": _emscripten_glDeleteTextures, "V": _emscripten_glDeleteVertexArraysOES, "U": _emscripten_glDepthFunc, "T": _emscripten_glDepthMask, "S": _emscripten_glDepthRangef, "R": _emscripten_glDetachShader, "P": _emscripten_glDisable, "O": _emscripten_glDisableVertexAttribArray, "N": _emscripten_glDrawArrays, "M": _emscripten_glDrawArraysInstancedANGLE, "L": _emscripten_glDrawBuffersWEBGL, "K": _emscripten_glDrawElements, "J": _emscripten_glDrawElementsInstancedANGLE, "I": _emscripten_glEnable, "H": _emscripten_glEnableVertexAttribArray, "G": _emscripten_glEndQueryEXT, "dd": _emscripten_glFinish, "cd": _emscripten_glFlush, "bd": _emscripten_glFramebufferRenderbuffer, "ad": _emscripten_glFramebufferTexture2D, "$c": _emscripten_glFrontFace, "_c": _emscripten_glGenBuffers, "Zc": _emscripten_glGenFramebuffers, "Yc": _emscripten_glGenQueriesEXT, "Xc": _emscripten_glGenRenderbuffers, "Wc": _emscripten_glGenTextures, "Vc": _emscripten_glGenVertexArraysOES, "Uc": _emscripten_glGenerateMipmap, "Tc": _emscripten_glGetActiveAttrib, "Sc": _emscripten_glGetActiveUniform, "Rc": _emscripten_glGetAttachedShaders, "Qc": _emscripten_glGetAttribLocation, "Pc": _emscripten_glGetBooleanv, "Oc": _emscripten_glGetBufferParameteriv, "Nc": _emscripten_glGetError, "Mc": _emscripten_glGetFloatv, "Kc": _emscripten_glGetFramebufferAttachmentParameteriv, "Jc": _emscripten_glGetIntegerv, "Ic": _emscripten_glGetProgramInfoLog, "Hc": _emscripten_glGetProgramiv, "Gc": _emscripten_glGetQueryObjecti64vEXT, "Fc": _emscripten_glGetQueryObjectivEXT, "Ec": _emscripten_glGetQueryObjectui64vEXT, "Dc": _emscripten_glGetQueryObjectuivEXT, "Cc": _emscripten_glGetQueryivEXT, "Bc": _emscripten_glGetRenderbufferParameteriv, "zc": _emscripten_glGetShaderInfoLog, "yc": _emscripten_glGetShaderPrecisionFormat, "xc": _emscripten_glGetShaderSource, "wc": _emscripten_glGetShaderiv, "vc": _emscripten_glGetString, "uc": _emscripten_glGetTexParameterfv, "tc": _emscripten_glGetTexParameteriv, "sc": _emscripten_glGetUniformLocation, "rc": _emscripten_glGetUniformfv, "qc": _emscripten_glGetUniformiv, "oc": _emscripten_glGetVertexAttribPointerv, "nc": _emscripten_glGetVertexAttribfv, "mc": _emscripten_glGetVertexAttribiv, "lc": _emscripten_glHint, "kc": _emscripten_glIsBuffer, "jc": _emscripten_glIsEnabled, "ic": _emscripten_glIsFramebuffer, "hc": _emscripten_glIsProgram, "gc": _emscripten_glIsQueryEXT, "fc": _emscripten_glIsRenderbuffer, "ec": _emscripten_glIsShader, "dc": _emscripten_glIsTexture, "cc": _emscripten_glIsVertexArrayOES, "bc": _emscripten_glLineWidth, "ac": _emscripten_glLinkProgram, "$b": _emscripten_glPixelStorei, "_b": _emscripten_glPolygonOffset, "Zb": _emscripten_glQueryCounterEXT, "Yb": _emscripten_glReadPixels, "Xb": _emscripten_glReleaseShaderCompiler, "Vb": _emscripten_glRenderbufferStorage, "Ub": _emscripten_glSampleCoverage, "Tb": _emscripten_glScissor, "Sb": _emscripten_glShaderBinary, "Rb": _emscripten_glShaderSource, "Qb": _emscripten_glStencilFunc, "Pb": _emscripten_glStencilFuncSeparate, "Ob": _emscripten_glStencilMask, "Nb": _emscripten_glStencilMaskSeparate, "Mb": _emscripten_glStencilOp, "Kb": _emscripten_glStencilOpSeparate, "Jb": _emscripten_glTexImage2D, "Ib": _emscripten_glTexParameterf, "Hb": _emscripten_glTexParameterfv, "Gb": _emscripten_glTexParameteri, "Fb": _emscripten_glTexParameteriv, "Eb": _emscripten_glTexSubImage2D, "Db": _emscripten_glUniform1f, "Cb": _emscripten_glUniform1fv, "Bb": _emscripten_glUniform1i, "zb": _emscripten_glUniform1iv, "yb": _emscripten_glUniform2f, "xb": _emscripten_glUniform2fv, "wb": _emscripten_glUniform2i, "vb": _emscripten_glUniform2iv, "ub": _emscripten_glUniform3f, "tb": _emscripten_glUniform3fv, "sb": _emscripten_glUniform3i, "rb": _emscripten_glUniform3iv, "qb": _emscripten_glUniform4f, "ob": _emscripten_glUniform4fv, "nb": _emscripten_glUniform4i, "mb": _emscripten_glUniform4iv, "lb": _emscripten_glUniformMatrix2fv, "kb": _emscripten_glUniformMatrix3fv, "jb": _emscripten_glUniformMatrix4fv, "ib": _emscripten_glUseProgram, "hb": _emscripten_glValidateProgram, "gb": _emscripten_glVertexAttrib1f, "fb": _emscripten_glVertexAttrib1fv, "eb": _emscripten_glVertexAttrib2f, "db": _emscripten_glVertexAttrib2fv, "cb": _emscripten_glVertexAttrib3f, "bb": _emscripten_glVertexAttrib3fv, "ab": _emscripten_glVertexAttrib4f, "$a": _emscripten_glVertexAttrib4fv, "_a": _emscripten_glVertexAttribDivisorANGLE, "Za": _emscripten_glVertexAttribPointer, "Ya": _emscripten_glViewport, "Xa": _emscripten_memcpy_big, "Wa": _emscripten_resize_heap, "x": _exit, "s": _getenv, "k": _llvm_stackrestore, "j": _llvm_stacksave, "Va": _llvm_trap, "Ua": _pthread_cond_wait, "Ta": _strftime_l, "Sa": abortOnCannotGrowMemory, "a": DYNAMICTOP_PTR };
          var asm = Module2["asm"](asmGlobalArg, asmLibraryArg, buffer);
          Module2["asm"] = asm;
          var __ZSt18uncaught_exceptionv = Module2["__ZSt18uncaught_exceptionv"] = function() {
            return Module2["asm"]["fd"].apply(null, arguments);
          };
          var ___embind_register_native_and_builtin_types = Module2["___embind_register_native_and_builtin_types"] = function() {
            return Module2["asm"]["gd"].apply(null, arguments);
          };
          var ___errno_location = Module2["___errno_location"] = function() {
            return Module2["asm"]["hd"].apply(null, arguments);
          };
          var ___getTypeName = Module2["___getTypeName"] = function() {
            return Module2["asm"]["id"].apply(null, arguments);
          };
          var _free = Module2["_free"] = function() {
            return Module2["asm"]["jd"].apply(null, arguments);
          };
          var _malloc = Module2["_malloc"] = function() {
            return Module2["asm"]["kd"].apply(null, arguments);
          };
          var globalCtors = Module2["globalCtors"] = function() {
            return Module2["asm"]["Wd"].apply(null, arguments);
          };
          var stackAlloc = Module2["stackAlloc"] = function() {
            return Module2["asm"]["Xd"].apply(null, arguments);
          };
          var stackRestore = Module2["stackRestore"] = function() {
            return Module2["asm"]["Yd"].apply(null, arguments);
          };
          var stackSave = Module2["stackSave"] = function() {
            return Module2["asm"]["Zd"].apply(null, arguments);
          };
          var dynCall_i = Module2["dynCall_i"] = function() {
            return Module2["asm"]["ld"].apply(null, arguments);
          };
          var dynCall_ii = Module2["dynCall_ii"] = function() {
            return Module2["asm"]["md"].apply(null, arguments);
          };
          var dynCall_iidiiii = Module2["dynCall_iidiiii"] = function() {
            return Module2["asm"]["nd"].apply(null, arguments);
          };
          var dynCall_iii = Module2["dynCall_iii"] = function() {
            return Module2["asm"]["od"].apply(null, arguments);
          };
          var dynCall_iiii = Module2["dynCall_iiii"] = function() {
            return Module2["asm"]["pd"].apply(null, arguments);
          };
          var dynCall_iiiii = Module2["dynCall_iiiii"] = function() {
            return Module2["asm"]["qd"].apply(null, arguments);
          };
          var dynCall_iiiiid = Module2["dynCall_iiiiid"] = function() {
            return Module2["asm"]["rd"].apply(null, arguments);
          };
          var dynCall_iiiiii = Module2["dynCall_iiiiii"] = function() {
            return Module2["asm"]["sd"].apply(null, arguments);
          };
          var dynCall_iiiiiid = Module2["dynCall_iiiiiid"] = function() {
            return Module2["asm"]["td"].apply(null, arguments);
          };
          var dynCall_iiiiiii = Module2["dynCall_iiiiiii"] = function() {
            return Module2["asm"]["ud"].apply(null, arguments);
          };
          var dynCall_iiiiiiii = Module2["dynCall_iiiiiiii"] = function() {
            return Module2["asm"]["vd"].apply(null, arguments);
          };
          var dynCall_iiiiiiiii = Module2["dynCall_iiiiiiiii"] = function() {
            return Module2["asm"]["wd"].apply(null, arguments);
          };
          var dynCall_iiiiiijii = Module2["dynCall_iiiiiijii"] = function() {
            return Module2["asm"]["xd"].apply(null, arguments);
          };
          var dynCall_iiiiij = Module2["dynCall_iiiiij"] = function() {
            return Module2["asm"]["yd"].apply(null, arguments);
          };
          var dynCall_iij = Module2["dynCall_iij"] = function() {
            return Module2["asm"]["zd"].apply(null, arguments);
          };
          var dynCall_jiji = Module2["dynCall_jiji"] = function() {
            return Module2["asm"]["Ad"].apply(null, arguments);
          };
          var dynCall_v = Module2["dynCall_v"] = function() {
            return Module2["asm"]["Bd"].apply(null, arguments);
          };
          var dynCall_vf = Module2["dynCall_vf"] = function() {
            return Module2["asm"]["Cd"].apply(null, arguments);
          };
          var dynCall_vff = Module2["dynCall_vff"] = function() {
            return Module2["asm"]["Dd"].apply(null, arguments);
          };
          var dynCall_vffff = Module2["dynCall_vffff"] = function() {
            return Module2["asm"]["Ed"].apply(null, arguments);
          };
          var dynCall_vfi = Module2["dynCall_vfi"] = function() {
            return Module2["asm"]["Fd"].apply(null, arguments);
          };
          var dynCall_vi = Module2["dynCall_vi"] = function() {
            return Module2["asm"]["Gd"].apply(null, arguments);
          };
          var dynCall_vif = Module2["dynCall_vif"] = function() {
            return Module2["asm"]["Hd"].apply(null, arguments);
          };
          var dynCall_viff = Module2["dynCall_viff"] = function() {
            return Module2["asm"]["Id"].apply(null, arguments);
          };
          var dynCall_vifff = Module2["dynCall_vifff"] = function() {
            return Module2["asm"]["Jd"].apply(null, arguments);
          };
          var dynCall_viffff = Module2["dynCall_viffff"] = function() {
            return Module2["asm"]["Kd"].apply(null, arguments);
          };
          var dynCall_vii = Module2["dynCall_vii"] = function() {
            return Module2["asm"]["Ld"].apply(null, arguments);
          };
          var dynCall_viif = Module2["dynCall_viif"] = function() {
            return Module2["asm"]["Md"].apply(null, arguments);
          };
          var dynCall_viii = Module2["dynCall_viii"] = function() {
            return Module2["asm"]["Nd"].apply(null, arguments);
          };
          var dynCall_viiii = Module2["dynCall_viiii"] = function() {
            return Module2["asm"]["Od"].apply(null, arguments);
          };
          var dynCall_viiiii = Module2["dynCall_viiiii"] = function() {
            return Module2["asm"]["Pd"].apply(null, arguments);
          };
          var dynCall_viiiiii = Module2["dynCall_viiiiii"] = function() {
            return Module2["asm"]["Qd"].apply(null, arguments);
          };
          var dynCall_viiiiiii = Module2["dynCall_viiiiiii"] = function() {
            return Module2["asm"]["Rd"].apply(null, arguments);
          };
          var dynCall_viiiiiiii = Module2["dynCall_viiiiiiii"] = function() {
            return Module2["asm"]["Sd"].apply(null, arguments);
          };
          var dynCall_viiiiiiiii = Module2["dynCall_viiiiiiiii"] = function() {
            return Module2["asm"]["Td"].apply(null, arguments);
          };
          var dynCall_viiiiiiiiii = Module2["dynCall_viiiiiiiiii"] = function() {
            return Module2["asm"]["Ud"].apply(null, arguments);
          };
          var dynCall_viijii = Module2["dynCall_viijii"] = function() {
            return Module2["asm"]["Vd"].apply(null, arguments);
          };
          Module2["asm"] = asm;
          Module2["GL"] = GL;
          var calledRun;
          Module2["then"] = function(func) {
            if (calledRun) {
              func(Module2);
            } else {
              var old = Module2["onRuntimeInitialized"];
              Module2["onRuntimeInitialized"] = function() {
                if (old) old();
                func(Module2);
              };
            }
            return Module2;
          };
          function ExitStatus(status) {
            this.name = "ExitStatus";
            this.message = "Program terminated with exit(" + status + ")";
            this.status = status;
          }
          dependenciesFulfilled = function runCaller() {
            if (!calledRun) run();
            if (!calledRun) dependenciesFulfilled = runCaller;
          };
          function run(args) {
            args = args || arguments_;
            if (runDependencies > 0) {
              return;
            }
            preRun();
            if (runDependencies > 0) return;
            function doRun() {
              if (calledRun) return;
              calledRun = true;
              if (ABORT) return;
              initRuntime();
              preMain();
              if (Module2["onRuntimeInitialized"]) Module2["onRuntimeInitialized"]();
              postRun();
            }
            if (Module2["setStatus"]) {
              Module2["setStatus"]("Running...");
              setTimeout(function() {
                setTimeout(function() {
                  Module2["setStatus"]("");
                }, 1);
                doRun();
              }, 1);
            } else {
              doRun();
            }
          }
          Module2["run"] = run;
          function exit(status, implicit) {
            if (implicit && noExitRuntime && status === 0) {
              return;
            }
            if (noExitRuntime) {
            } else {
              ABORT = true;
              EXITSTATUS = status;
              exitRuntime();
              if (Module2["onExit"]) Module2["onExit"](status);
            }
            quit_(status, new ExitStatus(status));
          }
          function abort(what) {
            if (Module2["onAbort"]) {
              Module2["onAbort"](what);
            }
            what += "";
            out(what);
            err(what);
            ABORT = true;
            EXITSTATUS = 1;
            throw "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
          }
          Module2["abort"] = abort;
          if (Module2["preInit"]) {
            if (typeof Module2["preInit"] == "function") Module2["preInit"] = [Module2["preInit"]];
            while (Module2["preInit"].length > 0) {
              Module2["preInit"].pop()();
            }
          }
          noExitRuntime = true;
          run();
          return LIBKTX2;
        });
      })();
      if (typeof exports === "object" && typeof module === "object")
        module.exports = LIBKTX;
      else if (typeof define === "function" && define["amd"])
        define([], function() {
          return LIBKTX;
        });
      else if (typeof exports === "object")
        exports["LIBKTX"] = LIBKTX;
    }
  });

  // glslang.js
  var glslang_exports = {};
  __export(glslang_exports, {
    default: () => glslang_default
  });
  var import_meta, glslangModule, glslang_default;
  var init_glslang = __esm({
    "glslang.js"() {
      import_meta = {};
      glslangModule = (function() {
        var _scriptDir = import_meta.url;
        return (function(glslangModule2) {
          glslangModule2 = glslangModule2 || {};
          var e;
          e || (e = typeof glslangModule2 !== "undefined" ? glslangModule2 : {});
          e.compileGLSLZeroCopy = function(a, b, c) {
            c = !!c;
            if ("vertex" === b) var d = 0;
            else if ("fragment" === b) d = 4;
            else if ("compute" === b) d = 5;
            else throw Error("shader_stage must be 'vertex', 'fragment', or 'compute'");
            b = e._malloc(4);
            var f = e._malloc(4), g = aa([a, d, c, b, f]);
            c = ba(b);
            a = ba(f);
            e._free(b);
            e._free(f);
            if (0 === a) throw Error("GLSL compilation failed");
            b = {};
            f = c / 4;
            b.data = e.HEAPU32.subarray(f, f + a);
            b.fa = function() {
              e._destroy_output_buffer(g);
            };
            return b;
          };
          e.compileGLSL = function(a, b, c) {
            a = e.compileGLSLZeroCopy(a, b, c);
            b = a.data.slice();
            a.fa();
            return b;
          };
          var m = {}, p;
          for (p in e) e.hasOwnProperty(p) && (m[p] = e[p]);
          var ca = false, r = false;
          ca = "object" === typeof window;
          r = "function" === typeof importScripts;
          var t = "", da;
          if (ca || r) r ? t = self.location.href : document.currentScript && (t = document.currentScript.src), _scriptDir && (t = _scriptDir), 0 !== t.indexOf("blob:") ? t = t.substr(0, t.lastIndexOf("/") + 1) : t = "", r && (da = function(a) {
            var b = new XMLHttpRequest();
            b.open("GET", a, false);
            b.responseType = "arraybuffer";
            b.send(null);
            return new Uint8Array(b.response);
          });
          var ea = e.print || console.log.bind(console), u = e.printErr || console.warn.bind(console);
          for (p in m) m.hasOwnProperty(p) && (e[p] = m[p]);
          m = null;
          var fa = { "f64-rem": function(a, b) {
            return a % b;
          }, "debugger": function() {
          } }, v;
          e.wasmBinary && (v = e.wasmBinary);
          "object" !== typeof WebAssembly && u("no native wasm support detected");
          function ba(a) {
            var b = "i32";
            "*" === b.charAt(b.length - 1) && (b = "i32");
            switch (b) {
              case "i1":
                return w[a >> 0];
              case "i8":
                return w[a >> 0];
              case "i16":
                return x[a >> 1];
              case "i32":
                return y[a >> 2];
              case "i64":
                return y[a >> 2];
              case "float":
                return ha[a >> 2];
              case "double":
                return ia[a >> 3];
              default:
                z("invalid type for getValue: " + b);
            }
            return null;
          }
          var A, ja = false;
          function ka() {
            var a = e._convert_glsl_to_spirv;
            a || z("Assertion failed: Cannot call unknown function convert_glsl_to_spirv, make sure it is exported");
            return a;
          }
          function aa(a) {
            var b = ["string", "number", "boolean", "number", "number"], c = { string: function(a2) {
              var b2 = 0;
              if (null !== a2 && void 0 !== a2 && 0 !== a2) {
                var c2 = (a2.length << 2) + 1;
                b2 = la(c2);
                B(a2, C, b2, c2);
              }
              return b2;
            }, array: function(a2) {
              var b2 = la(a2.length);
              w.set(a2, b2);
              return b2;
            } }, d = ka(), f = [], g = 0;
            if (a) for (var h = 0; h < a.length; h++) {
              var k = c[b[h]];
              k ? (0 === g && (g = ma()), f[h] = k(a[h])) : f[h] = a[h];
            }
            a = d.apply(null, f);
            0 !== g && na(g);
            return a;
          }
          var oa = "undefined" !== typeof TextDecoder ? new TextDecoder("utf8") : void 0;
          function pa(a, b, c) {
            var d = b + c;
            for (c = b; a[c] && !(c >= d); ) ++c;
            if (16 < c - b && a.subarray && oa) return oa.decode(a.subarray(b, c));
            for (d = ""; b < c; ) {
              var f = a[b++];
              if (f & 128) {
                var g = a[b++] & 63;
                if (192 == (f & 224)) d += String.fromCharCode((f & 31) << 6 | g);
                else {
                  var h = a[b++] & 63;
                  f = 224 == (f & 240) ? (f & 15) << 12 | g << 6 | h : (f & 7) << 18 | g << 12 | h << 6 | a[b++] & 63;
                  65536 > f ? d += String.fromCharCode(f) : (f -= 65536, d += String.fromCharCode(55296 | f >> 10, 56320 | f & 1023));
                }
              } else d += String.fromCharCode(f);
            }
            return d;
          }
          function D(a) {
            return a ? pa(C, a, void 0) : "";
          }
          function B(a, b, c, d) {
            if (0 < d) {
              d = c + d - 1;
              for (var f = 0; f < a.length; ++f) {
                var g = a.charCodeAt(f);
                if (55296 <= g && 57343 >= g) {
                  var h = a.charCodeAt(++f);
                  g = 65536 + ((g & 1023) << 10) | h & 1023;
                }
                if (127 >= g) {
                  if (c >= d) break;
                  b[c++] = g;
                } else {
                  if (2047 >= g) {
                    if (c + 1 >= d) break;
                    b[c++] = 192 | g >> 6;
                  } else {
                    if (65535 >= g) {
                      if (c + 2 >= d) break;
                      b[c++] = 224 | g >> 12;
                    } else {
                      if (c + 3 >= d) break;
                      b[c++] = 240 | g >> 18;
                      b[c++] = 128 | g >> 12 & 63;
                    }
                    b[c++] = 128 | g >> 6 & 63;
                  }
                  b[c++] = 128 | g & 63;
                }
              }
              b[c] = 0;
            }
          }
          function qa(a) {
            for (var b = 0, c = 0; c < a.length; ++c) {
              var d = a.charCodeAt(c);
              55296 <= d && 57343 >= d && (d = 65536 + ((d & 1023) << 10) | a.charCodeAt(++c) & 1023);
              127 >= d ? ++b : b = 2047 >= d ? b + 2 : 65535 >= d ? b + 3 : b + 4;
            }
            return b;
          }
          "undefined" !== typeof TextDecoder && new TextDecoder("utf-16le");
          function ra(a) {
            0 < a % 65536 && (a += 65536 - a % 65536);
            return a;
          }
          var E, w, C, x, sa, y, F, ha, ia;
          function ta(a) {
            E = a;
            e.HEAP8 = w = new Int8Array(a);
            e.HEAP16 = x = new Int16Array(a);
            e.HEAP32 = y = new Int32Array(a);
            e.HEAPU8 = C = new Uint8Array(a);
            e.HEAPU16 = sa = new Uint16Array(a);
            e.HEAPU32 = F = new Uint32Array(a);
            e.HEAPF32 = ha = new Float32Array(a);
            e.HEAPF64 = ia = new Float64Array(a);
          }
          var ua = e.TOTAL_MEMORY || 16777216;
          e.wasmMemory ? A = e.wasmMemory : A = new WebAssembly.Memory({ initial: ua / 65536 });
          A && (E = A.buffer);
          ua = E.byteLength;
          ta(E);
          y[69820] = 5522192;
          function G(a) {
            for (; 0 < a.length; ) {
              var b = a.shift();
              if ("function" == typeof b) b();
              else {
                var c = b.ga;
                "number" === typeof c ? void 0 === b.da ? e.dynCall_v(c) : e.dynCall_vi(c, b.da) : c(void 0 === b.da ? null : b.da);
              }
            }
          }
          var va = [], wa = [], xa = [], ya = [];
          function za() {
            var a = e.preRun.shift();
            va.unshift(a);
          }
          var H = 0, Aa = null, J = null;
          e.preloadedImages = {};
          e.preloadedAudios = {};
          function Ba() {
            var a = K;
            return String.prototype.startsWith ? a.startsWith("data:application/octet-stream;base64,") : 0 === a.indexOf("data:application/octet-stream;base64,");
          }
          var K = "glslang.wasm";
          if (!Ba()) {
            var Ca = K;
            K = e.locateFile ? e.locateFile(Ca, t) : t + Ca;
          }
          function Da() {
            try {
              if (v) return new Uint8Array(v);
              if (da) return da(K);
              throw "both async and sync fetching of the wasm failed";
            } catch (a) {
              z(a);
            }
          }
          function Ea() {
            return v || !ca && !r || "function" !== typeof fetch ? new Promise(function(a) {
              a(Da());
            }) : fetch(K, { credentials: "same-origin" }).then(function(a) {
              if (!a.ok) throw "failed to load wasm binary file at '" + K + "'";
              return a.arrayBuffer();
            }).catch(function() {
              return Da();
            });
          }
          function Fa(a) {
            function b(a2) {
              e.asm = a2.exports;
              H--;
              e.monitorRunDependencies && e.monitorRunDependencies(H);
              0 == H && (null !== Aa && (clearInterval(Aa), Aa = null), J && (a2 = J, J = null, a2()));
            }
            function c(a2) {
              b(a2.instance);
            }
            function d(a2) {
              return Ea().then(function(a3) {
                return WebAssembly.instantiate(a3, f);
              }).then(a2, function(a3) {
                u("failed to asynchronously prepare wasm: " + a3);
                z(a3);
              });
            }
            var f = { env: a, global: { NaN: NaN, Infinity: Infinity }, "global.Math": Math, asm2wasm: fa };
            H++;
            e.monitorRunDependencies && e.monitorRunDependencies(H);
            if (e.instantiateWasm) try {
              return e.instantiateWasm(
                f,
                b
              );
            } catch (g) {
              return u("Module.instantiateWasm callback failed with error: " + g), false;
            }
            (function() {
              if (v || "function" !== typeof WebAssembly.instantiateStreaming || Ba() || "function" !== typeof fetch) return d(c);
              fetch("./glslang.wasm", { credentials: "same-origin" }).then(function(a2) {
                return WebAssembly.instantiateStreaming(a2, f).then(c, function(a3) {
                  u("wasm streaming compile failed: " + a3);
                  u("falling back to ArrayBuffer instantiation");
                  d(c);
                });
              });
            })();
            return {};
          }
          e.asm = function(a, b) {
            b.memory = A;
            b.table = new WebAssembly.Table({ initial: 1320, maximum: 1320, element: "anyfunc" });
            b.__memory_base = 1024;
            b.__table_base = 0;
            return Fa(b);
          };
          wa.push({ ga: function() {
            Ga();
          } });
          function Ha(a) {
            e.___errno_location && (y[e.___errno_location() >> 2] = a);
            return a;
          }
          var Ia = [null, [], []], L = 0;
          function M() {
            L += 4;
            return y[L - 4 >> 2];
          }
          var N = {};
          function Ja(a) {
            switch (a) {
              case 1:
                return 0;
              case 2:
                return 1;
              case 4:
                return 2;
              case 8:
                return 3;
              default:
                throw new TypeError("Unknown type size: " + a);
            }
          }
          var Ka = void 0;
          function O(a) {
            for (var b = ""; C[a]; ) b += Ka[C[a++]];
            return b;
          }
          var La = {}, Ma = {}, Na = {};
          function Oa(a, b) {
            if (void 0 === a) a = "_unknown";
            else {
              a = a.replace(/[^a-zA-Z0-9_]/g, "$");
              var c = a.charCodeAt(0);
              a = 48 <= c && 57 >= c ? "_" + a : a;
            }
            return new Function("body", "return function " + a + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(b);
          }
          function Pa(a) {
            var b = Error, c = Oa(a, function(b2) {
              this.name = a;
              this.message = b2;
              b2 = Error(b2).stack;
              void 0 !== b2 && (this.stack = this.toString() + "\n" + b2.replace(/^Error(:[^\n]*)?\n/, ""));
            });
            c.prototype = Object.create(b.prototype);
            c.prototype.constructor = c;
            c.prototype.toString = function() {
              return void 0 === this.message ? this.name : this.name + ": " + this.message;
            };
            return c;
          }
          var Ra = void 0;
          function P(a) {
            throw new Ra(a);
          }
          function Q(a, b, c) {
            c = c || {};
            if (!("argPackAdvance" in b)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
            var d = b.name;
            a || P('type "' + d + '" must have a positive integer typeid pointer');
            if (Ma.hasOwnProperty(a)) {
              if (c.ia) return;
              P("Cannot register type '" + d + "' twice");
            }
            Ma[a] = b;
            delete Na[a];
            La.hasOwnProperty(a) && (b = La[a], delete La[a], b.forEach(function(a2) {
              a2();
            }));
          }
          var Sa = [], R = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
          function Ta(a) {
            switch (a) {
              case void 0:
                return 1;
              case null:
                return 2;
              case true:
                return 3;
              case false:
                return 4;
              default:
                var b = Sa.length ? Sa.pop() : R.length;
                R[b] = { ka: 1, value: a };
                return b;
            }
          }
          function Ua(a) {
            return this.fromWireType(F[a >> 2]);
          }
          function Va(a) {
            if (null === a) return "null";
            var b = typeof a;
            return "object" === b || "array" === b || "function" === b ? a.toString() : "" + a;
          }
          function Wa(a, b) {
            switch (b) {
              case 2:
                return function(a2) {
                  return this.fromWireType(ha[a2 >> 2]);
                };
              case 3:
                return function(a2) {
                  return this.fromWireType(ia[a2 >> 3]);
                };
              default:
                throw new TypeError("Unknown float type: " + a);
            }
          }
          function Xa(a, b, c) {
            switch (b) {
              case 0:
                return c ? function(a2) {
                  return w[a2];
                } : function(a2) {
                  return C[a2];
                };
              case 1:
                return c ? function(a2) {
                  return x[a2 >> 1];
                } : function(a2) {
                  return sa[a2 >> 1];
                };
              case 2:
                return c ? function(a2) {
                  return y[a2 >> 2];
                } : function(a2) {
                  return F[a2 >> 2];
                };
              default:
                throw new TypeError("Unknown integer type: " + a);
            }
          }
          function Ya() {
            return w.length;
          }
          var Za = {};
          function S(a) {
            if (0 === a) return 0;
            a = D(a);
            if (!Za.hasOwnProperty(a)) return 0;
            S.X && T(S.X);
            a = Za[a];
            var b = qa(a) + 1, c = $a(b);
            c && B(a, w, c, b);
            S.X = c;
            return S.X;
          }
          function U() {
            U.X || (U.X = []);
            U.X.push(ma());
            return U.X.length - 1;
          }
          function V(a) {
            return 0 === a % 4 && (0 !== a % 100 || 0 === a % 400);
          }
          function ab(a, b) {
            for (var c = 0, d = 0; d <= b; c += a[d++]) ;
            return c;
          }
          var W = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], X = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          function Y(a, b) {
            for (a = new Date(a.getTime()); 0 < b; ) {
              var c = a.getMonth(), d = (V(a.getFullYear()) ? W : X)[c];
              if (b > d - a.getDate()) b -= d - a.getDate() + 1, a.setDate(1), 11 > c ? a.setMonth(c + 1) : (a.setMonth(0), a.setFullYear(a.getFullYear() + 1));
              else {
                a.setDate(a.getDate() + b);
                break;
              }
            }
            return a;
          }
          function bb(a, b, c, d) {
            function f(a2, b2, c2) {
              for (a2 = "number" === typeof a2 ? a2.toString() : a2 || ""; a2.length < b2; ) a2 = c2[0] + a2;
              return a2;
            }
            function g(a2, b2) {
              return f(a2, b2, "0");
            }
            function h(a2, b2) {
              function c2(a3) {
                return 0 > a3 ? -1 : 0 < a3 ? 1 : 0;
              }
              var Z;
              0 === (Z = c2(a2.getFullYear() - b2.getFullYear())) && 0 === (Z = c2(a2.getMonth() - b2.getMonth())) && (Z = c2(a2.getDate() - b2.getDate()));
              return Z;
            }
            function k(a2) {
              switch (a2.getDay()) {
                case 0:
                  return new Date(a2.getFullYear() - 1, 11, 29);
                case 1:
                  return a2;
                case 2:
                  return new Date(a2.getFullYear(), 0, 3);
                case 3:
                  return new Date(
                    a2.getFullYear(),
                    0,
                    2
                  );
                case 4:
                  return new Date(a2.getFullYear(), 0, 1);
                case 5:
                  return new Date(a2.getFullYear() - 1, 11, 31);
                case 6:
                  return new Date(a2.getFullYear() - 1, 11, 30);
              }
            }
            function q(a2) {
              a2 = Y(new Date(a2.W + 1900, 0, 1), a2.ca);
              var b2 = k(new Date(a2.getFullYear() + 1, 0, 4));
              return 0 >= h(k(new Date(a2.getFullYear(), 0, 4)), a2) ? 0 >= h(b2, a2) ? a2.getFullYear() + 1 : a2.getFullYear() : a2.getFullYear() - 1;
            }
            var l = y[d + 40 >> 2];
            d = { na: y[d >> 2], ma: y[d + 4 >> 2], aa: y[d + 8 >> 2], $: y[d + 12 >> 2], Y: y[d + 16 >> 2], W: y[d + 20 >> 2], ba: y[d + 24 >> 2], ca: y[d + 28 >> 2], ya: y[d + 32 >> 2], la: y[d + 36 >> 2], oa: l ? D(l) : "" };
            c = D(c);
            l = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
            for (var n in l) c = c.replace(new RegExp(n, "g"), l[n]);
            var I = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), Qa = "January February March April May June July August September October November December".split(" ");
            l = { "%a": function(a2) {
              return I[a2.ba].substring(0, 3);
            }, "%A": function(a2) {
              return I[a2.ba];
            }, "%b": function(a2) {
              return Qa[a2.Y].substring(0, 3);
            }, "%B": function(a2) {
              return Qa[a2.Y];
            }, "%C": function(a2) {
              return g((a2.W + 1900) / 100 | 0, 2);
            }, "%d": function(a2) {
              return g(a2.$, 2);
            }, "%e": function(a2) {
              return f(a2.$, 2, " ");
            }, "%g": function(a2) {
              return q(a2).toString().substring(2);
            }, "%G": function(a2) {
              return q(a2);
            }, "%H": function(a2) {
              return g(
                a2.aa,
                2
              );
            }, "%I": function(a2) {
              a2 = a2.aa;
              0 == a2 ? a2 = 12 : 12 < a2 && (a2 -= 12);
              return g(a2, 2);
            }, "%j": function(a2) {
              return g(a2.$ + ab(V(a2.W + 1900) ? W : X, a2.Y - 1), 3);
            }, "%m": function(a2) {
              return g(a2.Y + 1, 2);
            }, "%M": function(a2) {
              return g(a2.ma, 2);
            }, "%n": function() {
              return "\n";
            }, "%p": function(a2) {
              return 0 <= a2.aa && 12 > a2.aa ? "AM" : "PM";
            }, "%S": function(a2) {
              return g(a2.na, 2);
            }, "%t": function() {
              return "	";
            }, "%u": function(a2) {
              return a2.ba || 7;
            }, "%U": function(a2) {
              var b2 = new Date(a2.W + 1900, 0, 1), c2 = 0 === b2.getDay() ? b2 : Y(b2, 7 - b2.getDay());
              a2 = new Date(a2.W + 1900, a2.Y, a2.$);
              return 0 > h(c2, a2) ? g(Math.ceil((31 - c2.getDate() + (ab(V(a2.getFullYear()) ? W : X, a2.getMonth() - 1) - 31) + a2.getDate()) / 7), 2) : 0 === h(c2, b2) ? "01" : "00";
            }, "%V": function(a2) {
              var b2 = k(new Date(a2.W + 1900, 0, 4)), c2 = k(new Date(a2.W + 1901, 0, 4)), d2 = Y(new Date(a2.W + 1900, 0, 1), a2.ca);
              return 0 > h(d2, b2) ? "53" : 0 >= h(c2, d2) ? "01" : g(Math.ceil((b2.getFullYear() < a2.W + 1900 ? a2.ca + 32 - b2.getDate() : a2.ca + 1 - b2.getDate()) / 7), 2);
            }, "%w": function(a2) {
              return a2.ba;
            }, "%W": function(a2) {
              var b2 = new Date(a2.W, 0, 1), c2 = 1 === b2.getDay() ? b2 : Y(b2, 0 === b2.getDay() ? 1 : 7 - b2.getDay() + 1);
              a2 = new Date(a2.W + 1900, a2.Y, a2.$);
              return 0 > h(c2, a2) ? g(Math.ceil((31 - c2.getDate() + (ab(V(a2.getFullYear()) ? W : X, a2.getMonth() - 1) - 31) + a2.getDate()) / 7), 2) : 0 === h(c2, b2) ? "01" : "00";
            }, "%y": function(a2) {
              return (a2.W + 1900).toString().substring(2);
            }, "%Y": function(a2) {
              return a2.W + 1900;
            }, "%z": function(a2) {
              a2 = a2.la;
              var b2 = 0 <= a2;
              a2 = Math.abs(a2) / 60;
              return (b2 ? "+" : "-") + String("0000" + (a2 / 60 * 100 + a2 % 60)).slice(-4);
            }, "%Z": function(a2) {
              return a2.oa;
            }, "%%": function() {
              return "%";
            } };
            for (n in l) 0 <= c.indexOf(n) && (c = c.replace(new RegExp(n, "g"), l[n](d)));
            n = cb(c);
            if (n.length > b) return 0;
            w.set(
              n,
              a
            );
            return n.length - 1;
          }
          for (var db = Array(256), eb = 0; 256 > eb; ++eb) db[eb] = String.fromCharCode(eb);
          Ka = db;
          Ra = e.BindingError = Pa("BindingError");
          e.InternalError = Pa("InternalError");
          e.count_emval_handles = function() {
            for (var a = 0, b = 5; b < R.length; ++b) void 0 !== R[b] && ++a;
            return a;
          };
          e.get_first_emval = function() {
            for (var a = 5; a < R.length; ++a) if (void 0 !== R[a]) return R[a];
            return null;
          };
          function cb(a) {
            var b = Array(qa(a) + 1);
            B(a, b, 0, b.length);
            return b;
          }
          var gb = e.asm({}, {
            c: z,
            I: function() {
              ja = true;
              throw "Pure virtual function called!";
            },
            C: function() {
              return fb.pa;
            },
            v: function() {
            },
            q: function() {
              Ha(1);
              return -1;
            },
            j: Ha,
            p: function(a, b) {
              L = b;
              try {
                return N.ha(), M(), M(), M(), M(), 0;
              } catch (c) {
                return z(c), -c.ea;
              }
            },
            i: function(a, b) {
              L = b;
              try {
                var c = M(), d = M(), f = M();
                for (b = a = 0; b < f; b++) {
                  for (var g = y[d + 8 * b >> 2], h = y[d + (8 * b + 4) >> 2], k = 0; k < h; k++) {
                    var q = C[g + k], l = Ia[c];
                    0 === q || 10 === q ? ((1 === c ? ea : u)(pa(l, 0)), l.length = 0) : l.push(q);
                  }
                  a += h;
                }
                return a;
              } catch (n) {
                return z(n), -n.ea;
              }
            },
            o: function(a, b) {
              L = b;
              return 0;
            },
            n: function(a, b) {
              L = b;
              try {
                return N.ha(), 0;
              } catch (c) {
                return z(c), -c.ea;
              }
            },
            H: function(a, b) {
              L = b;
              try {
                var c = M();
                var d = M();
                if (-1 === c || 0 === d) var f = -22;
                else {
                  var g = N.ja[c];
                  if (g && d === g.va) {
                    var h = (void 0).ta(g.sa);
                    N.ra(c, h, d, g.flags);
                    (void 0).xa(h);
                    N.ja[c] = null;
                    g.qa && T(g.wa);
                  }
                  f = 0;
                }
                return f;
              } catch (k) {
                return z(k), -k.ea;
              }
            },
            m: function() {
            },
            G: function(a, b, c, d, f) {
              var g = Ja(c);
              b = O(b);
              Q(a, { name: b, fromWireType: function(a2) {
                return !!a2;
              }, toWireType: function(a2, b2) {
                return b2 ? d : f;
              }, argPackAdvance: 8, readValueFromPointer: function(a2) {
                if (1 === c) var d2 = w;
                else if (2 === c) d2 = x;
                else if (4 === c) d2 = y;
                else throw new TypeError("Unknown boolean type size: " + b);
                return this.fromWireType(d2[a2 >> g]);
              }, Z: null });
            },
            F: function(a, b) {
              b = O(b);
              Q(a, { name: b, fromWireType: function(a2) {
                var b2 = R[a2].value;
                4 < a2 && 0 === --R[a2].ka && (R[a2] = void 0, Sa.push(a2));
                return b2;
              }, toWireType: function(a2, b2) {
                return Ta(b2);
              }, argPackAdvance: 8, readValueFromPointer: Ua, Z: null });
            },
            l: function(a, b, c) {
              c = Ja(c);
              b = O(b);
              Q(a, { name: b, fromWireType: function(a2) {
                return a2;
              }, toWireType: function(a2, b2) {
                if ("number" !== typeof b2 && "boolean" !== typeof b2) throw new TypeError('Cannot convert "' + Va(b2) + '" to ' + this.name);
                return b2;
              }, argPackAdvance: 8, readValueFromPointer: Wa(b, c), Z: null });
            },
            e: function(a, b, c, d, f) {
              function g(a2) {
                return a2;
              }
              b = O(b);
              -1 === f && (f = 4294967295);
              var h = Ja(c);
              if (0 === d) {
                var k = 32 - 8 * c;
                g = function(a2) {
                  return a2 << k >>> k;
                };
              }
              var q = -1 != b.indexOf("unsigned");
              Q(a, { name: b, fromWireType: g, toWireType: function(a2, c2) {
                if ("number" !== typeof c2 && "boolean" !== typeof c2) throw new TypeError('Cannot convert "' + Va(c2) + '" to ' + this.name);
                if (c2 < d || c2 > f) throw new TypeError('Passing a number "' + Va(c2) + '" from JS side to C/C++ side to an argument of type "' + b + '", which is outside the valid range [' + d + ", " + f + "]!");
                return q ? c2 >>> 0 : c2 | 0;
              }, argPackAdvance: 8, readValueFromPointer: Xa(b, h, 0 !== d), Z: null });
            },
            d: function(a, b, c) {
              function d(a2) {
                a2 >>= 2;
                var b2 = F;
                return new f(b2.buffer, b2[a2 + 1], b2[a2]);
              }
              var f = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][b];
              c = O(c);
              Q(a, { name: c, fromWireType: d, argPackAdvance: 8, readValueFromPointer: d }, { ia: true });
            },
            k: function(a, b) {
              b = O(b);
              var c = "std::string" === b;
              Q(a, { name: b, fromWireType: function(a2) {
                var b2 = F[a2 >> 2];
                if (c) {
                  var d = C[a2 + 4 + b2], h = 0;
                  0 != d && (h = d, C[a2 + 4 + b2] = 0);
                  var k = a2 + 4;
                  for (d = 0; d <= b2; ++d) {
                    var q = a2 + 4 + d;
                    if (0 == C[q]) {
                      k = D(k);
                      if (void 0 === l) var l = k;
                      else l += String.fromCharCode(0), l += k;
                      k = q + 1;
                    }
                  }
                  0 != h && (C[a2 + 4 + b2] = h);
                } else {
                  l = Array(b2);
                  for (d = 0; d < b2; ++d) l[d] = String.fromCharCode(C[a2 + 4 + d]);
                  l = l.join("");
                }
                T(a2);
                return l;
              }, toWireType: function(a2, b2) {
                b2 instanceof ArrayBuffer && (b2 = new Uint8Array(b2));
                var d = "string" === typeof b2;
                d || b2 instanceof Uint8Array || b2 instanceof Uint8ClampedArray || b2 instanceof Int8Array || P("Cannot pass non-string to std::string");
                var f = (c && d ? function() {
                  return qa(b2);
                } : function() {
                  return b2.length;
                })(), k = $a(4 + f + 1);
                F[k >> 2] = f;
                if (c && d) B(b2, C, k + 4, f + 1);
                else if (d) for (d = 0; d < f; ++d) {
                  var q = b2.charCodeAt(d);
                  255 < q && (T(k), P("String has UTF-16 code units that do not fit in 8 bits"));
                  C[k + 4 + d] = q;
                }
                else for (d = 0; d < f; ++d) C[k + 4 + d] = b2[d];
                null !== a2 && a2.push(T, k);
                return k;
              }, argPackAdvance: 8, readValueFromPointer: Ua, Z: function(a2) {
                T(a2);
              } });
            },
            E: function(a, b, c) {
              c = O(c);
              if (2 === b) {
                var d = function() {
                  return sa;
                };
                var f = 1;
              } else 4 === b && (d = function() {
                return F;
              }, f = 2);
              Q(a, { name: c, fromWireType: function(a2) {
                for (var b2 = d(), c2 = F[a2 >> 2], g = Array(c2), l = a2 + 4 >> f, n = 0; n < c2; ++n) g[n] = String.fromCharCode(b2[l + n]);
                T(a2);
                return g.join("");
              }, toWireType: function(a2, c2) {
                var g = d(), h = c2.length, l = $a(4 + h * b);
                F[l >> 2] = h;
                for (var n = l + 4 >> f, I = 0; I < h; ++I) g[n + I] = c2.charCodeAt(I);
                null !== a2 && a2.push(T, l);
                return l;
              }, argPackAdvance: 8, readValueFromPointer: Ua, Z: function(a2) {
                T(a2);
              } });
            },
            D: function(a, b) {
              b = O(b);
              Q(a, { ua: true, name: b, argPackAdvance: 0, fromWireType: function() {
              }, toWireType: function() {
              } });
            },
            b: function() {
              e.abort();
            },
            B: Ya,
            A: function(a, b, c) {
              C.set(C.subarray(b, b + c), a);
            },
            z: function(a) {
              if (2147418112 < a) return false;
              for (var b = Math.max(Ya(), 16777216); b < a; ) 536870912 >= b ? b = ra(2 * b) : b = Math.min(ra((3 * b + 2147483648) / 4), 2147418112);
              a: {
                try {
                  A.grow(b - E.byteLength + 65535 >> 16);
                  ta(A.buffer);
                  var c = 1;
                  break a;
                } catch (d) {
                }
                c = void 0;
              }
              return c ? true : false;
            },
            h: S,
            y: function(a) {
              return Math.log(a) / Math.LN2;
            },
            g: function(a) {
              var b = U.X[a];
              U.X.splice(a, 1);
              na(b);
            },
            f: U,
            x: function() {
              z("trap!");
            },
            w: function() {
              return 0;
            },
            u: function() {
            },
            t: function() {
            },
            s: function(a, b, c, d) {
              return bb(a, b, c, d);
            },
            r: function() {
              z("OOM");
            },
            a: 279280
          }, E);
          e.asm = gb;
          var Ga = e.__GLOBAL__sub_I_bind_cpp = function() {
            return e.asm.J.apply(null, arguments);
          }, fb = e.__ZSt18uncaught_exceptionv = function() {
            return e.asm.K.apply(null, arguments);
          };
          e.___embind_register_native_and_builtin_types = function() {
            return e.asm.L.apply(null, arguments);
          };
          e.___getTypeName = function() {
            return e.asm.M.apply(null, arguments);
          };
          e._convert_glsl_to_spirv = function() {
            return e.asm.N.apply(null, arguments);
          };
          e._destroy_output_buffer = function() {
            return e.asm.O.apply(null, arguments);
          };
          var T = e._free = function() {
            return e.asm.P.apply(null, arguments);
          }, $a = e._malloc = function() {
            return e.asm.Q.apply(null, arguments);
          }, la = e.stackAlloc = function() {
            return e.asm.T.apply(null, arguments);
          }, na = e.stackRestore = function() {
            return e.asm.U.apply(null, arguments);
          }, ma = e.stackSave = function() {
            return e.asm.V.apply(null, arguments);
          };
          e.dynCall_v = function() {
            return e.asm.R.apply(null, arguments);
          };
          e.dynCall_vi = function() {
            return e.asm.S.apply(null, arguments);
          };
          e.asm = gb;
          var hb;
          "undefined" !== typeof Promise && (e.ready = new Promise(function(a) {
            var b = e.onRuntimeInitialized;
            e.onRuntimeInitialized = function() {
              b && b();
              a(e);
            };
          }));
          J = function ib() {
            hb || jb();
            hb || (J = ib);
          };
          function jb() {
            function a() {
              if (!hb && (hb = true, !ja)) {
                G(wa);
                G(xa);
                if (e.onRuntimeInitialized) e.onRuntimeInitialized();
                if (e.postRun) for ("function" == typeof e.postRun && (e.postRun = [e.postRun]); e.postRun.length; ) {
                  var a2 = e.postRun.shift();
                  ya.unshift(a2);
                }
                G(ya);
              }
            }
            if (!(0 < H)) {
              if (e.preRun) for ("function" == typeof e.preRun && (e.preRun = [e.preRun]); e.preRun.length; ) za();
              G(va);
              0 < H || (e.setStatus ? (e.setStatus("Running..."), setTimeout(function() {
                setTimeout(function() {
                  e.setStatus("");
                }, 1);
                a();
              }, 1)) : a());
            }
          }
          e.run = jb;
          function z(a) {
            if (e.onAbort) e.onAbort(a);
            ea(a);
            u(a);
            ja = true;
            throw "abort(" + a + "). Build with -s ASSERTIONS=1 for more info.";
          }
          e.abort = z;
          if (e.preInit) for ("function" == typeof e.preInit && (e.preInit = [e.preInit]); 0 < e.preInit.length; ) e.preInit.pop()();
          jb();
          return glslangModule2.ready;
        });
      })();
      glslang_default = glslangModule;
    }
  });

  // twgsl.js
  var twgsl_exports = {};
  var Module;
  var init_twgsl = __esm({
    "twgsl.js"() {
      Module = function(Module2) {
        Module2 = Module2 || {};
        var Module2 = typeof Module2 != "undefined" ? Module2 : {};
        var moduleOverrides = Object.assign({}, Module2);
        var arguments_ = [];
        var thisProgram = "./this.program";
        var quit_ = (status, toThrow) => {
          throw toThrow;
        };
        var ENVIRONMENT_IS_WEB = typeof window == "object";
        var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
        var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
        var scriptDirectory = "";
        function locateFile(path) {
          if (Module2["locateFile"]) {
            return Module2["locateFile"](path, scriptDirectory);
          }
          return scriptDirectory + path;
        }
        var read_, readAsync, readBinary, setWindowTitle;
        function logExceptionOnExit(e) {
          if (e instanceof ExitStatus) return;
          let toLog = e;
          err("exiting due to exception: " + toLog);
        }
        if (ENVIRONMENT_IS_NODE) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = (init_path(), __toCommonJS(path_exports)).dirname(scriptDirectory) + "/";
          } else {
            scriptDirectory = __dirname + "/";
          }
          var fs, nodePath;
          if (typeof __require === "function") {
            fs = (init_fs(), __toCommonJS(fs_exports));
            nodePath = (init_path(), __toCommonJS(path_exports));
          }
          read_ = (filename, binary) => {
            filename = nodePath["normalize"](filename);
            return fs.readFileSync(filename, binary ? void 0 : "utf8");
          };
          readBinary = (filename) => {
            var ret = read_(filename, true);
            if (!ret.buffer) {
              ret = new Uint8Array(ret);
            }
            return ret;
          };
          readAsync = (filename, onload, onerror) => {
            filename = nodePath["normalize"](filename);
            fs.readFile(filename, function(err2, data) {
              if (err2) onerror(err2);
              else onload(data.buffer);
            });
          };
          if (process["argv"].length > 1) {
            thisProgram = process["argv"][1].replace(/\\/g, "/");
          }
          arguments_ = process["argv"].slice(2);
          if (typeof module != "undefined") {
            module["exports"] = Module2;
          }
          process["on"]("uncaughtException", function(ex) {
            if (!(ex instanceof ExitStatus)) {
              throw ex;
            }
          });
          process["on"]("unhandledRejection", function(reason) {
            throw reason;
          });
          quit_ = (status, toThrow) => {
            if (keepRuntimeAlive()) {
              process["exitCode"] = status;
              throw toThrow;
            }
            logExceptionOnExit(toThrow);
            process["exit"](status);
          };
          Module2["inspect"] = function() {
            return "[Emscripten Module object]";
          };
        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = self.location.href;
          } else if (typeof document != "undefined" && document.currentScript) {
            scriptDirectory = document.currentScript.src;
          }
          if (scriptDirectory.indexOf("blob:") !== 0) {
            scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
          } else {
            scriptDirectory = "";
          }
          {
            read_ = (url) => {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.send(null);
              return xhr.responseText;
            };
            if (ENVIRONMENT_IS_WORKER) {
              readBinary = (url) => {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(xhr.response);
              };
            }
            readAsync = (url, onload, onerror) => {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = () => {
                if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                  onload(xhr.response);
                  return;
                }
                onerror();
              };
              xhr.onerror = onerror;
              xhr.send(null);
            };
          }
          setWindowTitle = (title) => document.title = title;
        } else {
        }
        var out = Module2["print"] || console.log.bind(console);
        var err = Module2["printErr"] || console.warn.bind(console);
        Object.assign(Module2, moduleOverrides);
        moduleOverrides = null;
        if (Module2["arguments"]) arguments_ = Module2["arguments"];
        if (Module2["thisProgram"]) thisProgram = Module2["thisProgram"];
        if (Module2["quit"]) quit_ = Module2["quit"];
        var wasmBinary;
        if (Module2["wasmBinary"]) wasmBinary = Module2["wasmBinary"];
        var noExitRuntime = Module2["noExitRuntime"] || true;
        if (typeof WebAssembly != "object") {
          abort("no native wasm support detected");
        }
        var wasmMemory;
        var ABORT = false;
        var EXITSTATUS;
        function assert(condition, text) {
          if (!condition) {
            abort(text);
          }
        }
        var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
        function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
          var endIdx = idx + maxBytesToRead;
          var endPtr = idx;
          while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
          if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
            return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
          }
          var str = "";
          while (idx < endPtr) {
            var u0 = heapOrArray[idx++];
            if (!(u0 & 128)) {
              str += String.fromCharCode(u0);
              continue;
            }
            var u1 = heapOrArray[idx++] & 63;
            if ((u0 & 224) == 192) {
              str += String.fromCharCode((u0 & 31) << 6 | u1);
              continue;
            }
            var u2 = heapOrArray[idx++] & 63;
            if ((u0 & 240) == 224) {
              u0 = (u0 & 15) << 12 | u1 << 6 | u2;
            } else {
              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
            }
            if (u0 < 65536) {
              str += String.fromCharCode(u0);
            } else {
              var ch = u0 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            }
          }
          return str;
        }
        function UTF8ToString(ptr, maxBytesToRead) {
          return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
        }
        function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
          if (!(maxBytesToWrite > 0)) return 0;
          var startIdx = outIdx;
          var endIdx = outIdx + maxBytesToWrite - 1;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343) {
              var u1 = str.charCodeAt(++i);
              u = 65536 + ((u & 1023) << 10) | u1 & 1023;
            }
            if (u <= 127) {
              if (outIdx >= endIdx) break;
              heap[outIdx++] = u;
            } else if (u <= 2047) {
              if (outIdx + 1 >= endIdx) break;
              heap[outIdx++] = 192 | u >> 6;
              heap[outIdx++] = 128 | u & 63;
            } else if (u <= 65535) {
              if (outIdx + 2 >= endIdx) break;
              heap[outIdx++] = 224 | u >> 12;
              heap[outIdx++] = 128 | u >> 6 & 63;
              heap[outIdx++] = 128 | u & 63;
            } else {
              if (outIdx + 3 >= endIdx) break;
              heap[outIdx++] = 240 | u >> 18;
              heap[outIdx++] = 128 | u >> 12 & 63;
              heap[outIdx++] = 128 | u >> 6 & 63;
              heap[outIdx++] = 128 | u & 63;
            }
          }
          heap[outIdx] = 0;
          return outIdx - startIdx;
        }
        function lengthBytesUTF8(str) {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var c = str.charCodeAt(i);
            if (c <= 127) {
              len++;
            } else if (c <= 2047) {
              len += 2;
            } else if (c >= 55296 && c <= 57343) {
              len += 4;
              ++i;
            } else {
              len += 3;
            }
          }
          return len;
        }
        var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
        function updateGlobalBufferAndViews(buf) {
          buffer = buf;
          Module2["HEAP8"] = HEAP8 = new Int8Array(buf);
          Module2["HEAP16"] = HEAP16 = new Int16Array(buf);
          Module2["HEAP32"] = HEAP32 = new Int32Array(buf);
          Module2["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
          Module2["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
          Module2["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
          Module2["HEAPF32"] = HEAPF32 = new Float32Array(buf);
          Module2["HEAPF64"] = HEAPF64 = new Float64Array(buf);
        }
        var INITIAL_MEMORY = Module2["INITIAL_MEMORY"] || 16777216;
        var wasmTable;
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATPOSTRUN__ = [];
        var runtimeInitialized = false;
        function keepRuntimeAlive() {
          return noExitRuntime;
        }
        function preRun() {
          if (Module2["preRun"]) {
            if (typeof Module2["preRun"] == "function") Module2["preRun"] = [Module2["preRun"]];
            while (Module2["preRun"].length) {
              addOnPreRun(Module2["preRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPRERUN__);
        }
        function initRuntime() {
          runtimeInitialized = true;
          if (!Module2["noFSInit"] && !FS.init.initialized) FS.init();
          FS.ignorePermissions = false;
          TTY.init();
          callRuntimeCallbacks(__ATINIT__);
        }
        function postRun() {
          if (Module2["postRun"]) {
            if (typeof Module2["postRun"] == "function") Module2["postRun"] = [Module2["postRun"]];
            while (Module2["postRun"].length) {
              addOnPostRun(Module2["postRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPOSTRUN__);
        }
        function addOnPreRun(cb) {
          __ATPRERUN__.unshift(cb);
        }
        function addOnInit(cb) {
          __ATINIT__.unshift(cb);
        }
        function addOnPostRun(cb) {
          __ATPOSTRUN__.unshift(cb);
        }
        var runDependencies = 0;
        var runDependencyWatcher = null;
        var dependenciesFulfilled = null;
        function getUniqueRunDependency(id) {
          return id;
        }
        function addRunDependency(id) {
          runDependencies++;
          if (Module2["monitorRunDependencies"]) {
            Module2["monitorRunDependencies"](runDependencies);
          }
        }
        function removeRunDependency(id) {
          runDependencies--;
          if (Module2["monitorRunDependencies"]) {
            Module2["monitorRunDependencies"](runDependencies);
          }
          if (runDependencies == 0) {
            if (runDependencyWatcher !== null) {
              clearInterval(runDependencyWatcher);
              runDependencyWatcher = null;
            }
            if (dependenciesFulfilled) {
              var callback = dependenciesFulfilled;
              dependenciesFulfilled = null;
              callback();
            }
          }
        }
        function abort(what) {
          {
            if (Module2["onAbort"]) {
              Module2["onAbort"](what);
            }
          }
          what = "Aborted(" + what + ")";
          err(what);
          ABORT = true;
          EXITSTATUS = 1;
          what += ". Build with -sASSERTIONS for more info.";
          var e = new WebAssembly.RuntimeError(what);
          throw e;
        }
        var dataURIPrefix = "data:application/octet-stream;base64,";
        function isDataURI(filename) {
          return filename.startsWith(dataURIPrefix);
        }
        function isFileURI(filename) {
          return filename.startsWith("file://");
        }
        var wasmBinaryFile;
        wasmBinaryFile = "twgsl.wasm";
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = locateFile(wasmBinaryFile);
        }
        function getBinary(file) {
          try {
            if (file == wasmBinaryFile && wasmBinary) {
              return new Uint8Array(wasmBinary);
            }
            if (readBinary) {
              return readBinary(file);
            }
            throw "both async and sync fetching of the wasm failed";
          } catch (err2) {
            abort(err2);
          }
        }
        function getBinaryPromise() {
          if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
            if (typeof fetch == "function" && !isFileURI(wasmBinaryFile)) {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                if (!response["ok"]) {
                  throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                }
                return response["arrayBuffer"]();
              }).catch(function() {
                return getBinary(wasmBinaryFile);
              });
            } else {
              if (readAsync) {
                return new Promise(function(resolve, reject) {
                  readAsync(wasmBinaryFile, function(response) {
                    resolve(new Uint8Array(response));
                  }, reject);
                });
              }
            }
          }
          return Promise.resolve().then(function() {
            return getBinary(wasmBinaryFile);
          });
        }
        function createWasm() {
          var info = { "a": asmLibraryArg };
          function receiveInstance(instance, module2) {
            var exports3 = instance.exports;
            Module2["asm"] = exports3;
            wasmMemory = Module2["asm"]["o"];
            updateGlobalBufferAndViews(wasmMemory.buffer);
            wasmTable = Module2["asm"]["s"];
            addOnInit(Module2["asm"]["p"]);
            removeRunDependency("wasm-instantiate");
          }
          addRunDependency("wasm-instantiate");
          function receiveInstantiationResult(result) {
            receiveInstance(result["instance"]);
          }
          function instantiateArrayBuffer(receiver) {
            return getBinaryPromise().then(function(binary) {
              return WebAssembly.instantiate(binary, info);
            }).then(function(instance) {
              return instance;
            }).then(receiver, function(reason) {
              err("failed to asynchronously prepare wasm: " + reason);
              abort(reason);
            });
          }
          function instantiateAsync() {
            if (!wasmBinary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                var result = WebAssembly.instantiateStreaming(response, info);
                return result.then(receiveInstantiationResult, function(reason) {
                  err("wasm streaming compile failed: " + reason);
                  err("falling back to ArrayBuffer instantiation");
                  return instantiateArrayBuffer(receiveInstantiationResult);
                });
              });
            } else {
              return instantiateArrayBuffer(receiveInstantiationResult);
            }
          }
          if (Module2["instantiateWasm"]) {
            try {
              var exports2 = Module2["instantiateWasm"](info, receiveInstance);
              return exports2;
            } catch (e) {
              err("Module.instantiateWasm callback failed with error: " + e);
              return false;
            }
          }
          instantiateAsync();
          return {};
        }
        var tempDouble;
        var tempI64;
        function ExitStatus(status) {
          this.name = "ExitStatus";
          this.message = "Program terminated with exit(" + status + ")";
          this.status = status;
        }
        function callRuntimeCallbacks(callbacks) {
          while (callbacks.length > 0) {
            callbacks.shift()(Module2);
          }
        }
        function ___assert_fail(condition, filename, line, func) {
          abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
        }
        function ___cxa_allocate_exception(size) {
          return _malloc(size + 24) + 24;
        }
        function ExceptionInfo(excPtr) {
          this.excPtr = excPtr;
          this.ptr = excPtr - 24;
          this.set_type = function(type) {
            HEAPU32[this.ptr + 4 >> 2] = type;
          };
          this.get_type = function() {
            return HEAPU32[this.ptr + 4 >> 2];
          };
          this.set_destructor = function(destructor) {
            HEAPU32[this.ptr + 8 >> 2] = destructor;
          };
          this.get_destructor = function() {
            return HEAPU32[this.ptr + 8 >> 2];
          };
          this.set_refcount = function(refcount) {
            HEAP32[this.ptr >> 2] = refcount;
          };
          this.set_caught = function(caught) {
            caught = caught ? 1 : 0;
            HEAP8[this.ptr + 12 >> 0] = caught;
          };
          this.get_caught = function() {
            return HEAP8[this.ptr + 12 >> 0] != 0;
          };
          this.set_rethrown = function(rethrown) {
            rethrown = rethrown ? 1 : 0;
            HEAP8[this.ptr + 13 >> 0] = rethrown;
          };
          this.get_rethrown = function() {
            return HEAP8[this.ptr + 13 >> 0] != 0;
          };
          this.init = function(type, destructor) {
            this.set_adjusted_ptr(0);
            this.set_type(type);
            this.set_destructor(destructor);
            this.set_refcount(0);
            this.set_caught(false);
            this.set_rethrown(false);
          };
          this.add_ref = function() {
            var value = HEAP32[this.ptr >> 2];
            HEAP32[this.ptr >> 2] = value + 1;
          };
          this.release_ref = function() {
            var prev = HEAP32[this.ptr >> 2];
            HEAP32[this.ptr >> 2] = prev - 1;
            return prev === 1;
          };
          this.set_adjusted_ptr = function(adjustedPtr) {
            HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;
          };
          this.get_adjusted_ptr = function() {
            return HEAPU32[this.ptr + 16 >> 2];
          };
          this.get_exception_ptr = function() {
            var isPointer = ___cxa_is_pointer_type(this.get_type());
            if (isPointer) {
              return HEAPU32[this.excPtr >> 2];
            }
            var adjusted = this.get_adjusted_ptr();
            if (adjusted !== 0) return adjusted;
            return this.excPtr;
          };
        }
        var exceptionLast = 0;
        var uncaughtExceptionCount = 0;
        function ___cxa_throw(ptr, type, destructor) {
          var info = new ExceptionInfo(ptr);
          info.init(type, destructor);
          exceptionLast = ptr;
          uncaughtExceptionCount++;
          throw ptr;
        }
        function _abort() {
          abort("");
        }
        function getHeapMax() {
          return 2147483648;
        }
        function emscripten_realloc_buffer(size) {
          try {
            wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
            updateGlobalBufferAndViews(wasmMemory.buffer);
            return 1;
          } catch (e) {
          }
        }
        function _emscripten_resize_heap(requestedSize) {
          var oldSize = HEAPU8.length;
          requestedSize = requestedSize >>> 0;
          var maxHeapSize = getHeapMax();
          if (requestedSize > maxHeapSize) {
            return false;
          }
          let alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
          for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
            var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
            overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
            var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
            var replacement = emscripten_realloc_buffer(newSize);
            if (replacement) {
              return true;
            }
          }
          return false;
        }
        var ENV = {};
        function getExecutableName() {
          return thisProgram || "./this.program";
        }
        function getEnvStrings() {
          if (!getEnvStrings.strings) {
            var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
            var env = { "USER": "web_user", "LOGNAME": "web_user", "PATH": "/", "PWD": "/", "HOME": "/home/web_user", "LANG": lang, "_": getExecutableName() };
            for (var x in ENV) {
              if (ENV[x] === void 0) delete env[x];
              else env[x] = ENV[x];
            }
            var strings = [];
            for (var x in env) {
              strings.push(x + "=" + env[x]);
            }
            getEnvStrings.strings = strings;
          }
          return getEnvStrings.strings;
        }
        function writeAsciiToMemory(str, buffer2, dontAddNull) {
          for (var i = 0; i < str.length; ++i) {
            HEAP8[buffer2++ >> 0] = str.charCodeAt(i);
          }
          if (!dontAddNull) HEAP8[buffer2 >> 0] = 0;
        }
        var PATH = { isAbs: (path) => path.charAt(0) === "/", splitPath: (filename) => {
          var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
          return splitPathRe.exec(filename).slice(1);
        }, normalizeArray: (parts, allowAboveRoot) => {
          var up = 0;
          for (var i = parts.length - 1; i >= 0; i--) {
            var last = parts[i];
            if (last === ".") {
              parts.splice(i, 1);
            } else if (last === "..") {
              parts.splice(i, 1);
              up++;
            } else if (up) {
              parts.splice(i, 1);
              up--;
            }
          }
          if (allowAboveRoot) {
            for (; up; up--) {
              parts.unshift("..");
            }
          }
          return parts;
        }, normalize: (path) => {
          var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
          path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
          if (!path && !isAbsolute) {
            path = ".";
          }
          if (path && trailingSlash) {
            path += "/";
          }
          return (isAbsolute ? "/" : "") + path;
        }, dirname: (path) => {
          var result = PATH.splitPath(path), root = result[0], dir = result[1];
          if (!root && !dir) {
            return ".";
          }
          if (dir) {
            dir = dir.substr(0, dir.length - 1);
          }
          return root + dir;
        }, basename: (path) => {
          if (path === "/") return "/";
          path = PATH.normalize(path);
          path = path.replace(/\/$/, "");
          var lastSlash = path.lastIndexOf("/");
          if (lastSlash === -1) return path;
          return path.substr(lastSlash + 1);
        }, join: function() {
          var paths = Array.prototype.slice.call(arguments);
          return PATH.normalize(paths.join("/"));
        }, join2: (l, r) => {
          return PATH.normalize(l + "/" + r);
        } };
        function getRandomDevice() {
          if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
            var randomBuffer = new Uint8Array(1);
            return () => {
              crypto.getRandomValues(randomBuffer);
              return randomBuffer[0];
            };
          } else if (ENVIRONMENT_IS_NODE) {
            try {
              var crypto_module = (init_crypto(), __toCommonJS(crypto_exports));
              return () => crypto_module["randomBytes"](1)[0];
            } catch (e) {
            }
          }
          return () => abort("randomDevice");
        }
        var PATH_FS = { resolve: function() {
          var resolvedPath = "", resolvedAbsolute = false;
          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path = i >= 0 ? arguments[i] : FS.cwd();
            if (typeof path != "string") {
              throw new TypeError("Arguments to path.resolve must be strings");
            } else if (!path) {
              return "";
            }
            resolvedPath = path + "/" + resolvedPath;
            resolvedAbsolute = PATH.isAbs(path);
          }
          resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
          return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
        }, relative: (from, to) => {
          from = PATH_FS.resolve(from).substr(1);
          to = PATH_FS.resolve(to).substr(1);
          function trim(arr) {
            var start = 0;
            for (; start < arr.length; start++) {
              if (arr[start] !== "") break;
            }
            var end = arr.length - 1;
            for (; end >= 0; end--) {
              if (arr[end] !== "") break;
            }
            if (start > end) return [];
            return arr.slice(start, end - start + 1);
          }
          var fromParts = trim(from.split("/"));
          var toParts = trim(to.split("/"));
          var length = Math.min(fromParts.length, toParts.length);
          var samePartsLength = length;
          for (var i = 0; i < length; i++) {
            if (fromParts[i] !== toParts[i]) {
              samePartsLength = i;
              break;
            }
          }
          var outputParts = [];
          for (var i = samePartsLength; i < fromParts.length; i++) {
            outputParts.push("..");
          }
          outputParts = outputParts.concat(toParts.slice(samePartsLength));
          return outputParts.join("/");
        } };
        function intArrayFromString(stringy, dontAddNull, length) {
          var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
          var u8array = new Array(len);
          var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
          if (dontAddNull) u8array.length = numBytesWritten;
          return u8array;
        }
        var TTY = { ttys: [], init: function() {
        }, shutdown: function() {
        }, register: function(dev, ops) {
          TTY.ttys[dev] = { input: [], output: [], ops };
          FS.registerDevice(dev, TTY.stream_ops);
        }, stream_ops: { open: function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        }, close: function(stream) {
          stream.tty.ops.fsync(stream.tty);
        }, fsync: function(stream) {
          stream.tty.ops.fsync(stream.tty);
        }, read: function(stream, buffer2, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0) break;
            bytesRead++;
            buffer2[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        }, write: function(stream, buffer2, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer2[offset + i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        } }, default_tty_ops: { get_char: function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              var BUFSIZE = 256;
              var buf = Buffer.alloc(BUFSIZE);
              var bytesRead = 0;
              try {
                bytesRead = fs.readSync(process.stdin.fd, buf, 0, BUFSIZE, -1);
              } catch (e) {
                if (e.toString().includes("EOF")) bytesRead = 0;
                else throw e;
              }
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString("utf-8");
              } else {
                result = null;
              }
            } else if (typeof window != "undefined" && typeof window.prompt == "function") {
              result = window.prompt("Input: ");
              if (result !== null) {
                result += "\n";
              }
            } else if (typeof readline == "function") {
              result = readline();
              if (result !== null) {
                result += "\n";
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        }, put_char: function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        }, fsync: function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        } }, default_tty1_ops: { put_char: function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        }, fsync: function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        } } };
        function mmapAlloc(size) {
          abort();
        }
        var MEMFS = { ops_table: null, mount: function(mount) {
          return MEMFS.createNode(null, "/", 16384 | 511, 0);
        }, createNode: function(parent, name, mode, dev) {
          if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
            throw new FS.ErrnoError(63);
          }
          if (!MEMFS.ops_table) {
            MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } };
          }
          var node = FS.createNode(parent, name, mode, dev);
          if (FS.isDir(node.mode)) {
            node.node_ops = MEMFS.ops_table.dir.node;
            node.stream_ops = MEMFS.ops_table.dir.stream;
            node.contents = {};
          } else if (FS.isFile(node.mode)) {
            node.node_ops = MEMFS.ops_table.file.node;
            node.stream_ops = MEMFS.ops_table.file.stream;
            node.usedBytes = 0;
            node.contents = null;
          } else if (FS.isLink(node.mode)) {
            node.node_ops = MEMFS.ops_table.link.node;
            node.stream_ops = MEMFS.ops_table.link.stream;
          } else if (FS.isChrdev(node.mode)) {
            node.node_ops = MEMFS.ops_table.chrdev.node;
            node.stream_ops = MEMFS.ops_table.chrdev.stream;
          }
          node.timestamp = Date.now();
          if (parent) {
            parent.contents[name] = node;
            parent.timestamp = node.timestamp;
          }
          return node;
        }, getFileDataAsTypedArray: function(node) {
          if (!node.contents) return new Uint8Array(0);
          if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);
          return new Uint8Array(node.contents);
        }, expandFileStorage: function(node, newCapacity) {
          var prevCapacity = node.contents ? node.contents.length : 0;
          if (prevCapacity >= newCapacity) return;
          var CAPACITY_DOUBLING_MAX = 1024 * 1024;
          newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
          if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
          var oldContents = node.contents;
          node.contents = new Uint8Array(newCapacity);
          if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
        }, resizeFileStorage: function(node, newSize) {
          if (node.usedBytes == newSize) return;
          if (newSize == 0) {
            node.contents = null;
            node.usedBytes = 0;
          } else {
            var oldContents = node.contents;
            node.contents = new Uint8Array(newSize);
            if (oldContents) {
              node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
            }
            node.usedBytes = newSize;
          }
        }, node_ops: { getattr: function(node) {
          var attr = {};
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        }, setattr: function(node, attr) {
          if (attr.mode !== void 0) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== void 0) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        }, lookup: function(parent, name) {
          throw FS.genericErrors[44];
        }, mknod: function(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        }, rename: function(old_node, new_dir, new_name) {
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now();
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        }, unlink: function(parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        }, rmdir: function(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        }, readdir: function(node) {
          var entries = [".", ".."];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        }, symlink: function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
          node.link = oldpath;
          return node;
        }, readlink: function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        } }, stream_ops: { read: function(stream, buffer2, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) {
            buffer2.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer2[offset + i] = contents[position + i];
          }
          return size;
        }, write: function(stream, buffer2, offset, length, position, canOwn) {
          if (buffer2.buffer === HEAP8.buffer) {
            canOwn = false;
          }
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
          if (buffer2.subarray && (!node.contents || node.contents.subarray)) {
            if (canOwn) {
              node.contents = buffer2.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) {
              node.contents = buffer2.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) {
              node.contents.set(buffer2.subarray(offset, offset + length), position);
              return length;
            }
          }
          MEMFS.expandFileStorage(node, position + length);
          if (node.contents.subarray && buffer2.subarray) {
            node.contents.set(buffer2.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
              node.contents[position + i] = buffer2[offset + i];
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        }, llseek: function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        }, allocate: function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        }, mmap: function(stream, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          if (!(flags & 2) && contents.buffer === buffer) {
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            HEAP8.set(contents, ptr);
          }
          return { ptr, allocated };
        }, msync: function(stream, buffer2, offset, length, mmapFlags) {
          MEMFS.stream_ops.write(stream, buffer2, 0, length, offset, false);
          return 0;
        } } };
        function asyncLoad(url, onload, onerror, noRunDep) {
          var dep = !noRunDep ? getUniqueRunDependency("al " + url) : "";
          readAsync(url, (arrayBuffer) => {
            assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
            onload(new Uint8Array(arrayBuffer));
            if (dep) removeRunDependency(dep);
          }, (event) => {
            if (onerror) {
              onerror();
            } else {
              throw 'Loading data file "' + url + '" failed.';
            }
          });
          if (dep) addRunDependency(dep);
        }
        var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath: (path, opts = {}) => {
          path = PATH_FS.resolve(FS.cwd(), path);
          if (!path) return { path: "", node: null };
          var defaults = { follow_mount: true, recurse_count: 0 };
          opts = Object.assign(defaults, opts);
          if (opts.recurse_count > 8) {
            throw new FS.ErrnoError(32);
          }
          var parts = PATH.normalizeArray(path.split("/").filter((p) => !!p), false);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            current = FS.lookupNode(current, parts[i]);
            current_path = PATH.join2(current_path, parts[i]);
            if (FS.isMountpoint(current)) {
              if (!islast || islast && opts.follow_mount) {
                current = current.mounted.root;
              }
            }
            if (!islast || opts.follow) {
              var count = 0;
              while (FS.isLink(current.mode)) {
                var link = FS.readlink(current_path);
                current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });
                current = lookup.node;
                if (count++ > 40) {
                  throw new FS.ErrnoError(32);
                }
              }
            }
          }
          return { path: current_path, node: current };
        }, getPath: (node) => {
          var path;
          while (true) {
            if (FS.isRoot(node)) {
              var mount = node.mount.mountpoint;
              if (!path) return mount;
              return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
            }
            path = path ? node.name + "/" + path : node.name;
            node = node.parent;
          }
        }, hashName: (parentid, name) => {
          var hash = 0;
          for (var i = 0; i < name.length; i++) {
            hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
          }
          return (parentid + hash >>> 0) % FS.nameTable.length;
        }, hashAddNode: (node) => {
          var hash = FS.hashName(node.parent.id, node.name);
          node.name_next = FS.nameTable[hash];
          FS.nameTable[hash] = node;
        }, hashRemoveNode: (node) => {
          var hash = FS.hashName(node.parent.id, node.name);
          if (FS.nameTable[hash] === node) {
            FS.nameTable[hash] = node.name_next;
          } else {
            var current = FS.nameTable[hash];
            while (current) {
              if (current.name_next === node) {
                current.name_next = node.name_next;
                break;
              }
              current = current.name_next;
            }
          }
        }, lookupNode: (parent, name) => {
          var errCode = FS.mayLookup(parent);
          if (errCode) {
            throw new FS.ErrnoError(errCode, parent);
          }
          var hash = FS.hashName(parent.id, name);
          for (var node = FS.nameTable[hash]; node; node = node.name_next) {
            var nodeName = node.name;
            if (node.parent.id === parent.id && nodeName === name) {
              return node;
            }
          }
          return FS.lookup(parent, name);
        }, createNode: (parent, name, mode, rdev) => {
          var node = new FS.FSNode(parent, name, mode, rdev);
          FS.hashAddNode(node);
          return node;
        }, destroyNode: (node) => {
          FS.hashRemoveNode(node);
        }, isRoot: (node) => {
          return node === node.parent;
        }, isMountpoint: (node) => {
          return !!node.mounted;
        }, isFile: (mode) => {
          return (mode & 61440) === 32768;
        }, isDir: (mode) => {
          return (mode & 61440) === 16384;
        }, isLink: (mode) => {
          return (mode & 61440) === 40960;
        }, isChrdev: (mode) => {
          return (mode & 61440) === 8192;
        }, isBlkdev: (mode) => {
          return (mode & 61440) === 24576;
        }, isFIFO: (mode) => {
          return (mode & 61440) === 4096;
        }, isSocket: (mode) => {
          return (mode & 49152) === 49152;
        }, flagModes: { "r": 0, "r+": 2, "w": 577, "w+": 578, "a": 1089, "a+": 1090 }, modeStringToFlags: (str) => {
          var flags = FS.flagModes[str];
          if (typeof flags == "undefined") {
            throw new Error("Unknown file open mode: " + str);
          }
          return flags;
        }, flagsToPermissionString: (flag) => {
          var perms = ["r", "w", "rw"][flag & 3];
          if (flag & 512) {
            perms += "w";
          }
          return perms;
        }, nodePermissions: (node, perms) => {
          if (FS.ignorePermissions) {
            return 0;
          }
          if (perms.includes("r") && !(node.mode & 292)) {
            return 2;
          } else if (perms.includes("w") && !(node.mode & 146)) {
            return 2;
          } else if (perms.includes("x") && !(node.mode & 73)) {
            return 2;
          }
          return 0;
        }, mayLookup: (dir) => {
          var errCode = FS.nodePermissions(dir, "x");
          if (errCode) return errCode;
          if (!dir.node_ops.lookup) return 2;
          return 0;
        }, mayCreate: (dir, name) => {
          try {
            var node = FS.lookupNode(dir, name);
            return 20;
          } catch (e) {
          }
          return FS.nodePermissions(dir, "wx");
        }, mayDelete: (dir, name, isdir) => {
          var node;
          try {
            node = FS.lookupNode(dir, name);
          } catch (e) {
            return e.errno;
          }
          var errCode = FS.nodePermissions(dir, "wx");
          if (errCode) {
            return errCode;
          }
          if (isdir) {
            if (!FS.isDir(node.mode)) {
              return 54;
            }
            if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
              return 10;
            }
          } else {
            if (FS.isDir(node.mode)) {
              return 31;
            }
          }
          return 0;
        }, mayOpen: (node, flags) => {
          if (!node) {
            return 44;
          }
          if (FS.isLink(node.mode)) {
            return 32;
          } else if (FS.isDir(node.mode)) {
            if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
              return 31;
            }
          }
          return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
        }, MAX_OPEN_FDS: 4096, nextfd: (fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {
          for (var fd = fd_start; fd <= fd_end; fd++) {
            if (!FS.streams[fd]) {
              return fd;
            }
          }
          throw new FS.ErrnoError(33);
        }, getStream: (fd) => FS.streams[fd], createStream: (stream, fd_start, fd_end) => {
          if (!FS.FSStream) {
            FS.FSStream = function() {
              this.shared = {};
            };
            FS.FSStream.prototype = {};
            Object.defineProperties(FS.FSStream.prototype, { object: { get: function() {
              return this.node;
            }, set: function(val) {
              this.node = val;
            } }, isRead: { get: function() {
              return (this.flags & 2097155) !== 1;
            } }, isWrite: { get: function() {
              return (this.flags & 2097155) !== 0;
            } }, isAppend: { get: function() {
              return this.flags & 1024;
            } }, flags: { get: function() {
              return this.shared.flags;
            }, set: function(val) {
              this.shared.flags = val;
            } }, position: { get: function() {
              return this.shared.position;
            }, set: function(val) {
              this.shared.position = val;
            } } });
          }
          stream = Object.assign(new FS.FSStream(), stream);
          var fd = FS.nextfd(fd_start, fd_end);
          stream.fd = fd;
          FS.streams[fd] = stream;
          return stream;
        }, closeStream: (fd) => {
          FS.streams[fd] = null;
        }, chrdev_stream_ops: { open: (stream) => {
          var device = FS.getDevice(stream.node.rdev);
          stream.stream_ops = device.stream_ops;
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        }, llseek: () => {
          throw new FS.ErrnoError(70);
        } }, major: (dev) => dev >> 8, minor: (dev) => dev & 255, makedev: (ma, mi) => ma << 8 | mi, registerDevice: (dev, ops) => {
          FS.devices[dev] = { stream_ops: ops };
        }, getDevice: (dev) => FS.devices[dev], getMounts: (mount) => {
          var mounts = [];
          var check2 = [mount];
          while (check2.length) {
            var m = check2.pop();
            mounts.push(m);
            check2.push.apply(check2, m.mounts);
          }
          return mounts;
        }, syncfs: (populate, callback) => {
          if (typeof populate == "function") {
            callback = populate;
            populate = false;
          }
          FS.syncFSRequests++;
          if (FS.syncFSRequests > 1) {
            err("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
          }
          var mounts = FS.getMounts(FS.root.mount);
          var completed = 0;
          function doCallback(errCode) {
            FS.syncFSRequests--;
            return callback(errCode);
          }
          function done(errCode) {
            if (errCode) {
              if (!done.errored) {
                done.errored = true;
                return doCallback(errCode);
              }
              return;
            }
            if (++completed >= mounts.length) {
              doCallback(null);
            }
          }
          mounts.forEach((mount) => {
            if (!mount.type.syncfs) {
              return done(null);
            }
            mount.type.syncfs(mount, populate, done);
          });
        }, mount: (type, opts, mountpoint) => {
          var root = mountpoint === "/";
          var pseudo = !mountpoint;
          var node;
          if (root && FS.root) {
            throw new FS.ErrnoError(10);
          } else if (!root && !pseudo) {
            var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
            mountpoint = lookup.path;
            node = lookup.node;
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            if (!FS.isDir(node.mode)) {
              throw new FS.ErrnoError(54);
            }
          }
          var mount = { type, opts, mountpoint, mounts: [] };
          var mountRoot = type.mount(mount);
          mountRoot.mount = mount;
          mount.root = mountRoot;
          if (root) {
            FS.root = mountRoot;
          } else if (node) {
            node.mounted = mount;
            if (node.mount) {
              node.mount.mounts.push(mount);
            }
          }
          return mountRoot;
        }, unmount: (mountpoint) => {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
          if (!FS.isMountpoint(lookup.node)) {
            throw new FS.ErrnoError(28);
          }
          var node = lookup.node;
          var mount = node.mounted;
          var mounts = FS.getMounts(mount);
          Object.keys(FS.nameTable).forEach((hash) => {
            var current = FS.nameTable[hash];
            while (current) {
              var next = current.name_next;
              if (mounts.includes(current.mount)) {
                FS.destroyNode(current);
              }
              current = next;
            }
          });
          node.mounted = null;
          var idx = node.mount.mounts.indexOf(mount);
          node.mount.mounts.splice(idx, 1);
        }, lookup: (parent, name) => {
          return parent.node_ops.lookup(parent, name);
        }, mknod: (path, mode, dev) => {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name = PATH.basename(path);
          if (!name || name === "." || name === "..") {
            throw new FS.ErrnoError(28);
          }
          var errCode = FS.mayCreate(parent, name);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.mknod) {
            throw new FS.ErrnoError(63);
          }
          return parent.node_ops.mknod(parent, name, mode, dev);
        }, create: (path, mode) => {
          mode = mode !== void 0 ? mode : 438;
          mode &= 4095;
          mode |= 32768;
          return FS.mknod(path, mode, 0);
        }, mkdir: (path, mode) => {
          mode = mode !== void 0 ? mode : 511;
          mode &= 511 | 512;
          mode |= 16384;
          return FS.mknod(path, mode, 0);
        }, mkdirTree: (path, mode) => {
          var dirs = path.split("/");
          var d = "";
          for (var i = 0; i < dirs.length; ++i) {
            if (!dirs[i]) continue;
            d += "/" + dirs[i];
            try {
              FS.mkdir(d, mode);
            } catch (e) {
              if (e.errno != 20) throw e;
            }
          }
        }, mkdev: (path, mode, dev) => {
          if (typeof dev == "undefined") {
            dev = mode;
            mode = 438;
          }
          mode |= 8192;
          return FS.mknod(path, mode, dev);
        }, symlink: (oldpath, newpath) => {
          if (!PATH_FS.resolve(oldpath)) {
            throw new FS.ErrnoError(44);
          }
          var lookup = FS.lookupPath(newpath, { parent: true });
          var parent = lookup.node;
          if (!parent) {
            throw new FS.ErrnoError(44);
          }
          var newname = PATH.basename(newpath);
          var errCode = FS.mayCreate(parent, newname);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.symlink) {
            throw new FS.ErrnoError(63);
          }
          return parent.node_ops.symlink(parent, newname, oldpath);
        }, rename: (old_path, new_path) => {
          var old_dirname = PATH.dirname(old_path);
          var new_dirname = PATH.dirname(new_path);
          var old_name = PATH.basename(old_path);
          var new_name = PATH.basename(new_path);
          var lookup, old_dir, new_dir;
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
          if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
          if (old_dir.mount !== new_dir.mount) {
            throw new FS.ErrnoError(75);
          }
          var old_node = FS.lookupNode(old_dir, old_name);
          var relative = PATH_FS.relative(old_path, new_dirname);
          if (relative.charAt(0) !== ".") {
            throw new FS.ErrnoError(28);
          }
          relative = PATH_FS.relative(new_path, old_dirname);
          if (relative.charAt(0) !== ".") {
            throw new FS.ErrnoError(55);
          }
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (old_node === new_node) {
            return;
          }
          var isdir = FS.isDir(old_node.mode);
          var errCode = FS.mayDelete(old_dir, old_name, isdir);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!old_dir.node_ops.rename) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
            throw new FS.ErrnoError(10);
          }
          if (new_dir !== old_dir) {
            errCode = FS.nodePermissions(old_dir, "w");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
          }
          FS.hashRemoveNode(old_node);
          try {
            old_dir.node_ops.rename(old_node, new_dir, new_name);
          } catch (e) {
            throw e;
          } finally {
            FS.hashAddNode(old_node);
          }
        }, rmdir: (path) => {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name = PATH.basename(path);
          var node = FS.lookupNode(parent, name);
          var errCode = FS.mayDelete(parent, name, true);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.rmdir) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          parent.node_ops.rmdir(parent, name);
          FS.destroyNode(node);
        }, readdir: (path) => {
          var lookup = FS.lookupPath(path, { follow: true });
          var node = lookup.node;
          if (!node.node_ops.readdir) {
            throw new FS.ErrnoError(54);
          }
          return node.node_ops.readdir(node);
        }, unlink: (path) => {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          if (!parent) {
            throw new FS.ErrnoError(44);
          }
          var name = PATH.basename(path);
          var node = FS.lookupNode(parent, name);
          var errCode = FS.mayDelete(parent, name, false);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.unlink) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          parent.node_ops.unlink(parent, name);
          FS.destroyNode(node);
        }, readlink: (path) => {
          var lookup = FS.lookupPath(path);
          var link = lookup.node;
          if (!link) {
            throw new FS.ErrnoError(44);
          }
          if (!link.node_ops.readlink) {
            throw new FS.ErrnoError(28);
          }
          return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
        }, stat: (path, dontFollow) => {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          var node = lookup.node;
          if (!node) {
            throw new FS.ErrnoError(44);
          }
          if (!node.node_ops.getattr) {
            throw new FS.ErrnoError(63);
          }
          return node.node_ops.getattr(node);
        }, lstat: (path) => {
          return FS.stat(path, true);
        }, chmod: (path, mode, dontFollow) => {
          var node;
          if (typeof path == "string") {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() });
        }, lchmod: (path, mode) => {
          FS.chmod(path, mode, true);
        }, fchmod: (fd, mode) => {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          FS.chmod(stream.node, mode);
        }, chown: (path, uid, gid, dontFollow) => {
          var node;
          if (typeof path == "string") {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          node.node_ops.setattr(node, { timestamp: Date.now() });
        }, lchown: (path, uid, gid) => {
          FS.chown(path, uid, gid, true);
        }, fchown: (fd, uid, gid) => {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          FS.chown(stream.node, uid, gid);
        }, truncate: (path, len) => {
          if (len < 0) {
            throw new FS.ErrnoError(28);
          }
          var node;
          if (typeof path == "string") {
            var lookup = FS.lookupPath(path, { follow: true });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isDir(node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!FS.isFile(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          var errCode = FS.nodePermissions(node, "w");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
        }, ftruncate: (fd, len) => {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(28);
          }
          FS.truncate(stream.node, len);
        }, utime: (path, atime, mtime) => {
          var lookup = FS.lookupPath(path, { follow: true });
          var node = lookup.node;
          node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
        }, open: (path, flags, mode) => {
          if (path === "") {
            throw new FS.ErrnoError(44);
          }
          flags = typeof flags == "string" ? FS.modeStringToFlags(flags) : flags;
          mode = typeof mode == "undefined" ? 438 : mode;
          if (flags & 64) {
            mode = mode & 4095 | 32768;
          } else {
            mode = 0;
          }
          var node;
          if (typeof path == "object") {
            node = path;
          } else {
            path = PATH.normalize(path);
            try {
              var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
              node = lookup.node;
            } catch (e) {
            }
          }
          var created = false;
          if (flags & 64) {
            if (node) {
              if (flags & 128) {
                throw new FS.ErrnoError(20);
              }
            } else {
              node = FS.mknod(path, mode, 0);
              created = true;
            }
          }
          if (!node) {
            throw new FS.ErrnoError(44);
          }
          if (FS.isChrdev(node.mode)) {
            flags &= ~512;
          }
          if (flags & 65536 && !FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
          if (!created) {
            var errCode = FS.mayOpen(node, flags);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
          }
          if (flags & 512 && !created) {
            FS.truncate(node, 0);
          }
          flags &= ~(128 | 512 | 131072);
          var stream = FS.createStream({ node, path: FS.getPath(node), flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false });
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
          if (Module2["logReadFiles"] && !(flags & 1)) {
            if (!FS.readFiles) FS.readFiles = {};
            if (!(path in FS.readFiles)) {
              FS.readFiles[path] = 1;
            }
          }
          return stream;
        }, close: (stream) => {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (stream.getdents) stream.getdents = null;
          try {
            if (stream.stream_ops.close) {
              stream.stream_ops.close(stream);
            }
          } catch (e) {
            throw e;
          } finally {
            FS.closeStream(stream.fd);
          }
          stream.fd = null;
        }, isClosed: (stream) => {
          return stream.fd === null;
        }, llseek: (stream, offset, whence) => {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (!stream.seekable || !stream.stream_ops.llseek) {
            throw new FS.ErrnoError(70);
          }
          if (whence != 0 && whence != 1 && whence != 2) {
            throw new FS.ErrnoError(28);
          }
          stream.position = stream.stream_ops.llseek(stream, offset, whence);
          stream.ungotten = [];
          return stream.position;
        }, read: (stream, buffer2, offset, length, position) => {
          if (length < 0 || position < 0) {
            throw new FS.ErrnoError(28);
          }
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 1) {
            throw new FS.ErrnoError(8);
          }
          if (FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!stream.stream_ops.read) {
            throw new FS.ErrnoError(28);
          }
          var seeking = typeof position != "undefined";
          if (!seeking) {
            position = stream.position;
          } else if (!stream.seekable) {
            throw new FS.ErrnoError(70);
          }
          var bytesRead = stream.stream_ops.read(stream, buffer2, offset, length, position);
          if (!seeking) stream.position += bytesRead;
          return bytesRead;
        }, write: (stream, buffer2, offset, length, position, canOwn) => {
          if (length < 0 || position < 0) {
            throw new FS.ErrnoError(28);
          }
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(8);
          }
          if (FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!stream.stream_ops.write) {
            throw new FS.ErrnoError(28);
          }
          if (stream.seekable && stream.flags & 1024) {
            FS.llseek(stream, 0, 2);
          }
          var seeking = typeof position != "undefined";
          if (!seeking) {
            position = stream.position;
          } else if (!stream.seekable) {
            throw new FS.ErrnoError(70);
          }
          var bytesWritten = stream.stream_ops.write(stream, buffer2, offset, length, position, canOwn);
          if (!seeking) stream.position += bytesWritten;
          return bytesWritten;
        }, allocate: (stream, offset, length) => {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (offset < 0 || length <= 0) {
            throw new FS.ErrnoError(28);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(8);
          }
          if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (!stream.stream_ops.allocate) {
            throw new FS.ErrnoError(138);
          }
          stream.stream_ops.allocate(stream, offset, length);
        }, mmap: (stream, length, position, prot, flags) => {
          if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
            throw new FS.ErrnoError(2);
          }
          if ((stream.flags & 2097155) === 1) {
            throw new FS.ErrnoError(2);
          }
          if (!stream.stream_ops.mmap) {
            throw new FS.ErrnoError(43);
          }
          return stream.stream_ops.mmap(stream, length, position, prot, flags);
        }, msync: (stream, buffer2, offset, length, mmapFlags) => {
          if (!stream.stream_ops.msync) {
            return 0;
          }
          return stream.stream_ops.msync(stream, buffer2, offset, length, mmapFlags);
        }, munmap: (stream) => 0, ioctl: (stream, cmd, arg) => {
          if (!stream.stream_ops.ioctl) {
            throw new FS.ErrnoError(59);
          }
          return stream.stream_ops.ioctl(stream, cmd, arg);
        }, readFile: (path, opts = {}) => {
          opts.flags = opts.flags || 0;
          opts.encoding = opts.encoding || "binary";
          if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
            throw new Error('Invalid encoding type "' + opts.encoding + '"');
          }
          var ret;
          var stream = FS.open(path, opts.flags);
          var stat = FS.stat(path);
          var length = stat.size;
          var buf = new Uint8Array(length);
          FS.read(stream, buf, 0, length, 0);
          if (opts.encoding === "utf8") {
            ret = UTF8ArrayToString(buf, 0);
          } else if (opts.encoding === "binary") {
            ret = buf;
          }
          FS.close(stream);
          return ret;
        }, writeFile: (path, data, opts = {}) => {
          opts.flags = opts.flags || 577;
          var stream = FS.open(path, opts.flags, opts.mode);
          if (typeof data == "string") {
            var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
            var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
            FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
          } else if (ArrayBuffer.isView(data)) {
            FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
          } else {
            throw new Error("Unsupported data type");
          }
          FS.close(stream);
        }, cwd: () => FS.currentPath, chdir: (path) => {
          var lookup = FS.lookupPath(path, { follow: true });
          if (lookup.node === null) {
            throw new FS.ErrnoError(44);
          }
          if (!FS.isDir(lookup.node.mode)) {
            throw new FS.ErrnoError(54);
          }
          var errCode = FS.nodePermissions(lookup.node, "x");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          FS.currentPath = lookup.path;
        }, createDefaultDirectories: () => {
          FS.mkdir("/tmp");
          FS.mkdir("/home");
          FS.mkdir("/home/web_user");
        }, createDefaultDevices: () => {
          FS.mkdir("/dev");
          FS.registerDevice(FS.makedev(1, 3), { read: () => 0, write: (stream, buffer2, offset, length, pos) => length });
          FS.mkdev("/dev/null", FS.makedev(1, 3));
          TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
          TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
          FS.mkdev("/dev/tty", FS.makedev(5, 0));
          FS.mkdev("/dev/tty1", FS.makedev(6, 0));
          var random_device = getRandomDevice();
          FS.createDevice("/dev", "random", random_device);
          FS.createDevice("/dev", "urandom", random_device);
          FS.mkdir("/dev/shm");
          FS.mkdir("/dev/shm/tmp");
        }, createSpecialDirectories: () => {
          FS.mkdir("/proc");
          var proc_self = FS.mkdir("/proc/self");
          FS.mkdir("/proc/self/fd");
          FS.mount({ mount: () => {
            var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
            node.node_ops = { lookup: (parent, name) => {
              var fd = +name;
              var stream = FS.getStream(fd);
              if (!stream) throw new FS.ErrnoError(8);
              var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: () => stream.path } };
              ret.parent = ret;
              return ret;
            } };
            return node;
          } }, {}, "/proc/self/fd");
        }, createStandardStreams: () => {
          if (Module2["stdin"]) {
            FS.createDevice("/dev", "stdin", Module2["stdin"]);
          } else {
            FS.symlink("/dev/tty", "/dev/stdin");
          }
          if (Module2["stdout"]) {
            FS.createDevice("/dev", "stdout", null, Module2["stdout"]);
          } else {
            FS.symlink("/dev/tty", "/dev/stdout");
          }
          if (Module2["stderr"]) {
            FS.createDevice("/dev", "stderr", null, Module2["stderr"]);
          } else {
            FS.symlink("/dev/tty1", "/dev/stderr");
          }
          var stdin = FS.open("/dev/stdin", 0);
          var stdout = FS.open("/dev/stdout", 1);
          var stderr = FS.open("/dev/stderr", 1);
        }, ensureErrnoError: () => {
          if (FS.ErrnoError) return;
          FS.ErrnoError = function ErrnoError(errno, node) {
            this.node = node;
            this.setErrno = function(errno2) {
              this.errno = errno2;
            };
            this.setErrno(errno);
            this.message = "FS error";
          };
          FS.ErrnoError.prototype = new Error();
          FS.ErrnoError.prototype.constructor = FS.ErrnoError;
          [44].forEach((code) => {
            FS.genericErrors[code] = new FS.ErrnoError(code);
            FS.genericErrors[code].stack = "<generic error, no stack>";
          });
        }, staticInit: () => {
          FS.ensureErrnoError();
          FS.nameTable = new Array(4096);
          FS.mount(MEMFS, {}, "/");
          FS.createDefaultDirectories();
          FS.createDefaultDevices();
          FS.createSpecialDirectories();
          FS.filesystems = { "MEMFS": MEMFS };
        }, init: (input, output, error) => {
          FS.init.initialized = true;
          FS.ensureErrnoError();
          Module2["stdin"] = input || Module2["stdin"];
          Module2["stdout"] = output || Module2["stdout"];
          Module2["stderr"] = error || Module2["stderr"];
          FS.createStandardStreams();
        }, quit: () => {
          FS.init.initialized = false;
          for (var i = 0; i < FS.streams.length; i++) {
            var stream = FS.streams[i];
            if (!stream) {
              continue;
            }
            FS.close(stream);
          }
        }, getMode: (canRead, canWrite) => {
          var mode = 0;
          if (canRead) mode |= 292 | 73;
          if (canWrite) mode |= 146;
          return mode;
        }, findObject: (path, dontResolveLastLink) => {
          var ret = FS.analyzePath(path, dontResolveLastLink);
          if (!ret.exists) {
            return null;
          }
          return ret.object;
        }, analyzePath: (path, dontResolveLastLink) => {
          try {
            var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
            path = lookup.path;
          } catch (e) {
          }
          var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
          try {
            var lookup = FS.lookupPath(path, { parent: true });
            ret.parentExists = true;
            ret.parentPath = lookup.path;
            ret.parentObject = lookup.node;
            ret.name = PATH.basename(path);
            lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
            ret.exists = true;
            ret.path = lookup.path;
            ret.object = lookup.node;
            ret.name = lookup.node.name;
            ret.isRoot = lookup.path === "/";
          } catch (e) {
            ret.error = e.errno;
          }
          return ret;
        }, createPath: (parent, path, canRead, canWrite) => {
          parent = typeof parent == "string" ? parent : FS.getPath(parent);
          var parts = path.split("/").reverse();
          while (parts.length) {
            var part = parts.pop();
            if (!part) continue;
            var current = PATH.join2(parent, part);
            try {
              FS.mkdir(current);
            } catch (e) {
            }
            parent = current;
          }
          return current;
        }, createFile: (parent, name, properties, canRead, canWrite) => {
          var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
          var mode = FS.getMode(canRead, canWrite);
          return FS.create(path, mode);
        }, createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {
          var path = name;
          if (parent) {
            parent = typeof parent == "string" ? parent : FS.getPath(parent);
            path = name ? PATH.join2(parent, name) : parent;
          }
          var mode = FS.getMode(canRead, canWrite);
          var node = FS.create(path, mode);
          if (data) {
            if (typeof data == "string") {
              var arr = new Array(data.length);
              for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
              data = arr;
            }
            FS.chmod(node, mode | 146);
            var stream = FS.open(node, 577);
            FS.write(stream, data, 0, data.length, 0, canOwn);
            FS.close(stream);
            FS.chmod(node, mode);
          }
          return node;
        }, createDevice: (parent, name, input, output) => {
          var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
          var mode = FS.getMode(!!input, !!output);
          if (!FS.createDevice.major) FS.createDevice.major = 64;
          var dev = FS.makedev(FS.createDevice.major++, 0);
          FS.registerDevice(dev, { open: (stream) => {
            stream.seekable = false;
          }, close: (stream) => {
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          }, read: (stream, buffer2, offset, length, pos) => {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === void 0 && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === void 0) break;
              bytesRead++;
              buffer2[offset + i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          }, write: (stream, buffer2, offset, length, pos) => {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer2[offset + i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          } });
          return FS.mkdev(path, mode, dev);
        }, forceLoadFile: (obj) => {
          if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
          if (typeof XMLHttpRequest != "undefined") {
            throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
          } else if (read_) {
            try {
              obj.contents = intArrayFromString(read_(obj.url), true);
              obj.usedBytes = obj.contents.length;
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          } else {
            throw new Error("Cannot load without read() or XMLHttpRequest.");
          }
        }, createLazyFile: (parent, name, url, canRead, canWrite) => {
          function LazyUint8Array() {
            this.lengthKnown = false;
            this.chunks = [];
          }
          LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
            if (idx > this.length - 1 || idx < 0) {
              return void 0;
            }
            var chunkOffset = idx % this.chunkSize;
            var chunkNum = idx / this.chunkSize | 0;
            return this.getter(chunkNum)[chunkOffset];
          };
          LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
            this.getter = getter;
          };
          LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
            var xhr = new XMLHttpRequest();
            xhr.open("HEAD", url, false);
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            var datalength = Number(xhr.getResponseHeader("Content-length"));
            var header;
            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
            var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
            var chunkSize = 1024 * 1024;
            if (!hasByteServing) chunkSize = datalength;
            var doXHR = (from, to) => {
              if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
              if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!");
              var xhr2 = new XMLHttpRequest();
              xhr2.open("GET", url, false);
              if (datalength !== chunkSize) xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
              xhr2.responseType = "arraybuffer";
              if (xhr2.overrideMimeType) {
                xhr2.overrideMimeType("text/plain; charset=x-user-defined");
              }
              xhr2.send(null);
              if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
              if (xhr2.response !== void 0) {
                return new Uint8Array(xhr2.response || []);
              }
              return intArrayFromString(xhr2.responseText || "", true);
            };
            var lazyArray2 = this;
            lazyArray2.setDataGetter((chunkNum) => {
              var start = chunkNum * chunkSize;
              var end = (chunkNum + 1) * chunkSize - 1;
              end = Math.min(end, datalength - 1);
              if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
                lazyArray2.chunks[chunkNum] = doXHR(start, end);
              }
              if (typeof lazyArray2.chunks[chunkNum] == "undefined") throw new Error("doXHR failed!");
              return lazyArray2.chunks[chunkNum];
            });
            if (usesGzip || !datalength) {
              chunkSize = datalength = 1;
              datalength = this.getter(0).length;
              chunkSize = datalength;
              out("LazyFiles on gzip forces download of the whole file when length is accessed");
            }
            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
          };
          if (typeof XMLHttpRequest != "undefined") {
            if (!ENVIRONMENT_IS_WORKER) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
            var lazyArray = new LazyUint8Array();
            Object.defineProperties(lazyArray, { length: { get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._length;
            } }, chunkSize: { get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._chunkSize;
            } } });
            var properties = { isDevice: false, contents: lazyArray };
          } else {
            var properties = { isDevice: false, url };
          }
          var node = FS.createFile(parent, name, properties, canRead, canWrite);
          if (properties.contents) {
            node.contents = properties.contents;
          } else if (properties.url) {
            node.contents = null;
            node.url = properties.url;
          }
          Object.defineProperties(node, { usedBytes: { get: function() {
            return this.contents.length;
          } } });
          var stream_ops = {};
          var keys = Object.keys(node.stream_ops);
          keys.forEach((key) => {
            var fn = node.stream_ops[key];
            stream_ops[key] = function forceLoadLazyFile() {
              FS.forceLoadFile(node);
              return fn.apply(null, arguments);
            };
          });
          function writeChunks(stream, buffer2, offset, length, position) {
            var contents = stream.node.contents;
            if (position >= contents.length) return 0;
            var size = Math.min(contents.length - position, length);
            if (contents.slice) {
              for (var i = 0; i < size; i++) {
                buffer2[offset + i] = contents[position + i];
              }
            } else {
              for (var i = 0; i < size; i++) {
                buffer2[offset + i] = contents.get(position + i);
              }
            }
            return size;
          }
          stream_ops.read = (stream, buffer2, offset, length, position) => {
            FS.forceLoadFile(node);
            return writeChunks(stream, buffer2, offset, length, position);
          };
          stream_ops.mmap = (stream, length, position, prot, flags) => {
            FS.forceLoadFile(node);
            var ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            writeChunks(stream, HEAP8, ptr, length, position);
            return { ptr, allocated: true };
          };
          node.stream_ops = stream_ops;
          return node;
        }, createPreloadedFile: (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
          var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
          var dep = getUniqueRunDependency("cp " + fullname);
          function processData(byteArray) {
            function finish(byteArray2) {
              if (preFinish) preFinish();
              if (!dontCreateFile) {
                FS.createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
              }
              if (onload) onload();
              removeRunDependency(dep);
            }
            if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {
              if (onerror) onerror();
              removeRunDependency(dep);
            })) {
              return;
            }
            finish(byteArray);
          }
          addRunDependency(dep);
          if (typeof url == "string") {
            asyncLoad(url, (byteArray) => processData(byteArray), onerror);
          } else {
            processData(url);
          }
        }, indexedDB: () => {
          return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        }, DB_NAME: () => {
          return "EM_FS_" + window.location.pathname;
        }, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: (paths, onload, onerror) => {
          onload = onload || (() => {
          });
          onerror = onerror || (() => {
          });
          var indexedDB2 = FS.indexedDB();
          try {
            var openRequest = indexedDB2.open(FS.DB_NAME(), FS.DB_VERSION);
          } catch (e) {
            return onerror(e);
          }
          openRequest.onupgradeneeded = () => {
            out("creating db");
            var db = openRequest.result;
            db.createObjectStore(FS.DB_STORE_NAME);
          };
          openRequest.onsuccess = () => {
            var db = openRequest.result;
            var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
            var files = transaction.objectStore(FS.DB_STORE_NAME);
            var ok = 0, fail = 0, total = paths.length;
            function finish() {
              if (fail == 0) onload();
              else onerror();
            }
            paths.forEach((path) => {
              var putRequest = files.put(FS.analyzePath(path).object.contents, path);
              putRequest.onsuccess = () => {
                ok++;
                if (ok + fail == total) finish();
              };
              putRequest.onerror = () => {
                fail++;
                if (ok + fail == total) finish();
              };
            });
            transaction.onerror = onerror;
          };
          openRequest.onerror = onerror;
        }, loadFilesFromDB: (paths, onload, onerror) => {
          onload = onload || (() => {
          });
          onerror = onerror || (() => {
          });
          var indexedDB2 = FS.indexedDB();
          try {
            var openRequest = indexedDB2.open(FS.DB_NAME(), FS.DB_VERSION);
          } catch (e) {
            return onerror(e);
          }
          openRequest.onupgradeneeded = onerror;
          openRequest.onsuccess = () => {
            var db = openRequest.result;
            try {
              var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
            } catch (e) {
              onerror(e);
              return;
            }
            var files = transaction.objectStore(FS.DB_STORE_NAME);
            var ok = 0, fail = 0, total = paths.length;
            function finish() {
              if (fail == 0) onload();
              else onerror();
            }
            paths.forEach((path) => {
              var getRequest = files.get(path);
              getRequest.onsuccess = () => {
                if (FS.analyzePath(path).exists) {
                  FS.unlink(path);
                }
                FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
                ok++;
                if (ok + fail == total) finish();
              };
              getRequest.onerror = () => {
                fail++;
                if (ok + fail == total) finish();
              };
            });
            transaction.onerror = onerror;
          };
          openRequest.onerror = onerror;
        } };
        var SYSCALLS = { DEFAULT_POLLMASK: 5, calculateAt: function(dirfd, path, allowEmpty) {
          if (PATH.isAbs(path)) {
            return path;
          }
          var dir;
          if (dirfd === -100) {
            dir = FS.cwd();
          } else {
            var dirstream = SYSCALLS.getStreamFromFD(dirfd);
            dir = dirstream.path;
          }
          if (path.length == 0) {
            if (!allowEmpty) {
              throw new FS.ErrnoError(44);
            }
            return dir;
          }
          return PATH.join2(dir, path);
        }, doStat: function(func, path, buf) {
          try {
            var stat = func(path);
          } catch (e) {
            if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
              return -54;
            }
            throw e;
          }
          HEAP32[buf >> 2] = stat.dev;
          HEAP32[buf + 8 >> 2] = stat.ino;
          HEAP32[buf + 12 >> 2] = stat.mode;
          HEAPU32[buf + 16 >> 2] = stat.nlink;
          HEAP32[buf + 20 >> 2] = stat.uid;
          HEAP32[buf + 24 >> 2] = stat.gid;
          HEAP32[buf + 28 >> 2] = stat.rdev;
          tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
          HEAP32[buf + 48 >> 2] = 4096;
          HEAP32[buf + 52 >> 2] = stat.blocks;
          tempI64 = [Math.floor(stat.atime.getTime() / 1e3) >>> 0, (tempDouble = Math.floor(stat.atime.getTime() / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
          HEAPU32[buf + 64 >> 2] = 0;
          tempI64 = [Math.floor(stat.mtime.getTime() / 1e3) >>> 0, (tempDouble = Math.floor(stat.mtime.getTime() / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
          HEAPU32[buf + 80 >> 2] = 0;
          tempI64 = [Math.floor(stat.ctime.getTime() / 1e3) >>> 0, (tempDouble = Math.floor(stat.ctime.getTime() / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
          HEAPU32[buf + 96 >> 2] = 0;
          tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 104 >> 2] = tempI64[0], HEAP32[buf + 108 >> 2] = tempI64[1];
          return 0;
        }, doMsync: function(addr, stream, len, flags, offset) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (flags & 2) {
            return 0;
          }
          var buffer2 = HEAPU8.slice(addr, addr + len);
          FS.msync(stream, buffer2, offset, len, flags);
        }, varargs: void 0, get: function() {
          SYSCALLS.varargs += 4;
          var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
          return ret;
        }, getStr: function(ptr) {
          var ret = UTF8ToString(ptr);
          return ret;
        }, getStreamFromFD: function(fd) {
          var stream = FS.getStream(fd);
          if (!stream) throw new FS.ErrnoError(8);
          return stream;
        } };
        function _environ_get(__environ, environ_buf) {
          var bufSize = 0;
          getEnvStrings().forEach(function(string, i) {
            var ptr = environ_buf + bufSize;
            HEAPU32[__environ + i * 4 >> 2] = ptr;
            writeAsciiToMemory(string, ptr);
            bufSize += string.length + 1;
          });
          return 0;
        }
        function _environ_sizes_get(penviron_count, penviron_buf_size) {
          var strings = getEnvStrings();
          HEAPU32[penviron_count >> 2] = strings.length;
          var bufSize = 0;
          strings.forEach(function(string) {
            bufSize += string.length + 1;
          });
          HEAPU32[penviron_buf_size >> 2] = bufSize;
          return 0;
        }
        function _proc_exit(code) {
          EXITSTATUS = code;
          if (!keepRuntimeAlive()) {
            if (Module2["onExit"]) Module2["onExit"](code);
            ABORT = true;
          }
          quit_(code, new ExitStatus(code));
        }
        function exitJS(status, implicit) {
          EXITSTATUS = status;
          _proc_exit(status);
        }
        var _exit = exitJS;
        function _fd_close(fd) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.close(stream);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e instanceof FS.ErrnoError)) throw e;
            return e.errno;
          }
        }
        function doReadv(stream, iov, iovcnt, offset) {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = HEAPU32[iov >> 2];
            var len = HEAPU32[iov + 4 >> 2];
            iov += 8;
            var curr = FS.read(stream, HEAP8, ptr, len, offset);
            if (curr < 0) return -1;
            ret += curr;
            if (curr < len) break;
          }
          return ret;
        }
        function _fd_read(fd, iov, iovcnt, pnum) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = doReadv(stream, iov, iovcnt);
            HEAPU32[pnum >> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e instanceof FS.ErrnoError)) throw e;
            return e.errno;
          }
        }
        function convertI32PairToI53Checked(lo, hi) {
          return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
        }
        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
          try {
            var offset = convertI32PairToI53Checked(offset_low, offset_high);
            if (isNaN(offset)) return 61;
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.llseek(stream, offset, whence);
            tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
            if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e instanceof FS.ErrnoError)) throw e;
            return e.errno;
          }
        }
        function doWritev(stream, iov, iovcnt, offset) {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = HEAPU32[iov >> 2];
            var len = HEAPU32[iov + 4 >> 2];
            iov += 8;
            var curr = FS.write(stream, HEAP8, ptr, len, offset);
            if (curr < 0) return -1;
            ret += curr;
          }
          return ret;
        }
        function _fd_write(fd, iov, iovcnt, pnum) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = doWritev(stream, iov, iovcnt);
            HEAPU32[pnum >> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e instanceof FS.ErrnoError)) throw e;
            return e.errno;
          }
        }
        function _return_string(data, length) {
          Module2._return_string_callback(data, length);
        }
        function __isLeapYear(year) {
          return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        }
        function __arraySum(array, index) {
          var sum = 0;
          for (var i = 0; i <= index; sum += array[i++]) {
          }
          return sum;
        }
        var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function __addDays(date, days) {
          var newDate = new Date(date.getTime());
          while (days > 0) {
            var leap = __isLeapYear(newDate.getFullYear());
            var currentMonth = newDate.getMonth();
            var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
            if (days > daysInCurrentMonth - newDate.getDate()) {
              days -= daysInCurrentMonth - newDate.getDate() + 1;
              newDate.setDate(1);
              if (currentMonth < 11) {
                newDate.setMonth(currentMonth + 1);
              } else {
                newDate.setMonth(0);
                newDate.setFullYear(newDate.getFullYear() + 1);
              }
            } else {
              newDate.setDate(newDate.getDate() + days);
              return newDate;
            }
          }
          return newDate;
        }
        function writeArrayToMemory(array, buffer2) {
          HEAP8.set(array, buffer2);
        }
        function _strftime(s, maxsize, format, tm) {
          var tm_zone = HEAP32[tm + 40 >> 2];
          var date = { tm_sec: HEAP32[tm >> 2], tm_min: HEAP32[tm + 4 >> 2], tm_hour: HEAP32[tm + 8 >> 2], tm_mday: HEAP32[tm + 12 >> 2], tm_mon: HEAP32[tm + 16 >> 2], tm_year: HEAP32[tm + 20 >> 2], tm_wday: HEAP32[tm + 24 >> 2], tm_yday: HEAP32[tm + 28 >> 2], tm_isdst: HEAP32[tm + 32 >> 2], tm_gmtoff: HEAP32[tm + 36 >> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" };
          var pattern = UTF8ToString(format);
          var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
          for (var rule in EXPANSION_RULES_1) {
            pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
          }
          var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
          var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
          function leadingSomething(value, digits, character) {
            var str = typeof value == "number" ? value.toString() : value || "";
            while (str.length < digits) {
              str = character[0] + str;
            }
            return str;
          }
          function leadingNulls(value, digits) {
            return leadingSomething(value, digits, "0");
          }
          function compareByDay(date1, date2) {
            function sgn(value) {
              return value < 0 ? -1 : value > 0 ? 1 : 0;
            }
            var compare;
            if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
              if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                compare = sgn(date1.getDate() - date2.getDate());
              }
            }
            return compare;
          }
          function getFirstWeekStartDate(janFourth) {
            switch (janFourth.getDay()) {
              case 0:
                return new Date(janFourth.getFullYear() - 1, 11, 29);
              case 1:
                return janFourth;
              case 2:
                return new Date(janFourth.getFullYear(), 0, 3);
              case 3:
                return new Date(janFourth.getFullYear(), 0, 2);
              case 4:
                return new Date(janFourth.getFullYear(), 0, 1);
              case 5:
                return new Date(janFourth.getFullYear() - 1, 11, 31);
              case 6:
                return new Date(janFourth.getFullYear() - 1, 11, 30);
            }
          }
          function getWeekBasedYear(date2) {
            var thisDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
            var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
            var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
            var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
            var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
            if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
              if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                return thisDate.getFullYear() + 1;
              }
              return thisDate.getFullYear();
            }
            return thisDate.getFullYear() - 1;
          }
          var EXPANSION_RULES_2 = { "%a": function(date2) {
            return WEEKDAYS[date2.tm_wday].substring(0, 3);
          }, "%A": function(date2) {
            return WEEKDAYS[date2.tm_wday];
          }, "%b": function(date2) {
            return MONTHS[date2.tm_mon].substring(0, 3);
          }, "%B": function(date2) {
            return MONTHS[date2.tm_mon];
          }, "%C": function(date2) {
            var year = date2.tm_year + 1900;
            return leadingNulls(year / 100 | 0, 2);
          }, "%d": function(date2) {
            return leadingNulls(date2.tm_mday, 2);
          }, "%e": function(date2) {
            return leadingSomething(date2.tm_mday, 2, " ");
          }, "%g": function(date2) {
            return getWeekBasedYear(date2).toString().substring(2);
          }, "%G": function(date2) {
            return getWeekBasedYear(date2);
          }, "%H": function(date2) {
            return leadingNulls(date2.tm_hour, 2);
          }, "%I": function(date2) {
            var twelveHour = date2.tm_hour;
            if (twelveHour == 0) twelveHour = 12;
            else if (twelveHour > 12) twelveHour -= 12;
            return leadingNulls(twelveHour, 2);
          }, "%j": function(date2) {
            return leadingNulls(date2.tm_mday + __arraySum(__isLeapYear(date2.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
          }, "%m": function(date2) {
            return leadingNulls(date2.tm_mon + 1, 2);
          }, "%M": function(date2) {
            return leadingNulls(date2.tm_min, 2);
          }, "%n": function() {
            return "\n";
          }, "%p": function(date2) {
            if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
              return "AM";
            }
            return "PM";
          }, "%S": function(date2) {
            return leadingNulls(date2.tm_sec, 2);
          }, "%t": function() {
            return "	";
          }, "%u": function(date2) {
            return date2.tm_wday || 7;
          }, "%U": function(date2) {
            var days = date2.tm_yday + 7 - date2.tm_wday;
            return leadingNulls(Math.floor(days / 7), 2);
          }, "%V": function(date2) {
            var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
            if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
              val++;
            }
            if (!val) {
              val = 52;
              var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
              if (dec31 == 4 || dec31 == 5 && __isLeapYear(date2.tm_year % 400 - 1)) {
                val++;
              }
            } else if (val == 53) {
              var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
              if (jan1 != 4 && (jan1 != 3 || !__isLeapYear(date2.tm_year))) val = 1;
            }
            return leadingNulls(val, 2);
          }, "%w": function(date2) {
            return date2.tm_wday;
          }, "%W": function(date2) {
            var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
            return leadingNulls(Math.floor(days / 7), 2);
          }, "%y": function(date2) {
            return (date2.tm_year + 1900).toString().substring(2);
          }, "%Y": function(date2) {
            return date2.tm_year + 1900;
          }, "%z": function(date2) {
            var off = date2.tm_gmtoff;
            var ahead = off >= 0;
            off = Math.abs(off) / 60;
            off = off / 60 * 100 + off % 60;
            return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
          }, "%Z": function(date2) {
            return date2.tm_zone;
          }, "%%": function() {
            return "%";
          } };
          pattern = pattern.replace(/%%/g, "\0\0");
          for (var rule in EXPANSION_RULES_2) {
            if (pattern.includes(rule)) {
              pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
            }
          }
          pattern = pattern.replace(/\0\0/g, "%");
          var bytes = intArrayFromString(pattern, false);
          if (bytes.length > maxsize) {
            return 0;
          }
          writeArrayToMemory(bytes, s);
          return bytes.length - 1;
        }
        function _strftime_l(s, maxsize, format, tm, loc) {
          return _strftime(s, maxsize, format, tm);
        }
        var FSNode = function(parent, name, mode, rdev) {
          if (!parent) {
            parent = this;
          }
          this.parent = parent;
          this.mount = parent.mount;
          this.mounted = null;
          this.id = FS.nextInode++;
          this.name = name;
          this.mode = mode;
          this.node_ops = {};
          this.stream_ops = {};
          this.rdev = rdev;
        };
        var readMode = 292 | 73;
        var writeMode = 146;
        Object.defineProperties(FSNode.prototype, { read: { get: function() {
          return (this.mode & readMode) === readMode;
        }, set: function(val) {
          val ? this.mode |= readMode : this.mode &= ~readMode;
        } }, write: { get: function() {
          return (this.mode & writeMode) === writeMode;
        }, set: function(val) {
          val ? this.mode |= writeMode : this.mode &= ~writeMode;
        } }, isFolder: { get: function() {
          return FS.isDir(this.mode);
        } }, isDevice: { get: function() {
          return FS.isChrdev(this.mode);
        } } });
        FS.FSNode = FSNode;
        FS.staticInit();
        var asmLibraryArg = { "a": ___assert_fail, "f": ___cxa_allocate_exception, "e": ___cxa_throw, "b": _abort, "i": _emscripten_resize_heap, "l": _environ_get, "m": _environ_sizes_get, "d": _exit, "g": _fd_close, "h": _fd_read, "k": _fd_seek, "j": _fd_write, "n": _return_string, "c": _strftime_l };
        var asm = createWasm();
        var ___wasm_call_ctors = Module2["___wasm_call_ctors"] = function() {
          return (___wasm_call_ctors = Module2["___wasm_call_ctors"] = Module2["asm"]["p"]).apply(null, arguments);
        };
        var _test = Module2["_test"] = function() {
          return (_test = Module2["_test"] = Module2["asm"]["q"]).apply(null, arguments);
        };
        var _spirv_to_wgsl = Module2["_spirv_to_wgsl"] = function() {
          return (_spirv_to_wgsl = Module2["_spirv_to_wgsl"] = Module2["asm"]["r"]).apply(null, arguments);
        };
        var _malloc = Module2["_malloc"] = function() {
          return (_malloc = Module2["_malloc"] = Module2["asm"]["t"]).apply(null, arguments);
        };
        var _free = Module2["_free"] = function() {
          return (_free = Module2["_free"] = Module2["asm"]["u"]).apply(null, arguments);
        };
        var ___cxa_is_pointer_type = Module2["___cxa_is_pointer_type"] = function() {
          return (___cxa_is_pointer_type = Module2["___cxa_is_pointer_type"] = Module2["asm"]["v"]).apply(null, arguments);
        };
        var calledRun;
        dependenciesFulfilled = function runCaller() {
          if (!calledRun) run();
          if (!calledRun) dependenciesFulfilled = runCaller;
        };
        function run(args) {
          args = args || arguments_;
          if (runDependencies > 0) {
            return;
          }
          preRun();
          if (runDependencies > 0) {
            return;
          }
          function doRun() {
            if (calledRun) return;
            calledRun = true;
            Module2["calledRun"] = true;
            if (ABORT) return;
            initRuntime();
            if (Module2["onRuntimeInitialized"]) Module2["onRuntimeInitialized"]();
            postRun();
          }
          if (Module2["setStatus"]) {
            Module2["setStatus"]("Running...");
            setTimeout(function() {
              setTimeout(function() {
                Module2["setStatus"]("");
              }, 1);
              doRun();
            }, 1);
          } else {
            doRun();
          }
        }
        if (Module2["preInit"]) {
          if (typeof Module2["preInit"] == "function") Module2["preInit"] = [Module2["preInit"]];
          while (Module2["preInit"].length > 0) {
            Module2["preInit"].pop()();
          }
        }
        run();
        return Module2;
      };
      (function tryToExport(root, factory) {
        if (typeof exports === "object" && typeof module === "object")
          module.exports = factory();
        else if (typeof define === "function" && define.amd)
          define("twgsl", [], factory);
        else if (typeof exports === "object")
          exports["twgsl"] = factory();
        else root["twgsl"] = factory();
      })(typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : void 0, () => {
        const initialize = (wasmPath) => {
          wasmPath = wasmPath || "twgsl.wasm";
          return new Promise((resolve) => {
            Module({
              locateFile() {
                return wasmPath;
              },
              onRuntimeInitialized() {
                var twgsl2 = this;
                var wgsl = "";
                var textDecoder = new TextDecoder();
                var convertSpirV2WGSL = (code) => {
                  if (!twgsl2._return_string_callback) {
                    twgsl2._return_string_callback = (data, length) => {
                      const bytes = new Uint8ClampedArray(twgsl2.HEAPU8.subarray(data, data + length));
                      wgsl = textDecoder.decode(bytes);
                    };
                  }
                  let addr = twgsl2._malloc(code.byteLength);
                  twgsl2.HEAPU32.set(code, addr / 4);
                  twgsl2._spirv_to_wgsl(addr, code.byteLength);
                  twgsl2._free(addr);
                  return wgsl;
                };
                resolve({
                  convertSpirV2WGSL
                });
              }
            });
          });
        };
        let instance;
        return (wasmPath) => {
          if (!instance) {
            instance = initialize(wasmPath);
          }
          return instance;
        };
      });
    }
  });

  // src/redcube.webgpu.ts
  var redcube_webgpu_exports = {};
  __export(redcube_webgpu_exports, {
    RedCube: () => RedCube
  });

  // src/container.ts
  var Container = class {
    _services;
    _singletons;
    constructor() {
      this._services = /* @__PURE__ */ new Map();
      this._singletons = /* @__PURE__ */ new Map();
      this.update = this.update.bind(this);
    }
    register(name, definition, dependencies = [], ...args) {
      this._services.set(name, { definition, dependencies, args });
      if (!this._isClass(definition)) {
        this._updateDep(name, definition);
      } else {
        definition.__update = this.update;
      }
    }
    get(name) {
      const c = this._services.get(name);
      if (!c) {
        return null;
      }
      if (this._isClass(c.definition)) {
        const singletonInstance = this._singletons.get(name);
        if (singletonInstance) {
          return singletonInstance;
        } else {
          const newSingletonInstance = this._createInstance(c);
          this._singletons.set(name, newSingletonInstance);
          return newSingletonInstance;
        }
      } else {
        return c.definition;
      }
    }
    update(name, ...args) {
      const c = this._services.get(name);
      c.args = args;
      this._singletons.delete(name);
      const instance = this.get(name);
      this._updateDep(name, instance);
    }
    _updateDep(name, definition) {
      for (const [key, instance] of this._singletons) {
        if (this._services.get(key).dependencies.some((dep) => dep === name)) {
          instance[`set${name.charAt(0).toUpperCase() + name.slice(1)}`].call(instance, definition);
        }
      }
      this._singletons.set(name, definition);
    }
    _getResolvedDependencies(service) {
      let classDependencies = [];
      if (service.dependencies) {
        classDependencies = service.dependencies.map((dep) => {
          return [dep, this.get(dep)];
        });
      }
      return classDependencies;
    }
    _createInstance(service) {
      const instance = new service.definition(...service.args);
      this._getResolvedDependencies(service).forEach(([name, dep]) => {
        instance[`set${name.charAt(0).toUpperCase() + name.slice(1)}`].call(instance, dep);
      });
      return instance;
    }
    _isClass(definition) {
      return typeof definition === "function" && /^class\s/.test(Function.prototype.toString.call(definition));
    }
  };

  // src/matrix.ts
  var Matrix4 = class _Matrix4 {
    elements;
    constructor(opt_src) {
      let i;
      let s;
      let d;
      if (opt_src && typeof opt_src === "object" && opt_src.hasOwnProperty("elements")) {
        s = opt_src.elements;
        d = new Float32Array(16);
        for (i = 0; i < 16; ++i) {
          d[i] = s[i];
        }
        this.elements = d;
      } else {
        this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      }
    }
    /**
     * Copy matrix.
     * @param src source matrix
     * @return this
     */
    set(src) {
      let i;
      let s;
      let d;
      s = src;
      d = this.elements;
      if (s === d) {
        return;
      }
      for (i = 0; i < 16; ++i) {
        d[i] = s[i];
      }
      return this;
    }
    multiply(matrix) {
      this.concat(matrix);
      return this;
    }
    /**
     * Multiply the matrix from the right.
     * @param other The multiply matrix
     * @return this
     */
    concat({ elements }) {
      let i;
      let e;
      let a;
      let b;
      let ai0;
      let ai1;
      let ai2;
      let ai3;
      e = this.elements;
      a = this.elements;
      b = elements;
      if (e === b) {
        b = new Float32Array(16);
        for (i = 0; i < 16; ++i) {
          b[i] = e[i];
        }
      }
      for (i = 0; i < 4; i++) {
        ai0 = a[i];
        ai1 = a[i + 4];
        ai2 = a[i + 8];
        ai3 = a[i + 12];
        e[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];
        e[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];
        e[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];
        e[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
      }
      return this;
    }
    /**
     * Calculate the inverse matrix of specified matrix, and set to this.
     * @param other The source matrix
     * @return this
     */
    setInverseOf({ elements }) {
      let i;
      let s;
      let d;
      let inv;
      let det;
      s = elements;
      d = this.elements;
      inv = new Float32Array(16);
      inv[0] = s[5] * s[10] * s[15] - s[5] * s[11] * s[14] - s[9] * s[6] * s[15] + s[9] * s[7] * s[14] + s[13] * s[6] * s[11] - s[13] * s[7] * s[10];
      inv[4] = -s[4] * s[10] * s[15] + s[4] * s[11] * s[14] + s[8] * s[6] * s[15] - s[8] * s[7] * s[14] - s[12] * s[6] * s[11] + s[12] * s[7] * s[10];
      inv[8] = s[4] * s[9] * s[15] - s[4] * s[11] * s[13] - s[8] * s[5] * s[15] + s[8] * s[7] * s[13] + s[12] * s[5] * s[11] - s[12] * s[7] * s[9];
      inv[12] = -s[4] * s[9] * s[14] + s[4] * s[10] * s[13] + s[8] * s[5] * s[14] - s[8] * s[6] * s[13] - s[12] * s[5] * s[10] + s[12] * s[6] * s[9];
      inv[1] = -s[1] * s[10] * s[15] + s[1] * s[11] * s[14] + s[9] * s[2] * s[15] - s[9] * s[3] * s[14] - s[13] * s[2] * s[11] + s[13] * s[3] * s[10];
      inv[5] = s[0] * s[10] * s[15] - s[0] * s[11] * s[14] - s[8] * s[2] * s[15] + s[8] * s[3] * s[14] + s[12] * s[2] * s[11] - s[12] * s[3] * s[10];
      inv[9] = -s[0] * s[9] * s[15] + s[0] * s[11] * s[13] + s[8] * s[1] * s[15] - s[8] * s[3] * s[13] - s[12] * s[1] * s[11] + s[12] * s[3] * s[9];
      inv[13] = s[0] * s[9] * s[14] - s[0] * s[10] * s[13] - s[8] * s[1] * s[14] + s[8] * s[2] * s[13] + s[12] * s[1] * s[10] - s[12] * s[2] * s[9];
      inv[2] = s[1] * s[6] * s[15] - s[1] * s[7] * s[14] - s[5] * s[2] * s[15] + s[5] * s[3] * s[14] + s[13] * s[2] * s[7] - s[13] * s[3] * s[6];
      inv[6] = -s[0] * s[6] * s[15] + s[0] * s[7] * s[14] + s[4] * s[2] * s[15] - s[4] * s[3] * s[14] - s[12] * s[2] * s[7] + s[12] * s[3] * s[6];
      inv[10] = s[0] * s[5] * s[15] - s[0] * s[7] * s[13] - s[4] * s[1] * s[15] + s[4] * s[3] * s[13] + s[12] * s[1] * s[7] - s[12] * s[3] * s[5];
      inv[14] = -s[0] * s[5] * s[14] + s[0] * s[6] * s[13] + s[4] * s[1] * s[14] - s[4] * s[2] * s[13] - s[12] * s[1] * s[6] + s[12] * s[2] * s[5];
      inv[3] = -s[1] * s[6] * s[11] + s[1] * s[7] * s[10] + s[5] * s[2] * s[11] - s[5] * s[3] * s[10] - s[9] * s[2] * s[7] + s[9] * s[3] * s[6];
      inv[7] = s[0] * s[6] * s[11] - s[0] * s[7] * s[10] - s[4] * s[2] * s[11] + s[4] * s[3] * s[10] + s[8] * s[2] * s[7] - s[8] * s[3] * s[6];
      inv[11] = -s[0] * s[5] * s[11] + s[0] * s[7] * s[9] + s[4] * s[1] * s[11] - s[4] * s[3] * s[9] - s[8] * s[1] * s[7] + s[8] * s[3] * s[5];
      inv[15] = s[0] * s[5] * s[10] - s[0] * s[6] * s[9] - s[4] * s[1] * s[10] + s[4] * s[2] * s[9] + s[8] * s[1] * s[6] - s[8] * s[2] * s[5];
      det = s[0] * inv[0] + s[1] * inv[4] + s[2] * inv[8] + s[3] * inv[12];
      if (det === 0) {
        return this;
      }
      det = 1 / det;
      for (i = 0; i < 16; i++) {
        d[i] = inv[i] * det;
      }
      return this;
    }
    /**
     * Calculate the inverse matrix of this, and set to this.
     * @return this
     */
    invert() {
      return this.setInverseOf(this);
    }
    makeOrthographic(left, right, top, bottom, near, far) {
      var te = this.elements;
      var w = 1 / (right - left);
      var h = 1 / (top - bottom);
      var p = 1 / (far - near);
      var x = (right + left) * w;
      var y = (top + bottom) * h;
      var z = (far + near) * p;
      te[0] = 2 * w;
      te[4] = 0;
      te[8] = 0;
      te[12] = -x;
      te[1] = 0;
      te[5] = 2 * h;
      te[9] = 0;
      te[13] = -y;
      te[2] = 0;
      te[6] = 0;
      te[10] = -2 * p;
      te[14] = -z;
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[15] = 1;
      return this;
    }
    /**
     * Set the orthographic projection matrix.
     * @param left The coordinate of the left of clipping plane.
     * @param right The coordinate of the right of clipping plane.
     * @param bottom The coordinate of the bottom of clipping plane.
     * @param top The coordinate of the top top clipping plane.
     * @param near The distances to the nearer depth clipping plane. This value is minus if the plane is to be behind the viewer.
     * @param far The distances to the farther depth clipping plane. This value is minus if the plane is to be behind the viewer.
     * @return this
     */
    setOrtho(r, t, near, far) {
      let e;
      let rw;
      let rh;
      let rd;
      rw = 1 / r;
      rh = 1 / t;
      rd = 2 / (near - far);
      e = this.elements;
      e[0] = rw;
      e[1] = 0;
      e[2] = 0;
      e[3] = 0;
      e[4] = 0;
      e[5] = rh;
      e[6] = 0;
      e[7] = 0;
      e[8] = 0;
      e[9] = 0;
      e[10] = rd;
      e[11] = (far + near) / (near - far);
      e[12] = 0;
      e[13] = 0;
      e[14] = 0;
      e[15] = 1;
      return this;
    }
    /**
     * Set the perspective projection matrix by fovy and aspect.
     * @param fovy The angle between the upper and lower sides of the frustum.
     * @param aspect The aspect ratio of the frustum. (width/height)
     * @param near The distances to the nearer depth clipping plane. This value must be plus value.
     * @param far The distances to the farther depth clipping plane. This value must be plus value.
     * @return this
     */
    setPerspective(fovy, aspect, near, far) {
      let e;
      let rd;
      let s;
      let ct;
      if (near === far || aspect === 0) {
        throw "null frustum";
      }
      if (near <= 0) {
        throw "near <= 0";
      }
      if (far <= 0) {
        throw "far <= 0";
      }
      fovy /= 2;
      s = Math.sin(fovy);
      if (s === 0) {
        throw "null frustum";
      }
      rd = 1 / (far - near);
      ct = Math.cos(fovy) / s;
      e = this.elements;
      e[0] = ct / aspect;
      e[1] = 0;
      e[2] = 0;
      e[3] = 0;
      e[4] = 0;
      e[5] = ct;
      e[6] = 0;
      e[7] = 0;
      e[8] = 0;
      e[9] = 0;
      e[10] = -(far + near) * rd;
      e[11] = -1;
      e[12] = 0;
      e[13] = 0;
      e[14] = -2 * near * far * rd;
      e[15] = 0;
      return this;
    }
    /**
     * Multiply the perspective projection matrix from the right.
     * @param fovy The angle between the upper and lower sides of the frustum.
     * @param aspect The aspect ratio of the frustum. (width/height)
     * @param near The distances to the nearer depth clipping plane. This value must be plus value.
     * @param far The distances to the farther depth clipping plane. This value must be plus value.
     * @return this
     */
    perspective(fovy, aspect, near, far) {
      return this.concat(new _Matrix4().setPerspective(fovy, aspect, near, far));
    }
    /**
     * Multiply the four-dimensional vector.
     * @param pos  The multiply vector
     * @return The result of multiplication(Float32Array)
     */
    multiplyVector4({ elements }) {
      const e = this.elements;
      const p = elements;
      const v = new Vector4();
      const result = v.elements;
      result[0] = p[0] * e[0] + p[1] * e[4] + p[2] * e[8] + p[3] * e[12];
      result[1] = p[0] * e[1] + p[1] * e[5] + p[2] * e[9] + p[3] * e[13];
      result[2] = p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + p[3] * e[14];
      result[3] = p[0] * e[3] + p[1] * e[7] + p[2] * e[11] + p[3] * e[15];
      return v;
    }
    getScaling() {
      let e = this.elements;
      let m11 = e[0];
      let m12 = e[1];
      let m13 = e[2];
      let m21 = e[4];
      let m22 = e[5];
      let m23 = e[6];
      let m31 = e[8];
      let m32 = e[9];
      let m33 = e[10];
      let out = new Vector3([
        Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13),
        Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23),
        Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33)
      ]);
      return out;
    }
    scale(vec3) {
      const x = vec3.elements[0];
      const y = vec3.elements[1];
      const z = vec3.elements[2];
      const e = this.elements;
      e[0] *= x;
      e[4] *= y;
      e[8] *= z;
      e[1] *= x;
      e[5] *= y;
      e[9] *= z;
      e[2] *= x;
      e[6] *= y;
      e[10] *= z;
      e[3] *= x;
      e[7] *= y;
      e[11] *= z;
      return this;
    }
    restoreScale(vec3) {
      const x = vec3.elements[0];
      const y = vec3.elements[1];
      const z = vec3.elements[2];
      const e = this.elements;
      e[0] /= x;
      e[4] /= y;
      e[8] /= z;
      e[1] /= x;
      e[5] /= y;
      e[9] /= z;
      e[2] /= x;
      e[6] /= y;
      e[10] /= z;
      e[3] /= x;
      e[7] /= y;
      e[11] /= z;
      return this;
    }
    setTranslate(vec3) {
      const e = this.elements;
      const x = vec3.elements[0];
      const y = vec3.elements[1];
      const z = vec3.elements[2];
      e[12] = x;
      e[13] = y;
      e[14] = z;
      e[15] = 1;
      return this;
    }
    /**
     * Multiply the matrix for translation from the right.
     * @param x The X value of a translation.
     * @param y The Y value of a translation.
     * @param z The Z value of a translation.
     * @return this
     */
    translate(x, y, z) {
      const e = this.elements;
      e[12] += e[0] * x + e[4] * y + e[8] * z;
      e[13] += e[1] * x + e[5] * y + e[9] * z;
      e[14] += e[2] * x + e[6] * y + e[10] * z;
      e[15] += e[3] * x + e[7] * y + e[11] * z;
      return this;
    }
    getMaxScaleOnAxis() {
      const te = this.elements;
      const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
      const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
      const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
    rotate(axis, rad) {
      let x = axis.elements[0], y = axis.elements[1], z = axis.elements[2];
      let len = Math.hypot(x, y, z);
      let s, c, t;
      let a00, a01, a02, a03;
      let a10, a11, a12, a13;
      let a20, a21, a22, a23;
      let b00, b01, b02;
      let b10, b11, b12;
      let b20, b21, b22;
      if (len < Number.EPSILON) {
        return null;
      }
      len = 1 / len;
      x *= len;
      y *= len;
      z *= len;
      s = Math.sin(rad);
      c = Math.cos(rad);
      t = 1 - c;
      let a = this.elements;
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      b00 = x * x * t + c;
      b01 = y * x * t + z * s;
      b02 = z * x * t - y * s;
      b10 = x * y * t - z * s;
      b11 = y * y * t + c;
      b12 = z * y * t + x * s;
      b20 = x * z * t + y * s;
      b21 = y * z * t - x * s;
      b22 = z * z * t + c;
      a[0] = a00 * b00 + a10 * b01 + a20 * b02;
      a[1] = a01 * b00 + a11 * b01 + a21 * b02;
      a[2] = a02 * b00 + a12 * b01 + a22 * b02;
      a[3] = a03 * b00 + a13 * b01 + a23 * b02;
      a[4] = a00 * b10 + a10 * b11 + a20 * b12;
      a[5] = a01 * b10 + a11 * b11 + a21 * b12;
      a[6] = a02 * b10 + a12 * b11 + a22 * b12;
      a[7] = a03 * b10 + a13 * b11 + a23 * b12;
      a[8] = a00 * b20 + a10 * b21 + a20 * b22;
      a[9] = a01 * b20 + a11 * b21 + a21 * b22;
      a[10] = a02 * b20 + a12 * b21 + a22 * b22;
      a[11] = a03 * b20 + a13 * b21 + a23 * b22;
      return this;
    }
    makeRotationAxis(axis, angle) {
      const te = this.elements;
      const c = Math.cos(angle);
      const s = Math.sin(angle);
      const t = 1 - c;
      const x = axis.elements[0], y = axis.elements[1], z = axis.elements[2];
      const tx = t * x, ty = t * y;
      te[0] = tx * x + c;
      te[1] = tx * y - s * z;
      te[2] = tx * z + s * y;
      te[3] = 0;
      te[4] = tx * y + s * z;
      te[5] = ty * y + c;
      te[6] = ty * z - s * x;
      te[7] = 0;
      te[8] = tx * z - s * y;
      te[9] = ty * z + s * x;
      te[10] = t * z * z + c;
      te[11] = 0;
      te[15] = 1;
      return this;
    }
    makeRotationFromQuaternion(q) {
      const te = this.elements;
      const x = q[0];
      const y = q[1];
      const z = q[2];
      const w = q[3];
      const x2 = x + x;
      const y2 = y + y;
      const z2 = z + z;
      const xx = x * x2;
      const xy = x * y2;
      const xz = x * z2;
      const yy = y * y2;
      const yz = y * z2;
      const zz = z * z2;
      const wx = w * x2;
      const wy = w * y2;
      const wz = w * z2;
      te[0] = 1 - (yy + zz);
      te[4] = xy - wz;
      te[8] = xz + wy;
      te[1] = xy + wz;
      te[5] = 1 - (xx + zz);
      te[9] = yz - wx;
      te[2] = xz - wy;
      te[6] = yz + wx;
      te[10] = 1 - (xx + yy);
      return this;
    }
    transpose() {
      let e;
      let t;
      e = this.elements;
      t = e[1];
      e[1] = e[4];
      e[4] = t;
      t = e[2];
      e[2] = e[8];
      e[8] = t;
      t = e[3];
      e[3] = e[12];
      e[12] = t;
      t = e[6];
      e[6] = e[9];
      e[9] = t;
      t = e[7];
      e[7] = e[13];
      e[13] = t;
      t = e[11];
      e[11] = e[14];
      e[14] = t;
      return this;
    }
  };
  var Vector = class {
    elements;
    constructor(src) {
      this.elements = src.slice();
    }
    lerp(a, b, t) {
      const out = this.elements;
      for (let i = 0; i < out.length; i++) {
        out[i] = a[i] + t * (b[i] - a[i]);
      }
      return this;
    }
  };
  var Vector3 = class _Vector3 {
    elements;
    get x() {
      return this.elements[0];
    }
    get y() {
      return this.elements[1];
    }
    get z() {
      return this.elements[2];
    }
    set x(v) {
      this.elements[0] = v;
    }
    set y(v) {
      this.elements[1] = v;
    }
    set z(v) {
      this.elements[2] = v;
    }
    static FromArrayToRef(array, offset, result) {
      result.x = array[offset];
      result.y = array[offset + 1];
      result.z = array[offset + 2];
    }
    constructor(opt_src) {
      const v = new Float32Array(3);
      if (opt_src && typeof opt_src === "object") {
        v[0] = opt_src[0];
        v[1] = opt_src[1];
        v[2] = opt_src[2];
      }
      this.elements = v;
    }
    projectOnVector(vector) {
      const scalar = _Vector3.dot(vector, this) / vector.lengthSq();
      return new _Vector3(vector).scale(scalar);
    }
    applyQuaternion({ elements }) {
      const x = this.elements[0];
      const y = this.elements[1];
      const z = this.elements[2];
      const qx = elements[0];
      const qy = elements[1];
      const qz = elements[2];
      const qw = elements[3];
      const ix = qw * x + qy * z - qz * y;
      const iy = qw * y + qz * x - qx * z;
      const iz = qw * z + qx * y - qy * x;
      const iw = -qx * x - qy * y - qz * z;
      this.elements[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      this.elements[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      this.elements[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
      return this;
    }
    /**
     * Normalize.
     * @return this
     */
    normalize() {
      const v = this.elements;
      const c = v[0];
      const d = v[1];
      const e = v[2];
      let g = Math.sqrt(c * c + d * d + e * e);
      if (g) {
        if (g == 1) {
          return this;
        }
      } else {
        v[0] = 0;
        v[1] = 0;
        v[2] = 0;
        return this;
      }
      g = 1 / g;
      v[0] = c * g;
      v[1] = d * g;
      v[2] = e * g;
      return this;
    }
    /**
     * Scales a vec3 by a scalar number
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the vector to scale
     * @param {Number} b amount to scale the vector by
     * @returns {vec3} out
     */
    add(b) {
      const a = this.elements;
      b = b.elements;
      a[0] = a[0] + b[0];
      a[1] = a[1] + b[1];
      a[2] = a[2] + b[2];
      return this;
    }
    addS(b) {
      const a = this.elements;
      a[0] = a[0] + b;
      a[1] = a[1] + b;
      a[2] = a[2] + b;
      return this;
    }
    scale(b) {
      const a = this.elements;
      a[0] = a[0] * b;
      a[1] = a[1] * b;
      a[2] = a[2] * b;
      return this;
    }
    scale2(scale) {
      return new _Vector3([this.x * scale, this.y * scale, this.z * scale]);
    }
    subtract2(otherVector) {
      return new _Vector3([this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z]);
    }
    add2(otherVector) {
      return new _Vector3([this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z]);
    }
    distanceToSquared(x, y, z) {
      const dx = this.elements[0] - x;
      const dy = this.elements[1] - y;
      const dz = this.elements[2] - z;
      return dx * dx + dy * dy + dz * dz;
    }
    subtract(b) {
      const out = this.elements;
      b = b.elements;
      out[0] = out[0] - b[0];
      out[1] = out[1] - b[1];
      out[2] = out[2] - b[2];
      return this;
    }
    divideScalar(scalar) {
      return this.scale(1 / scalar);
    }
    applyMatrix4({ elements }) {
      const x = this.elements[0];
      const y = this.elements[1];
      const z = this.elements[2];
      const e = elements;
      this.elements[0] = e[0] * x + e[4] * y + e[8] * z + e[12];
      this.elements[1] = e[1] * x + e[5] * y + e[9] * z + e[13];
      this.elements[2] = e[2] * x + e[6] * y + e[10] * z + e[14];
      const w = e[3] * x + e[7] * y + e[11] * z + e[15];
      return this.divideScalar(w);
    }
    lerp(a, b, t) {
      const out = this.elements;
      const ax = a[0];
      const ay = a[1];
      const az = a[2];
      out[0] = ax + t * (b[0] - ax);
      out[1] = ay + t * (b[1] - ay);
      out[2] = az + t * (b[2] - az);
      return this;
    }
    lengthSq() {
      return this.elements[0] * this.elements[0] + this.elements[1] * this.elements[1] + this.elements[2] * this.elements[2];
    }
    multiply({ elements }) {
      this.elements[0] *= elements[0];
      this.elements[1] *= elements[1];
      this.elements[2] *= elements[2];
      return this;
    }
    static angle(a, b) {
      const tempA = new _Vector3(a.elements);
      const tempB = new _Vector3(b.elements);
      tempA.normalize();
      tempB.normalize();
      const cosine = _Vector3.dot(tempA, tempB);
      if (cosine > 1) {
        return 0;
      } else {
        return Math.acos(cosine);
      }
    }
    static cross(a, b) {
      a = a.elements;
      b = b.elements;
      const ax = a[0];
      const ay = a[1];
      const az = a[2];
      const bx = b[0];
      const by = b[1];
      const bz = b[2];
      const out = new _Vector3();
      out.elements[0] = ay * bz - az * by;
      out.elements[1] = az * bx - ax * bz;
      out.elements[2] = ax * by - ay * bx;
      return out;
    }
    static dot(a, b) {
      a = a.elements;
      b = b.elements;
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      return this;
    }
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      return this;
    }
  };
  var Box = class {
    min = new Vector3([Infinity, Infinity, Infinity]);
    max = new Vector3([-Infinity, -Infinity, -Infinity]);
    expand(box) {
      this.min.min(box.min);
      this.max.max(box.max);
    }
    getSize() {
      const size = new Vector3();
      size.subVectors(this.max, this.min);
      return size.length();
    }
  };
  var Vector4 = class {
    elements;
    constructor(opt_src) {
      const v = new Float32Array(4);
      if (opt_src && typeof opt_src === "object") {
        v[0] = opt_src[0];
        v[1] = opt_src[1];
        v[2] = opt_src[2];
        v[3] = opt_src[3];
      }
      this.elements = v;
    }
    set(e) {
      const a = this.elements;
      a[0] = e[0];
      a[1] = e[1];
      a[2] = e[2];
      a[3] = e[3];
      return this;
    }
    add(b) {
      const a = this.elements;
      b = b.elements;
      a[0] = b[0];
      a[1] = b[1];
      a[2] = b[2];
      a[3] = a[3] + b[3];
      return this;
    }
    normalize() {
      const x = this.elements[0];
      const y = this.elements[1];
      const z = this.elements[2];
      const w = this.elements[3];
      let len = x * x + y * y + z * z + w * w;
      if (len > 0) {
        len = 1 / Math.sqrt(len);
        this.elements[0] = x * len;
        this.elements[1] = y * len;
        this.elements[2] = z * len;
        this.elements[3] = w * len;
      }
      return this;
    }
    setFromRotationMatrix({ elements }) {
      const te = elements;
      const m11 = te[0];
      const m12 = te[4];
      const m13 = te[8];
      const m21 = te[1];
      const m22 = te[5];
      const m23 = te[9];
      const m31 = te[2];
      const m32 = te[6];
      const m33 = te[10];
      const trace = m11 + m22 + m33;
      let s;
      if (trace > 0) {
        s = 0.5 / Math.sqrt(trace + 1);
        this.elements[3] = 0.25 / s;
        this.elements[0] = (m32 - m23) * s;
        this.elements[1] = (m13 - m31) * s;
        this.elements[2] = (m21 - m12) * s;
      } else if (m11 > m22 && m11 > m33) {
        s = 2 * Math.sqrt(1 + m11 - m22 - m33);
        this.elements[3] = (m32 - m23) / s;
        this.elements[0] = 0.25 * s;
        this.elements[1] = (m12 + m21) / s;
        this.elements[2] = (m13 + m31) / s;
      } else if (m22 > m33) {
        s = 2 * Math.sqrt(1 + m22 - m11 - m33);
        this.elements[3] = (m13 - m31) / s;
        this.elements[0] = (m12 + m21) / s;
        this.elements[1] = 0.25 * s;
        this.elements[2] = (m23 + m32) / s;
      } else {
        s = 2 * Math.sqrt(1 + m33 - m11 - m22);
        this.elements[3] = (m21 - m12) / s;
        this.elements[0] = (m13 + m31) / s;
        this.elements[1] = (m23 + m32) / s;
        this.elements[2] = 0.25 * s;
      }
      return this;
    }
    lerp(a, b, t) {
      const out = this.elements;
      if (t === 0) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        return this;
      }
      if (t === 1) {
        out[0] = b[0];
        out[1] = b[1];
        out[2] = b[2];
        out[3] = b[3];
        return this;
      }
      const x = a[0], y = a[1], z = a[2], w = a[3];
      let cosHalfTheta = w * b[3] + x * b[0] + y * b[1] + z * b[2];
      if (cosHalfTheta < 0) {
        out[3] = -b[3];
        out[0] = -b[0];
        out[1] = -b[1];
        out[2] = -b[2];
        cosHalfTheta = -cosHalfTheta;
      } else {
        out[0] = b[0];
        out[1] = b[1];
        out[2] = b[2];
        out[3] = b[3];
      }
      if (cosHalfTheta >= 1) {
        out[3] = w;
        out[0] = x;
        out[1] = y;
        out[2] = z;
        return this;
      }
      const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
      if (sqrSinHalfTheta <= Number.EPSILON) {
        var s = 1 - t;
        out[3] = s * w + t * out[3];
        out[0] = s * x + t * out[0];
        out[1] = s * y + t * out[1];
        out[2] = s * z + t * out[2];
        return this.normalize();
      }
      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
      const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
      const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
      out[3] = w * ratioA + out[3] * ratioB;
      out[0] = x * ratioA + out[0] * ratioB;
      out[1] = y * ratioA + out[1] * ratioB;
      out[2] = z * ratioA + out[2] * ratioB;
      return this;
    }
    inverse() {
      this.elements[0] = -this.elements[0];
      this.elements[1] = -this.elements[1];
      this.elements[2] = -this.elements[2];
      return this;
    }
  };
  var Vector2 = class {
    elements;
    get x() {
      return this.elements[0];
    }
    get y() {
      return this.elements[1];
    }
    set x(v) {
      this.elements[0] = v;
    }
    set y(v) {
      this.elements[1] = v;
    }
    constructor(opt_src) {
      const v = new Float32Array(2);
      if (opt_src && typeof opt_src === "object") {
        v[0] = opt_src[0];
        v[1] = opt_src[1];
      }
      this.elements = v;
    }
    subtract(b) {
      const out = this.elements;
      b = b.elements;
      out[0] = out[0] - b[0];
      out[1] = out[1] - b[1];
      return this;
    }
    lerp(a, b, t) {
      const out = this.elements;
      const ax = a[0];
      const ay = a[1];
      out[0] = ax + t * (b[0] - ax);
      out[1] = ay + t * (b[1] - ay);
      return this;
    }
  };
  function Frustum(m) {
    const planes = [new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4()];
    const me = m.elements;
    let me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    let me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    let me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    let me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].set([me3 - me0, me7 - me4, me11 - me8, me15 - me12]).normalize();
    planes[1].set([me3 + me0, me7 + me4, me11 + me8, me15 + me12]).normalize();
    planes[2].set([me3 + me1, me7 + me5, me11 + me9, me15 + me13]).normalize();
    planes[3].set([me3 - me1, me7 - me5, me11 - me9, me15 - me13]).normalize();
    planes[4].set([me3 - me2, me7 - me6, me11 - me10, me15 - me14]).normalize();
    planes[5].set([me3 + me2, me7 + me6, me11 + me10, me15 + me14]).normalize();
    return planes;
  }

  // src/objects/scene.ts
  var Scene = class {
    children;
    bin;
    matrixWorld;
    matrix;
    transparentChildren;
    opaqueChildren;
    meshes;
    tracks;
    cameras;
    lights;
    variants;
    constructor() {
      this.opaqueChildren = [];
      this.transparentChildren = [];
      this.meshes = [];
      this.children = [];
      this.bin = [];
      this.matrixWorld = new Matrix4();
      this.matrix = new Matrix4();
      this.variants = [];
    }
  };

  // src/objects/object3d.ts
  var Object3D = class {
    uuid;
    name;
    id;
    children;
    matrix;
    matrixWorld;
    parent;
    reflow;
    repaint;
    constructor(name, parent) {
      this.uuid = Math.floor(Date.now() * Math.random());
      this.name = name;
      this.children = [];
      this.matrix = new Matrix4();
      this.matrixWorld = new Matrix4();
      this.parent = parent;
    }
    getPosition() {
      return new Float32Array([this.matrixWorld.elements[12], this.matrixWorld.elements[13], this.matrixWorld.elements[14]]);
    }
    setPosition(translation, rotation, scale) {
      if (rotation) {
        this.matrix.makeRotationFromQuaternion(rotation);
      }
      if (scale) {
        this.matrix.scale(new Vector3(scale));
      }
      if (translation) {
        this.matrix.setTranslate(new Vector3(translation));
      }
    }
    setMatrix(matrix) {
      this.matrix.set(matrix);
    }
    setMatrixWorld(matrix) {
      this.matrixWorld.set(matrix);
    }
    updateMatrix() {
      const m = new Matrix4();
      m.multiply(this.parent.matrixWorld);
      m.multiply(this.matrix);
      this.setMatrixWorld(m.elements);
    }
  };

  // src/glEnum.ts
  var glEnum_default = {
    "0": "NONE",
    "1": "ONE",
    "2": "LINE_LOOP",
    "3": "LINE_STRIP",
    "4": "TRIANGLES",
    "5": "TRIANGLE_STRIP",
    "6": "TRIANGLE_FAN",
    "256": "DEPTH_BUFFER_BIT",
    "512": "NEVER",
    "513": "LESS",
    "514": "EQUAL",
    "515": "LEQUAL",
    "516": "GREATER",
    "517": "NOTEQUAL",
    "518": "GEQUAL",
    "519": "ALWAYS",
    "768": "SRC_COLOR",
    "769": "ONE_MINUS_SRC_COLOR",
    "770": "SRC_ALPHA",
    "771": "ONE_MINUS_SRC_ALPHA",
    "772": "DST_ALPHA",
    "773": "ONE_MINUS_DST_ALPHA",
    "774": "DST_COLOR",
    "775": "ONE_MINUS_DST_COLOR",
    "776": "SRC_ALPHA_SATURATE",
    "1024": "STENCIL_BUFFER_BIT",
    "1028": "FRONT",
    "1029": "BACK",
    "1032": "FRONT_AND_BACK",
    "1280": "INVALID_ENUM",
    "1281": "INVALID_VALUE",
    "1282": "INVALID_OPERATION",
    "1285": "OUT_OF_MEMORY",
    "1286": "INVALID_FRAMEBUFFER_OPERATION",
    "1798": "drawingBufferHeight",
    "2304": "CW",
    "2305": "CCW",
    "2712": "drawingBufferWidth",
    "2849": "LINE_WIDTH",
    "2884": "CULL_FACE",
    "2885": "CULL_FACE_MODE",
    "2886": "FRONT_FACE",
    "2928": "DEPTH_RANGE",
    "2929": "DEPTH_TEST",
    "2930": "DEPTH_WRITEMASK",
    "2931": "DEPTH_CLEAR_VALUE",
    "2932": "DEPTH_FUNC",
    "2960": "STENCIL_TEST",
    "2961": "STENCIL_CLEAR_VALUE",
    "2962": "STENCIL_FUNC",
    "2963": "STENCIL_VALUE_MASK",
    "2964": "STENCIL_FAIL",
    "2965": "STENCIL_PASS_DEPTH_FAIL",
    "2966": "STENCIL_PASS_DEPTH_PASS",
    "2967": "STENCIL_REF",
    "2968": "STENCIL_WRITEMASK",
    "2978": "VIEWPORT",
    "3024": "DITHER",
    "3042": "BLEND",
    "3074": "READ_BUFFER",
    "3088": "SCISSOR_BOX",
    "3089": "SCISSOR_TEST",
    "3106": "COLOR_CLEAR_VALUE",
    "3107": "COLOR_WRITEMASK",
    "3314": "UNPACK_ROW_LENGTH",
    "3315": "UNPACK_SKIP_ROWS",
    "3316": "UNPACK_SKIP_PIXELS",
    "3317": "UNPACK_ALIGNMENT",
    "3330": "PACK_ROW_LENGTH",
    "3331": "PACK_SKIP_ROWS",
    "3332": "PACK_SKIP_PIXELS",
    "3333": "PACK_ALIGNMENT",
    "3379": "MAX_TEXTURE_SIZE",
    "3386": "MAX_VIEWPORT_DIMS",
    "3408": "SUBPIXEL_BITS",
    "3410": "RED_BITS",
    "3411": "GREEN_BITS",
    "3412": "BLUE_BITS",
    "3413": "ALPHA_BITS",
    "3414": "DEPTH_BITS",
    "3415": "STENCIL_BITS",
    "3553": "TEXTURE_2D",
    "4352": "DONT_CARE",
    "4353": "FASTEST",
    "4354": "NICEST",
    "5120": "BYTE",
    "5121": "UNSIGNED_BYTE",
    "5122": "SHORT",
    "5123": "UNSIGNED_SHORT",
    "5124": "INT",
    "5125": "UNSIGNED_INT",
    "5126": "FLOAT",
    "5131": "HALF_FLOAT",
    "5386": "INVERT",
    "5890": "TEXTURE",
    "6144": "COLOR",
    "6145": "DEPTH",
    "6146": "STENCIL",
    "6402": "DEPTH_COMPONENT",
    "6403": "RED",
    "6406": "ALPHA",
    "6407": "RGB",
    "6408": "RGBA",
    "6409": "LUMINANCE",
    "6410": "LUMINANCE_ALPHA",
    "7680": "KEEP",
    "7681": "REPLACE",
    "7682": "INCR",
    "7683": "DECR",
    "7936": "VENDOR",
    "7937": "RENDERER",
    "7938": "VERSION",
    "9728": "NEAREST",
    "9729": "LINEAR",
    "9984": "NEAREST_MIPMAP_NEAREST",
    "9985": "LINEAR_MIPMAP_NEAREST",
    "9986": "NEAREST_MIPMAP_LINEAR",
    "9987": "LINEAR_MIPMAP_LINEAR",
    "10240": "TEXTURE_MAG_FILTER",
    "10241": "TEXTURE_MIN_FILTER",
    "10242": "TEXTURE_WRAP_S",
    "10243": "TEXTURE_WRAP_T",
    "10497": "REPEAT",
    "10752": "POLYGON_OFFSET_UNITS",
    "16384": "COLOR_BUFFER_BIT",
    "32769": "CONSTANT_COLOR",
    "32770": "ONE_MINUS_CONSTANT_COLOR",
    "32771": "CONSTANT_ALPHA",
    "32772": "ONE_MINUS_CONSTANT_ALPHA",
    "32773": "BLEND_COLOR",
    "32774": "FUNC_ADD",
    "32775": "MIN",
    "32776": "MAX",
    "32777": "BLEND_EQUATION_RGB",
    "32778": "FUNC_SUBTRACT",
    "32779": "FUNC_REVERSE_SUBTRACT",
    "32819": "UNSIGNED_SHORT_4_4_4_4",
    "32820": "UNSIGNED_SHORT_5_5_5_1",
    "32823": "POLYGON_OFFSET_FILL",
    "32824": "POLYGON_OFFSET_FACTOR",
    "32849": "RGB8",
    "32854": "RGBA4",
    "32855": "RGB5_A1",
    "32856": "RGBA8",
    "32857": "RGB10_A2",
    "32873": "TEXTURE_BINDING_2D",
    "32874": "TEXTURE_BINDING_3D",
    "32877": "UNPACK_SKIP_IMAGES",
    "32878": "UNPACK_IMAGE_HEIGHT",
    "32879": "TEXTURE_3D",
    "32882": "TEXTURE_WRAP_R",
    "32883": "MAX_3D_TEXTURE_SIZE",
    "32926": "SAMPLE_ALPHA_TO_COVERAGE",
    "32928": "SAMPLE_COVERAGE",
    "32936": "SAMPLE_BUFFERS",
    "32937": "SAMPLES",
    "32938": "SAMPLE_COVERAGE_VALUE",
    "32939": "SAMPLE_COVERAGE_INVERT",
    "32968": "BLEND_DST_RGB",
    "32969": "BLEND_SRC_RGB",
    "32970": "BLEND_DST_ALPHA",
    "32971": "BLEND_SRC_ALPHA",
    "33000": "MAX_ELEMENTS_VERTICES",
    "33001": "MAX_ELEMENTS_INDICES",
    "33071": "CLAMP_TO_EDGE",
    "33082": "TEXTURE_MIN_LOD",
    "33083": "TEXTURE_MAX_LOD",
    "33084": "TEXTURE_BASE_LEVEL",
    "33085": "TEXTURE_MAX_LEVEL",
    "33170": "GENERATE_MIPMAP_HINT",
    "33189": "DEPTH_COMPONENT16",
    "33190": "DEPTH_COMPONENT24",
    "33296": "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING",
    "33297": "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE",
    "33298": "FRAMEBUFFER_ATTACHMENT_RED_SIZE",
    "33299": "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE",
    "33300": "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE",
    "33301": "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE",
    "33302": "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE",
    "33303": "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE",
    "33304": "FRAMEBUFFER_DEFAULT",
    "33306": "DEPTH_STENCIL_ATTACHMENT",
    "33319": "RG",
    "33320": "RG_INTEGER",
    "33321": "R8",
    "33323": "RG8",
    "33325": "R16F",
    "33326": "R32F",
    "33327": "RG16F",
    "33328": "RG32F",
    "33329": "R8I",
    "33330": "R8UI",
    "33331": "R16I",
    "33332": "R16UI",
    "33333": "R32I",
    "33334": "R32UI",
    "33335": "RG8I",
    "33336": "RG8UI",
    "33337": "RG16I",
    "33338": "RG16UI",
    "33339": "RG32I",
    "33340": "RG32UI",
    "33503": "TEXTURE_IMMUTABLE_LEVELS",
    "33635": "UNSIGNED_SHORT_5_6_5",
    "33640": "UNSIGNED_INT_2_10_10_10_REV",
    "33648": "MIRRORED_REPEAT",
    "33901": "ALIASED_POINT_SIZE_RANGE",
    "33902": "ALIASED_LINE_WIDTH_RANGE",
    "33984": "TEXTURE0",
    "33985": "TEXTURE1",
    "33986": "TEXTURE2",
    "33987": "TEXTURE3",
    "33988": "TEXTURE4",
    "33989": "TEXTURE5",
    "33990": "TEXTURE6",
    "33991": "TEXTURE7",
    "33992": "TEXTURE8",
    "33993": "TEXTURE9",
    "33994": "TEXTURE10",
    "33995": "TEXTURE11",
    "33996": "TEXTURE12",
    "33997": "TEXTURE13",
    "33998": "TEXTURE14",
    "33999": "TEXTURE15",
    "34000": "TEXTURE16",
    "34001": "TEXTURE17",
    "34002": "TEXTURE18",
    "34003": "TEXTURE19",
    "34004": "TEXTURE20",
    "34005": "TEXTURE21",
    "34006": "TEXTURE22",
    "34007": "TEXTURE23",
    "34008": "TEXTURE24",
    "34009": "TEXTURE25",
    "34010": "TEXTURE26",
    "34011": "TEXTURE27",
    "34012": "TEXTURE28",
    "34013": "TEXTURE29",
    "34014": "TEXTURE30",
    "34015": "TEXTURE31",
    "34016": "ACTIVE_TEXTURE",
    "34024": "MAX_RENDERBUFFER_SIZE",
    "34041": "DEPTH_STENCIL",
    "34042": "UNSIGNED_INT_24_8",
    "34045": "MAX_TEXTURE_LOD_BIAS",
    "34055": "INCR_WRAP",
    "34056": "DECR_WRAP",
    "34067": "TEXTURE_CUBE_MAP",
    "34068": "TEXTURE_BINDING_CUBE_MAP",
    "34069": "TEXTURE_CUBE_MAP_POSITIVE_X",
    "34070": "TEXTURE_CUBE_MAP_NEGATIVE_X",
    "34071": "TEXTURE_CUBE_MAP_POSITIVE_Y",
    "34072": "TEXTURE_CUBE_MAP_NEGATIVE_Y",
    "34073": "TEXTURE_CUBE_MAP_POSITIVE_Z",
    "34074": "TEXTURE_CUBE_MAP_NEGATIVE_Z",
    "34076": "MAX_CUBE_MAP_TEXTURE_SIZE",
    "34229": "VERTEX_ARRAY_BINDING",
    "34338": "VERTEX_ATTRIB_ARRAY_ENABLED",
    "34339": "VERTEX_ATTRIB_ARRAY_SIZE",
    "34340": "VERTEX_ATTRIB_ARRAY_STRIDE",
    "34341": "VERTEX_ATTRIB_ARRAY_TYPE",
    "34342": "CURRENT_VERTEX_ATTRIB",
    "34373": "VERTEX_ATTRIB_ARRAY_POINTER",
    "34467": "COMPRESSED_TEXTURE_FORMATS",
    "34660": "BUFFER_SIZE",
    "34661": "BUFFER_USAGE",
    "34816": "STENCIL_BACK_FUNC",
    "34817": "STENCIL_BACK_FAIL",
    "34818": "STENCIL_BACK_PASS_DEPTH_FAIL",
    "34819": "STENCIL_BACK_PASS_DEPTH_PASS",
    "34836": "RGBA32F",
    "34837": "RGB32F",
    "34842": "RGBA16F",
    "34843": "RGB16F",
    "34852": "MAX_DRAW_BUFFERS",
    "34853": "DRAW_BUFFER0",
    "34854": "DRAW_BUFFER1",
    "34855": "DRAW_BUFFER2",
    "34856": "DRAW_BUFFER3",
    "34857": "DRAW_BUFFER4",
    "34858": "DRAW_BUFFER5",
    "34859": "DRAW_BUFFER6",
    "34860": "DRAW_BUFFER7",
    "34861": "DRAW_BUFFER8",
    "34862": "DRAW_BUFFER9",
    "34863": "DRAW_BUFFER10",
    "34864": "DRAW_BUFFER11",
    "34865": "DRAW_BUFFER12",
    "34866": "DRAW_BUFFER13",
    "34867": "DRAW_BUFFER14",
    "34868": "DRAW_BUFFER15",
    "34877": "BLEND_EQUATION_ALPHA",
    "34892": "TEXTURE_COMPARE_MODE",
    "34893": "TEXTURE_COMPARE_FUNC",
    "34894": "COMPARE_REF_TO_TEXTURE",
    "34917": "CURRENT_QUERY",
    "34918": "QUERY_RESULT",
    "34919": "QUERY_RESULT_AVAILABLE",
    "34921": "MAX_VERTEX_ATTRIBS",
    "34922": "VERTEX_ATTRIB_ARRAY_NORMALIZED",
    "34930": "MAX_TEXTURE_IMAGE_UNITS",
    "34962": "ARRAY_BUFFER",
    "34963": "ELEMENT_ARRAY_BUFFER",
    "34964": "ARRAY_BUFFER_BINDING",
    "34965": "ELEMENT_ARRAY_BUFFER_BINDING",
    "34975": "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",
    "35040": "STREAM_DRAW",
    "35041": "STREAM_READ",
    "35042": "STREAM_COPY",
    "35044": "STATIC_DRAW",
    "35045": "STATIC_READ",
    "35046": "STATIC_COPY",
    "35048": "DYNAMIC_DRAW",
    "35049": "DYNAMIC_READ",
    "35050": "DYNAMIC_COPY",
    "35051": "PIXEL_PACK_BUFFER",
    "35052": "PIXEL_UNPACK_BUFFER",
    "35053": "PIXEL_PACK_BUFFER_BINDING",
    "35055": "PIXEL_UNPACK_BUFFER_BINDING",
    "35056": "DEPTH24_STENCIL8",
    "35069": "VERTEX_ATTRIB_ARRAY_INTEGER",
    "35070": "VERTEX_ATTRIB_ARRAY_DIVISOR",
    "35071": "MAX_ARRAY_TEXTURE_LAYERS",
    "35076": "MIN_PROGRAM_TEXEL_OFFSET",
    "35077": "MAX_PROGRAM_TEXEL_OFFSET",
    "35097": "SAMPLER_BINDING",
    "35345": "UNIFORM_BUFFER",
    "35368": "UNIFORM_BUFFER_BINDING",
    "35369": "UNIFORM_BUFFER_START",
    "35370": "UNIFORM_BUFFER_SIZE",
    "35371": "MAX_VERTEX_UNIFORM_BLOCKS",
    "35373": "MAX_FRAGMENT_UNIFORM_BLOCKS",
    "35374": "MAX_COMBINED_UNIFORM_BLOCKS",
    "35375": "MAX_UNIFORM_BUFFER_BINDINGS",
    "35376": "MAX_UNIFORM_BLOCK_SIZE",
    "35377": "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS",
    "35379": "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS",
    "35380": "UNIFORM_BUFFER_OFFSET_ALIGNMENT",
    "35382": "ACTIVE_UNIFORM_BLOCKS",
    "35383": "UNIFORM_TYPE",
    "35384": "UNIFORM_SIZE",
    "35386": "UNIFORM_BLOCK_INDEX",
    "35387": "UNIFORM_OFFSET",
    "35388": "UNIFORM_ARRAY_STRIDE",
    "35389": "UNIFORM_MATRIX_STRIDE",
    "35390": "UNIFORM_IS_ROW_MAJOR",
    "35391": "UNIFORM_BLOCK_BINDING",
    "35392": "UNIFORM_BLOCK_DATA_SIZE",
    "35394": "UNIFORM_BLOCK_ACTIVE_UNIFORMS",
    "35395": "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES",
    "35396": "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER",
    "35398": "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER",
    "35632": "FRAGMENT_SHADER",
    "35633": "VERTEX_SHADER",
    "35657": "MAX_FRAGMENT_UNIFORM_COMPONENTS",
    "35658": "MAX_VERTEX_UNIFORM_COMPONENTS",
    "35659": "MAX_VARYING_COMPONENTS",
    "35660": "MAX_VERTEX_TEXTURE_IMAGE_UNITS",
    "35661": "MAX_COMBINED_TEXTURE_IMAGE_UNITS",
    "35663": "SHADER_TYPE",
    "35664": "FLOAT_VEC2",
    "35665": "FLOAT_VEC3",
    "35666": "FLOAT_VEC4",
    "35667": "INT_VEC2",
    "35668": "INT_VEC3",
    "35669": "INT_VEC4",
    "35670": "BOOL",
    "35671": "BOOL_VEC2",
    "35672": "BOOL_VEC3",
    "35673": "BOOL_VEC4",
    "35674": "FLOAT_MAT2",
    "35675": "FLOAT_MAT3",
    "35676": "FLOAT_MAT4",
    "35678": "SAMPLER_2D",
    "35679": "SAMPLER_3D",
    "35680": "SAMPLER_CUBE",
    "35682": "SAMPLER_2D_SHADOW",
    "35685": "FLOAT_MAT2x3",
    "35686": "FLOAT_MAT2x4",
    "35687": "FLOAT_MAT3x2",
    "35688": "FLOAT_MAT3x4",
    "35689": "FLOAT_MAT4x2",
    "35690": "FLOAT_MAT4x3",
    "35712": "DELETE_STATUS",
    "35713": "COMPILE_STATUS",
    "35714": "LINK_STATUS",
    "35715": "VALIDATE_STATUS",
    "35717": "ATTACHED_SHADERS",
    "35718": "ACTIVE_UNIFORMS",
    "35721": "ACTIVE_ATTRIBUTES",
    "35723": "FRAGMENT_SHADER_DERIVATIVE_HINT",
    "35724": "SHADING_LANGUAGE_VERSION",
    "35725": "CURRENT_PROGRAM",
    "35738": "IMPLEMENTATION_COLOR_READ_TYPE",
    "35739": "IMPLEMENTATION_COLOR_READ_FORMAT",
    "35863": "UNSIGNED_NORMALIZED",
    "35866": "TEXTURE_2D_ARRAY",
    "35869": "TEXTURE_BINDING_2D_ARRAY",
    "35887": "ANY_SAMPLES_PASSED",
    "35898": "R11F_G11F_B10F",
    "35899": "UNSIGNED_INT_10F_11F_11F_REV",
    "35901": "RGB9_E5",
    "35902": "UNSIGNED_INT_5_9_9_9_REV",
    "35904": "SRGB",
    "35905": "SRGB8",
    "35907": "SRGB8_ALPHA8",
    "35967": "TRANSFORM_FEEDBACK_BUFFER_MODE",
    "35968": "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS",
    "35971": "TRANSFORM_FEEDBACK_VARYINGS",
    "35972": "TRANSFORM_FEEDBACK_BUFFER_START",
    "35973": "TRANSFORM_FEEDBACK_BUFFER_SIZE",
    "35976": "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN",
    "35977": "RASTERIZER_DISCARD",
    "35978": "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS",
    "35979": "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS",
    "35980": "INTERLEAVED_ATTRIBS",
    "35981": "SEPARATE_ATTRIBS",
    "35982": "TRANSFORM_FEEDBACK_BUFFER",
    "35983": "TRANSFORM_FEEDBACK_BUFFER_BINDING",
    "36003": "STENCIL_BACK_REF",
    "36004": "STENCIL_BACK_VALUE_MASK",
    "36005": "STENCIL_BACK_WRITEMASK",
    "36006": "FRAMEBUFFER_BINDING",
    "36007": "RENDERBUFFER_BINDING",
    "36008": "READ_FRAMEBUFFER",
    "36009": "DRAW_FRAMEBUFFER",
    "36010": "READ_FRAMEBUFFER_BINDING",
    "36011": "RENDERBUFFER_SAMPLES",
    "36012": "DEPTH_COMPONENT32F",
    "36013": "DEPTH32F_STENCIL8",
    "36048": "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",
    "36049": "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",
    "36050": "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",
    "36051": "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",
    "36052": "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER",
    "36053": "FRAMEBUFFER_COMPLETE",
    "36054": "FRAMEBUFFER_INCOMPLETE_ATTACHMENT",
    "36055": "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",
    "36057": "FRAMEBUFFER_INCOMPLETE_DIMENSIONS",
    "36061": "FRAMEBUFFER_UNSUPPORTED",
    "36063": "MAX_COLOR_ATTACHMENTS",
    "36064": "COLOR_ATTACHMENT0",
    "36065": "COLOR_ATTACHMENT1",
    "36066": "COLOR_ATTACHMENT2",
    "36067": "COLOR_ATTACHMENT3",
    "36068": "COLOR_ATTACHMENT4",
    "36069": "COLOR_ATTACHMENT5",
    "36070": "COLOR_ATTACHMENT6",
    "36071": "COLOR_ATTACHMENT7",
    "36072": "COLOR_ATTACHMENT8",
    "36073": "COLOR_ATTACHMENT9",
    "36074": "COLOR_ATTACHMENT10",
    "36075": "COLOR_ATTACHMENT11",
    "36076": "COLOR_ATTACHMENT12",
    "36077": "COLOR_ATTACHMENT13",
    "36078": "COLOR_ATTACHMENT14",
    "36079": "COLOR_ATTACHMENT15",
    "36096": "DEPTH_ATTACHMENT",
    "36128": "STENCIL_ATTACHMENT",
    "36160": "FRAMEBUFFER",
    "36161": "RENDERBUFFER",
    "36162": "RENDERBUFFER_WIDTH",
    "36163": "RENDERBUFFER_HEIGHT",
    "36164": "RENDERBUFFER_INTERNAL_FORMAT",
    "36168": "STENCIL_INDEX8",
    "36176": "RENDERBUFFER_RED_SIZE",
    "36177": "RENDERBUFFER_GREEN_SIZE",
    "36178": "RENDERBUFFER_BLUE_SIZE",
    "36179": "RENDERBUFFER_ALPHA_SIZE",
    "36180": "RENDERBUFFER_DEPTH_SIZE",
    "36181": "RENDERBUFFER_STENCIL_SIZE",
    "36182": "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE",
    "36183": "MAX_SAMPLES",
    "36194": "RGB565",
    "36202": "ANY_SAMPLES_PASSED_CONSERVATIVE",
    "36203": "MAX_ELEMENT_INDEX",
    "36208": "RGBA32UI",
    "36209": "RGB32UI",
    "36214": "RGBA16UI",
    "36215": "RGB16UI",
    "36220": "RGBA8UI",
    "36221": "RGB8UI",
    "36226": "RGBA32I",
    "36227": "RGB32I",
    "36232": "RGBA16I",
    "36233": "RGB16I",
    "36238": "RGBA8I",
    "36239": "RGB8I",
    "36244": "RED_INTEGER",
    "36248": "RGB_INTEGER",
    "36249": "RGBA_INTEGER",
    "36255": "INT_2_10_10_10_REV",
    "36269": "FLOAT_32_UNSIGNED_INT_24_8_REV",
    "36289": "SAMPLER_2D_ARRAY",
    "36292": "SAMPLER_2D_ARRAY_SHADOW",
    "36293": "SAMPLER_CUBE_SHADOW",
    "36294": "UNSIGNED_INT_VEC2",
    "36295": "UNSIGNED_INT_VEC3",
    "36296": "UNSIGNED_INT_VEC4",
    "36298": "INT_SAMPLER_2D",
    "36299": "INT_SAMPLER_3D",
    "36300": "INT_SAMPLER_CUBE",
    "36303": "INT_SAMPLER_2D_ARRAY",
    "36306": "UNSIGNED_INT_SAMPLER_2D",
    "36307": "UNSIGNED_INT_SAMPLER_3D",
    "36308": "UNSIGNED_INT_SAMPLER_CUBE",
    "36311": "UNSIGNED_INT_SAMPLER_2D_ARRAY",
    "36336": "LOW_FLOAT",
    "36337": "MEDIUM_FLOAT",
    "36338": "HIGH_FLOAT",
    "36339": "LOW_INT",
    "36340": "MEDIUM_INT",
    "36341": "HIGH_INT",
    "36347": "MAX_VERTEX_UNIFORM_VECTORS",
    "36348": "MAX_VARYING_VECTORS",
    "36349": "MAX_FRAGMENT_UNIFORM_VECTORS",
    "36386": "TRANSFORM_FEEDBACK",
    "36387": "TRANSFORM_FEEDBACK_PAUSED",
    "36388": "TRANSFORM_FEEDBACK_ACTIVE",
    "36389": "TRANSFORM_FEEDBACK_BINDING",
    "36662": "COPY_READ_BUFFER_BINDING",
    "36663": "COPY_WRITE_BUFFER_BINDING",
    "36756": "R8_SNORM",
    "36757": "RG8_SNORM",
    "36758": "RGB8_SNORM",
    "36759": "RGBA8_SNORM",
    "36764": "SIGNED_NORMALIZED",
    "36975": "RGB10_A2UI",
    "37137": "MAX_SERVER_WAIT_TIMEOUT",
    "37138": "OBJECT_TYPE",
    "37139": "SYNC_CONDITION",
    "37140": "SYNC_STATUS",
    "37141": "SYNC_FLAGS",
    "37142": "SYNC_FENCE",
    "37143": "SYNC_GPU_COMMANDS_COMPLETE",
    "37144": "UNSIGNALED",
    "37145": "SIGNALED",
    "37146": "ALREADY_SIGNALED",
    "37147": "TIMEOUT_EXPIRED",
    "37148": "CONDITION_SATISFIED",
    "37149": "WAIT_FAILED",
    "37154": "MAX_VERTEX_OUTPUT_COMPONENTS",
    "37157": "MAX_FRAGMENT_INPUT_COMPONENTS",
    "37167": "TEXTURE_IMMUTABLE_FORMAT",
    "37440": "UNPACK_FLIP_Y_WEBGL",
    "37441": "UNPACK_PREMULTIPLY_ALPHA_WEBGL",
    "37442": "CONTEXT_LOST_WEBGL",
    "37443": "UNPACK_COLORSPACE_CONVERSION_WEBGL",
    "37444": "BROWSER_DEFAULT_WEBGL",
    "37447": "MAX_CLIENT_WAIT_TIMEOUT_WEBGL",
    "4294967295": "INVALID_INDEX",
    "-1": "TIMEOUT_IGNORED"
  };

  // src/utils.ts
  var gl;
  var clearColor = [0, 0, 0, 1];
  var textureEnum = {
    baseColorTexture: 0,
    metallicRoughnessTexture: 1,
    normalTexture: 2,
    occlusionTexture: 3,
    emissiveTexture: 4,
    irradianceTexture: 5,
    prefilterTexture: 6,
    brdfLUTTexture: 7,
    clearcoatTexture: 8,
    clearcoatRoughnessTexture: 9,
    clearcoatNormalTexture: 10,
    sheenColorTexture: 11,
    sheenRoughnessTexture: 12,
    Sheen_E: 13,
    transmissionTexture: 14,
    specularTexture: 15,
    specularColorTexture: 19,
    thicknessTexture: 16,
    iridescenceThicknessTexture: 17,
    charlieTexture: 18,
    diffuseTransmissionTexture: 20,
    diffuseTransmissionColorTexture: 21,
    anisotropyTexture: 22,
    iridescenceTexture: 23
  };
  function random(min, max) {
    return Math.random() * (max - min) + min;
  }
  function lerp(a, b, f) {
    return a + f * (b - a);
  }
  function getDataType(type) {
    let count;
    switch (type) {
      case "MAT2":
        count = 4;
        break;
      case "MAT3":
        count = 9;
        break;
      case "MAT4":
        count = 16;
        break;
      case "VEC4":
        count = 4;
        break;
      case "VEC3":
        count = 3;
        break;
      case "VEC2":
        count = 2;
        break;
      case "SCALAR":
        count = 1;
        break;
    }
    return count;
  }
  function range(min, max, value) {
    return (value - min) / (max - min);
  }
  function interpolation(time, frames) {
    if (frames.length === 0) {
      return [-1, -1, 0];
    }
    let prev = -1;
    for (let i = frames.length - 1; i >= 0; i--) {
      if (time >= frames[i].time) {
        prev = i;
        break;
      }
    }
    if (prev === -1 || prev === frames.length - 1) {
      if (prev < 0) {
        prev = 0;
      }
      return [prev, prev, 0];
    } else {
      const startFrame = frames[prev];
      const endFrame = frames[prev + 1];
      time = Math.max(startFrame.time, Math.min(time, endFrame.time));
      const t = range(startFrame.time, endFrame.time, time);
      return [prev, prev + 1, t];
    }
  }
  function getCount(type) {
    let arr;
    switch (glEnum_default[type]) {
      case "BYTE":
      case "UNSIGNED_BYTE":
        arr = 1;
        break;
      case "SHORT":
      case "UNSIGNED_SHORT":
        arr = 2;
        break;
      case "UNSIGNED_INT":
      case "FLOAT":
        arr = 4;
        break;
    }
    return arr;
  }
  var ArrayBufferMap = /* @__PURE__ */ new Map();
  ArrayBufferMap.set(Int8Array, "BYTE");
  ArrayBufferMap.set(Uint8Array, "UNSIGNED_BYTE");
  ArrayBufferMap.set(Int16Array, "SHORT");
  ArrayBufferMap.set(Uint16Array, "UNSIGNED_SHORT");
  ArrayBufferMap.set(Uint32Array, "UNSIGNED_INT");
  ArrayBufferMap.set(Float32Array, "FLOAT");
  function buildArrayWithStride(arrayBuffer, accessor, bufferView) {
    const sizeofComponent = getCount(accessor.componentType);
    const typeofComponent = getDataType(accessor.type);
    const offset = (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
    const stride = bufferView.byteStride;
    const lengthByStride = stride * accessor.count / sizeofComponent;
    const requiredLength = accessor.count * typeofComponent;
    let length = lengthByStride || requiredLength;
    if (arrayBuffer.byteLength < length * sizeofComponent + offset) {
      length -= accessor.byteOffset;
    }
    let arr;
    switch (glEnum_default[accessor.componentType]) {
      case "BYTE":
        arr = new Int8Array(arrayBuffer, offset, length);
        break;
      case "UNSIGNED_BYTE":
        arr = new Uint8Array(arrayBuffer, offset, length);
        break;
      case "SHORT":
        arr = new Int16Array(arrayBuffer, offset, length);
        break;
      case "UNSIGNED_SHORT":
        arr = new Uint16Array(arrayBuffer, offset, length);
        break;
      case "UNSIGNED_INT":
        arr = new Uint32Array(arrayBuffer, offset, length);
        break;
      case "FLOAT":
        arr = new Float32Array(arrayBuffer, offset, length);
        break;
    }
    if (length !== requiredLength) {
      const stridedArr = new arr.constructor(requiredLength);
      let j = 0;
      for (let i = 0; i < stridedArr.length; i += typeofComponent) {
        for (let k = 0; k < typeofComponent; k++) {
          stridedArr[i + k] = arr[j + k];
        }
        j += stride / sizeofComponent;
      }
      return stridedArr;
    } else {
      return arr;
    }
  }
  function buildArray(arrayBuffer, type, offset, length) {
    let arr;
    switch (glEnum_default[type]) {
      case "BYTE":
        arr = new Int8Array(arrayBuffer, offset, length);
        break;
      case "UNSIGNED_BYTE":
        arr = new Uint8Array(arrayBuffer, offset, length);
        break;
      case "SHORT":
        arr = new Int16Array(arrayBuffer, offset, length);
        break;
      case "UNSIGNED_SHORT":
        arr = new Uint16Array(arrayBuffer, offset, length);
        break;
      case "UNSIGNED_INT":
        arr = new Uint32Array(arrayBuffer, offset, length);
        break;
      case "FLOAT":
        arr = new Float32Array(arrayBuffer, offset, length);
        break;
    }
    return arr;
  }
  function compileShader(type, shaderSource, program) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);
    gl.attachShader(program, shader);
    const log = gl.getShaderInfoLog(shader);
    if (log) {
      throw new Error(log);
    }
  }
  function createProgram(vertex, fragment) {
    const program = gl.createProgram();
    compileShader(gl.VERTEX_SHADER, vertex, program);
    compileShader(gl.FRAGMENT_SHADER, fragment, program);
    gl.linkProgram(program);
    gl.validateProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      const info = gl.getProgramInfoLog(program);
      throw new Error(`Could not compile WebGL program. ${info}`);
    }
    return program;
  }
  function walk(node, callback) {
    function _walk(node2) {
      callback(node2);
      if (node2.children) {
        node2.children.forEach(_walk);
      }
    }
    _walk(node);
  }
  function canvasToWorld(vec2, projection, width, height) {
    const [x, y] = vec2;
    const newM = new Matrix4();
    newM.setTranslate(new Vector3([0, 0, 0.05]));
    const m = new Matrix4(projection);
    m.multiply(newM);
    const mp = m.multiplyVector4(new Vector4([0, 0, 0, 1]));
    mp.elements[0] = (2 * x / width - 1) * mp.elements[3];
    mp.elements[1] = (-2 * y / height + 1) * mp.elements[3];
    const v = m.invert().multiplyVector4(mp);
    return [v.elements[0], v.elements[1]];
  }
  function calculateProjection(cam) {
    const { aspect, zoom } = cam;
    let proj;
    if (cam.type === "perspective" && cam.perspective) {
      const { yfov } = cam.perspective;
      const f = 1 / Math.tan(yfov / 2);
      const nf = 1 / (cam.perspective.znear - cam.perspective.zfar);
      return new Matrix4().set([
        f / aspect,
        0,
        0,
        0,
        0,
        f,
        0,
        0,
        0,
        0,
        cam.perspective.zfar * nf,
        -1,
        0,
        0,
        cam.perspective.znear * cam.perspective.zfar * nf,
        0
      ]);
    } else if (cam.type === "orthographic" && cam.orthographic) {
      proj = new Matrix4().setOrtho(
        cam.orthographic.xmag * zoom,
        cam.orthographic.ymag * zoom,
        cam.orthographic.znear,
        cam.orthographic.zfar
      );
    }
    return proj;
  }
  function calculateOffset(a = 0, b = 0) {
    return a + b;
  }
  function calculateUVs(vertex, normal) {
    const UVS = new Float32Array(vertex.length / 3 * 2);
    const Min = new Vector2([Infinity, Infinity]);
    const Max = new Vector2([-Infinity, -Infinity]);
    for (let i = 0; i < vertex.length / 3; ++i) {
      const coords = [];
      const norm = [];
      for (let c = 0; c < 3; ++c) {
        coords.push(vertex[3 * i + c]);
        norm.push(normal[3 * i + c]);
      }
      const N = new Vector3(norm);
      const components = ["x", "y", "z"].sort((a, b) => {
        return Math.abs(N[a]) - Math.abs(N[b]);
      });
      const pos = new Vector3(coords);
      const u = pos[components[0]];
      const v = pos[components[1]];
      UVS[i * 2] = u;
      UVS[i * 2 + 1] = v;
      Max.x = Math.max(Max.x, u);
      Max.y = Math.max(Max.y, v);
      Min.x = Math.min(Min.x, u);
      Min.y = Math.min(Min.y, v);
    }
    const diff = new Vector2(Max.elements).subtract(Min);
    for (let i = 0; i < vertex.length / 3; ++i) {
      const ix = i * 2;
      UVS[ix] = (UVS[ix] - Min.x) / diff.x;
      UVS[ix + 1] = (UVS[ix + 1] - Min.y) / diff.y;
    }
    return UVS;
  }
  function calculateNormals2(vertex) {
    const ns = new Float32Array(vertex.length);
    for (let i = 0; i < vertex.length; i += 9) {
      const faceVertices = [
        new Vector3([vertex[i], vertex[i + 1], vertex[i + 2]]),
        new Vector3([vertex[i + 3], vertex[i + 4], vertex[i + 5]]),
        new Vector3([vertex[i + 6], vertex[i + 7], vertex[i + 8]])
      ];
      const dv1 = faceVertices[1].subtract(faceVertices[0]);
      const dv2 = faceVertices[2].subtract(faceVertices[0]);
      const n = Vector3.cross(dv1.normalize(), dv2.normalize());
      const [x, y, z] = n.elements;
      ns[i] = x;
      ns[i + 1] = y;
      ns[i + 2] = z;
      ns[i + 3] = x;
      ns[i + 4] = y;
      ns[i + 5] = z;
      ns[i + 6] = x;
      ns[i + 7] = y;
      ns[i + 8] = z;
    }
    return ns;
  }
  function calculateNormals(index, vertex) {
    const ns = new Float32Array(vertex.length / 3 * 3);
    for (let i = 0; i < index.length; i += 3) {
      const faceIndexes = [index[i], index[i + 1], index[i + 2]];
      const faceVertices = faceIndexes.map((ix) => vectorFromArray(vertex, ix));
      const dv1 = faceVertices[1].subtract(faceVertices[0]);
      const dv2 = faceVertices[2].subtract(faceVertices[0]);
      const n = Vector3.cross(dv1.normalize(), dv2.normalize());
      const [x, y, z] = n.elements;
      for (let j = 0; j < 3; j++) {
        ns[3 * index[i + j] + 0] = ns[3 * index[i + j] + 0] + x;
        ns[3 * index[i + j] + 1] = ns[3 * index[i + j] + 1] + y;
        ns[3 * index[i + j] + 2] = ns[3 * index[i + j] + 2] + z;
      }
    }
    return ns;
    function vectorFromArray(array, index2, elements = 3) {
      index2 = index2 * elements;
      return new Vector3([array[index2], array[index2 + 1], array[index2 + 2]]);
    }
  }
  function calculateBinormals(index, vertex, normal, uv) {
    const tangent = new Float32Array(normal.length / 3 * 4);
    for (let i = 0; i < index.length; i += 3) {
      const faceIndexes = [index[i], index[i + 1], index[i + 2]];
      const faceVertices = faceIndexes.map((ix) => vectorFromArray(vertex, ix));
      const faceUVs = faceIndexes.map((ix) => vectorFromArray(uv, ix, 2));
      const dv1 = faceVertices[1].subtract(faceVertices[0]);
      const dv2 = faceVertices[2].subtract(faceVertices[0]);
      const duv1 = faceUVs[1].subtract(faceUVs[0]);
      const duv2 = faceUVs[2].subtract(faceUVs[0]);
      let r = duv1.elements[0] * duv2.elements[1] - duv1.elements[1] * duv2.elements[0];
      const sign = r > 0 ? 1 : -1;
      r = r !== 0 ? 1 / r : 1;
      const udir = new Vector3([
        (duv2.elements[1] * dv1.elements[0] - duv1.elements[1] * dv2.elements[0]) * r,
        (duv2.elements[1] * dv1.elements[1] - duv1.elements[1] * dv2.elements[1]) * r,
        (duv2.elements[1] * dv1.elements[2] - duv1.elements[1] * dv2.elements[2]) * r
      ]);
      udir.normalize();
      faceIndexes.forEach((ix) => {
        accumulateVectorInArray(tangent, ix, udir, sign);
      });
    }
    return tangent;
    function vectorFromArray(array, index2, elements = 3) {
      index2 = index2 * elements;
      if (elements === 3) {
        return new Vector3([array[index2], array[index2 + 1], array[index2 + 2]]);
      }
      if (elements === 2) {
        return new Vector2([array[index2], array[index2 + 1]]);
      }
    }
    function accumulateVectorInArray(array, index2, vector, sign, elements = 4, accumulator = (acc, x) => acc + x) {
      index2 = index2 * elements;
      for (let i = 0; i < elements; ++i) {
        if (i === 3) {
          array[index2 + i] = sign;
        } else {
          array[index2 + i] = accumulator(array[index2 + i], vector.elements[i]);
        }
      }
    }
  }
  function getGlEnum(name) {
    return glEnum_default[name];
  }
  function normalize(array) {
    let fn;
    switch (true) {
      case array instanceof Uint8Array:
        fn = (c) => c / 255;
        break;
      case array instanceof Int8Array:
        fn = (c) => Math.max(c / 127, -1);
        break;
      case array instanceof Uint16Array:
        fn = (c) => c / 65535;
        break;
      case array instanceof Int16Array:
        fn = (c) => Math.max(c / 32767, -1);
        break;
    }
    if (fn) {
      const normalizedArray = new Float32Array(array.length);
      for (let i = 0; i < array.length; i++) {
        normalizedArray[i] = fn(array[i]);
      }
      return normalizedArray;
    } else {
      return array;
    }
  }
  async function generateMipmaps(device, texture, width, height, mipLevelCount, { isCube = false } = {}) {
    const wgsl = `
    @group(0) @binding(0) var mySampler: sampler;
    @group(0) @binding(1) var myTexture: texture_2d<f32>;

    struct VSOut {
      @builtin(position) pos: vec4f,
      @location(0) uv: vec2f
    };

    @vertex
    fn vs_main(@builtin(vertex_index) vi: u32) -> VSOut {
      var pos = array<vec2f, 6>(
        vec2f(-1.0, -1.0),
        vec2f( 1.0, -1.0),
        vec2f(-1.0,  1.0),
        vec2f(-1.0,  1.0),
        vec2f( 1.0, -1.0),
        vec2f( 1.0,  1.0)
      );
      var out: VSOut;
      out.pos = vec4f(pos[vi], 0.0, 1.0);
      var  uv = (pos[vi] + vec2f(1.0)) * 0.5;
      uv.y = 1.0 - uv.y;
      out.uv  = uv;
      return out;
    }

    @fragment
    fn fs_main(@location(0) uv: vec2f) -> @location(0) vec4f {
      // sample exactly mip 0 of the bound view (which we create from src mip)
      return textureSampleLevel(myTexture, mySampler, uv, 0.0);
    }
  `;
    const module2 = device.createShaderModule({ code: wgsl });
    const pipeline = device.createRenderPipeline({
      layout: "auto",
      vertex: { module: module2, entryPoint: "vs_main" },
      fragment: {
        module: module2,
        entryPoint: "fs_main",
        targets: [{ format: texture.format }]
        // use the real texture format
      },
      primitive: { topology: "triangle-list" }
    });
    const genSampler = device.createSampler({
      magFilter: "linear",
      minFilter: "linear",
      mipmapFilter: "nearest",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    for (let level = 1; level < mipLevelCount; level++) {
      const dstWidth = Math.max(1, Math.floor(width / Math.pow(2, level)));
      const dstHeight = Math.max(1, Math.floor(height / Math.pow(2, level)));
      const faceCount = isCube ? 6 : 1;
      for (let face = 0; face < faceCount; face++) {
        const srcView = texture.createView({
          baseMipLevel: level - 1,
          mipLevelCount: 1,
          baseArrayLayer: isCube ? face : 0,
          arrayLayerCount: isCube ? 1 : void 0,
          dimension: "2d"
        });
        const dstView = texture.createView({
          baseMipLevel: level,
          mipLevelCount: 1,
          baseArrayLayer: isCube ? face : 0,
          arrayLayerCount: isCube ? 1 : void 0,
          dimension: "2d"
        });
        const bindGroup = device.createBindGroup({
          layout: pipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: genSampler },
            { binding: 1, resource: srcView }
          ]
        });
        const encoder = device.createCommandEncoder();
        const pass = encoder.beginRenderPass({
          colorAttachments: [
            {
              view: dstView,
              clearValue: { r: 0, g: 0, b: 0, a: 1 },
              loadOp: "clear",
              storeOp: "store"
            }
          ]
        });
        pass.setPipeline(pipeline);
        pass.setBindGroup(0, bindGroup);
        pass.setViewport(0, 0, dstWidth, dstHeight, 0, 1);
        pass.draw(6);
        pass.end();
        device.queue.submit([encoder.finish()]);
      }
    }
  }
  function fanToTriListIndices(fan) {
    if (fan.length < 3) return new Uint32Array(0);
    const use32 = fan instanceof Uint32Array || Math.max(...fan) > 65535;
    const out = new Uint32Array((fan.length - 2) * 3);
    const c = fan[0];
    let o = 0;
    for (let i = 1; i < fan.length - 1; i++) {
      out[o++] = c;
      out[o++] = fan[i];
      out[o++] = fan[i + 1];
    }
    return out;
  }
  function convertLineLoopToLineList(loopIndices) {
    const n = loopIndices.length;
    const listIndices = new loopIndices.constructor(n * 2);
    for (let i = 0; i < n; i++) {
      const curr = loopIndices[i];
      const next = loopIndices[(i + 1) % n];
      listIndices[i * 2] = curr;
      listIndices[i * 2 + 1] = next;
    }
    return listIndices;
  }

  // src/objects/mesh.ts
  var Mesh = class extends Object3D {
    geometry;
    material;
    program;
    defines;
    mode;
    frontFace;
    distance;
    visible;
    variants;
    order;
    uniformBindGroup1;
    pipeline;
    constructor(name, parent) {
      super(name, parent);
      this.program = null;
      this.defines = null;
      this.mode = 4;
      this.variants = [];
    }
    setDefines(defines) {
      this.defines = defines;
    }
    setBlend(value) {
      this.material.blend = value;
    }
    setMaterial(material) {
      this.material = material;
    }
    drawWebGPU(WebGPU2, passEncoder, i, { renderState, storage2, storage }) {
      const { isprerefraction } = renderState;
      if (this.defines.find((i2) => i2.name === "TRANSMISSION") && isprerefraction) {
        return;
      }
      if (this.reflow) {
        storage2.store.set(this.matrixWorld.elements, i * this.geometry.uniformBuffer.store.length);
        WebGPU2.device.queue.writeBuffer(storage2.bufferWebGPU, 0, storage2.store.buffer, storage2.store.byteOffset, storage2.store.byteLength);
      }
      if (this.repaint) {
        storage.store.set(this.material.materialUniformBuffer.store, i * this.material.materialUniformBuffer.store.length);
        WebGPU2.device.queue.writeBuffer(storage.bufferWebGPU, 0, storage.store.buffer, storage.store.byteOffset, storage.store.byteLength);
      }
      if (this instanceof SkinnedMesh) {
        if (this.bones.some((bone) => bone.reflow)) {
          const jointMatrix = this.getJointMatrix();
          const matrices = new Float32Array(jointMatrix.length * 16);
          let i2 = 0;
          for (const j of jointMatrix) {
            matrices.set(j.elements, 0 + 16 * i2);
            i2++;
          }
          WebGPU2.device.queue.writeBuffer(
            this.skinBuffer,
            0 * Float32Array.BYTES_PER_ELEMENT,
            matrices.buffer,
            matrices.byteOffset,
            matrices.byteLength
          );
        }
      }
      passEncoder.setBindGroup(0, this.uniformBindGroup1);
      passEncoder.setVertexBuffer(0, this.geometry.verticesWebGPUBuffer);
      if (this.geometry.indicesBuffer) {
        const type = this.geometry.indexType < 5124 ? "uint16" : "uint32";
        passEncoder.setIndexBuffer(this.geometry.indicesWebGPUBuffer, "uint32");
        passEncoder.drawIndexed(this.geometry.indicesBuffer.length, 1, 0, 0, i);
      } else {
        passEncoder.draw(this.geometry.attributes.POSITION.length / 3, 1, 0, i);
      }
    }
    draw(gl11, {
      lights,
      camera,
      needUpdateProjection,
      preDepthTexture,
      colorTexture,
      renderState,
      fakeDepth,
      isIBL,
      isDefaultLight
    }) {
      const { isprepender, isprerefraction } = renderState;
      if (this.defines.find((i) => i.name === "TRANSMISSION") && isprerefraction) {
        return;
      }
      gl11.useProgram(this.program);
      gl11.bindVertexArray(this.geometry.VAO);
      if (needUpdateProjection) {
        this.geometry.uniformBuffer.update(gl11, "projection", camera.projection.elements);
      }
      this.geometry.uniformBuffer.update(gl11, "isShadow", isprepender ? 1 : 0);
      if (this instanceof SkinnedMesh) {
        gl11.bindBufferBase(gl11.UNIFORM_BUFFER, 2, this.geometry.SKIN);
        if (this.bones.some((bone) => bone.reflow)) {
          const jointMatrix = this.getJointMatrix();
          const matrices = new Float32Array(jointMatrix.length * 16);
          let i = 0;
          for (const j of jointMatrix) {
            matrices.set(j.elements, 0 + 16 * i);
            i++;
          }
          gl11.bufferSubData(gl11.UNIFORM_BUFFER, 0, matrices);
        }
      }
      if (this.material.matrices.length) {
        gl11.bindBufferBase(gl11.UNIFORM_BUFFER, 8, this.material.lightUBO5);
      }
      if (this.material.sphericalHarmonics) {
        gl11.bindBufferBase(gl11.UNIFORM_BUFFER, 7, this.material.sphericalHarmonics);
      }
      gl11.uniform1i(this.material.uniforms.depthTexture, preDepthTexture && !isprepender ? preDepthTexture.index : fakeDepth.index);
      gl11.uniform1i(this.material.uniforms.colorTexture, !isprerefraction ? colorTexture.index : fakeDepth.index);
      gl11.uniform2f(this.material.uniforms.isTone, isprerefraction ? 0 : 1, 0);
      gl11.uniform2f(this.material.uniforms.isIBL, isIBL ? 1 : 0, 0);
      gl11.uniform2f(this.material.uniforms.isDefaultLight, isDefaultLight || lights.some((l) => !l.isInitial) ? 1 : 0, 0);
      if (this.material.baseColorTexture) {
        gl11.activeTexture(gl11[`TEXTURE${0}`]);
        gl11.bindTexture(gl11.TEXTURE_2D, this.material.baseColorTexture);
        gl11.bindSampler(0, this.material.baseColorTexture.sampler);
      }
      if (this.material.metallicRoughnessTexture) {
        gl11.activeTexture(gl11[`TEXTURE${1}`]);
        gl11.bindTexture(gl11.TEXTURE_2D, this.material.metallicRoughnessTexture);
        gl11.bindSampler(1, this.material.metallicRoughnessTexture.sampler);
      }
      if (this.material.normalTexture) {
        gl11.activeTexture(gl11[`TEXTURE${2}`]);
        gl11.bindTexture(gl11.TEXTURE_2D, this.material.normalTexture);
        gl11.bindSampler(2, this.material.normalTexture.sampler);
      }
      if (this.material.occlusionTexture) {
        gl11.activeTexture(gl11[`TEXTURE${3}`]);
        gl11.bindTexture(gl11.TEXTURE_2D, this.material.occlusionTexture);
        gl11.bindSampler(3, this.material.occlusionTexture.sampler);
      }
      if (this.material.emissiveTexture) {
        gl11.activeTexture(gl11[`TEXTURE${4}`]);
        gl11.bindTexture(gl11.TEXTURE_2D, this.material.emissiveTexture);
        gl11.bindSampler(4, this.material.emissiveTexture.sampler);
      }
      if (this.material.clearcoatTexture) {
        gl11.activeTexture(gl11[`TEXTURE${8}`]);
        gl11.bindTexture(gl11.TEXTURE_2D, this.material.clearcoatTexture);
        gl11.bindSampler(8, this.material.clearcoatTexture.sampler);
      }
      if (this.material.clearcoatRoughnessTexture) {
        gl11.activeTexture(gl11[`TEXTURE${9}`]);
        gl11.bindTexture(gl11.TEXTURE_2D, this.material.clearcoatRoughnessTexture);
        gl11.bindSampler(9, this.material.clearcoatRoughnessTexture.sampler);
      }
      if (this.material.sheenColorTexture) {
        gl11.activeTexture(gl11[`TEXTURE${11}`]);
        gl11.bindTexture(gl11.TEXTURE_2D, this.material.sheenColorTexture);
        gl11.bindSampler(11, this.material.sheenColorTexture.sampler);
      }
      if (this.material.sheenRoughnessTexture) {
        gl11.activeTexture(gl11[`TEXTURE${12}`]);
        gl11.bindTexture(gl11.TEXTURE_2D, this.material.sheenRoughnessTexture);
        gl11.bindSampler(12, this.material.sheenRoughnessTexture.sampler);
      }
      if (this.material.iridescenceThicknessTexture) {
        gl11.activeTexture(gl11[`TEXTURE${17}`]);
        gl11.bindTexture(gl11.TEXTURE_2D, this.material.iridescenceThicknessTexture);
        gl11.bindSampler(17, this.material.iridescenceThicknessTexture.sampler);
      }
      if (this.material.iridescenceTexture) {
        gl11.activeTexture(gl11[`TEXTURE${23}`]);
        gl11.bindTexture(gl11.TEXTURE_2D, this.material.iridescenceTexture);
        gl11.bindSampler(23, this.material.iridescenceTexture.sampler);
      }
      if (this.material.diffuseTransmissionTexture) {
        gl11.activeTexture(gl11[`TEXTURE${20}`]);
        gl11.bindTexture(gl11.TEXTURE_2D, this.material.diffuseTransmissionTexture);
        gl11.bindSampler(20, this.material.diffuseTransmissionTexture.sampler);
      }
      if (this.material.diffuseTransmissionColorTexture) {
        gl11.activeTexture(gl11[`TEXTURE${21}`]);
        gl11.bindTexture(gl11.TEXTURE_2D, this.material.diffuseTransmissionColorTexture);
        gl11.bindSampler(21, this.material.diffuseTransmissionColorTexture.sampler);
      }
      if (this.material.anisotropyTexture) {
        gl11.activeTexture(gl11[`TEXTURE${22}`]);
        gl11.bindTexture(gl11.TEXTURE_2D, this.material.anisotropyTexture);
        gl11.bindSampler(22, this.material.anisotropyTexture.sampler);
      }
      if (this.material.clearcoatNormalTexture) {
        gl11.activeTexture(gl11[`TEXTURE${10}`]);
        gl11.bindTexture(gl11.TEXTURE_2D, this.material.clearcoatNormalTexture);
        gl11.bindSampler(10, this.material.clearcoatNormalTexture.sampler);
      }
      if (this.material.transmissionTexture) {
        gl11.activeTexture(gl11[`TEXTURE${14}`]);
        gl11.bindTexture(gl11.TEXTURE_2D, this.material.transmissionTexture);
        gl11.bindSampler(14, this.material.transmissionTexture.sampler);
      }
      if (this.material.specularTexture) {
        gl11.activeTexture(gl11[`TEXTURE${15}`]);
        gl11.bindTexture(gl11.TEXTURE_2D, this.material.specularTexture);
        gl11.bindSampler(15, this.material.specularTexture.sampler);
      }
      if (this.material.specularColorTexture) {
        gl11.activeTexture(gl11[`TEXTURE${19}`]);
        gl11.bindTexture(gl11.TEXTURE_2D, this.material.specularColorTexture);
        gl11.bindSampler(19, this.material.specularColorTexture.sampler);
      }
      if (this.material.thicknessTexture) {
        gl11.activeTexture(gl11[`TEXTURE${16}`]);
        gl11.bindTexture(gl11.TEXTURE_2D, this.material.thicknessTexture);
        gl11.bindSampler(16, this.material.thicknessTexture.sampler);
      }
      if (this.material.doubleSided) {
        gl11.disable(gl11.CULL_FACE);
      }
      if (this.frontFace) {
        gl11.frontFace(gl11.CW);
      }
      if (this.geometry.indicesBuffer) {
        gl11.drawElements(
          this.mode,
          this.geometry.indicesBuffer.length,
          gl11[ArrayBufferMap.get(this.geometry.indicesBuffer.constructor)],
          0
        );
      } else {
        gl11.drawArrays(this.mode, 0, this.geometry.attributes.POSITION.length / 3);
      }
      if (this.material.doubleSided) {
        gl11.enable(gl11.CULL_FACE);
      }
      if (this.frontFace) {
        gl11.frontFace(gl11.CCW);
      }
    }
    setGeometry(geometry) {
      this.geometry = geometry;
    }
    setProgram(value) {
      this.program = value;
    }
    setMode(value = 4) {
      this.mode = value;
    }
    setVariants(variants) {
      this.variants = variants;
    }
    setFrontFace() {
      this.frontFace = true;
    }
    isVisible(planes) {
      const c = new Vector3(this.geometry.boundingSphere.center.elements).applyMatrix4(this.matrixWorld);
      const r = this.geometry.boundingSphere.radius * this.matrixWorld.getMaxScaleOnAxis();
      let dist;
      let visible = true;
      for (const p of planes) {
        dist = p.elements[0] * c.elements[0] + p.elements[1] * c.elements[1] + p.elements[2] * c.elements[2] + p.elements[3];
        if (dist < -r) {
          visible = false;
          break;
        }
      }
      this.distance = dist + r;
      return visible;
    }
    calculateBounding() {
      this.geometry.calculateBounding(this.matrixWorld);
    }
  };
  var SkinnedMesh = class extends Mesh {
    bones;
    boneInverses;
    skin;
    skinBuffer;
    constructor(name, parent) {
      super(name, parent);
    }
    setSkinWebGPU(WebGPU2, skin) {
      this.bones = skin.bones;
      this.boneInverses = skin.boneInverses;
      const jointMatrix = this.getJointMatrix();
      const matrices = new Float32Array(jointMatrix.length * 16);
      let i = 0;
      for (const j of jointMatrix) {
        matrices.set(j.elements, 0 + 16 * i);
        i++;
      }
      const matrixSize = matrices.byteLength;
      const offset = 256;
      const uniformBufferSize = offset + matrixSize;
      const { device } = WebGPU2;
      const uniformBuffer = device.createBuffer({
        size: uniformBufferSize,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });
      this.skinBuffer = uniformBuffer;
      const uniformBindGroup1 = {
        binding: 22,
        resource: uniformBuffer
      };
      device.queue.writeBuffer(uniformBuffer, 0, matrices.buffer, matrices.byteOffset, matrices.byteLength);
      return uniformBindGroup1;
    }
    setSkin(gl11, skin) {
      this.bones = skin.bones;
      this.boneInverses = skin.boneInverses;
      const jointMatrix = this.getJointMatrix();
      const matrices = new Float32Array(jointMatrix.length * 16);
      let i = 0;
      for (const j of jointMatrix) {
        matrices.set(j.elements, 0 + 16 * i);
        i++;
      }
      const uIndex = gl11.getUniformBlockIndex(this.program, "Skin");
      gl11.uniformBlockBinding(this.program, uIndex, 2);
      const UBO = gl11.createBuffer();
      gl11.bindBuffer(gl11.UNIFORM_BUFFER, UBO);
      gl11.bufferData(gl11.UNIFORM_BUFFER, matrices, gl11.DYNAMIC_DRAW);
      this.geometry.SKIN = UBO;
      gl11.bindBuffer(gl11.UNIFORM_BUFFER, null);
      return this;
    }
    getJointMatrix() {
      const m = new Matrix4(this.matrixWorld).invert();
      const resArray = [];
      for (let mi = 0; mi < this.boneInverses.length; mi++) {
        const res = new Matrix4().multiply(m).multiply(this.bones[mi].matrixWorld).multiply(this.boneInverses[mi]);
        resArray.push(res);
      }
      return resArray;
    }
  };
  var Bone = class extends Object3D {
  };

  // src/objects/camera.ts
  function clamp(a, b, c) {
    return a < b ? b : a > c ? c : a;
  }
  var Camera = class extends Object3D {
    isInitial;
    props;
    matrixWorldInvert;
    projection;
    modelSize;
    modelXSize;
    modelYSize;
    yaw;
    pitch;
    matrixInitial;
    rotation;
    constructor(props, name, parent) {
      super(name, parent);
      this.matrixWorldInvert = new Matrix4();
      this.projection = new Matrix4();
      this.props = props;
      this.yaw = 0;
      this.pitch = -Math.PI;
      this.rotation = new Matrix4();
    }
    setProjection(matrix) {
      this.projection.set(matrix.elements);
    }
    setMatrixWorld(matrix) {
      super.setMatrixWorld(matrix);
      this.matrixWorldInvert.setInverseOf(this.matrixWorld);
      if (!this.matrixInitial) {
        this.matrixInitial = new Matrix4(this.matrixWorld);
      }
    }
    setZ(z) {
      this.matrix.elements[14] = z;
      this.matrixInitial = new Matrix4(this.matrix);
      this.setMatrixWorld(this.matrix.elements);
    }
    getViewProjMatrix() {
      const m = new Matrix4();
      m.multiply(this.projection);
      m.multiply(this.matrixWorldInvert);
      return m;
    }
    pan(coordsStart, coordsMove, width, height) {
      const coordsStartWorld = canvasToWorld(coordsStart, this.projection, width, height);
      const coordsMoveWorld = canvasToWorld(coordsMove, this.projection, width, height);
      const p0 = new Vector3([...coordsStartWorld, 0]);
      const p1 = new Vector3([...coordsMoveWorld, 0]);
      if (this.props.type === "orthographic") {
        const pan = 2 * this.matrixWorld.elements[14];
        const delta = p0.subtract(p1).scale(pan);
        this.matrixInitial.translate(delta.elements[0], delta.elements[1], 0);
      } else {
        const pan = 10 * this.matrixWorld.elements[14];
        const delta = p1.subtract(p0).scale(pan);
        this.matrixInitial.translate(delta.elements[0], delta.elements[1], 0);
      }
      const res = new Matrix4(this.rotation);
      res.multiply(this.matrixInitial);
      this.setMatrixWorld(res.elements);
    }
    rotate(coordsStart, coordsMove) {
      this.yaw += (coordsStart[0] - coordsMove[0]) * 0.01;
      this.pitch += (coordsStart[1] - coordsMove[1]) * 0.01;
      this.pitch = clamp(this.pitch, -1.5 * Math.PI, -0.5 * Math.PI);
      const m = new Matrix4();
      m.rotate(new Vector3([1, 0, 0]), this.pitch);
      m.rotate(new Vector3([0, 1, 0]), -this.yaw);
      m.rotate(new Vector3([1, 0, 0]), Math.PI);
      this.rotation = m;
      const res = new Matrix4(m);
      res.multiply(this.matrixInitial);
      this.setMatrixWorld(res.elements);
    }
    zoom(value) {
      if (this.matrixInitial.elements[14] > this.modelSize * 5 && value > 0) {
        return;
      }
      this.matrixInitial.elements[14] += value * this.modelSize * 1e-3;
      const m = new Matrix4(this.rotation);
      m.multiply(this.matrixInitial);
      this.setMatrixWorld(m.elements);
      this.updateNF();
    }
    updateNF() {
      if (this.props.isInitial) {
        const scale = Math.min(...this.matrixWorld.getScaling().elements);
        const modelSize = this.modelSize / scale;
        const cameraZ = Math.abs(this.matrixWorldInvert.elements[14]);
        const cameraProps = this.props.perspective || this.props.orthographic;
        cameraProps.znear = Math.max(cameraZ - modelSize, modelSize * 0.05);
        cameraProps.zfar = cameraZ + modelSize;
      }
      this.setProjection(calculateProjection(this.props));
    }
  };

  // src/objects/light.ts
  var Light = class extends Object3D {
    matrixWorldInvert;
    type;
    color;
    intensity;
    isInitial;
    spot;
    constructor(props, name, parent) {
      super(name, parent);
      const { type, color = [1, 1, 1], intensity, isInitial, spot = {} } = props;
      this.type = type;
      this.color = new Vector3(color);
      this.intensity = intensity;
      this.isInitial = isInitial;
      this.spot = spot;
      this.matrixWorldInvert = new Matrix4();
    }
    setMatrixWorld(matrix) {
      super.setMatrixWorld(matrix);
      this.matrixWorldInvert.setInverseOf(this.matrixWorld);
    }
    setZ(z) {
      this.matrix.elements[13] = z;
      this.matrix.elements[14] = z;
      this.setMatrixWorld(this.matrix.elements);
    }
    update(v) {
      if (this.isInitial || this.type === "directional") {
        const camMatrix = new Matrix4();
        camMatrix.makeRotationAxis(new Vector3([0, 1, 0]), v);
        camMatrix.multiply(this.matrix);
        this.setMatrixWorld(camMatrix.elements);
      }
    }
  };

  // src/objects/uniform.ts
  var UniformBuffer = class {
    offset;
    map;
    tempStore;
    store;
    bufferWebGPU;
    constructor() {
      this.map = /* @__PURE__ */ new Map();
      this.tempStore = {};
      this.offset = 0;
    }
    getBuffer(v) {
      const { length } = v;
      if (length === 3) {
        return new Float32Array([v[0], v[1], v[2], 0]);
      }
      if (length === 9) {
        return new Float32Array([v[0], v[1], v[2], 0, v[3], v[4], v[5], 0, v[6], v[7], v[8], 0]);
      }
      if (length === 12) {
        return new Float32Array([v[0], v[1], v[2], 0, v[3], v[4], v[5], 0, v[6], v[7], v[8], 0, v[9], v[10], v[11], 0]);
      }
      if (length === 6) {
        return new Float32Array([v[0], v[1], v[2], 0, v[3], v[4], v[5], 0]);
      }
      return v;
    }
    add(name, value) {
      if (value.length === void 0) {
        value = [value];
      }
      this.map.set(name, this.offset);
      const buffer = this.getBuffer(value);
      this.tempStore[name] = buffer;
      this.offset += Math.max(buffer.length, 4);
    }
    update(gl11, name, value, skip = false) {
      if (value.length === void 0) {
        value = new Float32Array([value]);
      }
      const offset = this.map.get(name);
      if (offset === void 0) {
        return;
      }
      const buffer = this.getBuffer(value);
      this.store.set(buffer, offset);
      if (skip) {
        return;
      }
      gl11.bufferSubData(gl11.UNIFORM_BUFFER, offset * Float32Array.BYTES_PER_ELEMENT, buffer);
    }
    updateWebGPU(WebGPU2, name, value, skip = false) {
      const { device } = WebGPU2;
      if (value.length === void 0) {
        value = new Float32Array([value]);
      }
      const offset = this.map.get(name);
      if (offset === void 0) {
        return;
      }
      const buffer = this.getBuffer(value);
      this.store.set(buffer, offset);
      if (skip) {
        return;
      }
      device.queue.writeBuffer(
        this.bufferWebGPU,
        offset * Float32Array.BYTES_PER_ELEMENT,
        buffer.buffer,
        buffer.byteOffset,
        buffer.byteLength
      );
    }
    done() {
      this.store = new Float32Array(this.offset);
      for (const [name, offset] of this.map) {
        this.store.set(this.tempStore[name], offset);
      }
      this.tempStore = null;
    }
  };

  // GLTF.ts
  var Material = class {
    "name";
    "extensions";
    "extras";
    /**
     * A set of parameter values that are used to define the metallic-roughness material model from Physically-Based Rendering (PBR) methodology. When not specified, all the default values of `pbrMetallicRoughness` apply.
     */
    "pbrMetallicRoughness";
    /**
     * The normal map texture.
     */
    "normalTexture";
    /**
     * The occlusion map texture.
     */
    "occlusionTexture";
    /**
     * The emissive map texture.
     */
    "emissiveTexture";
    /**
     * The emissive color of the material.
     */
    "emissiveFactor";
    /**
     * The alpha rendering mode of the material.
     */
    "alphaMode";
    /**
     * The alpha cutoff value of the material.
     */
    "alphaCutoff";
    /**
     * Specifies whether the material is double sided.
     */
    "doubleSided";
  };

  // src/objects/material.ts
  var defaultMaterial = {
    baseColorFactor: [1, 0, 0, 1]
  };
  var lightEnum = {
    directional: 0,
    point: 1,
    spot: 2
  };
  var Material2 = class extends Material {
    blend;
    uniforms;
    alpha;
    UBO;
    defines;
    matrices;
    uniformBuffer;
    lightUBO1;
    lightUniformBuffer1;
    lightUBO2;
    lightUniformBuffer2;
    lightUBO3;
    lightUniformBuffer3;
    lightUBO4;
    lightUBO5;
    lightUniformBuffer4;
    matricesMap = /* @__PURE__ */ new Map();
    uniformBindGroup1;
    constructor(m = defaultMaterial, textures, defines) {
      super();
      const material = Object.assign({}, m);
      this.defines = defines;
      this.name = material.name;
      this.matrices = [];
      this.diffuseTransmissionColorFactor = [1, 1, 1];
      this.defines.push({ name: "LIGHTINDEX", value: 0 });
      if (!material.pbrMetallicRoughness && material.extensions && material.extensions.KHR_materials_pbrSpecularGlossiness) {
        material.pbrMetallicRoughness = {};
        const SG = material.extensions.KHR_materials_pbrSpecularGlossiness;
        material.pbrMetallicRoughness.baseColorTexture = SG.diffuseTexture;
        material.pbrMetallicRoughness.metallicRoughnessTexture = SG.specularGlossinessTexture;
        material.pbrMetallicRoughness.baseColorFactor = SG.diffuseFactor;
        material.pbrMetallicRoughness.specularFactor = SG.specularFactor;
        material.pbrMetallicRoughness.glossinessFactor = SG.glossinessFactor;
        defines.push({ name: "SPECULARGLOSSINESSMAP" });
      }
      if (material.extensions && material.extensions.KHR_materials_clearcoat) {
        const cl = material.extensions.KHR_materials_clearcoat;
        this.clearcoatFactor = cl.clearcoatFactor;
        this.clearcoatRoughnessFactor = cl.clearcoatRoughnessFactor;
        defines.push({ name: "CLEARCOAT" });
        if (cl.clearcoatTexture) {
          const { extensions, texCoord } = cl.clearcoatTexture;
          this.clearcoatTexture = textures[cl.clearcoatTexture.index];
          defines.push({ name: "CLEARCOATMAP", value: texCoord ?? 0 });
          if (extensions) {
            const ex = extensions.KHR_texture_transform;
            if (ex) {
              this.matricesMap.set("clearcoatTexture", this.buildTrans(ex, defines, "CLEARCOATMAP"));
            }
          }
        }
        if (cl.clearcoatNormalTexture) {
          const { extensions, texCoord } = cl.clearcoatNormalTexture;
          this.clearcoatNormalTexture = textures[cl.clearcoatNormalTexture.index];
          defines.push({ name: "CLEARCOATNORMALMAP", value: texCoord ?? 0 });
          if (extensions) {
            const ex = extensions.KHR_texture_transform;
            if (ex) {
              this.matricesMap.set("clearcoatNormalTexture", this.buildTrans(ex, defines, "CLEARCOATNORMALMAP"));
            }
          }
        }
        if (cl.clearcoatRoughnessTexture) {
          const { extensions, texCoord } = cl.clearcoatRoughnessTexture;
          this.clearcoatRoughnessTexture = textures[cl.clearcoatRoughnessTexture.index];
          defines.push({ name: "CLEARCOATROUGHMAP", value: texCoord ?? 0 });
          if (extensions) {
            const ex = extensions.KHR_texture_transform;
            if (ex) {
              this.matricesMap.set("clearcoatRoughnessTexture", this.buildTrans(ex, defines, "CLEARCOATROUGHMAP"));
            }
          }
        }
      }
      if (material.extensions && material.extensions.KHR_materials_sheen) {
        const {
          sheenColorTexture,
          sheenColorFactor,
          sheenRoughnessFactor,
          sheenRoughnessTexture
        } = material.extensions.KHR_materials_sheen;
        this.sheenColorFactor = sheenColorFactor;
        this.sheenRoughnessFactor = sheenRoughnessFactor;
        if (sheenColorTexture) {
          const { extensions, texCoord } = sheenColorTexture;
          this.sheenColorTexture = textures[sheenColorTexture.index];
          defines.push({ name: "SHEENMAP", value: texCoord ?? 0 });
          if (extensions) {
            const ex = extensions.KHR_texture_transform;
            if (ex) {
              this.matricesMap.set("sheenColorTexture", this.buildTrans(ex, defines, "SHEENMAP"));
            }
          }
        }
        if (sheenRoughnessTexture) {
          const { extensions, texCoord } = sheenRoughnessTexture;
          this.sheenRoughnessTexture = textures[sheenRoughnessTexture.index];
          defines.push({ name: "SHEENROUGHNESSMAP", value: texCoord ?? 0 });
          if (extensions) {
            const ex = extensions.KHR_texture_transform;
            if (ex) {
              this.matricesMap.set("sheenRoughnessTexture", this.buildTrans(ex, defines, "SHEENROUGHNESSMAP"));
            }
          }
        }
        defines.push({ name: "SHEEN" });
      }
      if (material.extensions && material.extensions.KHR_materials_transmission) {
        const { transmissionFactor, transmissionTexture } = material.extensions.KHR_materials_transmission;
        this.transmissionFactor = transmissionFactor;
        if (transmissionTexture) {
          const { extensions, texCoord } = transmissionTexture;
          this.transmissionTexture = textures[transmissionTexture.index];
          defines.push({ name: "TRANSMISSIONMAP", value: texCoord ?? 0 });
          if (extensions) {
            const ex = extensions.KHR_texture_transform;
            if (ex) {
              this.matricesMap.set("transmissionTexture", this.buildTrans(ex, defines, "TRANSMISSIONMAP"));
            }
          }
        }
        defines.push({ name: "TRANSMISSION" });
      }
      if (material.extensions && material.extensions.KHR_materials_volume) {
        const { attenuationColor, attenuationDistance, thicknessFactor, thicknessTexture } = material.extensions.KHR_materials_volume;
        this.attenuationColor = attenuationColor;
        this.attenuationDistance = attenuationDistance;
        this.thicknessFactor = thicknessFactor;
        this.ior = 1.5;
        if (thicknessTexture) {
          const { extensions, texCoord } = thicknessTexture;
          this.thicknessTexture = textures[thicknessTexture.index];
          defines.push({ name: "THICKNESSMAP", value: texCoord ?? 0 });
          if (extensions) {
            const ex = extensions.KHR_texture_transform;
            if (ex) {
              this.matricesMap.set("thicknessTexture", this.buildTrans(ex, defines, "THICKNESSMAP"));
            }
          }
        }
        defines.push({ name: "VOLUME" });
      }
      if (material.extensions && material.extensions.KHR_materials_emissive_strength) {
        const { emissiveStrength } = material.extensions.KHR_materials_emissive_strength;
        this.emissiveStrength = emissiveStrength;
      }
      if (material.extensions && material.extensions.KHR_materials_anisotropy) {
        const { anisotropyStrength, anisotropyRotation, anisotropyTexture } = material.extensions.KHR_materials_anisotropy;
        this.anisotropyStrength = anisotropyStrength;
        this.anisotropyRotation = anisotropyRotation;
        if (anisotropyTexture) {
          this.anisotropyTexture = textures[anisotropyTexture.index];
          defines.push({ name: "ANISOTROPYMAP", value: anisotropyTexture.texCoord ?? 0 });
          if (anisotropyTexture.extensions) {
            const ex = anisotropyTexture.extensions.KHR_texture_transform;
            if (ex) {
              this.matricesMap.set("anisotropyTexture", this.buildTrans(ex, defines, "ANISOTROPYMAP"));
            }
          }
        }
        defines.push({ name: "ANISOTROPY" });
      }
      if (material.extensions && material.extensions.KHR_materials_dispersion) {
        const { dispersion } = material.extensions.KHR_materials_dispersion;
        this.dispersion = dispersion;
        defines.push({ name: "DISPERSION" });
      }
      if (material.extensions && material.extensions.KHR_materials_iridescence) {
        const { iridescenceTexture, iridescenceThicknessTexture, iridescenceFactor, iridescenceIor, iridescenceThicknessMaximum, iridescenceThicknessMinimum } = material.extensions.KHR_materials_iridescence;
        this.iridescenceFactor = iridescenceFactor;
        this.iridescenceIOR = iridescenceIor;
        this.iridescenceThicknessMaximum = iridescenceThicknessMaximum;
        this.iridescenceThicknessMinimum = iridescenceThicknessMinimum;
        if (iridescenceTexture) {
          this.iridescenceTexture = textures[iridescenceTexture.index];
          defines.push({ name: "IRIDESCENCE_COLOR", value: iridescenceTexture.texCoord ?? 0 });
          if (iridescenceTexture.extensions) {
            const ex = iridescenceTexture.extensions.KHR_texture_transform;
            if (ex) {
              this.matricesMap.set("iridescenceTexture", this.buildTrans(ex, defines, "IRIDESCENCE_COLOR"));
            }
          }
        }
        if (iridescenceThicknessTexture) {
          this.iridescenceThicknessTexture = textures[iridescenceThicknessTexture.index];
          defines.push({ name: "IRIDESCENCEMAP", value: iridescenceThicknessTexture.texCoord ?? 0 });
          if (iridescenceThicknessTexture.extensions) {
            const ex = iridescenceThicknessTexture.extensions.KHR_texture_transform;
            if (ex) {
              this.matricesMap.set("iridescenceThicknessTexture", this.buildTrans(ex, defines, "IRIDESCENCEMAP"));
            }
          }
        }
        defines.push({ name: "IRIDESCENCE" });
      }
      if (material.extensions && material.extensions.KHR_materials_diffuse_transmission) {
        const { diffuseTransmissionFactor, diffuseTransmissionTexture, diffuseTransmissionColorFactor, diffuseTransmissionColorTexture } = material.extensions.KHR_materials_diffuse_transmission;
        this.diffuseTransmissionFactor = diffuseTransmissionFactor;
        if (diffuseTransmissionTexture) {
          this.diffuseTransmissionTexture = textures[diffuseTransmissionTexture.index];
          defines.push({ name: "DIFFUSE_TRANSMISSION_MAP", value: diffuseTransmissionTexture.texCoord ?? 0 });
          if (diffuseTransmissionTexture.extensions) {
            const ex = diffuseTransmissionTexture.extensions.KHR_texture_transform;
            if (ex) {
              this.matricesMap.set("diffuseTransmissionTexture", this.buildTrans(ex, defines, "DIFFUSE_TRANSMISSION_MAP"));
            }
          }
        }
        this.diffuseTransmissionColorFactor = diffuseTransmissionColorFactor ?? [1, 1, 1];
        if (diffuseTransmissionColorTexture) {
          this.diffuseTransmissionColorTexture = textures[diffuseTransmissionColorTexture.index];
          defines.push({ name: "DIFFUSE_TRANSMISSION_COLOR_MAP", value: diffuseTransmissionColorTexture.texCoord ?? 0 });
          if (diffuseTransmissionColorTexture.extensions) {
            const ex = diffuseTransmissionColorTexture.extensions.KHR_texture_transform;
            if (ex) {
              this.matricesMap.set("diffuseTransmissionColorTexture", this.buildTrans(ex, defines, "DIFFUSE_TRANSMISSION_COLOR_MAP"));
            }
          }
        }
        defines.push({ name: "DIFFUSE_TRANSMISSION" });
      }
      if (material.extensions && material.extensions.KHR_materials_ior) {
        this.ior = material.extensions.KHR_materials_ior.ior;
        defines.push({ name: "IOR" });
      }
      if (material.extensions && material.extensions.KHR_materials_specular) {
        const { specularFactor, specularTexture, specularColorFactor, specularColorTexture } = material.extensions.KHR_materials_specular;
        this.specularFactor = specularFactor;
        this.specularColorFactor = specularColorFactor;
        if (specularTexture) {
          this.specularTexture = textures[specularTexture.index];
          defines.push({ name: "SPECULARMAP" });
          if (specularTexture.extensions) {
            const ex = specularTexture.extensions.KHR_texture_transform;
            if (ex) {
              this.matricesMap.set("specularTexture", this.buildTrans(ex, defines, "SPECULARMAP"));
            }
          }
        }
        if (specularColorTexture) {
          this.specularColorTexture = textures[specularColorTexture.index];
          defines.push({ name: "SPECULARCOLORMAP" });
          if (specularColorTexture.extensions) {
            const ex = specularColorTexture.extensions.KHR_texture_transform;
            if (ex) {
              this.matricesMap.set("specularColorTexture", this.buildTrans(ex, defines, "SPECULARCOLORMAP"));
            }
          }
        }
        defines.push({ name: "SPECULAR" });
      }
      this.uniforms = {
        baseColorTexture: null,
        metallicRoughnessTexture: null,
        normalTexture: null,
        occlusionTexture: null,
        clearcoatTexture: null,
        clearcoatRoughnessTexture: null,
        sheenRoughnessTexture: null,
        iridescenceThicknessTexture: null,
        iridescenceTexture: null,
        sheenColorTexture: null,
        clearcoatNormalTexture: null,
        emissiveTexture: null,
        prefilterMap: null,
        charlieMap: null,
        brdfLUT: null,
        irradianceMap: null,
        transmissionTexture: null,
        specularTexture: null,
        specularColorTexture: null,
        thicknessTexture: null,
        colorTexture: null,
        Sheen_E: null,
        depthTexture: null,
        diffuseTransmissionTexture: null,
        diffuseTransmissionColorTexture: null,
        anisotropyTexture: null,
        isTone: null,
        isIBL: null,
        isDefaultLight: null
      };
      const { pbrMetallicRoughness } = material;
      if (pbrMetallicRoughness) {
        this.baseColorFactor = pbrMetallicRoughness.baseColorFactor;
        this.roughnessFactor = pbrMetallicRoughness.roughnessFactor;
        this.metallicFactor = pbrMetallicRoughness.metallicFactor;
        if (pbrMetallicRoughness.specularFactor) {
          this.specularFactor = pbrMetallicRoughness.specularFactor;
        }
        if (pbrMetallicRoughness.glossinessFactor) {
          this.glossinessFactor = pbrMetallicRoughness.glossinessFactor;
        }
      }
      this.alpha = material.alphaMode === "BLEND";
      this.doubleSided = material.doubleSided;
      this.emissiveFactor = material.emissiveFactor;
      this.extras = material.extras;
      if (pbrMetallicRoughness && pbrMetallicRoughness.metallicRoughnessTexture) {
        const { extensions, texCoord } = pbrMetallicRoughness.metallicRoughnessTexture;
        this.metallicRoughnessTexture = textures[pbrMetallicRoughness.metallicRoughnessTexture.index];
        defines.push({ name: "METALROUGHNESSMAP", value: texCoord ?? 0 });
        if (extensions) {
          const ex = extensions.KHR_texture_transform;
          if (ex) {
            this.matricesMap.set("metallicRoughnessTexture", this.buildTrans(ex, defines, "METALROUGHNESSMAP"));
          }
        }
      }
      if (material.normalTexture) {
        const { extensions, texCoord, scale } = material.normalTexture;
        this.normalTexture = textures[material.normalTexture.index];
        this.normalTextureScale = scale;
        defines.push({ name: "NORMALMAP", value: texCoord ?? 0 });
        if (extensions) {
          const ex = extensions.KHR_texture_transform;
          if (ex) {
            this.normalTextureScale = void 0;
            this.matricesMap.set("normalTexture", this.buildTrans(ex, defines, "NORMALMAP"));
          }
        }
      }
      if (material.occlusionTexture) {
        const { extensions, texCoord } = material.occlusionTexture;
        this.occlusionTexture = textures[material.occlusionTexture.index];
        defines.push({ name: "OCCLUSIONMAP", value: texCoord ?? 0 });
        if (extensions) {
          const ex = extensions.KHR_texture_transform;
          if (ex) {
            this.matricesMap.set("occlusionTexture", this.buildTrans(ex, defines, "OCCLUSIONMAP"));
          }
        }
      }
      if (pbrMetallicRoughness && pbrMetallicRoughness.baseColorTexture) {
        const { extensions, texCoord } = pbrMetallicRoughness.baseColorTexture;
        this.baseColorTexture = textures[pbrMetallicRoughness.baseColorTexture.index];
        defines.push({ name: "BASECOLORTEXTURE", value: texCoord ?? 0 });
        if (extensions) {
          const ex = extensions.KHR_texture_transform;
          if (ex) {
            this.matricesMap.set("baseColorTexture", this.buildTrans(ex, defines, "BASECOLORTEXTURE"));
          }
        }
      }
      if (material.emissiveTexture) {
        const { extensions, texCoord } = material.emissiveTexture;
        this.emissiveTexture = textures[material.emissiveTexture.index];
        defines.push({ name: "EMISSIVEMAP", value: texCoord ?? 0 });
        if (extensions) {
          const ex = extensions.KHR_texture_transform;
          if (ex) {
            this.matricesMap.set("emissiveTexture", this.buildTrans(ex, defines, "EMISSIVEMAP"));
          }
        }
      }
      if (material.alphaMode === "MASK") {
        defines.push({
          name: "ALPHATEST",
          value: material.alphaCutoff ?? 0.5
        });
      } else if (material.alphaMode === "BLEND") {
        defines.push({ name: "ALPHATEST", value: 0.01 });
      }
      if (this.doubleSided) {
        defines.push({ name: "DOUBLESIDED" });
      }
      if (material.extensions && material.extensions.KHR_materials_unlit) {
        defines.push({ name: "NOLIGHT" });
      }
      if (this.matrices.length) {
        defines.push({ name: "MATRICES", value: this.matrices.length });
      }
    }
    buildTrans(ex, defines, name = "") {
      if (ex.offset !== void 0 || ex.scale !== void 0 || ex.rotation !== void 0) {
        const offset = ex.offset || [0, 0];
        const scale = ex.scale || [1, 1];
        const rotation = ex.rotation || 0;
        const i = this.matrices.push(new Matrix4().set([...offset, 0, 0, ...scale, 0, 0, rotation, 0, 0, 0, 0, 0, 0, 0])) - 1;
        defines.push({ name: `${name}_TEXTURE_TRANSFORM`, value: i });
        return i;
      }
    }
    setHarmonics(sphericalHarmonics) {
      this.sphericalHarmonics = sphericalHarmonics;
    }
    updateUniformsWebgl(gl11, program) {
      gl11.useProgram(program);
      this.uniforms.isTone = gl11.getUniformLocation(program, "isTone");
      this.uniforms.isIBL = gl11.getUniformLocation(program, "isIBL");
      this.uniforms.isDefaultLight = gl11.getUniformLocation(program, "isDefaultLight");
      if (this.baseColorTexture) {
        this.uniforms.baseColorTexture = gl11.getUniformLocation(program, "baseColorTexture");
        gl11.uniform1i(this.uniforms.baseColorTexture, textureEnum.baseColorTexture);
      }
      if (this.metallicRoughnessTexture) {
        this.uniforms.metallicRoughnessTexture = gl11.getUniformLocation(program, "metallicRoughnessTexture");
        gl11.uniform1i(this.uniforms.metallicRoughnessTexture, textureEnum.metallicRoughnessTexture);
      }
      if (this.normalTexture) {
        this.uniforms.normalTexture = gl11.getUniformLocation(program, "normalTexture");
        gl11.uniform1i(this.uniforms.normalTexture, textureEnum.normalTexture);
      }
      if (this.occlusionTexture) {
        this.uniforms.occlusionTexture = gl11.getUniformLocation(program, "occlusionTexture");
        gl11.uniform1i(this.uniforms.occlusionTexture, textureEnum.occlusionTexture);
      }
      if (this.emissiveTexture) {
        this.uniforms.emissiveTexture = gl11.getUniformLocation(program, "emissiveTexture");
        gl11.uniform1i(this.uniforms.emissiveTexture, textureEnum.emissiveTexture);
      }
      if (this.clearcoatTexture) {
        this.uniforms.clearcoatTexture = gl11.getUniformLocation(program, "clearcoatTexture");
        gl11.uniform1i(this.uniforms.clearcoatTexture, textureEnum.clearcoatTexture);
      }
      if (this.clearcoatRoughnessTexture) {
        this.uniforms.clearcoatRoughnessTexture = gl11.getUniformLocation(program, "clearcoatRoughnessTexture");
        gl11.uniform1i(this.uniforms.clearcoatRoughnessTexture, textureEnum.clearcoatRoughnessTexture);
      }
      if (this.clearcoatNormalTexture) {
        this.uniforms.clearcoatNormalTexture = gl11.getUniformLocation(program, "clearcoatNormalTexture");
        gl11.uniform1i(this.uniforms.clearcoatNormalTexture, textureEnum.clearcoatNormalTexture);
      }
      if (this.sheenRoughnessTexture) {
        this.uniforms.sheenRoughnessTexture = gl11.getUniformLocation(program, "sheenRoughnessTexture");
        gl11.uniform1i(this.uniforms.sheenRoughnessTexture, textureEnum.sheenRoughnessTexture);
      }
      if (this.iridescenceThicknessTexture) {
        this.uniforms.iridescenceThicknessTexture = gl11.getUniformLocation(program, "iridescenceThicknessTexture");
        gl11.uniform1i(this.uniforms.iridescenceThicknessTexture, textureEnum.iridescenceThicknessTexture);
      }
      if (this.iridescenceTexture) {
        this.uniforms.iridescenceTexture = gl11.getUniformLocation(program, "iridescenceTexture");
        gl11.uniform1i(this.uniforms.iridescenceTexture, textureEnum.iridescenceTexture);
      }
      if (this.anisotropyTexture) {
        this.uniforms.anisotropyTexture = gl11.getUniformLocation(program, "anisotropyTexture");
        gl11.uniform1i(this.uniforms.anisotropyTexture, textureEnum.anisotropyTexture);
      }
      if (this.diffuseTransmissionColorTexture) {
        this.uniforms.diffuseTransmissionColorTexture = gl11.getUniformLocation(program, "diffuseTransmissionColorTexture");
        gl11.uniform1i(this.uniforms.diffuseTransmissionColorTexture, textureEnum.diffuseTransmissionColorTexture);
      }
      if (this.diffuseTransmissionTexture) {
        this.uniforms.diffuseTransmissionTexture = gl11.getUniformLocation(program, "diffuseTransmissionTexture");
        gl11.uniform1i(this.uniforms.diffuseTransmissionTexture, textureEnum.diffuseTransmissionTexture);
      }
      if (this.sheenColorTexture) {
        this.uniforms.sheenColorTexture = gl11.getUniformLocation(program, "sheenColorTexture");
        gl11.uniform1i(this.uniforms.sheenColorTexture, textureEnum.sheenColorTexture);
      }
      if (this.transmissionTexture) {
        this.uniforms.transmissionTexture = gl11.getUniformLocation(program, "transmissionTexture");
        gl11.uniform1i(this.uniforms.transmissionTexture, textureEnum.transmissionTexture);
      }
      if (this.specularTexture) {
        this.uniforms.specularTexture = gl11.getUniformLocation(program, "specularTexture");
        gl11.uniform1i(this.uniforms.specularTexture, textureEnum.specularTexture);
      }
      if (this.specularColorTexture) {
        this.uniforms.specularColorTexture = gl11.getUniformLocation(program, "specularColorTexture");
        gl11.uniform1i(this.uniforms.specularColorTexture, textureEnum.specularColorTexture);
      }
      if (this.thicknessTexture) {
        this.uniforms.thicknessTexture = gl11.getUniformLocation(program, "thicknessTexture");
        gl11.uniform1i(this.uniforms.thicknessTexture, textureEnum.thicknessTexture);
      }
      this.uniforms.prefilterMap = gl11.getUniformLocation(program, "prefilterMap");
      this.uniforms.charlieMap = gl11.getUniformLocation(program, "charlieMap");
      this.uniforms.brdfLUT = gl11.getUniformLocation(program, "brdfLUT");
      this.uniforms.irradianceMap = gl11.getUniformLocation(program, "irradianceMap");
      this.uniforms.depthTexture = gl11.getUniformLocation(program, "depthTexture");
      this.uniforms.colorTexture = gl11.getUniformLocation(program, "colorTexture");
      this.uniforms.Sheen_E = gl11.getUniformLocation(program, "Sheen_E");
      gl11.uniform1i(this.uniforms.prefilterMap, textureEnum.prefilterTexture);
      gl11.uniform1i(this.uniforms.charlieMap, textureEnum.charlieTexture);
      gl11.uniform1i(this.uniforms.brdfLUT, textureEnum.brdfLUTTexture);
      gl11.uniform1i(this.uniforms.irradianceMap, textureEnum.irradianceTexture);
      gl11.uniform1i(this.uniforms.Sheen_E, textureEnum.Sheen_E);
      {
        const mIndex = gl11.getUniformBlockIndex(program, "LightColor");
        gl11.uniformBlockBinding(program, mIndex, 4);
      }
      {
        const mIndex = gl11.getUniformBlockIndex(program, "LightPos");
        gl11.uniformBlockBinding(program, mIndex, 3);
      }
      {
        const mIndex = gl11.getUniformBlockIndex(program, "Spotdir");
        gl11.uniformBlockBinding(program, mIndex, 5);
      }
      {
        const mIndex = gl11.getUniformBlockIndex(program, "LightIntensity");
        gl11.uniformBlockBinding(program, mIndex, 6);
      }
      if (this.matrices.length) {
        const mIndex = gl11.getUniformBlockIndex(program, "TextureMatrices");
        gl11.uniformBlockBinding(program, mIndex, 8);
        const mUBO = gl11.createBuffer();
        gl11.bindBuffer(gl11.UNIFORM_BUFFER, mUBO);
        gl11.bufferData(gl11.UNIFORM_BUFFER, this.textureMatricesBuffer.store, gl11.STATIC_DRAW);
        this.lightUBO5 = mUBO;
      }
    }
    createUniforms(camera, lights) {
      const spotDirs = new Float32Array(lights.length * 4);
      const lightPos = new Float32Array(lights.length * 4);
      const lightColor = new Float32Array(lights.length * 4);
      const lightProps = new Float32Array(lights.length * 4);
      const textureMatrices = new Float32Array(this.matrices.length * 16);
      lights.forEach((light, i) => {
        spotDirs.set(
          new Vector3([light.matrixWorld.elements[8], light.matrixWorld.elements[9], light.matrixWorld.elements[10]]).normalize().elements,
          i * 4
        );
        lightPos.set(light.getPosition(), i * 4);
        lightColor.set(light.color.elements, i * 4);
        lightProps.set([light.intensity, light.spot.innerConeAngle ?? 0, light.spot.outerConeAngle ?? 0, lightEnum[light.type]], i * 4);
      });
      this.matrices.forEach((m, i) => {
        textureMatrices.set(m.elements, i * 16);
      });
      {
        const materialUniformBuffer = new UniformBuffer();
        materialUniformBuffer.add("baseColorFactor", this.baseColorFactor ?? [0.8, 0.8, 0.8, 1]);
        materialUniformBuffer.add("specularFactor", this.specularFactor ?? 1);
        materialUniformBuffer.add("specularColorFactor", this.specularColorFactor ?? [1, 1, 1]);
        materialUniformBuffer.add("emissiveFactor", this.emissiveFactor ?? [0, 0, 0]);
        materialUniformBuffer.add("glossinessFactor", this.glossinessFactor ?? 0.5);
        materialUniformBuffer.add("metallicFactor", this.metallicFactor ?? 1);
        materialUniformBuffer.add("roughnessFactor", this.roughnessFactor ?? 1);
        materialUniformBuffer.add("clearcoatFactor", this.clearcoatFactor ?? 0);
        materialUniformBuffer.add("clearcoatRoughnessFactor", this.clearcoatRoughnessFactor ?? 0);
        materialUniformBuffer.add("sheenColorFactor", this.sheenColorFactor ?? 0);
        materialUniformBuffer.add("sheenRoughnessFactor", this.sheenRoughnessFactor ?? 0);
        materialUniformBuffer.add("transmissionFactor", this.transmissionFactor ?? 0);
        materialUniformBuffer.add("ior", this.ior ?? 1);
        materialUniformBuffer.add("normalTextureScale", this.normalTextureScale ?? 1);
        materialUniformBuffer.add("attenuationColor", this.attenuationColor ?? [1, 1, 1]);
        materialUniformBuffer.add("attenuationDistance", this.attenuationDistance ?? 1);
        materialUniformBuffer.add("thicknessFactor", this.thicknessFactor ?? 0);
        materialUniformBuffer.add("emissiveStrength", this.emissiveStrength ?? 1);
        materialUniformBuffer.add("anisotropy", [this.anisotropyStrength ?? 0, this.anisotropyRotation ?? 0]);
        materialUniformBuffer.add("iridescence", [this.iridescenceFactor ?? 0, this.iridescenceIOR ?? 1.3, this.iridescenceThicknessMaximum ?? 400, this.iridescenceThicknessMinimum ?? 100]);
        materialUniformBuffer.add("diffuseTransmissionFactor", [this.diffuseTransmissionFactor ?? 0, ...this.diffuseTransmissionColorFactor]);
        materialUniformBuffer.add("dispersionFactor", [this.dispersion ?? 0]);
        materialUniformBuffer.done();
        this.materialUniformBuffer = materialUniformBuffer;
      }
      if (this.matrices.length) {
        const materialUniformBuffer = new UniformBuffer();
        materialUniformBuffer.add("textureMatrices", textureMatrices);
        materialUniformBuffer.done();
        this.textureMatricesBuffer = materialUniformBuffer;
      }
    }
    updateUniformsWebGPU(WebGPU2) {
      const { device, nearestSampler, linearSampler } = WebGPU2;
      let uniformBuffer6;
      if (this.textureMatricesBuffer) {
        uniformBuffer6 = device.createBuffer({
          size: 256 + this.textureMatricesBuffer.store.byteLength,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });
        this.textureMatricesBuffer.bufferWebGPU = uniformBuffer6;
      }
      const sampler = this.baseColorTexture ? this.baseColorTexture.sampler : linearSampler;
      const uniformBindGroup1 = [
        {
          binding: 2,
          resource: sampler
        },
        {
          binding: 37,
          resource: nearestSampler
        },
        {
          binding: 24,
          resource: linearSampler
        },
        {
          binding: 3,
          resource: this.baseColorTexture?.view
        },
        {
          binding: 4,
          resource: this.metallicRoughnessTexture?.view
        },
        {
          binding: 5,
          resource: this.normalTexture?.view
        },
        {
          binding: 6,
          resource: this.emissiveTexture?.view
        },
        {
          binding: 7,
          resource: this.occlusionTexture?.view
        },
        {
          binding: 8,
          resource: this.clearcoatTexture?.view
        },
        {
          binding: 9,
          resource: this.clearcoatRoughnessTexture?.view
        },
        {
          binding: 10,
          resource: this.transmissionTexture?.view
        },
        {
          binding: 11,
          resource: this.sheenColorTexture?.view
        },
        {
          binding: 12,
          resource: this.sheenRoughnessTexture?.view
        },
        {
          binding: 13,
          resource: this.clearcoatNormalTexture?.view
        },
        {
          binding: 14,
          resource: this.specularTexture?.view
        },
        {
          binding: 29,
          resource: this.thicknessTexture?.view
        },
        {
          binding: 31,
          resource: this.anisotropyTexture?.view
        },
        {
          binding: 32,
          resource: this.iridescenceThicknessTexture?.view
        },
        {
          binding: 38,
          resource: this.iridescenceTexture?.view
        },
        {
          binding: 33,
          resource: this.specularColorTexture?.view
        },
        {
          binding: 34,
          resource: this.diffuseTransmissionTexture?.view
        },
        {
          binding: 36,
          resource: this.diffuseTransmissionColorTexture?.view
        },
        {
          binding: 23,
          resource: this.textureMatricesBuffer && uniformBuffer6
        }
      ];
      if (this.textureMatricesBuffer) {
        device.queue.writeBuffer(
          uniformBuffer6,
          0,
          this.textureMatricesBuffer.store.buffer,
          this.textureMatricesBuffer.store.byteOffset,
          this.textureMatricesBuffer.store.byteLength
        );
      }
      this.uniformBindGroup1 = uniformBindGroup1.filter((r) => r.resource);
    }
    hasNormal() {
      return Boolean(this.normalTexture) || Boolean(this.clearcoatNormalTexture);
    }
    setColor(gl11, name, value) {
      this.materialUniformBuffer.update(gl11, name, value.elements, true);
    }
    setTexture(gl11, name, type, value) {
      gl11.bindBufferBase(gl11.UNIFORM_BUFFER, 8, this.lightUBO5);
      const i = this.matricesMap.get(name) * 16;
      if (type === "offset") {
        this.textureMatricesBuffer.store[i] = value.elements[0];
        this.textureMatricesBuffer.store[i + 1] = value.elements[1];
      }
      if (type === "scale") {
        this.textureMatricesBuffer.store[i + 4] = value.elements[0];
        this.textureMatricesBuffer.store[i + 5] = value.elements[1];
      }
      if (type === "rotation") {
        this.textureMatricesBuffer.store[i + 8] = value.elements[0];
      }
      gl11.bufferSubData(gl11.UNIFORM_BUFFER, 0, this.textureMatricesBuffer.store);
    }
    setTextureWebGPU(gl11, name, type, value) {
      const i = this.matricesMap.get(name) * 16;
      if (type === "offset") {
        this.textureMatricesBuffer.store[i] = value.elements[0];
        this.textureMatricesBuffer.store[i + 1] = value.elements[1];
      }
      if (type === "scale") {
        this.textureMatricesBuffer.store[i + 4] = value.elements[0];
        this.textureMatricesBuffer.store[i + 5] = value.elements[1];
      }
      if (type === "rotation") {
        this.textureMatricesBuffer.store[i + 8] = value.elements[0];
      }
      gl11.device.queue.writeBuffer(
        this.textureMatricesBuffer.bufferWebGPU,
        0,
        this.textureMatricesBuffer.store.buffer,
        this.textureMatricesBuffer.store.byteOffset,
        this.textureMatricesBuffer.store.byteLength
      );
    }
    setColorWebGPU(gl11, name, value) {
      this.materialUniformBuffer.updateWebGPU(gl11, name, value.elements, true);
    }
  };

  // src/events.ts
  var Events = class {
    redraw;
    isPan;
    isDrag;
    x;
    y;
    constructor(canvas, redraw) {
      this.redraw = redraw;
      document.addEventListener("wheel", this, { passive: false });
      canvas.addEventListener("mousedown", this);
      canvas.addEventListener("mousemove", this);
      canvas.addEventListener("mouseup", this);
      document.addEventListener("keyup", this);
      document.addEventListener("keydown", this);
      addEventListener("resize", this);
    }
    handleEvent(e) {
      switch (e.type) {
        case "wheel":
          this.zoom(e);
          break;
        case "mousedown":
          this.onStart(e);
          break;
        case "mousemove":
          this.onMove(e);
          break;
        case "mouseup":
          this.onEnd();
          break;
        case "keyup":
          this.onKeyUp();
          break;
        case "keydown":
          this.onKeyDown(e);
          break;
        case "resize":
          this.onResize();
          break;
      }
    }
    onResize() {
      this.redraw("resize");
    }
    onKeyDown(e) {
      if (e.shiftKey || e.ctrlKey) {
        this.isPan = true;
      }
    }
    onKeyUp() {
      this.isPan = false;
    }
    onStart(e) {
      this.x = e.clientX;
      this.y = e.clientY;
      this.isDrag = true;
    }
    onMove(e) {
      if (this.isDrag) {
        if (this.isPan) {
          this.redraw("pan", [this.x, this.y], [e.clientX, e.clientY]);
        } else {
          this.redraw("rotate", [this.x, this.y], [e.clientX, e.clientY]);
        }
        this.x = e.clientX;
        this.y = e.clientY;
      }
    }
    onEnd() {
      this.isDrag = false;
    }
    zoom(e) {
      e.preventDefault();
      this.redraw("zoom", e.deltaY);
    }
  };

  // src/env.webgpu.ts
  var import_parse_hdr = __toESM(require_parse_hdr(), 1);

  // src/shaders/env.webgpu.vert
  var env_webgpu_default = "#version 460\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 inPosition;\r\n\r\nlayout(set = 0, binding = 0) uniform Uniforms {\r\n    vec4 index;\r\n    mat4 projection;\r\n    mat4 view[6];\r\n};\r\n\r\n\r\nlayout (location = 0) out vec3 outUV;\r\n\r\nvoid main() {\r\n	outUV = inPosition;\r\n    mat4 rotView = mat4(mat3(view[int(index.x)]));\r\n    gl_Position = projection * rotView * vec4(inPosition, 1.0);\r\n}\r\n";

  // src/shaders/cube.webgpu.frag
  var cube_webgpu_default = "#version 460\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 outUV;\r\nlayout (location = 0) out vec4 color;\r\n\r\nlayout(set = 0, binding = 1) uniform sampler baseSampler;\r\nlayout(set = 0, binding = 2) uniform texture2D diffuse;\r\n\r\nlayout(set = 0, binding = 0) uniform Uniforms {\r\n    vec4 index;\r\n    mat4 projection;\r\n    mat4 view[6];\r\n};\r\n\r\nconst vec2 invAtan = vec2(0.1591, 0.3155);\r\nvec2 SampleSphericalMap(vec3 v) {\r\n    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\r\n    uv *= invAtan;\r\n    uv += 0.5;\r\n    return uv;\r\n}\r\n\r\nvoid main() {		\r\n    vec2 uv = SampleSphericalMap(normalize(outUV));\r\n\r\n    vec3 c = textureLod(sampler2D(diffuse, baseSampler), uv, index.y).rgb;\r\n    \r\n    color = vec4(c, 1.0);\r\n}\r\n";

  // src/shaders/irradiance.webgpu.frag
  var irradiance_webgpu_default = "#version 460\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 outUV;\r\nlayout (location = 0) out vec4 color;\r\n\r\nlayout(set = 0, binding = 1) uniform sampler baseSampler;\r\nlayout(set = 0, binding = 2) uniform textureCube environmentMap;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nvoid main() {\r\n    vec3 N = normalize(outUV);\r\n    vec3 irradiance = vec3(0.0);\r\n\r\n    vec3 up    = vec3(0.0, 1.0, 0.0);\r\n    vec3 right = cross(up, N);\r\n    up         = cross(N, right);\r\n\r\n    float sampleDelta = 0.025;\r\n    float nrSamples = 0.0; \r\n    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\r\n    {\r\n        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\r\n        {\r\n            // spherical to cartesian (in tangent space)\r\n            vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\r\n            // tangent space to world\r\n            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N;\r\n            vec3 sampleVecFixed = vec3(sampleVec.z, sampleVec.y, sampleVec.x);\r\n\r\n            float mip = floor(log2(512.0)) - 3.0;\r\n            irradiance += textureLod(samplerCube(environmentMap, baseSampler), sampleVecFixed, mip).rgb * cos(theta) * sin(theta);\r\n            nrSamples++;\r\n        }\r\n    }\r\n    irradiance = PI * irradiance * (1.0 / float(nrSamples));\r\n    \r\n    color = vec4(irradiance, 1.0);\r\n}\r\n";

  // src/shaders/cube-mipmap.webgpu.frag
  var cube_mipmap_webgpu_default = "#version 460\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 outUV;\r\nlayout (location = 0) out vec4 color;\r\nlayout (location = 1) out vec4 color2;\r\n\r\nlayout(set = 0, binding = 0) uniform Uniforms {\r\n    vec4 roughness;\r\n    mat4 projection;\r\n    mat4 view[6];\r\n};\r\nlayout(set = 0, binding = 1) uniform sampler baseSampler;\r\nlayout(set = 0, binding = 2) uniform textureCube environmentMap;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nfloat RadicalInverse_VdC(uint bits) {\r\n    bits = (bits << 16u) | (bits >> 16u);\r\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r\n}\r\n// ----------------------------------------------------------------------------\r\nvec2 Hammersley(uint i, uint N) {\r\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\r\n}  \r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness, bool isCharlie, inout float cosZ) {\r\n    float a = max(roughness*roughness, 0.000001);\r\n	\r\n    float phi = 2.0 * PI * Xi.x;\r\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\r\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\r\n\r\n    if (isCharlie) {\r\n        sinTheta = pow(Xi.y, a / (2.0*a + 1.0));\r\n        cosTheta = sqrt(1.0 - sinTheta * sinTheta);\r\n        cosZ = cosTheta;\r\n    }\r\n	\r\n    // from spherical coordinates to cartesian coordinates\r\n    vec3 H;\r\n    H.x = cos(phi) * sinTheta;\r\n    H.y = sin(phi) * sinTheta;\r\n    H.z = cosTheta;\r\n	\r\n    // from tangent-space vector to world-space sample vector\r\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r\n    vec3 tangent   = normalize(cross(up, N));\r\n    vec3 bitangent = cross(N, tangent);\r\n	\r\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\r\n    return normalize(sampleVec);\r\n} \r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = max(a*a, 0.0001);\r\n    float NdotH = max(dot(N, H), 0.0);\r\n    float NdotH2 = NdotH*NdotH;\r\n\r\n    float nom   = a2;\r\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n\r\n    return nom / max(denom, 0.0001);\r\n}\r\n\r\nfloat D_Charlie(float sheenRoughness, float NdotH) {\r\n    sheenRoughness = max(sheenRoughness, 0.000001); //clamp (0,1]\r\n    float invR = 1.0 / sheenRoughness;\r\n    float cos2h = NdotH * NdotH;\r\n    float sin2h = 1.0 - cos2h;\r\n    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\r\n}\r\n\r\nvec3 x(bool isCharlie, float roughness) {\r\n    vec3 N = normalize(vec3(outUV.z, outUV.y, outUV.x));    \r\n    vec3 R = N;\r\n    vec3 V = R;\r\n\r\n    const uint SAMPLE_COUNT = isCharlie ? 64u : 1024u;\r\n    float totalWeight = 0.0;   \r\n    vec3 prefilteredColor = vec3(0.0);     \r\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i) {\r\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\r\n        float cosZ = 0.0;\r\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness, isCharlie, cosZ);\r\n        vec3 L  = normalize(reflect(-V, H));\r\n\r\n        float NdotL = max(dot(N, L), 0.0);\r\n        if (NdotL > 0.0) {\r\n            float D = DistributionGGX(N, H, roughness);\r\n            float pdf = (D * max(dot(N, H), 0.0) / (4.0 * max(dot(H, V), 0.0))) + 0.0001;\r\n            if (isCharlie) {\r\n                pdf = D_Charlie(roughness * roughness, cosZ);\r\n                pdf /= 4.0;\r\n            }\r\n\r\n            float mip = floor(log2(512.0)) - 1.0;\r\n            float lod = roughness == 0.0 ? 0.0 : 0.5 * log2( mip * float(512) * float(512) / (float(SAMPLE_COUNT) * pdf));\r\n\r\n            prefilteredColor += textureLod( samplerCube(environmentMap, baseSampler), L, clamp(lod, 0.0, 4.0) ).rgb * NdotL;\r\n            totalWeight += NdotL;\r\n        }\r\n    }\r\n    prefilteredColor = prefilteredColor / totalWeight;\r\n    return prefilteredColor;\r\n}\r\n\r\nvoid main() {\r\n    color = vec4(x(false, roughness.y), 1.0);\r\n    color2 = vec4(x(true, roughness.y), 1.0);\r\n}\r\n";

  // src/shaders/bdrf.webgpu.frag
  var bdrf_webgpu_default = "#version 460\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec2 uv;\r\nlayout (location = 0) out vec4 color;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nfloat V_Ashikhmin(float NdotL, float NdotV) {\r\n    return clamp(1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV)), 0.0, 1.0);\r\n}\r\n\r\nfloat D_Charlie(float sheenRoughness, float NdotH) {\r\n    sheenRoughness = max(sheenRoughness, 0.000001); //clamp (0,1]\r\n    float invR = 1.0 / sheenRoughness;\r\n    float cos2h = NdotH * NdotH;\r\n    float sin2h = 1.0 - cos2h;\r\n    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\r\n}\r\n\r\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\r\n    float a = roughness;\r\n    float k = (a * a) / 2.0;\r\n\r\n    float nom   = NdotV;\r\n    float denom = NdotV * (1.0 - k) + k;\r\n\r\n    return nom / denom;\r\n}\r\n\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float NdotV = max(dot(N, V), 0.0);\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\r\n\r\n    return ggx1 * ggx2;\r\n} \r\n\r\nfloat RadicalInverse_VdC(uint bits) {\r\n    bits = (bits << 16u) | (bits >> 16u);\r\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r\n}\r\n\r\nvec2 Hammersley(uint i, uint N) {\r\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\r\n}  \r\n\r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness, bool isCharlie) {\r\n    float a = roughness*roughness;\r\n	\r\n    float phi = 2.0 * PI * Xi.x;\r\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\r\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\r\n\r\n    if (isCharlie) {\r\n        sinTheta = pow(Xi.y, a / (2.0*a + 1.0));\r\n        cosTheta = sqrt(1.0 - sinTheta * sinTheta);\r\n    }\r\n	\r\n    // from spherical coordinates to cartesian coordinates\r\n    vec3 H;\r\n    H.x = cos(phi) * sinTheta;\r\n    H.y = sin(phi) * sinTheta;\r\n    H.z = cosTheta;\r\n	\r\n    // from tangent-space vector to world-space sample vector\r\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r\n    vec3 tangent   = normalize(cross(up, N));\r\n    vec3 bitangent = cross(N, tangent);\r\n	\r\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\r\n    return normalize(sampleVec);\r\n} \r\n\r\nvec3 IntegrateBRDF(float NdotV, float roughness) {\r\n    vec3 V;\r\n    V.x = sqrt(1.0 - NdotV*NdotV);\r\n    V.y = 0.0;\r\n    V.z = NdotV;\r\n\r\n    float A = 0.0;\r\n    float B = 0.0;\r\n    float C = 0.0;\r\n\r\n    vec3 N = vec3(0.0, 0.0, 1.0);\r\n\r\n    const uint SAMPLE_COUNT = 1024u;\r\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i) {\r\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\r\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness, false);\r\n        vec3 L  = normalize(reflect(-V, H));\r\n\r\n        float NdotL = max(L.z, 0.0);\r\n        float NdotH = max(H.z, 0.0);\r\n        float VdotH = max(dot(V, H), 0.0);\r\n\r\n        if(NdotL > 0.0) {\r\n            float G = GeometrySmith(N, V, L, roughness);\r\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\r\n            float Fc = pow(1.0 - VdotH, 5.0);\r\n\r\n            A += (1.0 - Fc) * G_Vis;\r\n            B += Fc * G_Vis;\r\n        }\r\n\r\n        H  = ImportanceSampleGGX(Xi, N, roughness, true);\r\n        L  = normalize(2.0 * dot(V, H) * H - V);\r\n        NdotL = max(L.z, 0.0);\r\n        NdotH = max(H.z, 0.0);\r\n        VdotH = max(dot(V, H), 0.0);\r\n        if (NdotL > 0.0) {\r\n            float sheenDistribution = D_Charlie(roughness, NdotH);\r\n            float sheenVisibility = V_Ashikhmin(NdotL, NdotV);\r\n\r\n            C += sheenVisibility * sheenDistribution * NdotL * VdotH;\r\n        }\r\n    }\r\n    A /= float(SAMPLE_COUNT);\r\n    B /= float(SAMPLE_COUNT);\r\n    C = 4.0 * 2.0 * PI * C / float(SAMPLE_COUNT);\r\n    return vec3(A, B, C);\r\n}\r\n\r\nvoid main() {		\r\n    vec3 integratedBRDF = IntegrateBRDF(uv.x, uv.y);\r\n    color = vec4(integratedBRDF, 0.0);\r\n}\r\n";

  // src/shaders/quad.webgpu.glsl
  var quad_webgpu_default = "#version 460\r\nlayout (location = 0) in vec2 pos;\r\n\r\nlayout (location = 0) out vec2 uv;\r\n\r\nvoid main() {\r\n    uv = pos * 0.5 + 0.5;\r\n    uv.y = 1.0 - uv.y;\r\n    gl_Position = vec4(pos, 0.0, 1.0); \r\n}\r\n";

  // src/vertex.ts
  var cubeVertex = new Float32Array([
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    1,
    -1,
    1
  ]);
  var quadVertex = new Float32Array([-1, 1, -1, -1, 1, 1, 1, -1]);
  var quadFull = new Float32Array([-1, 1, -1, -1, 1, -1, 1, -1, 1, 1, -1, 1]);

  // src/images/Sheen_E.hdr
  var Sheen_E_default = "./assets/Sheen_E.hdr";

  // src/SH.ts
  var SH3ylmBasisConstants = [
    Math.sqrt(1 / (4 * Math.PI)),
    -Math.sqrt(3 / (4 * Math.PI)),
    Math.sqrt(3 / (4 * Math.PI)),
    -Math.sqrt(3 / (4 * Math.PI)),
    Math.sqrt(15 / (4 * Math.PI)),
    -Math.sqrt(15 / (4 * Math.PI)),
    Math.sqrt(5 / (16 * Math.PI)),
    -Math.sqrt(15 / (4 * Math.PI)),
    Math.sqrt(15 / (16 * Math.PI))
  ];
  var SphericalHarmonics = class _SphericalHarmonics {
    preScaled = false;
    l00 = new Vector3();
    l1_1 = new Vector3();
    l10 = new Vector3();
    l11 = new Vector3();
    l2_2 = new Vector3();
    l2_1 = new Vector3();
    l20 = new Vector3();
    l21 = new Vector3();
    l22 = new Vector3();
    scaleInPlace(scale) {
      this.l00.scale(scale);
      this.l1_1.scale(scale);
      this.l10.scale(scale);
      this.l11.scale(scale);
      this.l2_2.scale(scale);
      this.l2_1.scale(scale);
      this.l20.scale(scale);
      this.l21.scale(scale);
      this.l22.scale(scale);
    }
    convertIrradianceToLambertianRadiance() {
      this.scaleInPlace(1 / Math.PI);
    }
    preScaleForRendering() {
      this.preScaled = true;
      this.l00.scale(SH3ylmBasisConstants[0]);
      this.l1_1.scale(SH3ylmBasisConstants[1]);
      this.l10.scale(SH3ylmBasisConstants[2]);
      this.l11.scale(SH3ylmBasisConstants[3]);
      this.l2_2.scale(SH3ylmBasisConstants[4]);
      this.l2_1.scale(SH3ylmBasisConstants[5]);
      this.l20.scale(SH3ylmBasisConstants[6]);
      this.l21.scale(SH3ylmBasisConstants[7]);
      this.l22.scale(SH3ylmBasisConstants[8]);
    }
    static FromArray(data) {
      const sh = new _SphericalHarmonics();
      Vector3.FromArrayToRef(data[0], 0, sh.l00);
      Vector3.FromArrayToRef(data[1], 0, sh.l1_1);
      Vector3.FromArrayToRef(data[2], 0, sh.l10);
      Vector3.FromArrayToRef(data[3], 0, sh.l11);
      Vector3.FromArrayToRef(data[4], 0, sh.l2_2);
      Vector3.FromArrayToRef(data[5], 0, sh.l2_1);
      Vector3.FromArrayToRef(data[6], 0, sh.l20);
      Vector3.FromArrayToRef(data[7], 0, sh.l21);
      Vector3.FromArrayToRef(data[8], 0, sh.l22);
      return sh;
    }
  };
  var SphericalPolynomial = class _SphericalPolynomial {
    _harmonics;
    get preScaledHarmonics() {
      if (!this._harmonics.preScaled) {
        this._harmonics.preScaleForRendering();
      }
      return this._harmonics;
    }
    x = new Vector3();
    y = new Vector3();
    z = new Vector3();
    xx = new Vector3();
    yy = new Vector3();
    zz = new Vector3();
    xy = new Vector3();
    yz = new Vector3();
    zx = new Vector3();
    scale(scale) {
      this.x.scale(scale);
      this.y.scale(scale);
      this.z.scale(scale);
      this.xx.scale(scale);
      this.yy.scale(scale);
      this.zz.scale(scale);
      this.yz.scale(scale);
      this.zx.scale(scale);
      this.xy.scale(scale);
    }
    static FromHarmonics(harmonics) {
      const result = new _SphericalPolynomial();
      result._harmonics = harmonics;
      result.x = harmonics.l11.scale2(1.02333).scale2(-1);
      result.y = harmonics.l1_1.scale2(1.02333).scale2(-1);
      result.z = harmonics.l10.scale2(1.02333);
      result.xx = harmonics.l00.scale2(0.886277).subtract2(harmonics.l20.scale2(0.247708)).add2(harmonics.l22.scale2(0.429043));
      result.yy = harmonics.l00.scale2(0.886277).subtract2(harmonics.l20.scale2(0.247708)).subtract2(harmonics.l22.scale2(0.429043));
      result.zz = harmonics.l00.scale2(0.886277).add2(harmonics.l20.scale2(0.495417));
      result.yz = harmonics.l2_1.scale2(0.858086).scale2(-1);
      result.zx = harmonics.l21.scale2(0.858086).scale2(-1);
      result.xy = harmonics.l2_2.scale2(0.858086);
      result.scale(1 / Math.PI);
      return result;
    }
  };

  // src/env.webgpu.ts
  var FULL_SIZE = 512;
  var RADIANCE_SIZE = 128;
  var IRRADIANCE_SIZE = 32;
  function loadHDR(device, { data, shape, usage = GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST }, mipLevelCount) {
    const img = new Float16Array(data.length);
    let k;
    let r;
    let g;
    let b;
    let a;
    let m;
    for (let j = 0; j <= shape[1]; j++) {
      for (let i = 0; i <= shape[0]; i++) {
        k = j * shape[0] + i;
        r = data[4 * k];
        g = data[4 * k + 1];
        b = data[4 * k + 2];
        a = data[4 * k + 3];
        m = (shape[1] - j + 1) * shape[0] + i;
        img[4 * m] = r;
        img[4 * m + 1] = g;
        img[4 * m + 2] = b;
        img[4 * m + 3] = a;
      }
    }
    const tex = device.createTexture({
      mipLevelCount,
      size: [shape[0], shape[1], 1],
      format: "rgba16float",
      // TODO 16 filtered vs 32 non-filtered
      usage
    });
    const bytesPerRow = shape[0] * 4 * 2;
    device.queue.writeTexture(
      { texture: tex },
      img,
      {
        // offset: 0,
        bytesPerRow
        // rowsPerImage: shape[1]
      },
      [shape[0], shape[1], 1]
    );
    return tex;
  }
  var Env = class {
    camera;
    envMatrix;
    VAO;
    quadVAO;
    IndexBufferLength;
    cubeprogram;
    irradianceprogram;
    mipmapcubeprogram;
    bdrfprogram;
    level;
    diffuse;
    MVPMatrix;
    framebuffer;
    irradiancebuffer;
    prefilterbuffer;
    views;
    prefilterrender;
    brdfbuffer;
    canvas;
    url;
    sampler;
    samplerCube;
    envData;
    uniformBuffer;
    originalCubeTexture;
    brdfLUTTexture;
    original2DTexture;
    irradiancemap;
    prefilterMap;
    Sheen_E;
    prefilterTexture;
    charlieTexture;
    irradianceTexture;
    bdrfTexture;
    cubeTexture;
    pipeline;
    pipeline2;
    pipeline3;
    constructor(url) {
      this.url = url;
      this.envMatrix = new Matrix4();
    }
    setCamera(camera) {
      this.camera = camera;
    }
    setCanvas(canvas) {
      this.canvas = canvas;
    }
    get width() {
      return this.canvas.offsetWidth * devicePixelRatio;
    }
    get height() {
      return this.canvas.offsetHeight * devicePixelRatio;
    }
    drawQuad(WebGPU2, x) {
      const m = new Matrix4();
      const cam = Object.assign({}, this.camera.props, {
        perspective: {
          yfov: 0.3,
          znear: 0.01,
          zfar: 1e4
        }
      });
      m.multiply(calculateProjection(cam));
      const vertex = `#version 460
        precision highp float;
        
        layout (location = 0) in vec2 inPosition;
        
        layout (location = 0) out vec2 outUV;

        //uniform mat4 projection;
        //uniform mat4 view;
        
        void main() {
            outUV = inPosition * 0.5 + 0.5;
            gl_Position = vec4(inPosition, 0.0, 1.0);
        }
        `;
      const fragment = `#version 460
        precision highp float;
        
        layout (location = 0) in vec2 outUV;
        layout (location = 0) out vec4 color;

        layout(set = 0, binding = 0) uniform sampler baseSampler;
        layout(set = 0, binding = 1) uniform texture2D environmentMap;
        
        void main() {
            vec3 c = textureLod(sampler2D(environmentMap, baseSampler), outUV, 2.0).rgb;
            
            color = vec4(c, 1.0);
        }
        `;
      const { device, context } = WebGPU2;
      let pass;
      {
        const depthTexture = device.createTexture({
          size: [this.width, this.height, 1],
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
          format: "depth32float"
        });
        const depthTextureView = depthTexture.createView();
        pass = {
          colorAttachments: [
            {
              view: context.getCurrentTexture().createView(),
              storeOp: "store",
              loadOp: "clear",
              clearValue: { r: 0, g: 0, b: 0, a: 1 }
            }
          ],
          depthStencilAttachment: {
            view: depthTextureView,
            depthLoadOp: "clear",
            depthClearValue: 1,
            depthStoreOp: "store"
          }
        };
      }
      const sampler = device.createSampler({
        magFilter: "linear",
        minFilter: "linear",
        mipmapFilter: "nearest",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      });
      const entries = [
        {
          binding: 0,
          resource: sampler
        },
        {
          binding: 1,
          resource: x.createView()
        }
      ];
      const commandEncoder = device.createCommandEncoder();
      const shadowPass = commandEncoder.beginRenderPass(pass);
      const p = this.buildPipeline(
        WebGPU2,
        vertex,
        fragment,
        2,
        [
          {
            binding: 0,
            visibility: GPUShaderStage.FRAGMENT,
            sampler: {
              type: "filtering"
            }
          },
          {
            binding: 1,
            visibility: GPUShaderStage.FRAGMENT,
            texture: {
              sampleType: "float"
            }
          }
        ],
        [
          {
            format: "bgra8unorm"
          }
        ]
      );
      shadowPass.setPipeline(p);
      shadowPass.setVertexBuffer(0, this.buildVertex(WebGPU2, quadFull));
      shadowPass.setBindGroup(
        0,
        device.createBindGroup({
          layout: p.getBindGroupLayout(0),
          entries
        })
      );
      shadowPass.draw(6);
      shadowPass.end();
      device.queue.submit([commandEncoder.finish()]);
    }
    drawCube(WebGPU2, shadowPass) {
      const { device } = WebGPU2;
      const m = new Matrix4();
      const cam = Object.assign({}, this.camera.props, {
        perspective: {
          yfov: 0.3,
          znear: 0.01,
          zfar: 1e4
        }
      });
      m.multiply(calculateProjection(cam));
      const uniformBuffer = new UniformBuffer();
      const s = this.camera.modelSize * 2;
      uniformBuffer.add("model", new Matrix4().makeRotationAxis(new Vector3([1, 0, 0]), Math.PI).scale(new Vector3([s, s, s])).elements);
      uniformBuffer.add("view", this.camera.matrixWorldInvert.elements);
      uniformBuffer.add("projection", m.elements);
      uniformBuffer.done();
      const matrixSize = uniformBuffer.store.byteLength;
      const offset = 256;
      const uniformBufferSize = offset + matrixSize;
      const u = device.createBuffer({
        size: uniformBufferSize,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });
      device.queue.writeBuffer(u, 0, uniformBuffer.store.buffer, uniformBuffer.store.byteOffset, uniformBuffer.store.byteLength);
      const vertex = `#version 460
        precision highp float;
        
        layout (location = 0) in vec3 inPosition;
        
        layout (location = 0) out vec3 outUV;

        layout(set = 0, binding = 0) uniform Uniforms {
            mat4 model;
            mat4 view;
            mat4 projection;
        };
        
        void main() {
            outUV = inPosition;
            gl_Position = projection * view * model * vec4(inPosition, 1.0);
        }
        `;
      const fragment = `#version 460
        precision highp float;
        
        layout (location = 0) in vec3 outUV;
        layout (location = 0) out vec4 color;

        layout(set = 0, binding = 1) uniform sampler baseSampler;
        layout(set = 0, binding = 2) uniform textureCube environmentMap;
        
        void main() {
            vec3 c = textureLod(samplerCube(environmentMap, baseSampler), outUV, 1.0).rgb;
            
            color = vec4(c, 1.0);
        }
        `;
      const sampler = device.createSampler({
        magFilter: "linear",
        minFilter: "linear",
        mipmapFilter: "nearest",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      });
      const entries = [
        {
          binding: 0,
          resource: u
        },
        {
          binding: 1,
          resource: sampler
        },
        {
          binding: 2,
          resource: this.cubeTexture.createView({
            dimension: "cube"
          })
        }
      ];
      const p = this.buildPipeline(
        WebGPU2,
        vertex,
        fragment,
        3,
        [
          {
            binding: 0,
            visibility: GPUShaderStage.VERTEX,
            buffer: {}
          },
          {
            binding: 1,
            visibility: GPUShaderStage.FRAGMENT,
            sampler: {
              type: "filtering"
            }
          },
          {
            binding: 2,
            visibility: GPUShaderStage.FRAGMENT,
            texture: {
              viewDimension: "cube",
              sampleType: "float"
            }
          }
        ],
        [{ format: "bgra8unorm" }]
      );
      shadowPass.setPipeline(p);
      shadowPass.setVertexBuffer(0, this.buildVertex(WebGPU2, cubeVertex));
      shadowPass.setBindGroup(
        0,
        device.createBindGroup({
          layout: p.getBindGroupLayout(0),
          entries
        })
      );
      shadowPass.draw(36);
    }
    async createEnvironmentBuffer(envData, WebGPU2) {
      this.envData = envData;
      if (envData) {
        const matrix = new Matrix4();
        matrix.makeRotationFromQuaternion(new Vector4(envData.rotation).elements);
        const sphericalHarmonics = SphericalHarmonics.FromArray(envData.irradianceCoefficients);
        sphericalHarmonics.scaleInPlace(envData.intensity);
        sphericalHarmonics.convertIrradianceToLambertianRadiance();
        const sphericalPolynomial = SphericalPolynomial.FromHarmonics(sphericalHarmonics);
        const { preScaledHarmonics } = sphericalPolynomial;
        const uniformBuffer = new UniformBuffer();
        uniformBuffer.add("vSphericalL00", preScaledHarmonics.l00.elements);
        uniformBuffer.add("vSphericalL1_1", preScaledHarmonics.l1_1.elements);
        uniformBuffer.add("vSphericalL10", preScaledHarmonics.l10.elements);
        uniformBuffer.add("vSphericalL11", preScaledHarmonics.l11.elements);
        uniformBuffer.add("vSphericalL2_2", preScaledHarmonics.l2_2.elements);
        uniformBuffer.add("vSphericalL2_1", preScaledHarmonics.l2_1.elements);
        uniformBuffer.add("vSphericalL20", preScaledHarmonics.l20.elements);
        uniformBuffer.add("vSphericalL21", preScaledHarmonics.l21.elements);
        uniformBuffer.add("vSphericalL22", preScaledHarmonics.l22.elements);
        uniformBuffer.add("rotationMatrix", matrix.elements);
        uniformBuffer.done();
        this.uniformBuffer = uniformBuffer;
        const buffer = WebGPU2.device.createBuffer({
          size: 256 + uniformBuffer.store.byteLength,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });
        uniformBuffer.bufferWebGPU = buffer;
        WebGPU2.device.queue.writeBuffer(
          buffer,
          0,
          uniformBuffer.store.buffer,
          uniformBuffer.store.byteOffset,
          uniformBuffer.store.byteLength
        );
        RADIANCE_SIZE = envData.specularImageSize;
      }
    }
    async createTexture(WebGPU2) {
      const views = [
        [new Vector3([0, 1, 0]), Math.PI / 2],
        // Right
        [new Vector3([0, 1, 0]), -Math.PI / 2],
        // Left
        [new Vector3([1, 0, 0]), Math.PI / 2],
        // Top
        [new Vector3([1, 0, 0]), -Math.PI / 2],
        // Bottom
        [new Vector3([0, 1, 0]), Math.PI],
        // Front
        [new Vector3([0, 1, 0]), 0]
        // Back
      ];
      this.views = views.map((view, i) => {
        const camMatrix = new Matrix4();
        camMatrix.makeRotationAxis(view[0], view[1]);
        if (i !== 2 && i !== 3) {
          const m = new Matrix4();
          m.makeRotationAxis(new Vector3([0, 0, 1]), Math.PI);
          camMatrix.multiply(m);
        }
        return new Matrix4().setInverseOf(camMatrix);
      });
      const { device } = WebGPU2;
      await fetch(this.url).then((res) => res.arrayBuffer()).then((buffer) => {
        const env = (0, import_parse_hdr.default)(buffer);
        const mipLevelCount = Math.floor(Math.log2(env.shape[0])) - 1;
        const tex = loadHDR(device, env, mipLevelCount);
        generateMipmaps(device, tex, env.shape[0], env.shape[1], mipLevelCount);
        this.originalCubeTexture = tex;
        return tex;
      });
      await fetch(Sheen_E_default).then((res) => res.arrayBuffer()).then((buffer) => {
        const tex = loadHDR(device, (0, import_parse_hdr.default)(buffer), 1);
        this.Sheen_E = tex;
        this.Sheen_E.view = tex.createView();
        return tex;
      });
    }
    buildPass(WebGPU2, size) {
      const { device } = WebGPU2;
      const depthTexture = device.createTexture({
        size: [size, size, 1],
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
        format: "depth32float"
      });
      const depthTextureView = depthTexture.createView();
      const colorTexture = device.createTexture({
        size: [size, size, 1],
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC,
        format: "rgba16float"
      });
      const colorTextureView = colorTexture.createView();
      return [
        {
          colorAttachments: [
            {
              view: colorTextureView,
              storeOp: "store",
              loadOp: "clear",
              clearValue: { r: 0, g: 0, b: 0, a: 1 }
            }
          ],
          depthStencilAttachment: {
            view: depthTextureView,
            depthLoadOp: "clear",
            depthClearValue: 1,
            depthStoreOp: "store"
          }
        },
        colorTexture
      ];
    }
    buildPipeline(WebGPU2, vertex, fragment, vertexId, entries, targets) {
      const { device, glslang, wgsl } = WebGPU2;
      function convertGLSLtoWGSL(code, type) {
        const spirv = glslang.compileGLSL(code, type);
        return wgsl.convertSpirV2WGSL(spirv);
      }
      const bindGroupLayout = device.createBindGroupLayout({
        entries
      });
      const pipelineLayout = device.createPipelineLayout({
        bindGroupLayouts: [bindGroupLayout]
      });
      const pipeline = device.createRenderPipeline({
        label: "env-pipeline",
        layout: pipelineLayout,
        vertex: {
          module: device.createShaderModule({
            code: convertGLSLtoWGSL(vertex, "vertex")
          }),
          entryPoint: "main",
          buffers: [
            {
              arrayStride: Float32Array.BYTES_PER_ELEMENT * vertexId,
              attributes: [
                {
                  // position
                  shaderLocation: 0,
                  offset: 0,
                  format: `float32x${vertexId}`
                }
              ]
            }
          ]
        },
        fragment: {
          module: device.createShaderModule({
            code: convertGLSLtoWGSL(fragment, "fragment")
          }),
          entryPoint: "main",
          targets
        },
        primitive: {
          topology: "triangle-list",
          cullMode: "none"
        },
        depthStencil: {
          depthWriteEnabled: false,
          depthCompare: "less",
          format: "depth32float"
        }
      });
      return pipeline;
    }
    buildVertex(WebGPU2, g) {
      const { device } = WebGPU2;
      const verticesBuffer = device.createBuffer({
        size: g.byteLength,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true
      });
      new Float32Array(verticesBuffer.getMappedRange()).set(g);
      verticesBuffer.unmap();
      return verticesBuffer;
    }
    drawBRDF(WebGPU2) {
      const { device } = WebGPU2;
      this.bdrfTexture = device.createTexture({
        label: "bdrfTexture",
        size: [FULL_SIZE, FULL_SIZE, 1],
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
        format: "rgba16float"
      });
      this.bdrfTexture.view = this.bdrfTexture.createView();
      const commandEncoder = device.createCommandEncoder();
      const [pass, colorTexture] = this.buildPass(WebGPU2, FULL_SIZE);
      const shadowPass = commandEncoder.beginRenderPass(pass);
      const p = this.buildPipeline(
        WebGPU2,
        quad_webgpu_default,
        bdrf_webgpu_default,
        2,
        [],
        [
          {
            format: "rgba16float"
          }
        ]
      );
      shadowPass.setPipeline(p);
      shadowPass.setVertexBuffer(0, this.buildVertex(WebGPU2, quadFull));
      shadowPass.setBindGroup(
        0,
        device.createBindGroup({
          layout: p.getBindGroupLayout(0),
          entries: []
        })
      );
      shadowPass.setViewport(0, 0, FULL_SIZE, FULL_SIZE, 0, 1);
      shadowPass.draw(6);
      shadowPass.end();
      commandEncoder.copyTextureToTexture({ texture: colorTexture }, { texture: this.bdrfTexture }, [FULL_SIZE, FULL_SIZE, 1]);
      device.queue.submit([commandEncoder.finish()]);
    }
    drawWebGPU(WebGPU2, mipWidth, mipHeight, layer, mip) {
      const { device } = WebGPU2;
      const m = new Matrix4();
      const cam = Object.assign({}, this.camera.props, {
        aspect: 1,
        perspective: {
          yfov: Math.PI / 2,
          znear: 0.01,
          zfar: 1e4
        }
      });
      m.multiply(calculateProjection(cam));
      const roughness = mip / 4;
      const uniformBuffer = new UniformBuffer();
      uniformBuffer.add("index", new Float32Array([layer, roughness, 0, 0]));
      uniformBuffer.add("projection", m.elements);
      uniformBuffer.add("view0", this.views[0].elements);
      uniformBuffer.add("view1", this.views[1].elements);
      uniformBuffer.add("view2", this.views[2].elements);
      uniformBuffer.add("view3", this.views[3].elements);
      uniformBuffer.add("view4", this.views[4].elements);
      uniformBuffer.add("view5", this.views[5].elements);
      uniformBuffer.done();
      const matrixSize = uniformBuffer.store.byteLength;
      const offset = 256;
      const uniformBufferSize = offset + matrixSize;
      const u = device.createBuffer({
        size: uniformBufferSize,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });
      device.queue.writeBuffer(u, 0, uniformBuffer.store.buffer, uniformBuffer.store.byteOffset, uniformBuffer.store.byteLength);
      const sampler = device.createSampler({
        magFilter: "linear",
        minFilter: "linear",
        mipmapFilter: "linear",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      });
      const entries = [
        {
          binding: 0,
          resource: u
        },
        {
          binding: 1,
          resource: sampler
        },
        {
          binding: 2,
          resource: this.originalCubeTexture.createView()
        }
      ];
      const entriesL = [
        {
          binding: 0,
          visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
          buffer: {}
        },
        {
          binding: 1,
          visibility: GPUShaderStage.FRAGMENT,
          sampler: {
            type: "filtering"
          }
        },
        {
          binding: 2,
          visibility: GPUShaderStage.FRAGMENT,
          texture: {
            sampleType: "float"
          }
        }
      ];
      const commandEncoder = device.createCommandEncoder();
      const [pass, colorTexture] = this.buildPass(WebGPU2, FULL_SIZE);
      const shadowPass = commandEncoder.beginRenderPass(pass);
      const p = this.pipeline || this.buildPipeline(WebGPU2, env_webgpu_default, cube_webgpu_default, 3, entriesL, [
        {
          format: "rgba16float"
        }
      ]);
      this.pipeline = p;
      shadowPass.setPipeline(p);
      shadowPass.setVertexBuffer(0, this.buildVertex(WebGPU2, cubeVertex));
      shadowPass.setBindGroup(
        0,
        device.createBindGroup({
          layout: p.getBindGroupLayout(0),
          entries
        })
      );
      shadowPass.setViewport(0, 0, mipWidth, mipHeight, 0, 1);
      shadowPass.draw(36);
      shadowPass.end();
      commandEncoder.copyTextureToTexture({ texture: colorTexture }, { texture: this.cubeTexture, mipLevel: mip, origin: { z: layer } }, [
        mipWidth,
        mipHeight,
        1
      ]);
      device.queue.submit([commandEncoder.finish()]);
    }
    drawWebGPU2(WebGPU2, mipWidth, mipHeight, layer, mip) {
      const { device } = WebGPU2;
      const m = new Matrix4();
      const cam = Object.assign({}, this.camera.props, {
        aspect: 1,
        perspective: {
          yfov: Math.PI / 2,
          znear: 0.01,
          zfar: 1e4
        }
      });
      m.multiply(calculateProjection(cam));
      const uniformBuffer = new UniformBuffer();
      uniformBuffer.add("index", new Float32Array([layer, 0, 0, 0]));
      uniformBuffer.add("projection", m.elements);
      uniformBuffer.add("view0", this.views[0].elements);
      uniformBuffer.add("view1", this.views[1].elements);
      uniformBuffer.add("view2", this.views[2].elements);
      uniformBuffer.add("view3", this.views[3].elements);
      uniformBuffer.add("view4", this.views[4].elements);
      uniformBuffer.add("view5", this.views[5].elements);
      uniformBuffer.done();
      const matrixSize = uniformBuffer.store.byteLength;
      const offset = 256;
      const uniformBufferSize = offset + matrixSize;
      const u = device.createBuffer({
        size: uniformBufferSize,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });
      device.queue.writeBuffer(u, 0, uniformBuffer.store.buffer, uniformBuffer.store.byteOffset, uniformBuffer.store.byteLength);
      const sampler = device.createSampler({
        magFilter: "linear",
        minFilter: "linear",
        mipmapFilter: "linear",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      });
      const entries = [
        {
          binding: 0,
          resource: u
        },
        {
          binding: 1,
          resource: sampler
        },
        {
          binding: 2,
          resource: this.cubeTexture.createView({
            dimension: "cube"
          })
        }
      ];
      const entriesL = [
        {
          binding: 0,
          visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
          buffer: {}
        },
        {
          binding: 1,
          visibility: GPUShaderStage.FRAGMENT,
          sampler: {
            type: "filtering"
          }
        },
        {
          binding: 2,
          visibility: GPUShaderStage.FRAGMENT,
          texture: {
            viewDimension: "cube",
            sampleType: "float"
          }
        }
      ];
      const commandEncoder = device.createCommandEncoder();
      const [pass, colorTexture] = this.buildPass(WebGPU2, IRRADIANCE_SIZE);
      const shadowPass = commandEncoder.beginRenderPass(pass);
      const p = this.pipeline2 || this.buildPipeline(WebGPU2, env_webgpu_default, irradiance_webgpu_default, 3, entriesL, [
        {
          format: "rgba16float"
        }
      ]);
      this.pipeline2 = p;
      shadowPass.setPipeline(p);
      shadowPass.setVertexBuffer(0, this.buildVertex(WebGPU2, cubeVertex));
      shadowPass.setBindGroup(
        0,
        device.createBindGroup({
          layout: p.getBindGroupLayout(0),
          entries
        })
      );
      shadowPass.setViewport(0, 0, mipWidth, mipHeight, 0, 1);
      shadowPass.draw(36);
      shadowPass.end();
      commandEncoder.copyTextureToTexture(
        { texture: colorTexture },
        { texture: this.irradianceTexture, mipLevel: mip, origin: { z: layer } },
        [mipWidth, mipHeight, 1]
      );
      device.queue.submit([commandEncoder.finish()]);
    }
    drawWebGPU3(WebGPU2, mipWidth, mipHeight, layer, mip) {
      const { device } = WebGPU2;
      const m = new Matrix4();
      const cam = Object.assign({}, this.camera.props, {
        aspect: 1,
        perspective: {
          yfov: Math.PI / 2,
          znear: 0.01,
          zfar: 1e4
        }
      });
      m.multiply(calculateProjection(cam));
      const roughness = mip / 4;
      const uniformBuffer = new UniformBuffer();
      uniformBuffer.add("index", new Float32Array([layer, roughness, 0, 0]));
      uniformBuffer.add("projection", m.elements);
      uniformBuffer.add("view0", this.views[0].elements);
      uniformBuffer.add("view1", this.views[1].elements);
      uniformBuffer.add("view2", this.views[2].elements);
      uniformBuffer.add("view3", this.views[3].elements);
      uniformBuffer.add("view4", this.views[4].elements);
      uniformBuffer.add("view5", this.views[5].elements);
      uniformBuffer.done();
      const matrixSize = uniformBuffer.store.byteLength;
      const offset = 256;
      const uniformBufferSize = offset + matrixSize;
      const u = device.createBuffer({
        size: uniformBufferSize,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });
      device.queue.writeBuffer(u, 0, uniformBuffer.store.buffer, uniformBuffer.store.byteOffset, uniformBuffer.store.byteLength);
      const sampler = device.createSampler({
        magFilter: "linear",
        minFilter: "linear",
        mipmapFilter: "nearest",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      });
      const entries = [
        {
          binding: 0,
          resource: u
        },
        {
          binding: 1,
          resource: sampler
        },
        {
          binding: 2,
          resource: this.cubeTexture.createView({
            dimension: "cube"
          })
        }
      ];
      const entriesL = [
        {
          binding: 0,
          visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
          buffer: {}
        },
        {
          binding: 1,
          visibility: GPUShaderStage.FRAGMENT,
          sampler: {
            type: "filtering"
          }
        },
        {
          binding: 2,
          visibility: GPUShaderStage.FRAGMENT,
          texture: {
            viewDimension: "cube",
            sampleType: "float"
          }
        }
      ];
      const commandEncoder = device.createCommandEncoder();
      const [pass, colorTexture] = this.buildPass(WebGPU2, RADIANCE_SIZE);
      const colorTexture2 = device.createTexture({
        size: [RADIANCE_SIZE, RADIANCE_SIZE, 1],
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC,
        format: "rgba16float"
      });
      pass.colorAttachments.push({
        view: colorTexture2.createView(),
        storeOp: "store",
        loadOp: "clear",
        clearValue: { r: 0, g: 0, b: 0, a: 1 }
      });
      const shadowPass = commandEncoder.beginRenderPass(pass);
      const p = this.pipeline3 || this.buildPipeline(WebGPU2, env_webgpu_default, cube_mipmap_webgpu_default, 3, entriesL, [
        {
          format: "rgba16float"
        },
        { format: "rgba16float" }
      ]);
      this.pipeline3 = p;
      shadowPass.setPipeline(p);
      shadowPass.setVertexBuffer(0, this.buildVertex(WebGPU2, cubeVertex));
      shadowPass.setBindGroup(
        0,
        device.createBindGroup({
          layout: p.getBindGroupLayout(0),
          entries
        })
      );
      shadowPass.setViewport(0, 0, mipWidth, mipHeight, 0, 1);
      shadowPass.draw(36);
      shadowPass.end();
      if (this.envData) {
        let i = layer;
        if (layer === 2) {
          i = 3;
        }
        if (layer === 3) {
          i = 2;
        }
        if (!this.envData.specularImages[mip]) {
          return;
        }
        const data = this.envData.specularImages[mip][i];
        device.queue.copyExternalImageToTexture(
          { source: data.bitmap },
          { texture: this.prefilterTexture, mipLevel: mip, origin: { z: layer } },
          { width: mipWidth, height: mipHeight, depthOrArrayLayers: 1 }
        );
      } else {
        commandEncoder.copyTextureToTexture(
          { texture: colorTexture },
          { texture: this.prefilterTexture, mipLevel: mip, origin: { z: layer } },
          [mipWidth, mipHeight, 1]
        );
        commandEncoder.copyTextureToTexture(
          { texture: colorTexture2 },
          { texture: this.charlieTexture, mipLevel: mip, origin: { z: layer } },
          [mipWidth, mipHeight, 1]
        );
      }
      device.queue.submit([commandEncoder.finish()]);
    }
    drawMips(WebGPU2) {
      const { device } = WebGPU2;
      const mipLevelCount = 5;
      this.cubeTexture = device.createTexture({
        mipLevelCount,
        size: [FULL_SIZE, FULL_SIZE, 6],
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
        format: "rgba16float"
      });
      for (let mip = 0; mip < mipLevelCount; ++mip) {
        const mipWidth = FULL_SIZE * Math.pow(0.5, mip);
        const mipHeight = FULL_SIZE * Math.pow(0.5, mip);
        for (let i = 0; i < 6; i++) {
          this.drawWebGPU(WebGPU2, mipWidth, mipHeight, i, mip);
        }
      }
    }
    drawIrradiance(WebGPU2) {
      const { device } = WebGPU2;
      this.irradianceTexture = device.createTexture({
        label: "irradianceTexture",
        size: [IRRADIANCE_SIZE, IRRADIANCE_SIZE, 6],
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
        format: "rgba16float"
      });
      this.irradianceTexture.view = this.irradianceTexture.createView({
        dimension: "cube"
      });
      for (let i = 0; i < 6; i++) {
        this.drawWebGPU2(WebGPU2, IRRADIANCE_SIZE, IRRADIANCE_SIZE, i, 0);
      }
    }
    drawPrefilter(WebGPU2) {
      const { device } = WebGPU2;
      const mipLevelCount = Math.floor(Math.log2(RADIANCE_SIZE)) - 2;
      this.prefilterTexture = device.createTexture({
        label: "prefilterTexture",
        mipLevelCount,
        size: [RADIANCE_SIZE, RADIANCE_SIZE, 6],
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
        format: "rgba16float"
      });
      this.prefilterTexture.view = this.prefilterTexture.createView({
        dimension: "cube"
      });
      this.charlieTexture = device.createTexture({
        label: "charlieTexture",
        mipLevelCount,
        size: [RADIANCE_SIZE, RADIANCE_SIZE, 6],
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
        format: "rgba16float"
      });
      this.charlieTexture.view = this.charlieTexture.createView({
        dimension: "cube"
      });
      for (let mip = 0; mip < mipLevelCount; ++mip) {
        const mipWidth = RADIANCE_SIZE * Math.pow(0.5, mip);
        const mipHeight = RADIANCE_SIZE * Math.pow(0.5, mip);
        for (let i = 0; i < 6; i++) {
          this.drawWebGPU3(WebGPU2, mipWidth, mipHeight, i, mip);
        }
      }
    }
  };

  // src/fetch.ts
  function loadKTX(b) {
    const { ktxTexture, TranscodeTarget, transcoderConfig } = window.LIBKTX;
    const { astcSupported, dxtSupported, pvrtcSupported, etc1Supported, etc2Supported } = transcoderConfig;
    const ktxdata = new Uint8Array(b);
    if (!IsValid(ktxdata)) {
      throw new Error("Texture is not valid ktx 2.0 file");
    }
    const texture = new ktxTexture(ktxdata);
    if (texture.needsTranscoding) {
      let format;
      if (astcSupported) {
        format = TranscodeTarget.ASTC_4x4_RGBA;
      } else if (dxtSupported) {
        format = TranscodeTarget.BC1_OR_3;
      } else if (pvrtcSupported) {
        format = TranscodeTarget.PVRTC1_4_RGBA;
      } else if (etc1Supported || etc2Supported) {
        format = TranscodeTarget.ETC;
      } else {
        format = TranscodeTarget.RGBA4444;
      }
      const result = texture.transcodeBasis(format, 0);
      if (result !== window.LIBKTX.ErrorCode.SUCCESS) {
        throw new Error("Texture transcode failed. See console for details.");
      }
      return texture.glUpload().texture;
    }
  }
  function IsValid(data) {
    if (data.byteLength >= 12) {
      const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);
      if (identifier[0] === 171 && identifier[1] === 75 && identifier[2] === 84 && identifier[3] === 88 && identifier[4] === 32 && identifier[5] === 50 && identifier[6] === 48 && identifier[7] === 187 && identifier[8] === 13 && identifier[9] === 10 && identifier[10] === 26 && identifier[11] === 10) {
        return true;
      }
    }
    return false;
  }
  function fetchJSON(url) {
    return fetch(url).then((r) => r.json());
  }
  function fetchBinary(url) {
    return fetch(url).then((r) => r.arrayBuffer());
  }
  function fetchImage(isbitmap, s, { bufferView, mimeType, uri }, { url, name }, sampler) {
    if (typeof window !== "undefined") {
      return new Promise((resolve, reject) => {
        if (mimeType === "image/ktx2") {
          window.fetch(url).then((r) => r.arrayBuffer()).then((b) => {
            resolve({
              sampler,
              mimeType,
              name,
              image: loadKTX(b)
            });
          });
        } else {
          const image = new Image();
          image.onload = () => {
            if (isbitmap) {
              createImageBitmap(image).then((bitmap) => {
                resolve({
                  sampler,
                  name,
                  bitmap
                });
              });
            } else {
              resolve({
                sampler,
                name,
                image
              });
            }
          };
          image.onerror = () => {
            reject(new Error("Cant load texture"));
          };
          image.crossOrigin = "anonymous";
          if (bufferView !== void 0) {
            const view = s.json.bufferViews[bufferView];
            const buffer = new Uint8Array(s.arrayBuffer[view.buffer], view.byteOffset, view.byteLength);
            const blob = new Blob([buffer], { type: mimeType });
            image.src = URL.createObjectURL(blob);
          } else if (/base64/.test(uri)) {
            image.src = uri;
          } else {
            image.src = url;
          }
        }
      });
    } else {
      return fetch(url).then((r) => r.arrayBuffer()).then((b) => ({
        sampler,
        mimeType,
        name,
        image: b
      }));
    }
  }

  // src/decoder.ts
  var decoderModule;
  var DecoderModule = () => new Promise(async (resolve) => {
    const dracoDecoderType = {
      onModuleLoaded(module2) {
        decoderModule = module2;
        resolve(decoderModule);
      }
    };
    const m = await Promise.resolve().then(() => __toESM(require_draco3d(), 1));
    m.createDecoderModule(dracoDecoderType);
  });
  function decodeDracoData(rawBuffer, decoder, offset, length) {
    const buffer = new decoderModule.DecoderBuffer();
    buffer.Init(new Int8Array(rawBuffer, offset, length), rawBuffer.byteLength);
    const dracoGeometry = new decoderModule.Mesh();
    decoder.DecodeBufferToMesh(buffer, dracoGeometry);
    decoderModule.destroy(buffer);
    return dracoGeometry;
  }
  function getArray(type, length, decodedGeometry, attribute, decoder) {
    let arr;
    let dracoArr;
    switch (type) {
      case "BYTE":
        arr = new Int8Array(length);
        arr.type = "BYTE";
        dracoArr = new decoderModule.DracoInt8Array();
        if (decodedGeometry) {
          decoder.GetAttributeInt8ForAllPoints(decodedGeometry, attribute, dracoArr);
        }
        break;
      case "UNSIGNED_BYTE":
        arr = new Uint8Array(length);
        arr.type = "UNSIGNED_BYTE";
        dracoArr = new decoderModule.DracoUInt8Array();
        if (decodedGeometry) {
          decoder.GetAttributeUInt8ForAllPoints(decodedGeometry, attribute, dracoArr);
        }
        break;
      case "SHORT":
        arr = new Int16Array(length);
        arr.type = "SHORT";
        dracoArr = new decoderModule.DracoInt16Array();
        if (decodedGeometry) {
          decoder.GetAttributeInt16ForAllPoints(decodedGeometry, attribute, dracoArr);
        }
        break;
      case "UNSIGNED_SHORT":
        arr = new Uint16Array(length);
        arr.type = "UNSIGNED_SHORT";
        dracoArr = new decoderModule.DracoUInt16Array();
        if (decodedGeometry) {
          decoder.GetAttributeUInt16ForAllPoints(decodedGeometry, attribute, dracoArr);
        }
        break;
      case "UNSIGNED_INT":
        arr = new Uint32Array(length);
        arr.type = "UNSIGNED_INT";
        dracoArr = new decoderModule.DracoUInt32Array();
        if (decodedGeometry) {
          decoder.GetAttributeUInt32ForAllPoints(decodedGeometry, attribute, dracoArr);
        }
        break;
      case "FLOAT":
        arr = new Float32Array(length);
        arr.type = "FLOAT";
        dracoArr = new decoderModule.DracoFloat32Array();
        if (decodedGeometry) {
          decoder.GetAttributeFloatForAllPoints(decodedGeometry, attribute, dracoArr);
        }
        break;
    }
    return [dracoArr, arr];
  }

  // src/shaders/vertex.glsl
  var vertex_default = '#include "./vert.h"\r\n\r\nvoid main() {\r\n    #if defined(WEBGPU)\r\n    Transform tr = transforms.data[gl_InstanceIndex];\r\n    #else\r\n    Transform tr = fetchTransform(int(uMaterialID));\r\n    #endif\r\n    mat4 model = tr.model;\r\n\r\n    #ifdef JOINTNUMBER\r\n        mat4 skin = inWeight.x * joint[int(inJoint.x)];\r\n        skin += inWeight.y * joint[int(inJoint.y)];\r\n        skin += inWeight.z * joint[int(inJoint.z)];\r\n        skin += inWeight.w * joint[int(inJoint.w)];\r\n    #else\r\n        mat4 skin = mat4(1.0);\r\n    #endif\r\n\r\n    #ifdef COLOR\r\n    #ifdef COLOR_255\r\n        vColor = inColor / 255.0;\r\n    #else\r\n        vColor = inColor;\r\n    #endif\r\n    #endif\r\n    outUV0 = inUV;\r\n    #ifdef MULTIUV\r\n    outUV2 = inUV2;\r\n    #endif\r\n    #ifdef MULTIUV2\r\n    outUV3 = inUV3;\r\n    #endif\r\n    #ifdef TANGENT\r\n        vec3 normalW = normalize(vec3(model * vec4(inNormal.xyz, 0.0)));\r\n        vec3 tangentW = normalize(vec3(model * vec4(inTangent.xyz, 0.0)));\r\n        vec3 bitangentW = cross(normalW, tangentW) * inTangent.w;\r\n        #ifdef USERIGHTHANDEDSYSTEM\r\n        tangentW *= 1.0; // invertX\r\n        bitangentW *= -1.0; // invertY\r\n        #endif\r\n        outTBN = mat3(tangentW, bitangentW, normalW);\r\n    #else\r\n        outNormal = normalize(mat3(transpose(inverse(model))) * mat3(skin) * inNormal);\r\n    #endif\r\n    outPosition = vec3(model * skin * vec4(inPosition, 1.0));\r\n    outPositionView = projection * light * model * skin * vec4(inPosition, 1.0);\r\n    if (isShadow.x == 1.0) {\r\n        gl_Position = projection * light * model * skin * vec4(inPosition, 1.0);\r\n    } else {\r\n        gl_Position = projection * view * model * skin * vec4(inPosition, 1.0);\r\n    }\r\n\r\n    gl_PointSize = 1.0;\r\n    #if defined(WEBGPU)\r\n    id = gl_InstanceIndex;\r\n    #else\r\n    id = uMaterialID;\r\n    #endif\r\n}\r\n';

  // src/shaders/fragment.glsl
  var fragment_default = `#include "./frag.h"\r
\r
const float RECIPROCAL_PI = 0.31830988618;\r
const float PI = 3.141592653589793;\r
const float EPSILON = 1e-6;\r
const float ambientStrength = 0.1;\r
const float specularStrength = 2.5;\r
const float specularPower = 32.0;\r
const float gamma = 2.2;\r
\r
\r
vec2 getUV(int index) {\r
    #ifdef MULTIUV\r
    if (index == 2) {\r
        return outUV3;\r
    }\r
    if (index == 1) {\r
        return outUV2;\r
    }\r
    #endif\r
    if (index == 0) {\r
        return outUV0;\r
    }\r
}\r
#ifdef SHADOWMAP\r
float ShadowCalculation(vec4 fragPosLightSpace, float bias) {\r
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\r
    projCoords = projCoords * 0.5 + 0.5;\r
    float currentDepth = projCoords.z;\r
\r
    float shadow = 0.0;\r
    vec2 texelSize = 1.0 / vec2(textureSize(depthTexture, 0));\r
    for (int x = -2; x <= 2; ++x) {\r
        for (int y = -2; y <= 2; ++y) {\r
            float pcfDepth = texture2D(depthTexture, projCoords.xy + vec2(x, y) * texelSize).r;\r
            shadow += currentDepth - bias > pcfDepth ? 0.5 : 0.0;\r
        }\r
    }\r
    shadow /= 25.0;\r
\r
    return shadow;\r
}\r
#endif\r
\r
vec3 srgbToLinear(vec4 srgbIn) {\r
    #ifdef BASISU\r
    return srgbIn.rgb;\r
    #else\r
    return pow(srgbIn.rgb, vec3(2.2));\r
    #endif\r
}\r
\r
vec3 fresnelSchlick(float cosTheta, vec3 F0) {\r
    return F0 + (vec3(1.0) - F0) * pow(1.0 - cosTheta, 5.0);\r
}\r
float fresnelSchlick(float cosTheta, float F0) {\r
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r
}\r
vec3 Schlick_to_F0(vec3 f, vec3 f90, float VdotH) {\r
    float x = clamp(1.0 - VdotH, 0.0, 1.0);\r
    float x2 = x * x;\r
    float x5 = clamp(x * x2 * x2, 0.0, 0.9999);\r
\r
    return (f - f90 * x5) / (1.0 - x5);\r
}\r
vec3 Schlick_to_F0(vec3 f, float VdotH) {\r
    return Schlick_to_F0(f, vec3(1.0), VdotH);\r
}\r
float sq(float t) {\r
    return t * t;\r
}\r
vec3 sq(vec3 t) {\r
    return t * t;\r
}\r
// XYZ to sRGB color space\r
const mat3 XYZ_TO_REC709 = mat3(\r
     3.2404542, -0.9692660,  0.0556434,\r
    -1.5371385,  1.8760108, -0.2040259,\r
    -0.4985314,  0.0415560,  1.0572252\r
);\r
\r
float applyIorToRoughness(float roughness, float ior) {\r
    #if defined VOLUME\r
    // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\r
    // an IOR of 1.5 results in the default amount of microfacet refraction.\r
    return roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\r
    #else\r
    return roughness;\r
    #endif\r
}\r
\r
// Assume air interface for top\r
// Note: We don't handle the case fresnel0 == 1\r
vec3 Fresnel0ToIor(vec3 fresnel0) {\r
    vec3 sqrtF0 = sqrt(fresnel0);\r
    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\r
}\r
\r
// Conversion FO/IOR\r
vec3 IorToFresnel0(vec3 transmittedIor, float incidentIor) {\r
    return sq((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)));\r
}\r
\r
// ior is a value between 1.0 and 3.0. 1.0 is air interface\r
float IorToFresnel0(float transmittedIor, float incidentIor) {\r
    return sq((transmittedIor - incidentIor) / (transmittedIor + incidentIor));\r
}\r
\r
// Fresnel equations for dielectric/dielectric interfaces.\r
// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\r
// Evaluation XYZ sensitivity curves in Fourier space\r
vec3 evalSensitivity(float OPD, vec3 shift) {\r
    float phase = 2.0 * PI * OPD * 1.0e-9;\r
    vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\r
    vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\r
    vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\r
\r
    vec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-sq(phase) * var);\r
    xyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * sq(phase));\r
    xyz /= 1.0685e-7;\r
\r
    vec3 srgb = XYZ_TO_REC709 * xyz;\r
    return srgb;\r
}\r
\r
vec3 evalIridescence(float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0) {\r
    vec3 I;\r
\r
    // Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0\r
    float iridescenceIOR = mix(outsideIOR, eta2, smoothstep(0.0, 0.03, thinFilmThickness));\r
    // Evaluate the cosTheta on the base layer (Snell law)\r
    float sinTheta2Sq = sq(outsideIOR / iridescenceIOR) * (1.0 - sq(cosTheta1));\r
\r
    // Handle TIR:\r
    float cosTheta2Sq = 1.0 - sinTheta2Sq;\r
    if (cosTheta2Sq < 0.0) {\r
        return vec3(1.0);\r
    }\r
\r
    float cosTheta2 = sqrt(cosTheta2Sq);\r
\r
    // First interface\r
    float R0 = IorToFresnel0(iridescenceIOR, outsideIOR);\r
    float R12 = fresnelSchlick(cosTheta1, R0);\r
    float R21 = R12;\r
    float T121 = 1.0 - R12;\r
    float phi12 = 0.0;\r
    if (iridescenceIOR < outsideIOR) phi12 = PI;\r
    float phi21 = PI - phi12;\r
\r
    // Second interface\r
    vec3 baseIOR = Fresnel0ToIor(clamp(baseF0, 0.0, 0.9999)); // guard against 1.0\r
    vec3 R1 = IorToFresnel0(baseIOR, iridescenceIOR);\r
    vec3 R23 = fresnelSchlick(cosTheta2, R1);\r
    vec3 phi23 = vec3(0.0);\r
    if (baseIOR[0] < iridescenceIOR) phi23[0] = PI;\r
    if (baseIOR[1] < iridescenceIOR) phi23[1] = PI;\r
    if (baseIOR[2] < iridescenceIOR) phi23[2] = PI;\r
\r
    // Phase shift\r
    float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\r
    vec3 phi = vec3(phi21) + phi23;\r
\r
    // Compound terms\r
    vec3 R123 = clamp(R12 * R23, 1e-5, 0.9999);\r
    vec3 r123 = sqrt(R123);\r
    vec3 Rs = sq(T121) * R23 / (vec3(1.0) - R123);\r
\r
    // Reflectance term for m = 0 (DC term amplitude)\r
    vec3 C0 = R12 + Rs;\r
    I = C0;\r
\r
    // Reflectance term for m > 0 (pairs of diracs)\r
    vec3 Cm = Rs - T121;\r
    for (int m = 1; m <= 2; ++m)\r
    {\r
        Cm *= r123;\r
        vec3 Sm = 2.0 * evalSensitivity(float(m) * OPD, float(m) * phi);\r
        I += Cm * Sm;\r
    }\r
\r
    // Since out of gamut colors might be produced, negative color values are clamped to 0.\r
    return max(I, vec3(0.0));\r
}\r
#ifdef ANISOTROPY\r
float DistributionGGX(vec3 N, vec3 H, vec3 anisotropicT, vec3 anisotropicB, float at, float ab) {\r
    float NdotH = dot(N, H);\r
    float TdotH = dot(anisotropicT, H);\r
    float BdotH = dot(anisotropicB, H);\r
\r
    float a2 = at * ab;\r
    vec3 f = vec3(ab * TdotH, at * BdotH, a2 * NdotH);\r
    float w2 = a2 / dot(f, f);\r
    return a2 * w2 * w2 / PI;\r
}\r
\r
float GeometrySmith(vec3 N, vec3 V, vec3 L, vec3 anisotropicT, vec3 anisotropicB, float at, float ab) {\r
    float NdotV = dot(N, V);\r
    float NdotL = dot(N, L);\r
    float TdotV = dot(anisotropicT, V);\r
    float TdotL = dot(anisotropicT, L);\r
    float BdotV = dot(anisotropicB, V);\r
    float BdotL = dot(anisotropicB, L);\r
\r
    float GGXV = NdotL * length(vec3(at * TdotV, ab * BdotV, NdotV));\r
    float GGXL = NdotV * length(vec3(at * TdotL, ab * BdotL, NdotL));\r
    float v = 0.5 / (GGXV + GGXL);\r
    return clamp(v, 0.0, 1.0);\r
}\r
#else\r
float DistributionGGX(vec3 N, vec3 H, float roughness) {\r
    float NdotH = max(dot(N, H), 0.01);\r
    float a = max(roughness*roughness, 0.01);\r
    float alphaRoughnessSq = a * a;\r
    float f = (NdotH * NdotH) * (alphaRoughnessSq - 1.0) + 1.0;\r
    return alphaRoughnessSq / (PI * f * f);\r
}\r
\r
float GeometrySchlickGGX(float cosTheta, float roughness) {\r
    float r = (roughness + 1.0);\r
    float k = (r * r) / 8.0;\r
\r
    float nom   = cosTheta;\r
    float denom = cosTheta * (1.0 - k) + k;\r
\r
    return nom / denom;\r
}\r
\r
float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r
    float NdotV = max(dot(N, V), 0.0);\r
    float NdotL = max(dot(N, L), 0.0);\r
    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\r
    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\r
\r
    return ggx1 * ggx2;\r
}\r
#endif\r
\r
float fresnelSchlickRoughness(float cosTheta, float F0, float roughness) {\r
    return F0 + (max(1.0 - roughness, F0) - F0) * pow(1.0 - cosTheta, 5.0);\r
}\r
vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\r
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\r
}\r
vec3 calcTransmission(float dispersionFactor, float ior, vec3 color, vec3 N, float roughness, vec3 V, float transmission, float thickness) {\r
    float refraction_ior = 1.0 / ior;\r
    vec3 environmentRefraction = vec3(0.0);\r
    #ifdef DISPERSION\r
    float realIOR = 1.0 / ior;\r
    float iorDispersionSpread = 0.04 * dispersionFactor * (realIOR - 1.0);\r
    vec3 iors = vec3(realIOR - iorDispersionSpread, refraction_ior, realIOR + iorDispersionSpread);\r
    for (int i = 0; i < 3; i++) {\r
        refraction_ior = iors[i];\r
    #endif\r
\r
    vec4 refractS = projection * view * vec4(outPosition + refract(-V, N, refraction_ior) * thickness, 1.0);\r
    refractS.xy = refractS.xy / refractS.w;\r
    refractS.xy = refractS.xy * 0.5 + 0.5;\r
    const float MAX_REFLECTION_LOD = 7.0;\r
    #if defined(WEBGPU)\r
    refractS.y = 1.0 - refractS.y;\r
    #endif\r
    vec3 baseColor = textureLod2D2(colorTexture, refractS.xy, applyIorToRoughness(roughness, 1.0 / refraction_ior) * MAX_REFLECTION_LOD).xyz;\r
\r
    #ifdef DISPERSION\r
        environmentRefraction[i] = baseColor[i];\r
    }\r
    #else\r
        environmentRefraction = baseColor;\r
    #endif\r
\r
    return transmission * environmentRefraction * color;\r
}\r
\r
#ifdef SPHERICAL_HARMONICS\r
vec3 computeEnvironmentIrradiance(vec3 normal) {\r
    return vSphericalL00.xyz\r
        + vSphericalL1_1.xyz * (normal.y)\r
        + vSphericalL10.xyz * (normal.z)\r
        + vSphericalL11.xyz * (normal.x)\r
        + vSphericalL2_2.xyz * (normal.y * normal.x)\r
        + vSphericalL2_1.xyz * (normal.y * normal.z)\r
        + vSphericalL20.xyz * ((3.0 * normal.z * normal.z) - 1.0)\r
        + vSphericalL21.xyz * (normal.z * normal.x)\r
        + vSphericalL22.xyz * (normal.x * normal.x - (normal.y * normal.y));\r
}\r
#endif\r
float sheenDistribution(float sheenRoughness, vec3 N, vec3 H) {\r
    float NdotH = max(dot(N, H), 0.0);\r
    float alphaG = max(sheenRoughness * sheenRoughness, 0.01);\r
    float invR = 1.0 / alphaG;\r
    float cos2h = NdotH * NdotH;\r
    float sin2h = 1.0 - cos2h;\r
    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\r
}\r
float lambdaSheenNumericHelper(float x, float alphaG) {\r
    float oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);\r
    float a = mix(21.5473, 25.3245, oneMinusAlphaSq);\r
    float b = mix(3.82987, 3.32435, oneMinusAlphaSq);\r
    float c = mix(0.19823, 0.16801, oneMinusAlphaSq);\r
    float d = mix(-1.97760, -1.27393, oneMinusAlphaSq);\r
    float e = mix(-4.32054, -4.85967, oneMinusAlphaSq);\r
    return a / (1.0 + b * pow(x, c)) + d * x + e;\r
}\r
float lambdaSheen(float cosTheta, float alphaG) {\r
    if (abs(cosTheta) < 0.5) {\r
        return exp(lambdaSheenNumericHelper(cosTheta, alphaG));\r
    } else {\r
        return exp(2.0 * lambdaSheenNumericHelper(0.5, alphaG) - lambdaSheenNumericHelper(1.0 - cosTheta, alphaG));\r
    }\r
}\r
float sheenVisibility(vec3 N, vec3 V, vec3 L, float sheenRoughness) {\r
    float NdotL = max(dot(N, L), 0.0);\r
    float NdotV = max(dot(N, V), 0.0);\r
\r
    sheenRoughness = max(sheenRoughness, 0.000001); //clamp (0,1]\r
    float alphaG = sheenRoughness * sheenRoughness;\r
\r
    return clamp(1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) *\r
        (4.0 * NdotV * NdotL)), 0.0, 1.0);\r
}\r
float E(float x, float y) {\r
    return clamp(texture2D(Sheen_E, vec2(x,y)).r, 0.0, 1.0);\r
}\r
float max3(vec3 v) { return max(max(v.x, v.y), v.z); }\r
float pow2(float v) { return v * v; }\r
vec3 IBLAmbient(vec3 baseColor, float metallic, vec3 n, float roughness, vec3 viewDir, float transmission, vec3 sheenColor, float sheenRoughness, vec3 iridescenceFresnel, float iridescenceFactor, vec3 F0, float specularWeight, float anisotropy, vec3 anisotropicB, inout vec3 f_sheen, out vec3 specular) {\r
    #ifdef ANISOTROPY\r
    vec3 Normal = cross(anisotropicB, viewDir);\r
    Normal = normalize(cross(Normal, anisotropicB));\r
    float a = pow2(pow2(1.0 - anisotropy * (1.0 - roughness)));\r
    n = normalize(mix(Normal, n, a));\r
    #endif\r
    \r
    vec3 F = fresnelSchlickRoughness(max(dot(n, viewDir), 0.0), F0, roughness);\r
\r
    vec3 kD = vec3(1.0) - F * specularWeight;\r
    #if defined SPECULARGLOSSINESSMAP\r
    #else\r
        kD *= 1.0 - clamp(metallic, 0.0, 0.9);\r
    #endif\r
    #if defined IRIDESCENCE\r
    kD = vec3(1.0) - mix(F, iridescenceFresnel, iridescenceFactor) * specularWeight;\r
    kD *= 1.0 - clamp(metallic, 0.0, 0.9);\r
    #endif\r
\r
    vec3 R;\r
    #ifdef SPHERICAL_HARMONICS\r
    R = reflect(viewDir, n);\r
    vec4 rotatedR = rotationMatrix * vec4(R.x * -1.0, R.y, R.z, 0.0);\r
    R = rotatedR.xyz;\r
    vec4 prefilterColor = textureLodCube(prefilterMap, R, roughness * float(SPHERICAL_HARMONICS));\r
    vec3 prefilteredColor = srgbToLinear(vec4(prefilterColor.rgb, 0.0)) / pow(prefilterColor.a, 2.2);\r
    vec3 irradianceVector = vec3(rotationMatrix * vec4(n.x, n.y, n.z * -1.0, 0)).xyz;\r
    vec3 irradiance = computeEnvironmentIrradiance(irradianceVector).rgb;\r
    #else\r
    const float MAX_REFLECTION_LOD = 4.0;\r
    R = reflect(-viewDir, n);\r
    vec3 prefilteredColor = textureLodCube(prefilterMap, R, roughness * MAX_REFLECTION_LOD).rgb;\r
    vec3 irradiance = textureCube(irradianceMap, n).rgb;\r
    #endif\r
    vec2 envBRDF  = textureLod2D(brdfLUT, vec2(max(dot(n, viewDir), 0.0), roughness), 0.0).rg;\r
    vec3 kS = F;\r
    #if defined IRIDESCENCE\r
    kS = mix(F, iridescenceFresnel, iridescenceFactor);\r
    #endif\r
    specular = prefilteredColor * (kS * specularWeight * envBRDF.x + envBRDF.y);\r
\r
    #if defined SHEEN\r
    float charliebrdf = textureLod2D(brdfLUT, vec2(max(dot(n, viewDir), 0.0), sheenRoughness), 0.0).b;\r
    vec3 sheenSample = textureLodCube(charlieMap, R, sheenRoughness * MAX_REFLECTION_LOD).rgb;\r
    f_sheen += sheenSample * sheenColor * charliebrdf;\r
    #endif\r
\r
    return (1.0 - transmission) * kD * irradiance * baseColor;\r
}\r
\r
float specEnv(vec3 N, vec3 V, float metallic, float roughness, vec3 F0, float specularWeight) {\r
    float F = fresnelSchlickRoughness(max(dot(N, V), 0.0), (F0.x+F0.y+F0.z)/3.0, roughness);\r
    vec2 envBRDF  = textureLod2D(brdfLUT, vec2(max(dot(N, V), 0.0), roughness), 0.0).rg;\r
    return (F * specularWeight * envBRDF.x + envBRDF.y);\r
}\r
\r
#ifdef ANISOTROPY\r
vec3 CookTorranceSpecular2(vec3 baseColor, float metallic, vec3 n, vec3 H, vec3 anisotropicT, vec3 anisotropicB, float roughness, vec3 viewDir, vec3 lightDir, float anisotropy, vec3 iridescenceFresnel, float iridescenceFactor, vec3 F0, float specularWeight) {\r
    roughness = roughness * roughness;\r
    float at = max(mix(roughness, 1.0, anisotropy * anisotropy), 0.001);\r
    float ab = max(roughness, 0.001);\r
    float D = DistributionGGX(n, H, anisotropicT, anisotropicB, at, ab);\r
    float G = GeometrySmith(n, viewDir, lightDir, anisotropicT, anisotropicB, at, ab);\r
    vec3 F = mix(fresnelSchlick(max(dot(viewDir, H), 0.0), F0), iridescenceFresnel, iridescenceFactor);\r
\r
    vec3 nominator = D * G * F * specularWeight;\r
    float denominator = 4.0 * max(dot(n, viewDir), 0.0) * max(dot(n, lightDir), 0.0);\r
    return D * G * F;\r
}\r
vec3 CookTorranceSpecular(vec3 baseColor, float metallic, vec3 n, vec3 H, vec3 anisotropicT, vec3 anisotropicB, float roughness, vec3 viewDir, vec3 lightDir, float anisotropy, vec3 F0, float specularWeight) {\r
    roughness = roughness * roughness;\r
    float at = max(mix(roughness, 1.0, anisotropy * anisotropy), 0.001);\r
    float ab = max(roughness, 0.001);\r
    float D = DistributionGGX(n, H, anisotropicT, anisotropicB, at, ab);\r
    float G = GeometrySmith(n, viewDir, lightDir, anisotropicT, anisotropicB, at, ab);\r
    vec3 F = fresnelSchlick(max(dot(viewDir, H), 0.0), F0); \r
\r
    vec3 nominator = D * G * F * specularWeight;\r
    float denominator = 4.0 * max(dot(n, viewDir), 0.0) * max(dot(n, lightDir), 0.0);\r
    return D * G * F;\r
}\r
#else\r
vec3 CookTorranceSpecular2(vec3 baseColor, float metallic, vec3 n, vec3 H, vec3 anisotropicT, vec3 anisotropicB, float roughness, vec3 viewDir, vec3 lightDir, float anisotropy, vec3 iridescenceFresnel, float iridescenceFactor, vec3 F0, float specularWeight) {\r
    float D = DistributionGGX(n, H, roughness);\r
    float G = GeometrySmith(n, viewDir, lightDir, roughness);\r
    vec3 F = mix(fresnelSchlick(max(dot(viewDir, H), 0.0), F0), iridescenceFresnel, iridescenceFactor);\r
\r
    vec3 nominator = D * G * F * specularWeight;\r
    float denominator = 4.0 * max(dot(n, viewDir), 0.0) * max(dot(n, lightDir), 0.0);\r
    return nominator / max(denominator, 0.001);\r
}\r
vec3 CookTorranceSpecular(vec3 baseColor, float metallic, vec3 n, vec3 H, vec3 anisotropicT, vec3 anisotropicB, float roughness, vec3 viewDir, vec3 lightDir, float anisotropy, vec3 F0, float specularWeight) {\r
    float D = DistributionGGX(n, H, roughness);\r
    float G = GeometrySmith(n, viewDir, lightDir, roughness);\r
    vec3 F = fresnelSchlick(max(dot(viewDir, H), 0.0), F0); \r
\r
    vec3 nominator = D * G * F * specularWeight;\r
    float denominator = 4.0 * max(dot(n, viewDir), 0.0) * max(dot(n, lightDir), 0.0);\r
    return nominator / max(denominator, 0.001);\r
}\r
#endif\r
\r
vec3 LambertDiffuse(vec3 baseColor, float metallic, vec3 n, vec3 H, float roughness, vec3 viewDir, vec3 lightDir, vec3 F0, float specularWeight) {\r
    float NdotL = max(dot(n, lightDir), 0.0);\r
\r
    vec3 F = fresnelSchlick(max(dot(H, viewDir), 0.0), F0);    \r
\r
    vec3 kD = vec3(1.0) - F * specularWeight;\r
    #if defined SPECULARGLOSSINESSMAP\r
    #else\r
        kD *= 1.0 - metallic;\r
    #endif\r
    return baseColor * kD / PI;\r
}\r
\r
float saturate(float a) {\r
	if (a > 1.0) return 1.0;\r
	if (a < 0.0) return 0.0;\r
	return a;\r
}\r
vec3 ImprovedOrenNayarDiffuse(vec3 baseColor, float metallic, vec3 N, vec3 H, float a, vec3 V, vec3 L, vec3 F0, vec3 iridescenceFresnel, float iridescenceFactor, float specularWeight) {\r
    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);\r
    vec3 kD = vec3(1.0) - F * specularWeight;\r
    #if defined SPECULARGLOSSINESSMAP\r
    #else\r
        kD *= 1.0 - metallic;\r
    #endif\r
    #if defined IRIDESCENCE\r
    kD = vec3(1.0) - mix(F, iridescenceFresnel, iridescenceFactor) * specularWeight;\r
    kD *= 1.0 - clamp(metallic, 0.0, 0.9);\r
    #endif\r
    vec3 diffuseColor = baseColor * kD;\r
	// calculate intermediary values\r
	float dotNL = saturate(dot(N, L));\r
	float dotNV = saturate(dot(N, V));\r
	float dotLV = saturate(dot(L, V));\r
	float dotLH = saturate(dot(L, H));\r
\r
	float s = dotLV - dotNL * dotNV;\r
	float t = mix(1.0, max(max(dotNL, dotNV), 0.001), step(0.0, s));\r
	float st = s * (1.0 / (t + EPSILON));\r
\r
	float sigma2 = a;\r
	vec3 A = diffuseColor * (0.17 * sigma2 / (sigma2 + 0.13)) + vec3(1.0 - 0.5 * sigma2 / (sigma2 + 0.33));\r
	float B = 0.45 * sigma2 / (sigma2 + 0.09);\r
	return (diffuseColor * max(0.0, dotNL)) * (A + vec3(B * s / t) / PI) / PI;\r
}\r
\r
vec2 applyTransform(vec2 uv, mat4 textureMatrix) {\r
    mat3 translation = mat3(1, 0, 0, 0, 1, 0, textureMatrix[0].x, textureMatrix[0].y, 1);\r
    mat3 rotation = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\r
    if (textureMatrix[2].x != 0.0) {\r
        rotation = mat3(\r
            cos(-textureMatrix[2].x), sin(-textureMatrix[2].x), 0,\r
            -sin(-textureMatrix[2].x), cos(-textureMatrix[2].x), 0,\r
            0, 0, 1\r
        );\r
    }\r
    mat3 scale = mat3(textureMatrix[1].x, 0, 0, 0, textureMatrix[1].y, 0, 0, 0, 1);\r
\r
    mat3 matrix = translation * rotation * scale;\r
    vec2 outUV = ( matrix * vec3(uv, 1.0) ).xy;\r
    return outUV;\r
}\r
float computeWrappedDiffuseNdotL(float NdotL, float w) {\r
    float t = 1.0+w;\r
    float invt2 = 1.0/(t*t);\r
    return saturate((NdotL+w)*invt2);\r
}\r
float pow5(float value) {\r
    float sq = value*value;\r
    return sq*sq*value;\r
}\r
float diffuseBRDF_Burley(float NdotL, float NdotV, float VdotH, float roughness) {\r
    float diffuseFresnelNV = pow5(saturate(1.0-NdotL)+EPSILON);\r
    float diffuseFresnelNL = pow5(saturate(1.0-NdotV)+EPSILON);\r
    float diffuseFresnel90 = 0.5+2.0*VdotH*VdotH*roughness;\r
    float fresnel = (1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *\r
    (1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);\r
    return fresnel/PI;\r
}\r
#define absEps(x) abs(x)+EPSILON\r
\r
vec3 cocaLambert(vec3 alpha, float distance) {\r
    return exp(-alpha*distance);\r
}\r
#define maxEps(x) max(x, EPSILON)\r
vec3 transmittanceBRDF_Burley(const vec3 tintColor, const vec3 diffusionDistance, float thickness) {\r
    vec3 S = 1./maxEps(diffusionDistance);\r
    vec3 temp = exp((-0.333333333*thickness)*S);\r
    return tintColor.rgb*0.25*(temp*temp*temp+3.0*temp);\r
}\r
\r
vec3 computeColorAtDistanceInMedia(vec3 color, float distance) {\r
    return -log(color)/distance;\r
}\r
\r
void main() {\r
    mat4 inverseViewMatrix = inverse(view);\r
    vec3 viewPos = inverseViewMatrix[3].xyz;\r
\r
    #if defined(WEBGPU)\r
    Material mat = materials.data[int(id)];\r
    #else\r
    Material mat = fetchMaterial(int(id));\r
    #endif\r
    vec4 baseColorFactor = mat.baseColorFactor;\r
    vec3 specularFactor = mat.specularFactor;\r
    vec3 specularColorFactor = mat.specularColorFactor;\r
    vec3 emissiveFactor = mat.emissiveFactor;\r
    vec4 glossinessFactor = mat.glossinessFactor;\r
    vec4 metallicFactor = mat.metallicFactor;\r
    vec4 roughnessFactor = mat.roughnessFactor;\r
    vec4 clearcoatFactor = mat.clearcoatFactor;\r
    vec4 clearcoatRoughnessFactor = mat.clearcoatRoughnessFactor;;\r
    vec4 sheenColorFactor = mat.sheenColorFactor;\r
    vec4 sheenRoughnessFactor = mat.sheenRoughnessFactor;\r
    vec4 transmissionFactor = mat.transmissionFactor;\r
    vec4 ior = mat.ior;\r
    vec4 normalTextureScale = mat.normalTextureScale;;\r
    vec4 attenuationColorFactor = mat.attenuationColorFactor; \r
    vec4 attenuationDistance = mat.attenuationDistance;\r
    vec4 thicknessFactor = mat.thicknessFactor;\r
    vec4 emissiveStrength = mat.emissiveStrength;\r
    vec4 anisotropyFactor = mat.anisotropyFactor;\r
    vec4 iridescence = mat.iridescence;\r
    vec4 diffuseTransmissionFactor = mat.diffuseTransmissionFactor;\r
    vec4 dispersionFactor = mat.dispersionFactor;\r
\r
    vec2 outUV = outUV0;\r
    #ifdef BASECOLORTEXTURE\r
        outUV = getUV(BASECOLORTEXTURE);\r
        #ifdef BASECOLORTEXTURE_TEXTURE_TRANSFORM\r
            outUV = applyTransform(outUV, textureMatrices[BASECOLORTEXTURE_TEXTURE_TRANSFORM]);\r
        #endif\r
        vec3 baseColor = texture2D(baseColorTexture, outUV).rgb * baseColorFactor.rgb;\r
        float alpha = min(texture2D(baseColorTexture, outUV).a, baseColorFactor.a);\r
    #else\r
        vec3 baseColor = baseColorFactor.rgb;\r
        float alpha = baseColorFactor.a;\r
    #endif\r
\r
    #ifdef ALPHATEST\r
    if ( alpha < ALPHATEST ) {\r
        discard;\r
    }\r
    if ( ALPHATEST > 0.01 ) {\r
        alpha = 1.0;\r
    }\r
    #else\r
        alpha = 1.0;\r
    #endif\r
\r
    if ( length(vColor.rgb) != 0.0 ) {\r
        baseColor.rgb *= vColor.rgb;\r
    }\r
\r
    #ifdef NOLIGHT\r
        color = vec4(baseColor, alpha);\r
        return;\r
    #endif\r
\r
    float ao = 1.0;\r
    #ifdef OCCLUSIONMAP\r
        outUV = getUV(OCCLUSIONMAP);\r
        #ifdef OCCLUSIONMAP_TEXTURE_TRANSFORM\r
            outUV = applyTransform(outUV, textureMatrices[OCCLUSIONMAP_TEXTURE_TRANSFORM]);\r
        #endif\r
        ao = texture2D(occlusionTexture, outUV).r;\r
    #endif\r
\r
    float roughness = roughnessFactor.x;\r
    float metallic = metallicFactor.x;\r
    float clearcoatRoughness = clearcoatRoughnessFactor.x;\r
    float clearcoat = clearcoatFactor.x;\r
    float clearcoatBlendFactor = clearcoat;\r
    vec3 sheenColor = sheenColorFactor.xyz;\r
    float sheenRoughness = sheenRoughnessFactor.x;\r
    float transmission = transmissionFactor.x;\r
    float transmissionDiffuse = diffuseTransmissionFactor.x;\r
    float thickness = thicknessFactor.x;\r
    #ifdef DIFFUSE_TRANSMISSION_MAP\r
        #ifdef DIFFUSE_TRANSMISSION_MAP_TEXTURE_TRANSFORM\r
            outUV = applyTransform(outUV, textureMatrices[DIFFUSE_TRANSMISSION_MAP_TEXTURE_TRANSFORM]);\r
        #endif\r
        vec4 diffuseTransmissionTextureV = texture2D(diffuseTransmissionTexture, outUV);\r
        transmissionDiffuse *= diffuseTransmissionTextureV.a;\r
    #endif\r
    vec3 attenuationColor = attenuationColorFactor.rgb;\r
    vec3 tintColor = diffuseTransmissionFactor.yzw;\r
    #ifdef DIFFUSE_TRANSMISSION_COLOR_MAP\r
        #ifdef DIFFUSE_TRANSMISSION_COLOR_MAP_TEXTURE_TRANSFORM\r
            outUV = applyTransform(outUV, textureMatrices[DIFFUSE_TRANSMISSION_COLOR_MAP_TEXTURE_TRANSFORM]);\r
        #endif\r
        vec4 diffuseTransmissionColorTextureV = texture2D(diffuseTransmissionColorTexture, outUV);\r
        tintColor *= diffuseTransmissionColorTextureV.rgb;\r
    #endif\r
    #ifdef CLEARCOATMAP\r
        outUV = getUV(CLEARCOATMAP);\r
        #ifdef CLEARCOATMAP_TEXTURE_TRANSFORM\r
            outUV = applyTransform(outUV, textureMatrices[CLEARCOATMAP_TEXTURE_TRANSFORM]);\r
        #endif\r
        clearcoatBlendFactor = texture2D(clearcoatTexture, outUV).r * clearcoat;\r
    #endif\r
    #ifdef CLEARCOATROUGHMAP\r
        outUV = getUV(CLEARCOATROUGHMAP);\r
        #ifdef CLEARCOATROUGHMAP_TEXTURE_TRANSFORM\r
            outUV = applyTransform(outUV, textureMatrices[CLEARCOATROUGHMAP_TEXTURE_TRANSFORM]);\r
        #endif\r
        clearcoatRoughness = texture2D(clearcoatRoughnessTexture, outUV).g * clearcoatRoughness;\r
    #endif\r
    #ifdef SHEENMAP\r
        outUV = getUV(SHEENMAP);\r
        #ifdef SHEENMAP_TEXTURE_TRANSFORM\r
            outUV = applyTransform(outUV, textureMatrices[SHEENMAP_TEXTURE_TRANSFORM]);\r
        #endif\r
        vec3 sheenColorTextureV = texture2D(sheenColorTexture, outUV).rgb;\r
        sheenColor = sheenColorTextureV * sheenColor;\r
    #endif\r
    #ifdef SHEENROUGHNESSMAP\r
        outUV = getUV(SHEENROUGHNESSMAP);\r
        #ifdef SHEENROUGHNESSMAP_TEXTURE_TRANSFORM\r
            outUV = applyTransform(outUV, textureMatrices[SHEENROUGHNESSMAP_TEXTURE_TRANSFORM]);\r
        #endif\r
    vec4 sheenRoughnessTextureV = texture2D(sheenRoughnessTexture, outUV);\r
    sheenRoughness = sheenRoughnessTextureV.a * sheenRoughness;\r
    #endif\r
    float iridescenceThickness = iridescence.z;\r
    #ifdef IRIDESCENCEMAP\r
        #ifdef IRIDESCENCEMAP_TEXTURE_TRANSFORM\r
            outUV = applyTransform(outUV, textureMatrices[IRIDESCENCEMAP_TEXTURE_TRANSFORM]);\r
        #endif\r
        iridescenceThickness = mix(iridescence.w, iridescence.z, texture2D(iridescenceThicknessTexture, outUV).g);\r
    #endif\r
    float iridescenceFactor = iridescence.y;\r
    #ifdef IRIDESCENCE_COLOR\r
        #ifdef IRIDESCENCE_COLOR_TEXTURE_TRANSFORM\r
            outUV = applyTransform(outUV, textureMatrices[IRIDESCENCE_COLOR_TEXTURE_TRANSFORM]);\r
        #endif\r
        iridescenceFactor *= texture2D(iridescenceTexture, outUV).r;\r
    #endif\r
    #ifdef TRANSMISSIONMAP\r
        #ifdef TRANSMISSIONMAP_TEXTURE_TRANSFORM\r
            outUV = applyTransform(outUV, textureMatrices[TRANSMISSIONMAP_TEXTURE_TRANSFORM]);\r
        #endif\r
        float transmissionTextureV = texture2D(transmissionTexture, outUV).r;\r
        transmission = transmissionTextureV * transmission;\r
    #endif\r
    #ifdef THICKNESSMAP\r
        #ifdef THICKNESSMAP_TEXTURE_TRANSFORM\r
            outUV = applyTransform(outUV, textureMatrices[THICKNESSMAP_TEXTURE_TRANSFORM]);\r
        #endif\r
        float thicknessTextureV = texture2D(thicknessTexture, outUV).g;\r
        thickness = thicknessTextureV * thickness;\r
    #endif\r
    #ifdef DIFFUSE_TRANSMISSION\r
        thickness *= 2.2;\r
    #endif\r
    vec3 specularMap = vec3(0);\r
    #ifdef SPECULARGLOSSINESSMAP\r
        #ifdef METALROUGHNESSMAP\r
            outUV = getUV(METALROUGHNESSMAP);\r
            #ifdef METALROUGHNESSMAP_TEXTURE_TRANSFORM\r
                outUV = applyTransform(outUV, textureMatrices[METALROUGHNESSMAP_TEXTURE_TRANSFORM]);\r
            #endif\r
            roughness = 1.0 - texture2D(metallicRoughnessTexture, outUV).a;\r
            specularMap = texture2D(metallicRoughnessTexture, outUV).rgb;\r
        #else\r
            roughness = glossinessFactor.x;\r
            specularMap = specularFactor;\r
        #endif\r
    #else\r
        #ifdef METALROUGHNESSMAP\r
            outUV = getUV(METALROUGHNESSMAP);\r
            #ifdef METALROUGHNESSMAP_TEXTURE_TRANSFORM\r
                outUV = applyTransform(outUV, textureMatrices[METALROUGHNESSMAP_TEXTURE_TRANSFORM]);\r
            #endif\r
            vec4 metallicRoughness = texture2D(metallicRoughnessTexture, outUV);\r
            roughness *= metallicRoughness.g;\r
            metallic *= metallicRoughness.b;\r
        #endif\r
    #endif\r
    float specularWeight = 1.0;\r
    #ifdef SPECULAR\r
        specularMap = specularColorFactor;\r
        #ifdef SPECULARCOLORMAP\r
        #ifdef SPECULARCOLORMAP_TEXTURE_TRANSFORM\r
            outUV = applyTransform(outUV, textureMatrices[SPECULARCOLORMAP_TEXTURE_TRANSFORM]);\r
        #endif\r
        specularMap *= texture2D(specularColorTexture, outUV).rgb;\r
        #endif\r
        specularWeight = specularFactor.x;\r
        #ifdef SPECULARMAP\r
        #ifdef SPECULARMAP_TEXTURE_TRANSFORM\r
            outUV = applyTransform(outUV, textureMatrices[SPECULARMAP_TEXTURE_TRANSFORM]);\r
        #endif\r
        specularWeight *= texture2D(specularTexture, outUV).a;\r
        #endif\r
    #endif\r
    vec3 F0 = mix(vec3(0.04), baseColor, metallic);\r
    #if defined(IOR) && defined(VOLUME)\r
    F0 = vec3(pow(( ior.x - 1.0) /  (ior.x + 1.0), 2.0));\r
    #endif\r
    #if defined SPECULAR\r
    F0 = mix(min(F0 * specularMap, vec3(1.0)), baseColor, metallic);\r
    #endif\r
    #if defined SPECULARGLOSSINESSMAP\r
        F0 = specularMap;\r
    #endif\r
\r
    #ifdef TANGENT\r
        #ifdef NORMALMAP\r
            outUV = getUV(NORMALMAP);\r
            #ifdef NORMALMAP_TEXTURE_TRANSFORM\r
                outUV = applyTransform(outUV, textureMatrices[NORMALMAP_TEXTURE_TRANSFORM]);\r
            #endif\r
            vec3 n = texture2D(normalTexture, outUV).rgb;\r
            n = normalize(outTBN * (2.0 * n - 1.0) * vec3(normalTextureScale.x, normalTextureScale.x, 1.0));\r
        #else\r
            vec3 n = normalize(outTBN[2].xyz);\r
        #endif\r
    #else\r
        vec3 n = normalize(outNormal);\r
    #endif\r
\r
    #ifdef TANGENT\r
    #ifdef CLEARCOATNORMALMAP\r
        outUV = getUV(CLEARCOATNORMALMAP);\r
        #ifdef CLEARCOATNORMALMAP_TEXTURE_TRANSFORM\r
            outUV = applyTransform(outUV, textureMatrices[CLEARCOATNORMALMAP_TEXTURE_TRANSFORM]);\r
        #endif\r
        vec3 clearcoatNormal = texture2D(clearcoatNormalTexture, outUV).rgb;\r
        clearcoatNormal = normalize(outTBN * (2.0 * clearcoatNormal - 1.0));\r
    #else\r
        vec3 clearcoatNormal = outTBN[2].xyz;\r
    #endif\r
    #else\r
        vec3 clearcoatNormal = outNormal;\r
    #endif\r
\r
    vec3 viewDir = normalize(viewPos - outPosition);\r
\r
    #ifdef DOUBLESIDED\r
    if (gl_FrontFacing == false) {\r
        n = -n;\r
        clearcoatNormal = -clearcoatNormal;\r
    }\r
    #endif\r
\r
    float shadow = 1.0;\r
    #ifdef SHADOWMAP\r
        vec3 l = normalize(lightPos[0] - outPosition);\r
        float shadowBias = max(0.05 * (1.0 - dot(n, l)), 0.005);\r
        shadow = 1.0 - ShadowCalculation(outPositionView, shadowBias);\r
    #endif\r
\r
    vec3 anisotropicT = vec3(0.0);\r
    vec3 anisotropicB = vec3(0.0);\r
    vec3 anisotropy = anisotropyFactor.xyz;\r
    anisotropy.yz = vec2(cos(anisotropy.y), sin(anisotropy.y));\r
    #ifdef ANISOTROPYMAP\r
        #ifdef ANISOTROPYMAP_TEXTURE_TRANSFORM\r
            outUV = applyTransform(outUV, textureMatrices[ANISOTROPYMAP_TEXTURE_TRANSFORM]);\r
        #endif\r
        vec4 anisotropyTex = texture2D(anisotropyTexture, outUV);\r
        vec2 direction = anisotropyTex.rg * 2.0 - vec2(1.0);\r
        direction = mat2(anisotropy.y, anisotropy.z, -anisotropy.z, anisotropy.y) * normalize(direction);\r
        anisotropy.x = anisotropyTex.b * anisotropyFactor.x;\r
        anisotropy.yz = direction;\r
    #endif\r
    #ifdef TANGENT\r
        anisotropicT = normalize(outTBN * vec3(anisotropy.yz, 0.0));\r
        anisotropicB = normalize(cross(n, anisotropicT));\r
    #endif\r
\r
    #ifdef USE_PBR\r
        vec3 finalDiffuse = vec3(0.0);\r
        vec3 f_sheen = vec3(0.0);\r
        float albedoSheenScaling = 1.0;\r
        vec3 Lo = vec3(0.0);\r
\r
        #ifdef DIFFUSE_TRANSMISSION\r
        float translucencyIntensity = transmissionDiffuse;\r
        vec3 transmittance = transmittanceBRDF_Burley(tintColor, vec3(1.0), thickness);\r
        transmittance *= translucencyIntensity;\r
        vec3 f_transmission = transmittance;\r
        vec3 f_transmission2 = transmittance;\r
        #else\r
        vec3 f_transmission = cocaLambert(computeColorAtDistanceInMedia(attenuationColor.rgb, attenuationDistance.x), thickness) * calcTransmission(dispersionFactor.x, ior.x, baseColor, n, roughness, viewDir, transmission, thickness);\r
        #endif\r
\r
        if (isDefaultLight.x == 1.0) {\r
            int i = LIGHTINDEX;\r
        //for (int i = 0; i < LIGHTNUMBER; ++i) {\r
            vec3 lightDir = normalize(lightPos[i].xyz - outPosition);\r
            float NdotL = max(dot(n, lightDir), 0.0);\r
            vec3 H = normalize(viewDir + lightDir);\r
\r
            vec3 radiance = lightColor[i].xyz * lightIntensity[i].x;\r
            float distance = dot(lightPos[i].xyz - outPosition, lightPos[i].xyz - outPosition);\r
            float attenuation = 1.0 / (distance * distance);\r
            // radiance = radiance * attenuation;\r
            if (lightIntensity[i].w == 1.0) { // point\r
                radiance = radiance * attenuation;\r
            }\r
            if (lightIntensity[i].w == 2.0) { // spot\r
                float lightAngleScale = 1.0 / max(0.001, cos(lightIntensity[i].y) - cos(lightIntensity[i].z));\r
                float lightAngleOffset = -cos(lightIntensity[i].z) * lightAngleScale;\r
\r
                float cd = dot(spotdir[i].xyz, lightDir);\r
                float attenuationSpot = saturate(cd * lightAngleScale + lightAngleOffset);\r
                attenuationSpot *= attenuationSpot;\r
\r
                radiance = radiance * attenuationSpot * attenuation;\r
            }\r
\r
            float NdotV = saturate(dot(n, viewDir));\r
            vec3 iridescenceF0 = vec3(0.0);\r
            #if defined IRIDESCENCE\r
            vec3 iridescenceFresnel = evalIridescence(1.0, iridescenceFactor, NdotV, iridescenceThickness, F0);\r
            iridescenceF0 = Schlick_to_F0(iridescenceFresnel, NdotV);\r
            vec3 specular = CookTorranceSpecular2(baseColor, metallic, n, H, anisotropicT, anisotropicB, roughness, viewDir, lightDir, anisotropy.x, iridescenceF0, iridescence.x, F0, specularWeight);\r
            #else\r
            vec3 specular = CookTorranceSpecular(baseColor, metallic, n, H, anisotropicT, anisotropicB, roughness, viewDir, lightDir, anisotropy.x, F0, specularWeight);\r
            #endif\r
            vec3 f_clearcoat = CookTorranceSpecular(vec3(0.0), 0.0, clearcoatNormal, H, anisotropicT, anisotropicB, clearcoatRoughness, viewDir, lightDir, anisotropy.x, F0, specularWeight);\r
            vec3 clearcoatFresnel = 1.0 - clearcoatBlendFactor * fresnelSchlick(saturate(dot(clearcoatNormal, viewDir)), vec3(0.04));\r
            #ifndef DIFFUSE_TRANSMISSION\r
            vec3 diffuse = ImprovedOrenNayarDiffuse(baseColor, metallic, n, H, roughness, viewDir, lightDir, F0, iridescenceF0, iridescence.x, specularWeight);\r
            //#ifdef CLEARCOAT\r
            diffuse *= radiance * clearcoatFresnel;\r
            //#endif\r
            #else\r
            float NdotV2 = absEps(dot(n, viewDir));\r
            float NdotL2 = absEps(dot(n, lightDir));\r
            float VdotH = absEps(dot(viewDir, H));\r
            float diffuse = diffuseBRDF_Burley(NdotL2, NdotV2, VdotH, roughness);\r
            #endif\r
            #if defined SPECULARGLOSSINESSMAP\r
                diffuse = baseColor * (1.0 - max(max(specularMap.r, specularMap.g), specularMap.b));\r
            #endif\r
            #if defined SHEEN\r
            f_sheen = NdotL * (sheenColor * sheenDistribution(sheenRoughness, n, H) * sheenVisibility(n, viewDir, lightDir, sheenRoughness));\r
            albedoSheenScaling = min(1.0 - max3(sheenColor) * E(max(dot(viewDir, n), 0.0), sheenRoughness), 1.0 - max3(sheenColor) * E(max(dot(lightDir, n), 0.0), sheenRoughness));\r
            #endif\r
\r
            Lo += (specular * NdotL);\r
            //#ifdef CLEARCOAT\r
            Lo = Lo * radiance * clearcoatFresnel + f_clearcoat * clearcoatBlendFactor;\r
            //#endif\r
            vec3 diffuseLobe = vec3(diffuse);\r
\r
            #ifdef DIFFUSE_TRANSMISSION\r
            float trAdapt = step(0., dot(n, lightDir));\r
            float wrapNdotL = computeWrappedDiffuseNdotL(absEps(dot(n, lightDir)), 0.02);\r
            vec3 transmittanceNdotL = mix(f_transmission*wrapNdotL, vec3(wrapNdotL), trAdapt);\r
            diffuseLobe = diffuseLobe * radiance * baseColor;\r
            diffuseLobe = mix(diffuseLobe, f_transmission * transmittanceNdotL, transmissionDiffuse);\r
            transmission = 0.0;\r
            f_transmission = vec3(0.0);\r
            #else\r
            diffuseLobe *= (1.0 - transmission);\r
            #endif\r
\r
            #ifndef SCATTERING\r
            Lo += diffuseLobe;\r
            #endif\r
\r
            finalDiffuse += diffuseLobe;\r
        //}\r
        }\r
\r
        vec3 ambient = vec3(0.0);\r
        vec3 ambientClearcoat = vec3(0.0);\r
        vec3 clearcoatFresnel = vec3(1.0);\r
        vec3 aSpecular;\r
        vec3 cSpecular;\r
        if (isIBL.x == 1.0) {\r
            float NdotV = saturate(dot(n, viewDir));\r
            vec3 iridescenceFresnel = evalIridescence(1.0, iridescenceFactor, NdotV, iridescenceThickness, F0);\r
            vec3 iridescenceF0 = Schlick_to_F0(iridescenceFresnel, NdotV);\r
            ambient = IBLAmbient(baseColor, metallic, n, roughness, viewDir, transmission, sheenColor, sheenRoughness, iridescenceF0, iridescence.x, F0, specularWeight, anisotropy.x, anisotropicB, f_sheen, aSpecular);\r
            vec3 placeholder = vec3(0.0);\r
            ambientClearcoat = IBLAmbient(vec3(0.0), 0.0, clearcoatNormal, clearcoatRoughness, viewDir, transmission, sheenColor, sheenRoughness, iridescenceF0, iridescence.x, F0, specularWeight, anisotropy.x, anisotropicB, placeholder, cSpecular) * clearcoatBlendFactor;\r
            #ifdef DIFFUSE_TRANSMISSION\r
            ambient = mix(ambient, f_transmission2, transmissionDiffuse);\r
            #endif\r
            #ifndef SPHERICAL_HARMONICS\r
            #ifndef SCATTERING\r
            ambient += aSpecular;\r
            #endif\r
            ambientClearcoat += cSpecular * clearcoatBlendFactor;\r
            #endif\r
            clearcoatFresnel = (1.0 - clearcoatBlendFactor * fresnelSchlick(saturate(dot(clearcoatNormal, viewDir)), vec3(0.04)));\r
        } else {\r
            ambient = vec3(0.03) * baseColor * 0.2;\r
        }\r
\r
        vec3 emissive = emissiveFactor;\r
        #ifdef EMISSIVEMAP\r
            outUV = getUV(EMISSIVEMAP);\r
            #ifdef EMISSIVEMAP_TEXTURE_TRANSFORM\r
                outUV = applyTransform(outUV, textureMatrices[EMISSIVEMAP_TEXTURE_TRANSFORM]);\r
            #endif\r
            emissive *= texture2D(emissiveTexture, outUV).rgb;\r
        #endif\r
        emissive *= emissiveStrength.x;\r
\r
        #ifdef TRANSMISSION\r
            float kT = 1.0 - specEnv(n, viewDir, metallic, roughness, F0, specularWeight);\r
            f_transmission = f_transmission * kT;\r
            color = vec4((Lo) * clearcoatFresnel + ambientClearcoat, alpha);\r
            #ifndef SCATTERING\r
            color.rgb += (ambient * ao + emissive + f_transmission) * clearcoatFresnel;\r
            #endif\r
        #else\r
            color = vec4(ao * ((emissive + Lo) * clearcoatFresnel + ambientClearcoat), alpha);\r
            #ifndef SCATTERING\r
            color.rgb += ambient * ao * clearcoatFresnel;\r
            #endif\r
        #endif\r
\r
        color.rgb = f_sheen + color.rgb * albedoSheenScaling;\r
    #else\r
        vec3 lightDir = normalize(lightPos[0].xyz - outPosition);\r
        vec3 ambient = ambientStrength * lightColor[0].xyz;\r
\r
        float diff = max(dot(n, lightDir), 0.0);\r
        vec3 diffuse = diff * lightColor[0].XYZ;\r
\r
        vec3 reflectDir = reflect(-lightDir, n);\r
        float spec = pow(max(dot(viewDir, reflectDir), 0.0), specularPower);\r
        vec3 specular = specularStrength * spec * lightColor[0].xyz;\r
\r
        color = vec4(baseColor.rgb * (ambient + diffuse + specular) * shadow, alpha);\r
    #endif\r
\r
    #ifndef SCATTERING\r
    if (isTone.x == 1.0) {\r
        #ifdef SPHERICAL_HARMONICS\r
        color.rgb  *= 4.0;\r
        vec3 X = max(vec3(0.0, 0.0, 0.0), color.rgb - 0.004);\r
        vec3 retColor = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);\r
        color.rgb = retColor * retColor;\r
        #else\r
        // color.rgb = color.rgb / (color.rgb + vec3(1.0));\r
        color.rgb = pow(color.rgb, vec3(1.0 / gamma));\r
        #endif\r
    }\r
    #endif\r
\r
    #ifdef SPHERICAL_HARMONICS\r
    color.rgb += aSpecular;\r
    #endif\r
\r
    // normalColor = vec4(n, 0.0);\r
\r
    #ifdef SCATTERING\r
    specColor = vec4(Lo + aSpecular, 1.0);\r
\r
    vec3 irradiance = finalDiffuse;\r
    irradiance += ambient;\r
    irradiance += f_transmission;\r
    irradiance /= sqrt(baseColor.rgb);\r
\r
    irradianceColor = vec4(clamp(irradiance, vec3(0.), vec3(1.)), 1.0);\r
    #ifdef TRANSMISSION\r
    albedoColor = vec4(sqrt(attenuationColor.rgb), 1.0);\r
    #else\r
    albedoColor = vec4(sqrt(baseColor), 1.0);\r
    #endif\r
    #else\r
    irradianceColor = vec4(0.0);\r
    albedoColor = vec4(0.0);\r
    specColor = vec4(0.0);\r
    #endif\r
}\r
`;

  // src/shaders/frag.h
  var frag_default = "#version 300 es\r\nprecision highp float;\r\n\r\n// #ifdef DIFFUSE_TRANSMISSION\r\n//     #define SCATTERING 1\r\n// #endif\r\n\r\n#define texture2D(p, uv) texture(p, uv)\r\n#define textureCube(p, uv) texture(p, uv)\r\n#define textureLodCube(p, uv, i) textureLod(p, uv, i)\r\n#define textureLod2D(p, uv, i) textureLod(p, uv, i)\r\n#define textureLod2D2(p, uv, i) textureLod(p, uv, i)\r\n\r\nuniform sampler2D uMaterialTex;\r\n\r\nin vec4 vColor;\r\nin vec2 outUV0;\r\nin vec2 outUV2;\r\nin vec2 outUV3;\r\nin vec3 outPosition;\r\nin vec4 outPositionView;\r\nin float id;\r\n#ifdef TANGENT\r\n    in mat3 outTBN;\r\n#else\r\n    in vec3 outNormal;\r\n#endif\r\n\r\nlayout (location = 0) out vec4 color;\r\nlayout (location = 1) out vec4 normalColor;\r\nlayout (location = 2) out vec4 irradianceColor;\r\nlayout (location = 3) out vec4 albedoColor;\r\nlayout (location = 4) out vec4 specColor;\r\n\r\nstruct Material {\r\n    vec4 baseColorFactor;\r\n    vec3 specularFactor;\r\n    vec3 specularColorFactor;\r\n    vec3 emissiveFactor;\r\n    vec4 glossinessFactor;\r\n    vec4 metallicFactor;\r\n    vec4 roughnessFactor;\r\n    vec4 clearcoatFactor;\r\n    vec4 clearcoatRoughnessFactor;\r\n    vec4 sheenColorFactor;\r\n    vec4 sheenRoughnessFactor;\r\n    vec4 transmissionFactor;\r\n    vec4 ior;\r\n    vec4 normalTextureScale;\r\n    vec4 attenuationColorFactor; \r\n    vec4 attenuationDistance; \r\n    vec4 thicknessFactor;\r\n    vec4 emissiveStrength;\r\n    vec4 anisotropyFactor;\r\n    vec4 iridescence;\r\n    vec4 diffuseTransmissionFactor;\r\n    vec4 dispersionFactor;\r\n};\r\n\r\nMaterial fetchMaterial(int id) {\r\n    Material m;\r\n    int row = id;\r\n    m.baseColorFactor         = texelFetch(uMaterialTex, ivec2(0, row), 0);\r\n    m.specularFactor          = texelFetch(uMaterialTex, ivec2(1, row), 0).xyz;\r\n    m.specularColorFactor     = texelFetch(uMaterialTex, ivec2(2, row), 0).xyz;\r\n    m.emissiveFactor          = texelFetch(uMaterialTex, ivec2(3, row), 0).xyz;\r\n    m.glossinessFactor        = texelFetch(uMaterialTex, ivec2(4, row), 0);\r\n    m.metallicFactor          = texelFetch(uMaterialTex, ivec2(5, row), 0);\r\n    m.roughnessFactor         = texelFetch(uMaterialTex, ivec2(6, row), 0);\r\n    m.clearcoatFactor         = texelFetch(uMaterialTex, ivec2(7, row), 0);\r\n    m.clearcoatRoughnessFactor= texelFetch(uMaterialTex, ivec2(8, row), 0);\r\n    m.sheenColorFactor        = texelFetch(uMaterialTex, ivec2(9, row), 0);\r\n    m.sheenRoughnessFactor    = texelFetch(uMaterialTex, ivec2(10, row), 0);\r\n    m.transmissionFactor      = texelFetch(uMaterialTex, ivec2(11, row), 0);\r\n    m.ior                     = texelFetch(uMaterialTex, ivec2(12, row), 0);\r\n    m.normalTextureScale      = texelFetch(uMaterialTex, ivec2(13, row), 0);\r\n    m.attenuationColorFactor  = texelFetch(uMaterialTex, ivec2(14, row), 0);\r\n    m.attenuationDistance     = texelFetch(uMaterialTex, ivec2(15, row), 0);\r\n    m.thicknessFactor         = texelFetch(uMaterialTex, ivec2(16, row), 0);\r\n    m.emissiveStrength        = texelFetch(uMaterialTex, ivec2(17, row), 0);\r\n    m.anisotropyFactor        = texelFetch(uMaterialTex, ivec2(18, row), 0);\r\n    m.iridescence             = texelFetch(uMaterialTex, ivec2(19, row), 0);\r\n    m.diffuseTransmissionFactor= texelFetch(uMaterialTex, ivec2(20, row), 0);\r\n    m.dispersionFactor        = texelFetch(uMaterialTex, ivec2(21, row), 0);\r\n    return m;\r\n}\r\n\r\nuniform Matrices2 {\r\n    mat4 view;\r\n    mat4 projection;\r\n    mat4 light;\r\n    vec4 isShadow;\r\n};\r\nuniform LightPos {\r\n    vec4 lightPos[LIGHTNUMBER];\r\n};\r\nuniform LightColor {\r\n    vec4 lightColor[LIGHTNUMBER];\r\n};\r\nuniform Spotdir {\r\n    vec4 spotdir[LIGHTNUMBER];\r\n};\r\nuniform LightIntensity {\r\n    vec4 lightIntensity[LIGHTNUMBER];\r\n};\r\n#if defined MATRICES\r\nuniform TextureMatrices {\r\n    mat4 textureMatrices[MATRICES];\r\n};\r\n#endif\r\n#ifdef SPHERICAL_HARMONICS\r\nuniform SphericalHarmonics {\r\n    vec4 vSphericalL00;\r\n    vec4 vSphericalL1_1;\r\n    vec4 vSphericalL10;\r\n    vec4 vSphericalL11;\r\n    vec4 vSphericalL2_2;\r\n    vec4 vSphericalL2_1;\r\n    vec4 vSphericalL20;\r\n    vec4 vSphericalL21;\r\n    vec4 vSphericalL22;\r\n    mat4 rotationMatrix;\r\n};\r\n#endif\r\n\r\nuniform sampler2D baseColorTexture;\r\nuniform sampler2D metallicRoughnessTexture;\r\nuniform sampler2D normalTexture;\r\nuniform sampler2D emissiveTexture;\r\nuniform sampler2D occlusionTexture;\r\nuniform sampler2D clearcoatTexture;\r\nuniform sampler2D clearcoatRoughnessTexture;\r\nuniform sampler2D transmissionTexture;\r\nuniform sampler2D sheenColorTexture;\r\nuniform sampler2D sheenRoughnessTexture;\r\nuniform sampler2D iridescenceThicknessTexture;\r\nuniform sampler2D iridescenceTexture;\r\nuniform sampler2D clearcoatNormalTexture;\r\nuniform sampler2D specularTexture;\r\nuniform sampler2D specularColorTexture;\r\nuniform sampler2D thicknessTexture;\r\nuniform sampler2D diffuseTransmissionTexture;\r\nuniform sampler2D diffuseTransmissionColorTexture;\r\nuniform sampler2D anisotropyTexture;\r\n\r\nuniform samplerCube prefilterMap;\r\nuniform samplerCube charlieMap;\r\nuniform sampler2D brdfLUT;  \r\nuniform samplerCube irradianceMap;\r\nuniform sampler2D depthTexture;\r\nuniform sampler2D colorTexture;\r\nuniform vec2 isTone;\r\nuniform vec2 isIBL;\r\nuniform vec2 isDefaultLight;\r\nuniform sampler2D Sheen_E;\r\n";

  // src/shaders/vert.h
  var vert_default = "#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 inPosition;\r\nlayout (location = 1) in vec3 inNormal;\r\nlayout (location = 2) in vec2 inUV;\r\nlayout (location = 4) in vec4 inJoint;\r\nlayout (location = 5) in vec4 inWeight;\r\nlayout (location = 3) in vec4 inTangent;\r\nlayout (location = 6) in vec4 inColor;\r\nlayout (location = 7) in vec2 inUV2;\r\nlayout (location = 8) in vec2 inUV3;\r\nlayout (location = 9) in float uMaterialID;\r\n\r\nuniform sampler2D uTransformTex;\r\n\r\nout vec4 vColor;\r\nout vec2 outUV0;\r\nout vec2 outUV2;\r\nout vec2 outUV3;\r\nout vec3 outPosition;\r\nout vec4 outPositionView;\r\nout float id;\r\n#ifdef TANGENT\r\n    out mat3 outTBN;\r\n#else\r\n    out vec3 outNormal;\r\n#endif\r\n\r\nstruct Transform {\r\n    mat4 model;\r\n};\r\nTransform fetchTransform(int id) {\r\n    Transform t;\r\n\r\n    // 8 texels across (0..7)\r\n    t.model[0] = texelFetch(uTransformTex, ivec2(0, id), 0);\r\n    t.model[1] = texelFetch(uTransformTex, ivec2(1, id), 0);\r\n    t.model[2] = texelFetch(uTransformTex, ivec2(2, id), 0);\r\n    t.model[3] = texelFetch(uTransformTex, ivec2(3, id), 0);\r\n\r\n    return t;\r\n}\r\nuniform Matrices2 {\r\n    mat4 view;\r\n    mat4 projection;\r\n    mat4 light;\r\n    vec4 isShadow;\r\n};\r\n#ifdef JOINTNUMBER\r\nuniform Skin {\r\n    mat4 joint[JOINTNUMBER];\r\n};\r\n#endif";

  // src/objects/geometry.ts
  var GeometryEnum = {
    POSITION: [0, 3],
    TEXCOORD_0: [2, 2],
    NORMAL: [1, 3],
    TANGENT: [3, 4],
    JOINTS_0: [4, 4],
    WEIGHTS_0: [5, 4],
    COLOR_0: [6, 4],
    TEXCOORD_1: [7, 2],
    TEXCOORD_2: [8, 2]
  };
  var Geometry = class {
    UBO;
    VAO;
    uniformBuffer;
    indicesBuffer;
    attributes;
    targets;
    blend;
    uniforms;
    SKIN;
    boundingSphere;
    vertexAccessor;
    indexType;
    cubeVertexSize;
    VBO;
    indicesWebGPUBuffer;
    verticesWebGPUBuffer;
    uniformBindGroup1;
    g;
    constructor(json, arrayBuffer, weights, draco, primitive) {
      this.boundingSphere = {
        center: new Vector3(),
        radius: null,
        min: null,
        max: null
      };
      this.uniformBuffer = null;
      this.UBO = null;
      this.VAO = null;
      this.indicesBuffer = null;
      this.attributes = null;
      this.targets = null;
      this.blend = null;
      this.uniforms = null;
      this.SKIN = null;
      this.targets = [];
      let indicesBuffer;
      const vertexBuffers = {};
      const indicesAccessor = json.accessors[primitive.indices];
      this.indexType = indicesAccessor?.componentType;
      const vertexAccessor = /* @__PURE__ */ new Map();
      for (const a in primitive.attributes) {
        vertexAccessor.set(a, json.accessors[primitive.attributes[a]]);
      }
      const boundingBox = {
        min: vertexAccessor.get("POSITION").min,
        max: vertexAccessor.get("POSITION").max
      };
      const compresedMesh = primitive.extensions && primitive.extensions.KHR_draco_mesh_compression;
      if (compresedMesh) {
        const bufferView = json.bufferViews[compresedMesh.bufferView];
        const decoder = new draco.Decoder();
        const decodedGeometry = decodeDracoData(arrayBuffer[bufferView.buffer], decoder, bufferView.byteOffset, bufferView.byteLength);
        const numFaces = decodedGeometry.num_faces();
        const numPoints = decodedGeometry.num_points();
        for (const k of vertexAccessor.keys()) {
          const attribute = decoder.GetAttributeByUniqueId(decodedGeometry, compresedMesh.attributes[k]);
          const size = getDataType(vertexAccessor.get(k).type);
          const [dracoArr, arr] = getArray(
            getGlEnum(vertexAccessor.get(k).componentType),
            numPoints * size,
            decodedGeometry,
            attribute,
            decoder
          );
          for (let i = 0; i < numPoints * size; i += size) {
            arr[i] = dracoArr.GetValue(i);
            arr[i + 1] = dracoArr.GetValue(i + 1);
            if (size > 2) {
              arr[i + 2] = dracoArr.GetValue(i + 2);
            }
            if (size > 3) {
              arr[i + 3] = dracoArr.GetValue(i + 3);
            }
          }
          draco.destroy(dracoArr);
          vertexBuffers[k] = arr;
        }
        {
          indicesBuffer = new Uint32Array(numFaces * 3);
          indicesBuffer.type = "UNSIGNED_INT";
          const ia = new draco.DracoUInt32Array();
          for (let i = 0; i < numFaces; ++i) {
            decoder.GetFaceFromMesh(decodedGeometry, i, ia);
            const index = i * 3;
            indicesBuffer[index] = ia.GetValue(0);
            indicesBuffer[index + 1] = ia.GetValue(1);
            indicesBuffer[index + 2] = ia.GetValue(2);
          }
          draco.destroy(ia);
        }
        draco.destroy(decoder);
        draco.destroy(decodedGeometry);
      } else {
        if (indicesAccessor) {
          const bufferView = json.bufferViews[indicesAccessor.bufferView];
          indicesBuffer = buildArray(
            arrayBuffer[bufferView.buffer],
            indicesAccessor.componentType,
            calculateOffset(bufferView.byteOffset, indicesAccessor.byteOffset),
            getDataType(indicesAccessor.type) * indicesAccessor.count
          );
          if (primitive.mode === 6) {
            indicesBuffer = fanToTriListIndices(indicesBuffer);
          }
          if (primitive.mode === 2) {
            indicesBuffer = convertLineLoopToLineList(indicesBuffer);
          }
        }
        for (const k of vertexAccessor.keys()) {
          const accessor = vertexAccessor.get(k);
          const bufferView = json.bufferViews[accessor.bufferView];
          vertexBuffers[k] = buildArrayWithStride(arrayBuffer[bufferView.buffer], accessor, bufferView);
        }
      }
      if (primitive.targets) {
        for (const target of primitive.targets) {
          const vertexAcc = {};
          for (const a in target) {
            vertexAcc[a] = json.accessors[target[a]];
            const accessor = vertexAcc[a];
            const bufferView = json.bufferViews[accessor.bufferView];
            vertexAcc[a] = buildArrayWithStride(arrayBuffer[bufferView.buffer], accessor, bufferView);
          }
          this.targets.push(vertexAcc);
        }
        for (const k of vertexAccessor.keys()) {
          if (this.targets[0][k]) {
            let offset = 0;
            const geometry = vertexBuffers[k];
            vertexBuffers[k] = new geometry.constructor(geometry.length);
            for (let i = 0; i < vertexBuffers[k].length; i++) {
              if (k === "TANGENT" && (i + 1) % 4 === 0) {
                offset++;
                continue;
              }
              vertexBuffers[k][i] = geometry[i] + weights.reduce((a, b, index) => {
                return a + weights[index] * this.targets[index][k][i - offset];
              }, 0);
            }
          }
        }
      }
      for (const k of vertexAccessor.keys()) {
        const accessor = vertexAccessor.get(k);
        if (k === "COLOR_0" && accessor.type === "VEC3") {
          const temp = new vertexBuffers[k].constructor(accessor.count * 4);
          let j = 0;
          for (let i = 0; i < temp.length; i++) {
            if ((i + 1) % 4 === 0) {
              temp[i] = 1;
            } else {
              temp[i] = vertexBuffers[k][j];
              j++;
            }
          }
          vertexBuffers[k] = temp;
        }
        if (accessor.sparse !== void 0) {
          const itemSize = getDataType(accessor.type);
          const indicesBufferView = json.bufferViews[accessor.sparse.indices.bufferView];
          const valuesBufferView = json.bufferViews[accessor.sparse.values.bufferView];
          const sparseIndices = buildArray(
            arrayBuffer[indicesBufferView.buffer],
            accessor.sparse.indices.componentType,
            calculateOffset(indicesBufferView.byteOffset, accessor.sparse.indices.byteOffset),
            accessor.sparse.count
          );
          const sparseValues = buildArray(
            arrayBuffer[valuesBufferView.buffer],
            accessor.componentType,
            calculateOffset(valuesBufferView.byteOffset, accessor.byteOffset),
            getDataType(accessor.type) * accessor.sparse.count
          );
          for (let i = 0, il = sparseIndices.length; i < il; i++) {
            const index = sparseIndices[i];
            vertexBuffers[k][index * itemSize] = sparseValues[i * itemSize];
            if (itemSize >= 2) {
              vertexBuffers[k][index * itemSize + 1] = sparseValues[i * itemSize + 1];
            }
            if (itemSize >= 3) {
              vertexBuffers[k][index * itemSize + 2] = sparseValues[i * itemSize + 2];
            }
            if (itemSize >= 4) {
              vertexBuffers[k][index * itemSize + 3] = sparseValues[i * itemSize + 3];
            }
          }
        }
      }
      if (vertexBuffers.NORMAL === void 0 && indicesBuffer) {
        vertexBuffers.NORMAL = calculateNormals(indicesBuffer, vertexBuffers.POSITION);
        vertexAccessor.set("NORMAL", { componentType: 5126 });
      }
      if (vertexBuffers.NORMAL === void 0 && indicesBuffer === void 0) {
        vertexBuffers.NORMAL = calculateNormals2(vertexBuffers.POSITION);
        vertexAccessor.set("NORMAL", { componentType: 5126 });
      }
      if (vertexBuffers.TEXCOORD_0 === void 0 && indicesBuffer) {
        vertexBuffers.TEXCOORD_0 = calculateUVs(vertexBuffers.POSITION, vertexBuffers.NORMAL);
        vertexAccessor.set("TEXCOORD_0", { componentType: 5126 });
      }
      if (primitive.attributes.TANGENT === void 0 && indicesBuffer) {
        vertexBuffers.TANGENT = calculateBinormals(
          indicesBuffer,
          vertexBuffers.POSITION,
          vertexBuffers.NORMAL,
          vertexBuffers.TEXCOORD_0
        );
        vertexAccessor.set("TANGENT", { componentType: 5126 });
      }
      this.vertexAccessor = vertexAccessor;
      this.attributes = vertexBuffers;
      this.indicesBuffer = indicesBuffer;
      const { min, max } = boundingBox;
      this.boundingSphere.min = new Vector3(min);
      this.boundingSphere.max = new Vector3(max);
    }
    compose(order) {
      let total = 12;
      if (order !== void 0) {
        total = 13;
      }
      const count = this.attributes["POSITION"].length / 3;
      const g = new Float32Array(
        (order !== void 0 ? count : 0) + count * 3 + count * 2 + count * 3 + count * 4 + (this.attributes["JOINTS_0"]?.length ?? 0) + (this.attributes["WEIGHTS_0"]?.length ?? 0) + (this.attributes["COLOR_0"]?.length ?? 0) + (this.attributes["TEXCOORD_1"]?.length ?? 0) + (this.attributes["TEXCOORD_2"]?.length ?? 0)
      );
      if (this.attributes["WEIGHTS_0"]) {
        total += 8;
      }
      if (this.attributes["COLOR_0"]) {
        total += 4;
      }
      if (this.attributes["TEXCOORD_1"]) {
        total += 2;
      }
      if (this.attributes["TEXCOORD_2"]) {
        total += 2;
      }
      let k = 0;
      let l = 0;
      let m = 0;
      for (let i = 0; i < g.length; i += total) {
        let j = 12;
        g[i] = this.attributes["POSITION"][k];
        g[i + 1] = this.attributes["POSITION"][k + 1];
        g[i + 2] = this.attributes["POSITION"][k + 2];
        if (this.attributes["TEXCOORD_0"]) {
          g[i + 3] = this.attributes["TEXCOORD_0"][l];
          g[i + 4] = this.attributes["TEXCOORD_0"][l + 1];
        }
        g[i + 5] = this.attributes["NORMAL"][k];
        g[i + 6] = this.attributes["NORMAL"][k + 1];
        g[i + 7] = this.attributes["NORMAL"][k + 2];
        if (this.attributes["TANGENT"]) {
          g[i + 8] = this.attributes["TANGENT"][m];
          g[i + 9] = this.attributes["TANGENT"][m + 1];
          g[i + 10] = this.attributes["TANGENT"][m + 2];
          g[i + 11] = this.attributes["TANGENT"][m + 3];
        }
        if (this.attributes["WEIGHTS_0"]) {
          g[i + 12] = this.attributes["JOINTS_0"][m];
          g[i + 13] = this.attributes["JOINTS_0"][m + 1];
          g[i + 14] = this.attributes["JOINTS_0"][m + 2];
          g[i + 15] = this.attributes["JOINTS_0"][m + 3];
          g[i + 16] = this.attributes["WEIGHTS_0"][m];
          g[i + 17] = this.attributes["WEIGHTS_0"][m + 1];
          g[i + 18] = this.attributes["WEIGHTS_0"][m + 2];
          g[i + 19] = this.attributes["WEIGHTS_0"][m + 3];
          j += 8;
        }
        if (this.attributes["COLOR_0"]) {
          g[i + 12] = this.attributes["COLOR_0"][m];
          g[i + 13] = this.attributes["COLOR_0"][m + 1];
          g[i + 14] = this.attributes["COLOR_0"][m + 2];
          g[i + 15] = this.attributes["COLOR_0"][m + 3];
          j += 4;
        }
        if (this.attributes["TEXCOORD_1"]) {
          g[i + 12] = this.attributes["TEXCOORD_1"][l];
          g[i + 13] = this.attributes["TEXCOORD_1"][l + 1];
          j += 2;
        }
        if (this.attributes["TEXCOORD_2"]) {
          g[i + 14] = this.attributes["TEXCOORD_2"][l];
          g[i + 15] = this.attributes["TEXCOORD_2"][l + 1];
          j += 2;
        }
        if (order !== void 0) {
          g[i + j] = order;
        }
        k += 3;
        l += 2;
        m += 4;
      }
      this.g = g;
    }
    createGeometryForWebGPU(WebGPU2) {
      const { device } = WebGPU2;
      this.compose();
      const verticesBuffer = device.createBuffer({
        size: this.g.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Float32Array(verticesBuffer.getMappedRange()).set(this.g);
      verticesBuffer.unmap();
      this.verticesWebGPUBuffer = verticesBuffer;
      if (this.indicesBuffer) {
        this.indicesBuffer = new Uint32Array(this.indicesBuffer);
        const indicesBuffer = device.createBuffer({
          size: this.indicesBuffer.byteLength,
          usage: GPUBufferUsage.INDEX,
          mappedAtCreation: true
        });
        new Uint32Array(indicesBuffer.getMappedRange()).set(this.indicesBuffer);
        indicesBuffer.unmap();
        this.indicesWebGPUBuffer = indicesBuffer;
      }
    }
    createGeometryForWebGl(gl11, defines, order) {
      const VAO = gl11.createVertexArray();
      gl11.bindVertexArray(VAO);
      this.compose(order);
      const VBO = gl11.createBuffer();
      gl11.bindBuffer(gl11.ARRAY_BUFFER, VBO);
      gl11.bufferData(gl11.ARRAY_BUFFER, this.g, gl11.STATIC_DRAW);
      this.VBO = VBO;
      const vertexLayout = [3, 2, 3, 4];
      if (defines.find((d) => d.name === "JOINTNUMBER")) {
        vertexLayout.push(4, 4);
      }
      if (defines.find((d) => d.name === "COLOR")) {
        vertexLayout.push(4);
      }
      if (defines.find((d) => d.name === "MULTIUV")) {
        vertexLayout.push(2);
      }
      if (this.attributes["TEXCOORD_2"]) {
        vertexLayout.push(2);
      }
      vertexLayout.push(1);
      const cubeVertexSize = Float32Array.BYTES_PER_ELEMENT * vertexLayout.reduce((a, b) => a + b, 0);
      this.cubeVertexSize = cubeVertexSize;
      let offset = 0;
      for (const k in GeometryEnum) {
        if (k in this.attributes || k === "TANGENT" || k === "TEXCOORD_0") {
          const index = GeometryEnum[k];
          gl11.enableVertexAttribArray(index[0]);
          gl11.vertexAttribPointer(index[0], index[1], gl11.FLOAT, false, cubeVertexSize, Float32Array.BYTES_PER_ELEMENT * offset);
          offset += index[1];
        }
      }
      gl11.enableVertexAttribArray(9);
      gl11.vertexAttribPointer(9, 1, gl11.FLOAT, false, cubeVertexSize, Float32Array.BYTES_PER_ELEMENT * offset);
      if (this.indicesBuffer) {
        const VBO2 = gl11.createBuffer();
        gl11.bindBuffer(gl11.ELEMENT_ARRAY_BUFFER, VBO2);
        gl11.bufferData(gl11.ELEMENT_ARRAY_BUFFER, this.indicesBuffer, gl11.STATIC_DRAW);
      }
      this.VAO = VAO;
      gl11.bindVertexArray(null);
    }
    calculateBounding(matrix) {
      this.boundingSphere.min.applyMatrix4(matrix);
      this.boundingSphere.max.applyMatrix4(matrix);
      const vertices = this.attributes.POSITION;
      let maxRadiusSq = 0;
      this.boundingSphere.center.add(this.boundingSphere.min).add(this.boundingSphere.max).scale(0.5);
      for (let i = 0; i < vertices.length; i = i + 3) {
        maxRadiusSq = Math.max(
          maxRadiusSq,
          this.boundingSphere.center.distanceToSquared(vertices[i], vertices[i + 1], vertices[i + 2])
        );
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
    }
    createUniforms(matrixWorld) {
      const uniformBuffer = new UniformBuffer();
      uniformBuffer.add("model", matrixWorld.elements);
      uniformBuffer.done();
      this.uniformBuffer = uniformBuffer;
    }
    updateUniformsWebGPU(WebGPU2, buffer, usage = GPUBufferUsage.UNIFORM) {
      const matrixSize = buffer.store.byteLength;
      const offset = 256;
      const uniformBufferSize = offset + matrixSize;
      const { device } = WebGPU2;
      const uniformBuffer = device.createBuffer({
        size: uniformBufferSize,
        usage: usage | GPUBufferUsage.COPY_DST
      });
      buffer.bufferWebGPU = uniformBuffer;
      const uniformBindGroup1 = [
        {
          binding: 0,
          resource: uniformBuffer
        }
      ];
      device.queue.writeBuffer(
        uniformBuffer,
        0,
        buffer.store.buffer,
        buffer.store.byteOffset,
        buffer.store.byteLength
      );
      return uniformBindGroup1;
    }
    updateUniformsWebGl(gl11, program) {
      const uIndex2 = gl11.getUniformBlockIndex(program, "Matrices2");
      gl11.uniformBlockBinding(program, uIndex2, 1);
    }
    async updateWebGPU(WebGPU2, geometry) {
      const { device } = WebGPU2;
      let total = 12;
      if (this.attributes["COLOR_0"]) {
        total += 4;
      }
      if (this.attributes["TEXCOORD_1"]) {
        total += 2;
      }
      let k = 0;
      let l = 0;
      let m = 0;
      const { g } = this;
      for (let i = 0; i < g.length; i += total) {
        if (geometry["POSITION"]) {
          g[i] = geometry["POSITION"][k];
          g[i + 1] = geometry["POSITION"][k + 1];
          g[i + 2] = geometry["POSITION"][k + 2];
        }
        if (geometry["TEXCOORD_0"]) {
          g[i + 3] = geometry["TEXCOORD_0"][l];
          g[i + 4] = geometry["TEXCOORD_0"][l + 1];
        }
        if (geometry["NORMAL"]) {
          g[i + 5] = geometry["NORMAL"][k];
          g[i + 6] = geometry["NORMAL"][k + 1];
          g[i + 7] = geometry["NORMAL"][k + 2];
        }
        if (geometry["TANGENT"]) {
          g[i + 8] = geometry["TANGENT"][m];
          g[i + 9] = geometry["TANGENT"][m + 1];
          g[i + 10] = geometry["TANGENT"][m + 2];
          g[i + 11] = geometry["TANGENT"][m + 3];
        }
        k += 3;
        l += 2;
        m += 4;
      }
      device.queue.writeBuffer(this.verticesWebGPUBuffer, 0, g.buffer, g.byteOffset, g.byteLength);
    }
    update(gl11, geometry) {
      gl11.bindVertexArray(this.VAO);
      let total = 13;
      if (this.attributes["COLOR_0"]) {
        total += 4;
      }
      if (this.attributes["TEXCOORD_1"]) {
        total += 2;
      }
      let k = 0;
      let l = 0;
      let m = 0;
      const { g } = this;
      for (let i = 0; i < g.length; i += total) {
        if (geometry["POSITION"]) {
          g[i] = geometry["POSITION"][k];
          g[i + 1] = geometry["POSITION"][k + 1];
          g[i + 2] = geometry["POSITION"][k + 2];
        }
        if (geometry["TEXCOORD_0"]) {
          g[i + 3] = geometry["TEXCOORD_0"][l];
          g[i + 4] = geometry["TEXCOORD_0"][l + 1];
        }
        if (geometry["NORMAL"]) {
          g[i + 5] = geometry["NORMAL"][k];
          g[i + 6] = geometry["NORMAL"][k + 1];
          g[i + 7] = geometry["NORMAL"][k + 2];
        }
        if (geometry["TANGENT"]) {
          g[i + 8] = geometry["TANGENT"][m];
          g[i + 9] = geometry["TANGENT"][m + 1];
          g[i + 10] = geometry["TANGENT"][m + 2];
          g[i + 11] = geometry["TANGENT"][m + 3];
        }
        k += 3;
        l += 2;
        m += 4;
      }
      gl11.bindBuffer(gl11.ARRAY_BUFFER, this.VBO);
      gl11.bufferData(gl11.ARRAY_BUFFER, g, gl11.STATIC_DRAW);
      gl11.bindVertexArray(null);
    }
  };

  // src/parse.ts
  var gl2;
  var BASE64_MARKER = ";base64,";
  var Parse = class {
    tracks;
    url;
    host;
    skins;
    textures;
    images;
    samplers;
    arrayBuffer;
    cameras;
    lights;
    programs;
    scene;
    camera;
    light;
    aspect;
    zoom;
    canvas;
    resize;
    json;
    defines;
    draco;
    constructor(url, defines, resize) {
      this.url = url;
      this.host = url.substr(0, url.lastIndexOf("/") + 1);
      this.tracks = [];
      this.skins = [];
      this.textures = null;
      this.images = /* @__PURE__ */ new Map();
      this.samplers = null;
      this.arrayBuffer = null;
      this.cameras = [];
      this.lights = [];
      this.programs = {};
      this.defines = defines;
      this.resize = resize;
    }
    setScene(scene) {
      this.scene = scene;
    }
    setGl(g) {
      gl2 = g;
    }
    setCamera(camera) {
      this.camera = camera;
    }
    setLight(light) {
      this.light = light;
    }
    setCanvas(canvas) {
      this.canvas = canvas;
    }
    getBuffer() {
      return Promise.all(
        this.scene.bin.map((url) => {
          if (typeof url === "string") {
            if (/base64/.test(url)) {
              const base64Index = url.indexOf(BASE64_MARKER) + BASE64_MARKER.length;
              const base64 = url.substring(base64Index);
              const raw = window.atob(base64);
              const buffer = new ArrayBuffer(raw.length);
              const array = new Uint8Array(buffer);
              for (let i = 0; i < raw.length; i++) {
                array[i] = raw.charCodeAt(i);
              }
              return buffer;
            } else {
              return fetchBinary(`${this.host}${url}`);
            }
          } else {
            return Promise.resolve(url);
          }
        })
      ).then((buffers) => {
        this.arrayBuffer = buffers;
      });
    }
    createProgram(defines) {
      let program;
      const programHash = defines.map((define2) => `${define2.name}${define2.value ?? 1}`).join("");
      if (this.programs[programHash]) {
        program = this.programs[programHash];
      } else {
        const defineStr = defines.map((define2) => `#define ${define2.name} ${define2.value ?? 1}
`).join("");
        const shaders = [vertex_default, fragment_default].map(
          (p) => p.replace(/#include ".*/g, (str) => {
            const [, subPath] = str.split('"');
            if (subPath.includes("vert")) {
              return vert_default;
            } else {
              return frag_default;
            }
          })
        ).map((p) => p.replace(/\n/, `
${defineStr}`));
        this.programs[programHash] = createProgram(shaders[0], shaders[1]);
        program = this.programs[programHash];
      }
      return program;
    }
    buildPrim(el, parent, name, skin, weights, primitive) {
      const m = this.json.materials && this.json.materials[primitive.material];
      if (this.json.extensions && this.json.extensions.EXT_lights_image_based) {
        this.defines.push({
          name: "SPHERICAL_HARMONICS",
          value: Math.ceil(Math.log(this.json.extensions.EXT_lights_image_based.lights[0].specularImageSize) * Math.LOG2E) + 10
        });
      }
      if (this.json.extensionsUsed && this.json.extensionsUsed.includes("KHR_texture_basisu")) {
        this.defines.push({ name: "BASISU" });
      }
      const defines = [...this.defines];
      const material = new Material2(m, this.textures, defines);
      if (skin !== void 0) {
        defines.push({
          name: "JOINTNUMBER",
          value: this.skins[skin].jointNames.length
        });
      }
      if (primitive.indices !== void 0 || primitive.attributes["TANGENT"] !== void 0) {
        defines.push({ name: "TANGENT" });
      }
      if (primitive.attributes["TEXCOORD_1"] !== void 0 || primitive.attributes["TEXCOORD_2"] !== void 0) {
        defines.push({ name: "MULTIUV" });
      }
      if (primitive.attributes["TEXCOORD_2"] !== void 0) {
        defines.push({ name: "MULTIUV2" });
      }
      if (primitive.attributes["COLOR_0"]) {
        defines.push({ name: "COLOR" });
      }
      const mesh = skin !== void 0 ? new SkinnedMesh(name, parent) : new Mesh(name, parent);
      const geometry = new Geometry(this.json, this.arrayBuffer, weights, this.draco, primitive);
      if (geometry.attributes.COLOR_0 && geometry.attributes.COLOR_0.constructor !== Float32Array) {
        defines.push({ name: "COLOR_255" });
      }
      if (primitive.attributes.TANGENT === void 0) {
        defines.push({ name: "USERIGHTHANDEDSYSTEM" });
      }
      if (primitive.extensions && primitive.extensions.KHR_materials_variants) {
        const variants = primitive.extensions.KHR_materials_variants.mappings.map((m2) => {
          return { ...m2, m: new Material2(this.json.materials[m2.material], this.textures, [...defines]) };
        });
        mesh.setVariants(variants);
      }
      mesh.setMode(primitive.mode);
      mesh.setMaterial(material);
      mesh.setGeometry(geometry);
      if (el.scale && el.scale[0] < 0) {
        mesh.setFrontFace();
      }
      if (el.scale && material.thicknessFactor) {
        material.thicknessFactor *= el.scale[0];
      }
      mesh.setDefines(material.defines);
      if (mesh instanceof SkinnedMesh) {
        mesh.skin = skin;
      }
      mesh.updateMatrix();
      mesh.calculateBounding();
      return mesh;
    }
    buildNode(parent, name) {
      const el = this.json.nodes[name];
      let child;
      if (el.camera !== void 0) {
        const camera = Object.assign(
          {
            zoom: 1,
            aspect: this.canvas ? this.canvas.offsetWidth / this.canvas.offsetHeight : 1
          },
          this.json.cameras[el.camera]
        );
        child = new Camera(camera, name, parent);
        const proj = calculateProjection(child.props);
        child.setProjection(proj);
        this.cameras.push(child);
      } else if (el.extensions && el.extensions.KHR_lights_punctual) {
        const light = this.json.extensions.KHR_lights_punctual.lights[el.extensions.KHR_lights_punctual.light];
        light.isInitial = false;
        child = new Light(light, name, parent);
        this.lights.push(child);
      } else {
        if (el.isBone !== void 0) {
          child = new Bone(name, parent);
        } else {
          child = new Object3D(name, parent);
        }
      }
      if (el.translation || el.rotation || el.scale) {
        child.setPosition(el.translation, el.rotation, el.scale);
      } else if (el.matrix) {
        child.setMatrix(el.matrix);
      }
      child.updateMatrix();
      child.id = el.name;
      parent.children.push(child);
      parent = child;
      if (el.mesh !== void 0) {
        parent.children.push(
          ...this.json.meshes[el.mesh].primitives.map(
            this.buildPrim.bind(this, el, parent, this.json.meshes[el.mesh].name, el.skin, this.json.meshes[el.mesh].weights)
          )
        );
      }
      if (el.children && el.children.length) {
        el.children.forEach(this.buildNode.bind(this, parent));
      }
    }
    calculateFov(isInitial) {
      const box = new Box();
      walk(this.scene, (node) => {
        if (node instanceof Mesh) {
          box.expand(node.geometry.boundingSphere);
        }
      });
      const size = box.getSize();
      if (isInitial) {
        const center = new Vector3().add(box.min).add(box.max).scale(0.5);
        const matrix = new Matrix4();
        matrix.translate(center.x, center.y, center.z);
        matrix.invert();
        this.scene.matrixWorld.multiply(matrix);
        walk(this.scene, (node) => {
          if (node instanceof Object3D) {
            node.updateMatrix();
          }
        });
      }
      this.cameras.forEach((c) => {
        c.modelSize = size;
      });
      this.resize();
    }
    async buildMesh() {
      if (this.json.extensionsUsed && this.json.extensionsUsed.includes("KHR_draco_mesh_compression")) {
        this.draco = await DecoderModule();
      }
      if (this.json.extensions && this.json.extensions.KHR_materials_variants) {
        this.scene.variants = this.json.extensions.KHR_materials_variants.variants;
      }
      this.json.scenes[this.json.scene !== void 0 ? this.json.scene : 0].nodes.forEach((n) => {
        if (this.json.nodes[n].extensions) {
          this.buildNode(this.scene, n);
        }
      });
      if (this.lights.length === 0 && this.light) {
        this.lights.push(this.light);
      }
      this.json.scenes[this.json.scene !== void 0 ? this.json.scene : 0].nodes.forEach((n) => {
        if (this.json.nodes[n].children && this.json.nodes[n].children.length && !this.json.nodes[n].extensions) {
          this.buildNode(this.scene, n);
        }
        if (this.json.nodes[n].mesh !== void 0) {
          this.buildNode(this.scene, n);
        }
        if (this.json.nodes[n].camera !== void 0) {
          this.buildNode(this.scene, n);
        }
      });
      walk(this.scene, (mesh) => {
        if (mesh instanceof Mesh) {
          if (mesh.material.alpha) {
            this.scene.transparentChildren.push(mesh);
          } else {
            this.scene.opaqueChildren.push(mesh);
          }
          this.scene.meshes.push(mesh);
          mesh.material.defines.push({ name: "LIGHTNUMBER", value: this.lights.length });
        }
        if (mesh instanceof Light) {
          const i = this.lights.findIndex((l) => l === mesh);
          walk(mesh.parent, (m) => {
            if (m instanceof Mesh) {
              m.material.defines.find((d) => d.name === "LIGHTINDEX").value = i;
            }
          });
        }
      });
      this.scene.opaqueChildren.sort((a, b) => a.distance - b.distance);
      this.scene.transparentChildren.sort((a, b) => a.distance - b.distance);
    }
    buildAnimation() {
      if (!this.json.animations) {
        return true;
      }
      for (const animation of this.json.animations) {
        const tracks = [];
        for (const channel of animation.channels) {
          const duration = 0;
          const sampler = animation.samplers[channel.sampler];
          if (sampler) {
            const { target } = channel;
            let name = target.node;
            let path = target.path;
            if (name === void 0) {
              const s = target.extensions.KHR_animation_pointer.pointer.split("/");
              const mat = this.json.materials[s[2]].name;
              name = this.scene.meshes.find((m) => m.material.name === mat).name;
              path = s.splice(3).join("/");
            }
            const input = animation.parameters !== void 0 ? animation.parameters[sampler.input] : sampler.input;
            const output = animation.parameters !== void 0 ? animation.parameters[sampler.output] : sampler.output;
            const inputAccessor = this.json.accessors[input];
            const outputAccessor = this.json.accessors[output];
            const inputBuffer = this.json.bufferViews[inputAccessor.bufferView];
            const outputBuffer = this.json.bufferViews[outputAccessor.bufferView];
            const inputArray = buildArray(
              this.arrayBuffer[inputBuffer.buffer],
              inputAccessor.componentType,
              calculateOffset(inputBuffer.byteOffset, inputAccessor.byteOffset),
              getDataType(inputAccessor.type) * inputAccessor.count
            );
            const outputArray = buildArray(
              this.arrayBuffer[outputBuffer.buffer],
              outputAccessor.componentType,
              calculateOffset(outputBuffer.byteOffset, outputAccessor.byteOffset),
              getDataType(outputAccessor.type) * outputAccessor.count
            );
            const meshes = [];
            walk(this.scene, (node) => {
              if (node.name === name) {
                if (path === "weights" && node instanceof Object3D) {
                  meshes.push(...node.children);
                } else {
                  meshes.push(node);
                }
              }
            });
            let component = path === "weights" ? meshes[0].geometry.targets.length : getDataType(outputAccessor.type);
            if (sampler.interpolation === "CUBICSPLINE") {
              component = component * 3;
            }
            const keys = [];
            for (let i = 0; i < inputArray.length; i++) {
              const firstT = inputArray[i];
              const firstV = outputArray.slice(i * component, (i + 1) * component);
              keys.push({
                time: firstT,
                value: normalize(firstV)
              });
            }
            if (keys.length >= 2) {
              if (meshes.length) {
                tracks.push({
                  duration: Math.max(keys[keys.length - 1].time, duration),
                  stoped: false,
                  meshes,
                  component,
                  type: path,
                  name: `${meshes[0].name}.${path}`,
                  keys,
                  interpolation: sampler.interpolation
                });
              }
            }
          }
        }
        this.tracks.push(tracks);
      }
    }
    buildSkin() {
      if (!this.json.skins) {
        return true;
      }
      for (const skin of this.json.skins) {
        const acc = this.json.accessors[skin.inverseBindMatrices];
        const buffer = this.json.bufferViews[acc.bufferView];
        const array = buildArray(
          this.arrayBuffer[buffer.buffer],
          acc.componentType,
          calculateOffset(buffer.byteOffset, acc.byteOffset),
          getDataType(acc.type) * acc.count
        );
        const v = {
          jointNames: skin.joints,
          inverseBindMatrices: array,
          bones: [],
          boneInverses: []
        };
        let i = 0;
        for (const join of v.jointNames) {
          this.json.nodes[join].isBone = true;
          const m = v.inverseBindMatrices;
          const mat = new Matrix4().set(m.slice(i * 16, (i + 1) * 16));
          v.boneInverses.push(mat);
          i++;
        }
        this.skins.push(v);
      }
    }
    getJson() {
      if (/glb/.test(this.url)) {
        return fetchBinary(this.url).then((b) => {
          const decoder = new TextDecoder("utf-8");
          const [jsonLength] = new Uint32Array(b, 12, 1);
          const jsonBuffer = new Uint8Array(b, 20, jsonLength);
          const json = JSON.parse(decoder.decode(jsonBuffer));
          const [bufferLength] = new Uint32Array(b, 20 + jsonLength, 1);
          const buffer = b.slice(28 + jsonLength, 28 + jsonLength + bufferLength);
          this.json = json;
          this.scene.bin.push(buffer);
        });
      } else {
        return fetchJSON(this.url).then((json) => {
          for (const key in json.buffers) {
            this.scene.bin.push(json.buffers[key].uri);
          }
          this.json = json;
          return true;
        });
      }
    }
    createSamplers() {
      const samplers = this.json.samplers || [{}];
      this.samplers = samplers.map((s) => {
        const sampler = gl2.createSampler();
        gl2.samplerParameteri(sampler, gl2.TEXTURE_MIN_FILTER, s.minFilter || gl2.NEAREST_MIPMAP_LINEAR);
        gl2.samplerParameteri(sampler, gl2.TEXTURE_MAG_FILTER, s.magFilter || gl2.LINEAR);
        gl2.samplerParameteri(sampler, gl2.TEXTURE_WRAP_S, s.wrapS || gl2.REPEAT);
        gl2.samplerParameteri(sampler, gl2.TEXTURE_WRAP_T, s.wrapT || gl2.REPEAT);
        return sampler;
      });
    }
    createSamplersWebGPU(WebGPU2) {
      function getSamplerParam(value) {
        const map = {
          9729: "linear",
          9728: "linear",
          10497: "repeat",
          33648: "mirror-repeat",
          33071: "clamp-to-edge"
        };
        return map[value];
      }
      const samplers = this.json.samplers || [{}];
      this.samplers = samplers.map((s) => {
        const sampler = WebGPU2.device.createSampler({
          mipmapFilter: "linear",
          magFilter: getSamplerParam(s.minFilter) || "linear",
          minFilter: getSamplerParam(s.magFilter) || "nearest",
          addressModeU: getSamplerParam(s.wrapS) || "repeat",
          addressModeV: getSamplerParam(s.wrapT) || "repeat",
          addressModeW: getSamplerParam(s.wrapS) || "repeat"
        });
        return sampler;
      });
    }
    createTexturesWebGPU(WebGPU2) {
      this.createTextures(this.handleTextureLoadedWebGPU.bind(this, WebGPU2));
    }
    createTexturesWebGL() {
      this.createTextures(this.handleTextureLoaded.bind(this));
    }
    createTextures(callback) {
      this.scene.meshes.forEach((mesh) => {
        const materials = [mesh.material, ...mesh.variants.map((m) => m.m)];
        const textureTypes = [
          "baseColorTexture",
          "metallicRoughnessTexture",
          "emissiveTexture",
          "normalTexture",
          "occlusionTexture",
          "clearcoatTexture",
          "clearcoatRoughnessTexture",
          "clearcoatNormalTexture",
          "sheenColorTexture",
          "sheenRoughnessTexture",
          "transmissionTexture",
          "specularTexture",
          "specularColorTexture",
          "thicknessTexture",
          "iridescenceThicknessTexture",
          "iridescenceTexture",
          "diffuseTransmissionTexture",
          "diffuseTransmissionColorTexture",
          "anisotropyTexture"
        ];
        const textureSRGB = [
          "baseColorTexture",
          "sheenColorTexture",
          "emissiveTexture",
          //@ts-ignore
          mesh.defines.find((d) => d.name === "SPECULARGLOSSINESSMAP") && "metallicRoughnessTexture"
        ];
        for (let i = 0; i < textureTypes.length; i++) {
          for (const material of materials) {
            const textureType = textureTypes[i];
            const t = material[textureType];
            if (!t) {
              continue;
            }
            if (textureSRGB.find((name) => name === textureType)) {
              t.srgb = true;
            }
            material[textureType] = callback(t, textureType);
          }
        }
      });
    }
    async initTextures(isbitmap) {
      if (!this.json.textures) {
        return true;
      }
      const texturesMap = {};
      let hasBasisu = false;
      this.json.textures.forEach((t) => {
        if (t.extensions && t.extensions.KHR_texture_basisu) {
          hasBasisu = true;
        }
        let source = t.extensions && t.extensions.KHR_texture_basisu ? t.extensions.KHR_texture_basisu.source : t.source;
        source = t.extensions && t.extensions.EXT_texture_webp ? t.extensions.EXT_texture_webp.source : source;
        const name = String(t.sampler) + String(source);
        texturesMap[name] = t;
        texturesMap[name].name = name;
        t.name = name;
      });
      if (hasBasisu) {
        await Promise.resolve().then(() => (init_libktx(), libktx_exports));
        LIBKTX({ preinitializedWebGLContext: gl2 }).then((module2) => {
          const transcoderConfig = gl2.device ? {
            astcSupported: gl2.features.has("texture-compression-astc"),
            etc1Supported: gl2.features.has("texture-compression-etc2"),
            etc2Supported: gl2.features.has("texture-compression-etc2"),
            bptcSupported: gl2.features.has("texture-compression-bc"),
            dxtSupported: false,
            pvrtcSupported: false
          } : {
            astcSupported: gl2.getExtension("WEBGL_compressed_texture_astc"),
            etc1Supported: gl2.getExtension("WEBGL_compressed_texture_etc1"),
            etc2Supported: gl2.getExtension("WEBGL_compressed_texture_etc"),
            dxtSupported: gl2.getExtension("WEBGL_compressed_texture_s3tc"),
            bptcSupported: gl2.getExtension("EXT_texture_compression_bptc"),
            pvrtcSupported: gl2.getExtension("WEBGL_compressed_texture_pvrtc") || gl2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc")
          };
          window.LIBKTX = module2;
          window.LIBKTX.transcoderConfig = transcoderConfig;
          window.LIBKTX.GL.makeContextCurrent(window.LIBKTX.GL.registerContext(gl2, { majorVersion: 2 }));
        });
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
      const promiseArr = Object.values(texturesMap).map((t) => {
        let s = t.extensions && t.extensions.KHR_texture_basisu ? t.extensions.KHR_texture_basisu.source : t.source;
        s = t.extensions && t.extensions.EXT_texture_webp ? t.extensions.EXT_texture_webp.source : s;
        const source = this.json.images[s];
        return fetchImage(
          isbitmap,
          this,
          //@ts-ignore
          source,
          {
            url: `${this.host}${source.uri}`,
            name: t.name
          },
          t.sampler
        );
      });
      return Promise.all(promiseArr).then((textures) => {
        this.textures = this.json.textures.map((t) => {
          return textures.find((j) => j.name === t.name);
        });
        return true;
      });
    }
    handleTextureLoadedWebGPU(WebGPU2, { image: bitmap, sampler, srgb, name }, textureType) {
      if (this.images.get(name)) {
        return this.images.get(name);
      }
      const { device } = WebGPU2;
      const s = this.samplers[sampler !== void 0 ? sampler : 0];
      const mipLevelCount = Math.max(1, Math.floor(Math.log2(Math.max(bitmap.width, bitmap.height))) - 2);
      const tex = device.createTexture({
        label: textureType,
        size: [bitmap.width, bitmap.height, 1],
        format: srgb ? "rgba8unorm-srgb" : "rgba8unorm",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
        mipLevelCount
      });
      device.queue.copyExternalImageToTexture(
        { source: bitmap },
        { premultipliedAlpha: false, texture: tex, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },
        { width: bitmap.width, height: bitmap.height, depthOrArrayLayers: 1 }
      );
      tex.sampler = s;
      tex.view = tex.createView();
      generateMipmaps(device, tex, bitmap.width, bitmap.height, mipLevelCount);
      this.images.set(name, tex);
      return tex;
    }
    handleTextureLoaded({ image, name, mimeType, sampler, srgb }) {
      const s = this.samplers[sampler !== void 0 ? sampler : 0];
      if (mimeType) {
        image.sampler = s;
        return image;
      }
      if (this.images.get(name)) {
        return this.images.get(name);
      }
      const t = gl2.createTexture();
      t.name = name;
      t.image = image.src.substr(image.src.lastIndexOf("/"));
      t.sampler = s;
      gl2.activeTexture(gl2[`TEXTURE${31}`]);
      gl2.bindTexture(gl2.TEXTURE_2D, t);
      gl2.pixelStorei(gl2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl2.pixelStorei(gl2.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl2.NONE);
      gl2.texImage2D(gl2.TEXTURE_2D, 0, srgb ? gl2.SRGB8_ALPHA8 : gl2.RGBA, gl2.RGBA, gl2.UNSIGNED_BYTE, image);
      gl2.generateMipmap(gl2.TEXTURE_2D);
      this.images.set(name, t);
      return t;
    }
    async getEnv(isBuffer) {
      if (this.json.extensions && this.json.extensions.EXT_lights_image_based) {
        const [env] = this.json.extensions.EXT_lights_image_based.lights;
        env.specularImages = env.specularImages.map((cube) => {
          return cube.map((img) => {
            const accessor = this.json.images[img];
            const bufferView = this.json.bufferViews[accessor.bufferView];
            const { buffer, byteLength, byteOffset } = bufferView;
            const view = new Uint8Array(this.arrayBuffer[buffer], byteOffset, byteLength);
            const blob = new Blob([view], { type: accessor.mimeType });
            const imageUrl = window.URL.createObjectURL(blob);
            const imageEl = new Image();
            imageEl.src = imageUrl;
            return imageEl;
          });
        });
        await new Promise((r) => setTimeout(r, 200));
        if (isBuffer) {
          for (const images of env.specularImages) {
            for (const image of images) {
              image.bitmap = await createImageBitmap(image);
            }
          }
        }
        return env;
      }
    }
  };

  // src/profile.ts
  var WebGPUProfiler = class {
    device;
    canTimestamp;
    opts;
    frames = [];
    frameCursor = 0;
    frameCpuStart = 0;
    frameIndex = 0;
    constructor(device, opts = {}) {
      this.device = device;
      this.canTimestamp = device.features.has("timestamp-query");
      this.opts = {
        maxTimestampWrites: opts.maxTimestampWrites ?? 64,
        framesInFlight: opts.framesInFlight ?? 2,
        label: opts.label ?? "WebGPUProfiler"
      };
      for (let i = 0; i < this.opts.framesInFlight; ++i) {
        this.frames.push(this.makeQueryFrame(i));
      }
    }
    /** Begin a new frame (CPU timing starts here). Call once per frame. */
    beginFrame() {
      this.frameCpuStart = performance.now();
      const f = this.currFrame();
      f.nextQuery = 0;
      f.passes.length = 0;
    }
    /** Wraps a render pass with timestampWrites when available. */
    beginTimedRenderPass(encoder, desc, label = "render") {
      if (!this.canTimestamp) {
        return encoder.beginRenderPass(desc);
      }
      const f = this.currFrame();
      const begin = this.reserveQuery(f);
      const end = this.reserveQuery(f);
      const timedDesc = {
        ...desc,
        timestampWrites: {
          querySet: f.querySet,
          beginningOfPassWriteIndex: begin,
          endOfPassWriteIndex: end
        }
      };
      f.passes.push({ label, kind: "render", startIndex: begin, endIndex: end });
      return encoder.beginRenderPass(timedDesc);
    }
    /** Wraps a compute pass with timestampWrites when available. */
    beginTimedComputePass(encoder, desc = {}, label = "compute") {
      if (!this.canTimestamp) {
        return encoder.beginComputePass(desc);
      }
      const f = this.currFrame();
      const begin = this.reserveQuery(f);
      const end = this.reserveQuery(f);
      const timedDesc = {
        ...desc,
        timestampWrites: {
          querySet: f.querySet,
          beginningOfPassWriteIndex: begin,
          endOfPassWriteIndex: end
        }
      };
      f.passes.push({ label, kind: "compute", startIndex: begin, endIndex: end });
      return encoder.beginComputePass(timedDesc);
    }
    /**
     * Must be called before finishing the encoder:
     * resolves the timestamp queries used this frame and stages them for readback.
     */
    resolveQueries(encoder) {
      if (!this.canTimestamp) return;
      const f = this.currFrame();
      if (!f.querySet || f.nextQuery === 0) return;
      encoder.resolveQuerySet(f.querySet, 0, f.nextQuery, f.resolveBuffer, 0);
      if (f.readbackBuffer.mapState === "unmapped") {
        encoder.copyBufferToBuffer(f.resolveBuffer, 0, f.readbackBuffer, 0, f.nextQuery * 8);
      }
    }
    /**
     * Finish the frame. Call AFTER you submit the command buffer(s).
     * Returns timings (CPU + GPU if available).
     */
    async endFrame() {
      const cpuEncodeMs = performance.now() - this.frameCpuStart;
      const f = this.currFrame();
      const frameIndex = this.frameIndex++;
      let gpuTotalMs;
      const passes = f.passes.map((p) => ({ ...p }));
      if (this.canTimestamp && f.readbackBuffer.mapState === "unmapped" && f.nextQuery > 0) {
        await f.readbackBuffer.mapAsync(GPUMapMode.READ);
        try {
          const u8 = new Uint8Array(f.readbackBuffer.getMappedRange(0, f.nextQuery * 8));
          const ns = new BigUint64Array(u8.buffer, u8.byteOffset, f.nextQuery);
          for (const p of passes) {
            const begin = ns[p.startIndex];
            const end = ns[p.endIndex];
            if (begin !== void 0 && end !== void 0) {
              p.beginNs = begin;
              p.endNs = end;
              const durNs = end - begin;
              p.durationMs = Number(durNs) / 1e6;
            }
          }
          gpuTotalMs = passes.reduce((a, p) => a + (p.durationMs ?? 0), 0);
        } finally {
          f.readbackBuffer.unmap();
        }
      }
      this.frameCursor = (this.frameCursor + 1) % this.opts.framesInFlight;
      return { frameIndex, cpuEncodeMs, gpuTotalMs, passes };
    }
    /** Destroy all GPU resources created by the profiler. */
    destroy() {
      for (const f of this.frames) {
        f.querySet?.destroy();
        f.resolveBuffer?.destroy();
        f.readbackBuffer?.destroy();
      }
      this.frames.length = 0;
    }
    // ------- internals -------
    currFrame() {
      return this.frames[this.frameCursor];
    }
    reserveQuery(f) {
      if (!this.canTimestamp) return 0;
      if (!f.querySet) throw new Error("Profiler querySet missing");
      if (f.nextQuery + 1 >= f.querySet.count) {
        console.warn(`[${this.opts.label}] Out of timestamp slots this frame \u2014 increase maxTimestampWrites.`);
        return Math.max(0, f.querySet.count - 1);
      }
      return f.nextQuery++;
    }
    makeQueryFrame(i) {
      if (!this.canTimestamp) {
        return { nextQuery: 0, passes: [] };
      }
      const count = this.opts.maxTimestampWrites;
      const querySet = this.device.createQuerySet({
        label: `${this.opts.label}/timestamps#${i}`,
        type: "timestamp",
        count
      });
      const resolveBuffer = this.device.createBuffer({
        label: `${this.opts.label}/resolve#${i}`,
        size: count * 8,
        // 64-bit per timestamp
        usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
      });
      const readbackBuffer = this.device.createBuffer({
        label: `${this.opts.label}/readback#${i}`,
        size: resolveBuffer.size,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      });
      return {
        querySet,
        resolveBuffer,
        readbackBuffer,
        nextQuery: 0,
        passes: []
      };
    }
  };

  // src/fps.ts
  var FPS = class {
    counterEl;
    fps;
    elapsedTime;
    lastTime;
    constructor() {
      this.counterEl = document.createElement("div");
      this.counterEl.setAttribute("style", "position: absolute; top: 0; right: 0; color: #fff; font-size: 30px; background: #000;");
      document.body.appendChild(this.counterEl);
      this.fps = 0;
      this.elapsedTime = 0;
      this.lastTime = 0;
    }
    tick(time) {
      this.fps++;
      this.elapsedTime += time - this.lastTime;
      this.lastTime = time;
      if (this.elapsedTime >= 1e3) {
        this.counterEl.innerHTML = String(this.fps);
        this.fps = 0;
        this.elapsedTime -= 1e3;
      }
    }
  };

  // src/postprocessors/base.ts
  var PostProcessor = class {
    canvas;
    camera;
    light;
    framebuffer;
    setCanvas(canvas) {
      this.canvas = canvas;
    }
    setCamera(camera) {
      this.camera = camera;
    }
    setLight(light) {
      this.light = light;
    }
    get width() {
      return this.canvas.offsetWidth * devicePixelRatio;
    }
    get height() {
      return this.canvas.offsetHeight * devicePixelRatio;
    }
  };

  // src/shaders/light.glsl
  var light_default = "#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\n// in vec4 tPos1;\r\n// in vec4 tPos2;\r\nin vec4 vPosLight1;\r\nin vec4 vPosLight2;\r\nout float color;\r\n\r\nuniform sampler2D lightTexture;\r\nuniform sampler2D cameraTexture;\r\n\r\nuniform mat4 proj;\r\nuniform mat4 light;\r\nuniform mat4 view;\r\nuniform vec3 viewPos;\r\nuniform vec3 lightPos;\r\n\r\nin vec3 outPositionView;\r\nin vec3 outPositionLight;\r\n\r\nconst int samples = 80;\r\n\r\nvoid main() {\r\n    float stp = 1.0/float(samples);\r\n	float k = 0.0;\r\n    float d = 0.0;\r\n\r\n    for (int i = 0; i < samples; i++) {\r\n\r\n        //vec4 vPos = mix(tPos1,tPos2,k);\r\n        vec4 vPosLight = mix(vPosLight1,vPosLight2,k);\r\n        k += stp;\r\n\r\n        vec3 ShadowTexC = (vPosLight.xyz/vPosLight.w) * 0.5 + 0.5;\r\n\r\n        float add = step(texture(lightTexture, ShadowTexC.xy).x, ShadowTexC.z);\r\n        d += add*stp;\r\n	}\r\n\r\n    vec3 viewDir = normalize(viewPos - outPositionView);\r\n    vec3 L = normalize(lightPos - outPositionLight);\r\n    color = min((1.0 - d), (1.0 - dot(L, viewDir)) * 0.2);\r\n}\r\n";

  // src/shaders/light-vert.glsl
  var light_vert_default = "#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec2 pos;\r\n\r\nout vec2 uv;\r\nout vec4 vPosLight1;\r\nout vec4 vPosLight2;\r\nout vec3 outPositionView;\r\nout vec3 outPositionLight;\r\n\r\nuniform mat4 proj;\r\nuniform mat4 light;\r\nuniform mat4 Iproj;\r\nuniform mat4 Iview;\r\nuniform mat4 view;\r\n\r\nvoid main() {\r\n    vec4 p1 = Iview * Iproj * vec4(pos, -1.0/16.0, 1.0);\r\n    vec4 p2 = Iview * Iproj * vec4(pos, 1.0/16.0, 1.0);\r\n\r\n	vPosLight1 = proj * light * p1;\r\n    vPosLight2 = proj * light * p2;\r\n    outPositionLight = vec3(light * p1);\r\n    outPositionView = vec3(view * p1);\r\n\r\n	uv = pos * 0.5 + 0.5;\r\n	gl_Position = vec4(pos, 0.0, 1.0);\r\n}\r\n";

  // src/postprocessors/light.ts
  var gl3;
  var Light2 = class extends PostProcessor {
    texture;
    program;
    scale;
    quadVAO;
    constructor() {
      super();
      this.scale = 2;
    }
    setGL(g) {
      gl3 = g;
    }
    preProcessing(PP) {
      gl3.clear(gl3.COLOR_BUFFER_BIT | gl3.DEPTH_BUFFER_BIT);
      PP.renderScene({ isprepender: true });
      gl3.bindFramebuffer(gl3.FRAMEBUFFER, this.framebuffer);
      gl3.framebufferTexture2D(gl3.FRAMEBUFFER, gl3.COLOR_ATTACHMENT0, gl3.TEXTURE_2D, this.texture, 0);
      gl3.useProgram(this.program);
      gl3.viewport(0, 0, this.width / this.scale, this.height / this.scale);
      gl3.bindVertexArray(this.quadVAO);
      const cam = Object.assign({}, this.camera.props, { zoom: 1 });
      const proj = calculateProjection(cam);
      gl3.uniformMatrix4fv(gl3.getUniformLocation(this.program, "Iproj"), false, new Matrix4().setInverseOf(proj).elements);
      gl3.uniformMatrix4fv(gl3.getUniformLocation(this.program, "proj"), false, proj.elements);
      gl3.uniformMatrix4fv(gl3.getUniformLocation(this.program, "Iview"), false, this.camera.matrixWorld.elements);
      gl3.uniformMatrix4fv(gl3.getUniformLocation(this.program, "view"), false, this.camera.matrixWorldInvert.elements);
      gl3.uniformMatrix4fv(gl3.getUniformLocation(this.program, "light"), false, this.light.matrixWorldInvert.elements);
      gl3.uniform1i(gl3.getUniformLocation(this.program, "lightTexture"), PP.preDepthTexture.index);
      gl3.uniform1i(gl3.getUniformLocation(this.program, "cameraTexture"), PP.depthTexture.index);
      gl3.uniform3fv(gl3.getUniformLocation(this.program, "viewPos"), this.camera.getPosition());
      gl3.uniform3fv(gl3.getUniformLocation(this.program, "lightPos"), this.light.getPosition());
      gl3.drawArrays(gl3.TRIANGLE_STRIP, 0, 4);
      gl3.bindFramebuffer(gl3.FRAMEBUFFER, null);
      gl3.viewport(0, 0, this.width, this.height);
    }
    buildScreenBuffer(PP) {
      this.framebuffer = gl3.createFramebuffer();
      gl3.bindFramebuffer(gl3.FRAMEBUFFER, this.framebuffer);
      this.texture = PP.createOneChannelTexture(this.scale);
      gl3.framebufferTexture2D(gl3.FRAMEBUFFER, gl3.COLOR_ATTACHMENT0, gl3.TEXTURE_2D, this.texture, 0);
      this.program = createProgram(light_vert_default, light_default);
      this.quadVAO = gl3.createVertexArray();
      gl3.bindVertexArray(this.quadVAO);
      const quadVBO = gl3.createBuffer();
      gl3.bindBuffer(gl3.ARRAY_BUFFER, quadVBO);
      gl3.bufferData(gl3.ARRAY_BUFFER, new Float32Array(quadVertex), gl3.STATIC_DRAW);
      gl3.enableVertexAttribArray(0);
      gl3.vertexAttribPointer(0, 2, gl3.FLOAT, false, 0, 0);
      gl3.bindVertexArray(null);
      gl3.bindFramebuffer(gl3.FRAMEBUFFER, null);
      return { name: "LIGHT" };
    }
    attachUniform(program) {
      gl3.uniform1i(gl3.getUniformLocation(program, "light"), this.texture.index);
    }
    postProcessing() {
    }
  };

  // src/renderer.ts
  var gl4;
  var Renderer = class {
    parse;
    PP;
    scene;
    Particles;
    fps;
    camera;
    getState;
    reflow;
    needUpdateProjection = true;
    needUpdateView = true;
    env;
    currentTrack;
    constructor(getState) {
      this.reflow = true;
      this.fps = new FPS();
      this.getState = getState;
      this.currentTrack = 0;
    }
    setEnv(env) {
      this.env = env;
    }
    setCamera(camera) {
      this.camera = camera;
    }
    setParticles(Particles) {
      this.Particles = Particles;
    }
    setScene(scene) {
      this.scene = scene;
    }
    setPp(pp) {
      this.PP = pp;
    }
    setGl(g) {
      gl4 = g;
    }
    setParser(parser) {
      this.parse = parser;
    }
    step(sec, v) {
      const val = interpolation(sec, v.keys);
      if (val[0] === -1 || val[1] === -1 || val[0] === 0 && val[1] === 0) {
        return false;
      }
      const current = v.keys[val[0]];
      const { component } = v;
      let vectorC;
      if (component === 3) {
        vectorC = Vector3;
      } else if (component === 4) {
        vectorC = Vector4;
      } else {
        vectorC = Vector;
      }
      const vector = new vectorC(current.value);
      if (v.type === "rotation") {
        for (const mesh of v.meshes) {
          const scale = mesh.matrix.getScaling();
          mesh.matrix.makeRotationFromQuaternion(vector.elements);
          mesh.matrix.scale(scale);
        }
      } else if (v.type === "scale") {
        for (const mesh of v.meshes) {
          if (mesh.matrix.animated) {
            const scale = mesh.matrix.getScaling();
            mesh.matrix.restoreScale(scale);
          }
          mesh.matrix.scale(vector);
          mesh.matrix.animated = true;
        }
      } else if (v.type === "translation") {
        for (const mesh of v.meshes) {
          mesh.matrix.setTranslate(vector);
        }
      }
    }
    spline(sec, v) {
      const val = interpolation(sec, v.keys);
      if (val[0] === -1 || val[1] === -1 || val[0] === 0 && val[1] === 0) {
        return false;
      }
      const t = sec;
      const t1 = v.keys[val[1]].time;
      const t0 = v.keys[val[0]].time;
      const stride = v.component;
      const td = t1 - t0;
      const p = (t - t0) / td;
      const pp = p * p;
      const ppp = pp * p;
      const s2 = -2 * ppp + 3 * pp;
      const s3 = ppp - pp;
      const s0 = 1 - s2;
      const s1 = s3 - pp + p;
      const result = new Float32Array(stride);
      for (let i = 0; i !== stride; i++) {
        const p0 = v.keys[val[0]].value[stride + i];
        const m0 = v.keys[val[0]].value[stride * 2 + i] * td;
        const p1 = v.keys[val[1]].value[stride + i];
        const m1 = v.keys[val[1]].value[i] * td;
        result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
        if (isNaN(result[i])) {
          return false;
        }
      }
      if (v.type === "rotation") {
        const out = new Vector4(result).normalize();
        for (const mesh of v.meshes) {
          const scale = mesh.matrix.getScaling();
          mesh.matrix.makeRotationFromQuaternion(out.elements);
          mesh.matrix.scale(scale);
        }
      } else if (v.type === "scale") {
        const out = new Vector3(result);
        for (const mesh of v.meshes) {
          if (mesh.matrix.animated) {
            const scale = mesh.matrix.getScaling();
            mesh.matrix.restoreScale(scale);
          }
          mesh.matrix.scale(out);
          mesh.matrix.animated = true;
        }
      } else if (v.type === "translation") {
        const out = new Vector3(result);
        for (const mesh of v.meshes) {
          mesh.matrix.setTranslate(out);
        }
      }
    }
    updateGeometry(mesh, geometry) {
      mesh.geometry.update(gl4, geometry);
    }
    interpolation(sec, v) {
      const val = interpolation(sec, v.keys);
      if (val[0] === -1 || val[1] === -1 || val[0] === 0 && val[1] === 0) {
        return false;
      }
      const startFrame = v.keys[val[0]];
      const endFrame = v.keys[val[1]];
      const t = val[2];
      const { component } = v;
      let vectorC;
      if (component === 2) {
        vectorC = Vector2;
      } else if (component === 3) {
        vectorC = Vector3;
      } else if (component === 4) {
        vectorC = Vector4;
      } else {
        vectorC = Vector;
      }
      const vector = new vectorC(startFrame.value);
      const vector2 = new vectorC(endFrame.value);
      if (v.type === "rotation") {
        const out = new Vector4();
        out.lerp(vector.elements, vector2.elements, t);
        for (const mesh of v.meshes) {
          const scale = mesh.matrix.getScaling();
          mesh.matrix.makeRotationFromQuaternion(out.elements);
          mesh.matrix.scale(scale);
        }
      } else if (v.type === "scale") {
        const out = new Vector3();
        out.lerp(vector.elements, vector2.elements, t);
        for (const mesh of v.meshes) {
          if (mesh.matrix.animated) {
            const scale = mesh.matrix.getScaling();
            mesh.matrix.restoreScale(scale);
          }
          mesh.matrix.scale(out);
          mesh.matrix.animated = true;
        }
      } else if (v.type === "weights") {
        const out = new Vector(vector.elements);
        out.lerp(vector.elements, vector2.elements, t);
        for (const mesh of v.meshes) {
          const geometry = {};
          for (const k in mesh.geometry.targets[0]) {
            if (k !== "POSITION") {
              continue;
            }
            geometry[k] = mesh.geometry.attributes[k].slice();
            for (let i = 0; i < out.elements.length; i++) {
              if (out.elements[i] === 0) {
                continue;
              }
              const offset = 0;
              for (let l = 0; l < geometry[k].length; l++) {
                geometry[k][l] += out.elements[i] * mesh.geometry.targets[i][k][l - offset];
              }
            }
          }
          this.updateGeometry(mesh, geometry);
        }
      } else if (v.type === "translation") {
        const out = new Vector3();
        out.lerp(vector.elements, vector2.elements, t);
        for (const mesh of v.meshes) {
          mesh.matrix.setTranslate(out);
        }
      } else {
        const out = v.component === 2 ? new Vector2() : v.component === 4 ? new Vector4() : new Vector(new Float32Array(1));
        out.lerp(vector.elements, vector2.elements, t);
        for (const mesh of v.meshes) {
          this.updateMaterial(mesh, v.type, out);
        }
      }
    }
    updateMaterial(mesh, type, out) {
      const s = type.split("/");
      const last = s[s.length - 1];
      if (last === "offset" || last === "rotation" || last === "scale") {
        const name = s[s.length - 4];
        mesh.material.setTexture(gl4, name, last, out);
      } else {
        mesh.repaint = true;
        mesh.material.setColor(gl4, s[s.length - 1], out);
      }
    }
    animate(sec) {
      if (!this.parse.tracks.length) {
        return;
      }
      const duration = Math.max(...this.parse.tracks.map((t) => t[0].duration));
      const increment = Math.floor(sec / duration);
      sec -= increment * duration;
      for (const track of this.parse.tracks.sort((a, b) => a[0].duration - b[0].duration)) {
        for (const v of track) {
          let result;
          switch (v.interpolation) {
            case "LINEAR":
              result = this.interpolation(sec, v);
              break;
            case "CUBICSPLINE":
              result = this.spline(sec, v);
              break;
            case "STEP":
              result = this.step(sec, v);
              break;
            default:
              result = this.interpolation(sec, v);
              break;
          }
          if (result === false) {
            continue;
          }
          for (const mesh of v.meshes) {
            walk(mesh, (node) => {
              node.updateMatrix();
              if (node instanceof Bone) {
                node.reflow = true;
              }
              if (node instanceof Mesh) {
                node.reflow = true;
              }
              if (node instanceof Camera && node === this.camera) {
                this.needUpdateView = true;
              }
            });
          }
          this.reflow = true;
        }
      }
    }
    render(time = 0) {
      const sec = time / 1e3;
      if (!window.__FORCE_DETERMINISTIC__) {
        this.animate(sec);
      }
      if (this.reflow) {
        if (this.PP.hasPrePass) {
          this.PP.bindPrePass();
          this.PP.preProcessing();
        }
        if (this.PP.hasPostPass) {
          this.PP.bindPostPass();
        }
        gl4.clear(gl4.COLOR_BUFFER_BIT | gl4.DEPTH_BUFFER_BIT);
        if (this.parse.json.extensions && this.parse.json.extensions.EXT_lights_image_based) {
          this.env.draw();
        }
        this.renderScene();
        this.clean();
        if (this.PP.postprocessors.some((p) => p instanceof Light2)) {
          gl4.bindFramebuffer(gl4.DRAW_FRAMEBUFFER, null);
          this.Particles.draw(time);
          this.reflow = true;
        }
        if (this.PP.hasPostPass) {
          this.PP.postProcessing();
        }
      }
      this.fps.tick(time);
      requestAnimationFrame(this.render.bind(this));
    }
    renderScene() {
      if (this.needUpdateView) {
        const planes = Frustum(this.camera.getViewProjMatrix());
        this.scene.meshes.forEach((mesh) => {
          mesh.visible = mesh.isVisible(planes);
        });
      }
      const s = this.getState();
      if (s.needUpdateView) {
        gl4.bindBufferBase(gl4.UNIFORM_BUFFER, 1, s.UBO);
        s.cameraBuffer.update(gl4, "view", s.camera.matrixWorldInvert.elements);
        s.cameraBuffer.update(gl4, "light", s.light.matrixWorldInvert.elements);
        gl4.bindBufferBase(gl4.UNIFORM_BUFFER, 3, s.lightUBO1);
        const lightPos = new Float32Array(3);
        lightPos.set(s.light.getPosition(), 0);
        s.lightPosBuffer.update(gl4, "lightPos", lightPos);
      }
      if (s.needUpdateProjection) {
        gl4.bindBufferBase(gl4.UNIFORM_BUFFER, 1, s.UBO);
        s.cameraBuffer.update(gl4, "projection", s.camera.projection.elements);
      }
      this.scene.meshes.forEach((mesh, i) => {
        if (mesh.reflow) {
          gl4.activeTexture(gl4[`TEXTURE${31}`]);
          gl4.bindTexture(gl4.TEXTURE_2D, s.storage2.texture);
          gl4.texSubImage2D(
            gl4.TEXTURE_2D,
            0,
            // Mipmap level
            0,
            // xoffset
            i,
            // yoffset
            this.scene.meshes[0].geometry.uniformBuffer.store.length / Float32Array.BYTES_PER_ELEMENT,
            1,
            gl4.RGBA,
            gl4.FLOAT,
            mesh.matrixWorld.elements
          );
          mesh.reflow = false;
        }
        if (mesh.repaint) {
          gl4.activeTexture(gl4[`TEXTURE${30}`]);
          gl4.bindTexture(gl4.TEXTURE_2D, s.storage.texture2);
          gl4.texSubImage2D(
            gl4.TEXTURE_2D,
            0,
            // Mipmap level
            0,
            // xoffset
            i,
            // yoffset
            this.scene.meshes[0].material.materialUniformBuffer.store.length / Float32Array.BYTES_PER_ELEMENT,
            1,
            gl4.RGBA,
            gl4.FLOAT,
            mesh.material.materialUniformBuffer.store
          );
          mesh.repaint = false;
        }
      });
      this.scene.opaqueChildren.forEach((mesh) => {
        if (mesh.visible) {
          mesh.draw(gl4, this.getState());
        }
      });
      if (this.scene.transparentChildren.length) {
        gl4.enable(gl4.BLEND);
        gl4.blendFunc(gl4.SRC_ALPHA, gl4.ONE_MINUS_SRC_ALPHA);
        this.scene.transparentChildren.forEach((mesh) => {
          if (mesh.visible) {
            mesh.draw(gl4, this.getState());
          }
        });
        gl4.disable(gl4.BLEND);
        gl4.blendFunc(gl4.ONE, gl4.ZERO);
      }
    }
    clean() {
      walk(this.scene, (node) => {
        node.reflow = false;
      });
      this.needUpdateView = false;
      this.needUpdateProjection = false;
      this.reflow = false;
    }
  };

  // src/renderer.webgpu.ts
  var WebGPU;
  var RendererWebGPU = class extends Renderer {
    profiler;
    setEnv(env) {
      this.env = env;
    }
    setGl(g) {
      WebGPU = g;
      this.profiler = new WebGPUProfiler(g.device, { maxTimestampWrites: 64 });
    }
    setPp(pp) {
      this.PP = pp;
    }
    async render(time = 0) {
      const sec = time / 1e3;
      if (!window.__FORCE_DETERMINISTIC__) {
        this.animate(sec);
      }
      if (this.reflow) {
        if (this.PP.hasPrePass) {
          this.PP.bindPrePass();
          this.PP.preProcessing();
          this.PP.target = void 0;
        }
        if (this.PP.hasPostPass) {
          this.PP.bindPostPass();
        }
        this.renderScene();
        this.clean();
        if (this.PP.hasPostPass) {
          this.PP.postProcessing();
        }
      }
      this.fps.tick(time);
      requestAnimationFrame(this.render.bind(this));
    }
    updateGeometry(mesh, geometry) {
      mesh.geometry.updateWebGPU(WebGPU, geometry);
    }
    updateMaterial(mesh, type, out) {
      const s = type.split("/");
      const last = s[s.length - 1];
      if (last === "offset" || last === "rotation" || last === "scale") {
        const name = s[s.length - 4];
        mesh.material.setTextureWebGPU(WebGPU, name, last, out);
      } else {
        mesh.repaint = true;
        mesh.material.setColorWebGPU(WebGPU, s[s.length - 1], out);
      }
    }
    async renderScene() {
      let { renderPassDescriptor, context, device } = WebGPU;
      const s = this.getState();
      if (s.needUpdateView) {
        const planes = Frustum(s.camera.getViewProjMatrix());
        this.scene.meshes.forEach((mesh) => {
          mesh.visible = mesh.isVisible(planes);
        });
        this.scene.opaqueChildren.sort((a, b) => a.distance - b.distance);
        this.scene.transparentChildren.sort((a, b) => a.distance - b.distance);
      }
      if (this.PP.target) {
        renderPassDescriptor = {
          ...renderPassDescriptor,
          label: "g-pass",
          colorAttachments: this.PP.target,
          // @ts-expect-error
          depthStencilAttachment: this.PP.pipeline.pass.depthStencilAttachment
        };
      } else {
        renderPassDescriptor = { ...renderPassDescriptor, label: "main-pass", colorAttachments: [
          {
            // attachment is acquired in render loop.
            view: context.getCurrentTexture().createView(),
            storeOp: "store",
            loadOp: "clear",
            clearValue: { r: 0, g: 0, b: 0, a: 1 }
          }
        ] };
      }
      this.profiler.beginFrame();
      const commandEncoder = device.createCommandEncoder({ label: "main-command-encoder" });
      const passEncoder = this.profiler.beginTimedRenderPass(commandEncoder, renderPassDescriptor, "main-pass");
      s.stateBuffer.updateWebGPU(WebGPU, "isTone", s.renderState.isprerefraction ? 0 : 1);
      if (s.needUpdateView) {
        s.cameraBuffer.updateWebGPU(WebGPU, "view", s.camera.matrixWorldInvert.elements);
        s.cameraBuffer.updateWebGPU(WebGPU, "light", s.light.matrixWorldInvert.elements);
        const lightPos = new Float32Array(3);
        lightPos.set(s.light.getPosition(), 0);
        s.lightPosBuffer.updateWebGPU(WebGPU, "lightPos", lightPos);
      }
      if (s.needUpdateProjection) {
        s.cameraBuffer.updateWebGPU(WebGPU, "projection", s.camera.projection.elements);
      }
      this.scene.opaqueChildren.forEach((mesh) => {
        if (mesh.visible) {
          passEncoder.setPipeline(mesh.pipeline);
          mesh.drawWebGPU(WebGPU, passEncoder, mesh.order, s);
        }
      });
      this.scene.transparentChildren.forEach((mesh) => {
        if (mesh.visible) {
          passEncoder.setPipeline(mesh.pipeline);
          mesh.drawWebGPU(WebGPU, passEncoder, mesh.order, s);
        }
      });
      passEncoder.end();
      this.profiler.resolveQueries(commandEncoder);
      device.queue.submit([commandEncoder.finish()]);
      if (false) {
        const timings = await this.profiler.endFrame();
        console.table({
          frame: timings.frameIndex,
          cpuEncodeMs: timings.cpuEncodeMs.toFixed(3),
          gpuTotalMs: timings.gpuTotalMs?.toFixed(3)
        });
        timings.passes.forEach((p) => {
          if (p.durationMs !== void 0) {
            console.log(`${p.label} (${p.kind}): ${p.durationMs.toFixed(3)} ms`);
          }
        });
      }
    }
  };

  // src/shaders/frag.webgpu.h
  var frag_webgpu_default = "#version 460\r\n\r\n#extension GL_EXT_samplerless_texture_functions:require\r\n\r\n// #ifdef DIFFUSE_TRANSMISSION\r\n//     #define SCATTERING 1\r\n// #endif\r\n\r\n#define texture2D(p, uv) texture(sampler2D(p, baseSampler), uv)\r\n#define textureCube(p, uv) texture(samplerCube(p, unfilteredSampler), uv)\r\n#define textureLodCube(p, uv, i) textureLod(samplerCube(p, unfilteredSampler), uv, i)\r\n#define textureLod2D(p, uv, i) textureLod(sampler2D(p, baseSampler2), uv, i)\r\n#define textureLod2D2(p, uv, i) textureLod(sampler2D(p, unfilteredSampler), uv, i)\r\n\r\n#define IBL 1\r\n#define USE_PBR 1\r\n#define WEBGPU 1\r\n\r\nlayout(location = 0) in vec2 outUV0;\r\n\r\n#ifdef TANGENT\r\n    layout(location = 4) in mat3 outTBN;\r\n#else\r\n    layout(location = 11) in vec3 outNormal;\r\n#endif\r\n#ifdef MULTIUV\r\nlayout(location = 1) in vec2 outUV2;\r\nlayout(location = 8) in vec2 outUV3;\r\n#endif\r\nlayout(location = 2) in vec3 outPosition;\r\nlayout(location = 3) in vec4 vColor;\r\nlayout(location = 7) in vec4 outPositionView;\r\nlayout(location = 12) in float id;\r\n\r\nlayout(location = 0) out vec4 color;\r\n// layout (location = 1) out vec4 normalColor;\r\nlayout (location = 1) out vec4 irradianceColor;\r\nlayout (location = 2) out vec4 albedoColor;\r\nlayout (location = 3) out vec4 specColor;\r\n\r\nlayout(set = 0, binding = 0) uniform Matrices {\r\n    mat4 model;\r\n};\r\nlayout(set = 0, binding = 39) uniform Matrices2 {\r\n    mat4 view;\r\n    mat4 projection;\r\n    mat4 light;\r\n    vec4 isShadow;\r\n};\r\nstruct Material {\r\n    vec4 baseColorFactor;\r\n    vec3 specularFactor;\r\n    vec3 specularColorFactor;\r\n    vec3 emissiveFactor;\r\n    vec4 glossinessFactor;\r\n    vec4 metallicFactor;\r\n    vec4 roughnessFactor;\r\n    vec4 clearcoatFactor;\r\n    vec4 clearcoatRoughnessFactor;\r\n    vec4 sheenColorFactor;\r\n    vec4 sheenRoughnessFactor;\r\n    vec4 transmissionFactor;\r\n    vec4 ior;\r\n    vec4 normalTextureScale;\r\n    vec4 attenuationColorFactor; \r\n    vec4 attenuationDistance; \r\n    vec4 thicknessFactor;\r\n    vec4 emissiveStrength;\r\n    vec4 anisotropyFactor;\r\n    vec4 iridescence;\r\n    vec4 diffuseTransmissionFactor;\r\n    vec4 dispersionFactor;\r\n};\r\nlayout(set = 0, binding = 1) buffer Uniforms {\r\n    Material data[];\r\n} materials;\r\n\r\nlayout(set = 0, binding = 27) uniform SphericalHarmonics {\r\n    vec4 vSphericalL00;\r\n    vec4 vSphericalL1_1;\r\n    vec4 vSphericalL10;\r\n    vec4 vSphericalL11;\r\n    vec4 vSphericalL2_2;\r\n    vec4 vSphericalL2_1;\r\n    vec4 vSphericalL20;\r\n    vec4 vSphericalL21;\r\n    vec4 vSphericalL22;\r\n    mat4 rotationMatrix;\r\n};\r\nlayout(set = 0, binding = 15) uniform LightColor {\r\n    vec4 lightColor[LIGHTNUMBER];\r\n};\r\nlayout(set = 0, binding = 17) uniform Spotdir {\r\n    vec4 spotdir[LIGHTNUMBER];\r\n};\r\nlayout(set = 0, binding = 18) uniform LightIntensity {\r\n    vec4 lightIntensity[LIGHTNUMBER];\r\n};\r\nlayout(set = 0, binding = 16) uniform LightPos {\r\n    vec4 lightPos[LIGHTNUMBER];\r\n};\r\n#if defined MATRICES\r\nlayout(set = 0, binding = 23) uniform TextureMatrices {\r\n    mat4 textureMatrices[MATRICES];\r\n};\r\n#endif\r\n\r\nlayout(set = 0, binding = 2) uniform sampler baseSampler;\r\nlayout(set = 0, binding = 37) uniform sampler baseSampler2;\r\nlayout(set = 0, binding = 24) uniform sampler unfilteredSampler;\r\n#ifdef BASECOLORTEXTURE\r\nlayout(set = 0, binding = 3) uniform texture2D baseColorTexture;\r\n#endif\r\n#ifdef METALROUGHNESSMAP\r\nlayout(set = 0, binding = 4) uniform texture2D metallicRoughnessTexture;\r\n#endif\r\n#ifdef NORMALMAP\r\nlayout(set = 0, binding = 5) uniform texture2D normalTexture;\r\n#endif\r\n#ifdef EMISSIVEMAP\r\nlayout(set = 0, binding = 6) uniform texture2D emissiveTexture;\r\n#endif\r\n#ifdef OCCLUSIONMAP\r\nlayout(set = 0, binding = 7) uniform texture2D occlusionTexture;\r\n#endif\r\n#ifdef CLEARCOATMAP\r\nlayout(set = 0, binding = 8) uniform texture2D clearcoatTexture;\r\n#endif\r\n#ifdef CLEARCOATROUGHMAP\r\nlayout(set = 0, binding = 9) uniform texture2D clearcoatRoughnessTexture;\r\n#endif\r\n#ifdef TRANSMISSIONMAP\r\nlayout(set = 0, binding = 10) uniform texture2D transmissionTexture;\r\n#endif\r\n#ifdef SHEENMAP\r\nlayout(set = 0, binding = 11) uniform texture2D sheenColorTexture;\r\nlayout(set = 0, binding = 12) uniform texture2D sheenRoughnessTexture;\r\n#endif\r\n#ifdef CLEARCOATNORMALMAP\r\nlayout(set = 0, binding = 13) uniform texture2D clearcoatNormalTexture;\r\n#endif\r\n#ifdef SPECULARMAP\r\nlayout(set = 0, binding = 14) uniform texture2D specularTexture;\r\n#endif\r\nlayout(set = 0, binding = 19) uniform textureCube prefilterMap;\r\nlayout(set = 0, binding = 20) uniform textureCube irradianceMap;\r\nlayout(set = 0, binding = 21) uniform texture2D brdfLUT;\r\n#ifdef SHADOWMAP\r\nlayout(set = 0, binding = 25) uniform texture2D depthTexture;\r\n#endif\r\nlayout(set = 0, binding = 26) uniform texture2D colorTexture;\r\nlayout(set = 0, binding = 28) uniform texture2D Sheen_E;\r\nlayout(set = 0, binding = 29) uniform texture2D thicknessTexture;\r\nlayout(set = 0, binding = 31) uniform texture2D anisotropyTexture;\r\nlayout(set = 0, binding = 32) uniform texture2D iridescenceThicknessTexture;\r\nlayout(set = 0, binding = 38) uniform texture2D iridescenceTexture;\r\nlayout(set = 0, binding = 33) uniform texture2D specularColorTexture;\r\nlayout(set = 0, binding = 34) uniform texture2D diffuseTransmissionTexture;\r\nlayout(set = 0, binding = 36) uniform texture2D diffuseTransmissionColorTexture;\r\nlayout(set = 0, binding = 35) uniform textureCube charlieMap;\r\n\r\nlayout(set = 0, binding = 30) uniform StateUniform {\r\n    vec4 isTone;\r\n    vec4 isIBL;\r\n    vec4 isDefaultLight;\r\n};\r\n";

  // src/shaders/vert.webgpu.h
  var vert_webgpu_default = "#version 460\r\nprecision highp float;\r\n\r\n#define WEBGPU 1\r\n\r\nlayout (location = 0) in vec3 inPosition;\r\nlayout (location = 1) in vec2 inUV;\r\nlayout (location = 2) in vec3 inNormal;\r\n#ifdef JOINTNUMBER\r\nlayout (location = 4) in vec4 inJoint;\r\nlayout (location = 5) in vec4 inWeight;\r\n#endif\r\n#ifdef TANGENT\r\nlayout (location = 3) in vec4 inTangent;\r\n#endif\r\n#ifdef COLOR\r\nlayout (location = 6) in vec4 inColor;\r\n#endif\r\n#ifdef MULTIUV\r\nlayout (location = 7) in vec2 inUV2;\r\n#endif\r\n#ifdef MULTIUV2\r\nlayout (location = 8) in vec2 inUV3;\r\n#endif\r\n\r\nlayout(location = 0) out vec2 outUV0;\r\nlayout(location = 1) out vec2 outUV2;\r\nlayout(location = 8) out vec2 outUV3;\r\nlayout(location = 2) out vec3 outPosition;\r\nlayout(location = 3) out vec4 vColor;\r\nlayout(location = 12) out float id;\r\n\r\n#ifdef TANGENT\r\n    layout(location = 4) out mat3 outTBN;\r\n#else\r\n    layout(location = 11) out vec3 outNormal;\r\n#endif\r\nlayout(location = 7) out vec4 outPositionView;\r\n\r\nstruct Transform {\r\n    mat4 model;\r\n};\r\n\r\nlayout(set = 0, binding = 0) buffer readonly Matrices {\r\n    Transform data[];\r\n} transforms;\r\nlayout(set = 0, binding = 39) uniform Matrices2 {\r\n    mat4 view;\r\n    mat4 projection;\r\n    mat4 light;\r\n    vec4 isShadow;\r\n};\r\n\r\n#ifdef JOINTNUMBER\r\nlayout(set = 0, binding = 22) uniform Skin {\r\n    mat4 joint[JOINTNUMBER];\r\n};\r\n#endif";

  // src/objects/pipeline.ts
  var programs = {};
  function create(device, glslang, wgsl, uniformBindGroup1, defines, hasTransmission, mode, frontFace) {
    const programHash = defines.map((define2) => `${define2.name}${define2.value ?? 1}`).join("");
    let program;
    if (programs[programHash]) {
      program = programs[programHash];
    } else {
      const defineStr = defines.map((define2) => `#define ${define2.name} ${define2.value ?? 1}
`).join("");
      const shaders = [vertex_default, fragment_default].map((p) => p.replace(/#include ".*/g, (str) => {
        const subPath = str.split('"')[1];
        if (subPath.includes("vert")) {
          return vert_webgpu_default;
        } else {
          return frag_webgpu_default;
        }
      })).map((p) => p.replace(/\n/, `
${defineStr}`));
      programs[programHash] = [convertGLSLtoWGSL(shaders[0], "vertex"), convertGLSLtoWGSL(shaders[1], "fragment")];
      program = programs[programHash];
    }
    const entries = [
      {
        binding: 0,
        visibility: GPUShaderStage.VERTEX,
        buffer: {
          type: "read-only-storage"
        }
      },
      {
        binding: 39,
        visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
        buffer: {}
      },
      {
        binding: 1,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: {
          type: "storage"
        }
      },
      {
        binding: 2,
        visibility: GPUShaderStage.FRAGMENT,
        sampler: {}
      },
      {
        binding: 37,
        visibility: GPUShaderStage.FRAGMENT,
        sampler: {}
      }
    ];
    uniformBindGroup1.forEach((u) => {
      if (u.binding > 2 && u.binding < 15 || u.binding === 29 || u.binding === 31 || u.binding === 32 || u.binding === 33 || u.binding === 34 || u.binding === 36 || u.binding === 38) {
        entries.push({
          binding: u.binding,
          visibility: GPUShaderStage.FRAGMENT,
          texture: {}
        });
      }
    });
    entries.push(
      {
        binding: 15,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: {}
      },
      {
        binding: 16,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: {}
      },
      {
        binding: 17,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: {}
      },
      {
        binding: 18,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: {}
      },
      {
        binding: 19,
        visibility: GPUShaderStage.FRAGMENT,
        texture: {
          viewDimension: "cube",
          sampleType: "float"
        }
      },
      {
        binding: 20,
        visibility: GPUShaderStage.FRAGMENT,
        texture: {
          viewDimension: "cube",
          sampleType: "float"
        }
      },
      {
        binding: 21,
        visibility: GPUShaderStage.FRAGMENT,
        texture: {
          sampleType: "float"
        }
      },
      {
        binding: 24,
        visibility: GPUShaderStage.FRAGMENT,
        sampler: {
          type: "filtering"
        }
      },
      {
        binding: 26,
        visibility: GPUShaderStage.FRAGMENT,
        texture: {}
      },
      {
        binding: 28,
        visibility: GPUShaderStage.FRAGMENT,
        texture: {}
      },
      {
        binding: 35,
        visibility: GPUShaderStage.FRAGMENT,
        texture: {
          viewDimension: "cube",
          sampleType: "float"
        }
      },
      {
        binding: 30,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: {}
      }
    );
    if (defines.find((d) => d.name === "JOINTNUMBER")) {
      entries.push({
        binding: 22,
        visibility: GPUShaderStage.VERTEX,
        buffer: {}
      });
    }
    if (defines.find((d) => d.name === "SPHERICAL_HARMONICS")) {
      entries.push({
        binding: 27,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: {}
      });
    }
    if (defines.find((d) => d.name === "MATRICES")) {
      entries.push({
        binding: 23,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: {}
      });
    }
    const bindGroupLayout = device.createBindGroupLayout({
      entries
    });
    const pipelineLayout = device.createPipelineLayout({
      bindGroupLayouts: [bindGroupLayout]
    });
    const vertexLayout = [3, 2, 3, 4];
    if (defines.find((d) => d.name === "JOINTNUMBER")) {
      vertexLayout.push(4, 4);
    }
    if (defines.find((d) => d.name === "COLOR")) {
      vertexLayout.push(4);
    }
    if (defines.find((d) => d.name === "MULTIUV")) {
      vertexLayout.push(2);
    }
    if (defines.find((d) => d.name === "MULTIUV2")) {
      vertexLayout.push(2);
    }
    const cubeVertexSize = Float32Array.BYTES_PER_ELEMENT * vertexLayout.reduce((a, b) => a + b, 0);
    const buffers = [
      {
        arrayStride: cubeVertexSize,
        attributes: [
          {
            shaderLocation: 0,
            offset: 0,
            format: "float32x3"
          },
          {
            shaderLocation: 1,
            offset: Float32Array.BYTES_PER_ELEMENT * vertexLayout[0],
            format: "float32x2"
          },
          {
            shaderLocation: 2,
            offset: Float32Array.BYTES_PER_ELEMENT * (vertexLayout[0] + vertexLayout[1]),
            format: "float32x3"
          },
          {
            shaderLocation: 3,
            offset: Float32Array.BYTES_PER_ELEMENT * (vertexLayout[0] + vertexLayout[1] + vertexLayout[2]),
            format: "float32x4"
          }
        ]
      }
    ];
    if (defines.find((d) => d.name === "JOINTNUMBER")) {
      buffers[0].attributes.push(
        {
          shaderLocation: 4,
          offset: Float32Array.BYTES_PER_ELEMENT * (vertexLayout[0] + vertexLayout[1] + vertexLayout[2] + vertexLayout[3]),
          format: "float32x4"
        },
        {
          shaderLocation: 5,
          offset: Float32Array.BYTES_PER_ELEMENT * (vertexLayout[0] + vertexLayout[1] + vertexLayout[2] + vertexLayout[3] + vertexLayout[4]),
          format: "float32x4"
        }
      );
    }
    if (defines.find((d) => d.name === "COLOR")) {
      buffers[0].attributes.push({
        shaderLocation: 6,
        offset: Float32Array.BYTES_PER_ELEMENT * (vertexLayout[0] + vertexLayout[1] + vertexLayout[2] + vertexLayout[3]),
        format: "float32x4"
      });
    }
    if (defines.find((d) => d.name === "MULTIUV")) {
      buffers[0].attributes.push({
        shaderLocation: 7,
        offset: Float32Array.BYTES_PER_ELEMENT * (vertexLayout[0] + vertexLayout[1] + vertexLayout[2] + vertexLayout[3]),
        format: "float32x2"
      });
    }
    if (defines.find((d) => d.name === "MULTIUV2")) {
      buffers[0].attributes.push({
        shaderLocation: 8,
        offset: Float32Array.BYTES_PER_ELEMENT * (vertexLayout[0] + vertexLayout[1] + vertexLayout[2] + vertexLayout[3] + vertexLayout[4]),
        format: "float32x2"
      });
    }
    function convertGLSLtoWGSL(code, type) {
      const spirv = glslang.compileGLSL(code, type);
      return wgsl.convertSpirV2WGSL(spirv);
    }
    const pipeline = device.createRenderPipeline({
      label: "main-pipeline",
      layout: pipelineLayout,
      vertex: {
        module: device.createShaderModule({
          code: program[0]
        }),
        entryPoint: "main",
        buffers
      },
      fragment: {
        module: device.createShaderModule({
          code: program[1]
        }),
        entryPoint: "main",
        targets: [
          {
            format: hasTransmission ? "bgra8unorm" : "bgra8unorm",
            blend: defines.find((d) => d.name === "ALPHATEST") ? {
              color: {
                srcFactor: "src-alpha",
                dstFactor: "one-minus-src-alpha",
                operation: "add"
              },
              alpha: {
                srcFactor: "src-alpha",
                dstFactor: "one-minus-src-alpha",
                operation: "add"
              }
            } : void 0
          }
          // { format: 'rgba16float' },
          // { format: 'rgba16float' },
          // { format: 'rgba16float' }
        ]
      },
      primitive: {
        frontFace: frontFace ? "cw" : "ccw",
        stripIndexFormat: getMode(mode).endsWith("strip") ? "uint32" : void 0,
        topology: getMode(mode),
        cullMode: defines.find((d) => d.name === "DOUBLESIDED") ? "none" : "back"
      },
      depthStencil: {
        depthWriteEnabled: true,
        depthCompare: "less",
        format: "depth32float"
      }
    });
    return pipeline;
  }
  function getMode(mode) {
    switch (mode) {
      case 0:
        return "point-list";
      case 1:
        return "line-list";
      case 2:
        return "line-list";
      case 3:
        return "line-strip";
      case 4:
        return "triangle-list";
      case 5:
        return "triangle-strip";
      case 6:
        return "triangle-list";
    }
  }

  // src/shaders/quad.glsl
  var quad_default = "#version 300 es\r\nlayout (location = 0) in vec2 pos;\r\n\r\nout vec2 uv;\r\n\r\nvoid main() {\r\n    uv = pos * 0.5 + 0.5;\r\n    gl_Position = vec4(pos, 0.0, 1.0); \r\n}\r\n";

  // src/shaders/ssao.glsl
  var ssao_default = "#version 300 es\nprecision highp float;\n\nin vec2 uv;\nout float color;\n\nconst int kernelSize = 32;\nconst float power = 5.0;\n\nuniform sampler2D normBuff;\nuniform sampler2D depthBuff;\nuniform sampler2D noice;\nuniform vec2 noiseScale;\nuniform vec3 kernels[kernelSize];\nuniform mat4 proj;\nuniform mat4 projI;\nuniform mat4 view;\nuniform float zFar;\nuniform float zNear;\nuniform float bias;\n\nvec3 getPositionFromDepth(float depth) {\n	vec4 clipSpaceLocation = vec4(0.0);\n	clipSpaceLocation.xy = uv * 2.0 - 1.0;\n	clipSpaceLocation.z = depth * 2.0 - 1.0;;\n	clipSpaceLocation.w = 1.0;\n	vec4 homogenousLocation = projI * clipSpaceLocation;\n	homogenousLocation.xyz = homogenousLocation.xyz / homogenousLocation.w;\n	return homogenousLocation.xyz;\n}\n\nvoid main() {\n	float depth = texture(depthBuff, uv).x;\n	if ((2.0 * zNear) / (zFar + zNear - depth * (zFar - zNear)) > 0.99) {\n		discard;\n	}\n\n	float radius = bias * 2.0;\n	vec3 pos = getPositionFromDepth(depth);\n	vec3 normal = normalize(vec3(view * texture(normBuff, uv)));\n	vec3 rvec = normalize(texture(noice, uv * noiseScale).xyz);\n\n	vec3 tangent = normalize(rvec - normal * dot(rvec, normal));\n	vec3 bitangent = cross(tangent, normal);\n	mat3 rotate = mat3(tangent, bitangent, normal);\n\n	float occlusion  = 0.0;\n	for (int i = 0; i < kernelSize; i++) {\n		vec3 samplePos = rotate * kernels[i];\n		samplePos = pos + samplePos * radius;\n\n		vec4 shift = proj * vec4(samplePos, 1.0);\n		shift.xy /= shift.w;\n		shift.xy = shift.xy * 0.5 + 0.5;\n\n		float sampleDepth = getPositionFromDepth(texture(depthBuff, shift.xy).r).z;\n\n		float distanceCheck = smoothstep(0.0, 1.0, radius / abs(pos.z - sampleDepth));\n		occlusion  += (sampleDepth >= samplePos.z + bias ? 1.0 : 0.0) * distanceCheck;\n	}\n\n	occlusion = 1.0 - (occlusion / float(kernelSize));\n	color = pow(occlusion, power);\n}\n";

  // src/shaders/blur.glsl
  var blur_default = "#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\nout vec4 color;\r\n\r\nuniform vec2 denom;\r\nuniform sampler2D uTexture;\r\n\r\nconst float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\r\n\r\nvoid main() {             \r\n    vec2 offset = 1.0 / vec2(textureSize(uTexture, 0));\r\n    vec3 result = texture(uTexture, uv).rgb * weight[0];\r\n\r\n    for (int i = 1; i < 5; ++i) {\r\n        result += texture(uTexture, uv + denom * (offset * float(i))).rgb * weight[i];\r\n        result += texture(uTexture, uv - denom * (offset * float(i))).rgb * weight[i];\r\n    }\r\n\r\n    color = vec4(result, 1.0);\r\n}\r\n";

  // src/postprocessors/ssao.ts
  var gl5;
  var noiceSize = 4;
  var kernelSize = 32;
  var SSAO = class extends PostProcessor {
    ssaoBlurTexture;
    ssaoTexture;
    noice;
    kernels;
    ssaoProgram;
    ssaoBlurProgram;
    scale;
    constructor() {
      super();
      this.scale = 2;
    }
    setGL(g) {
      gl5 = g;
    }
    attachUniform(program) {
      gl5.uniform1i(gl5.getUniformLocation(program, "ssao"), this.ssaoTexture.index);
    }
    postProcessing(PP) {
      gl5.bindFramebuffer(gl5.FRAMEBUFFER, this.framebuffer);
      gl5.framebufferTexture2D(gl5.FRAMEBUFFER, gl5.COLOR_ATTACHMENT0, gl5.TEXTURE_2D, this.ssaoTexture, 0);
      gl5.clearColor(...clearColor);
      gl5.clear(gl5.COLOR_BUFFER_BIT | gl5.DEPTH_BUFFER_BIT);
      gl5.useProgram(this.ssaoProgram);
      const cameraProps = this.camera.props.perspective || this.camera.props.orthographic;
      gl5.uniform1i(gl5.getUniformLocation(this.ssaoProgram, "normBuff"), PP.normalTexture.index);
      gl5.uniform1i(gl5.getUniformLocation(this.ssaoProgram, "depthBuff"), PP.depthTexture.index);
      gl5.uniform1i(gl5.getUniformLocation(this.ssaoProgram, "noice"), this.noice.index);
      gl5.uniform2f(
        gl5.getUniformLocation(this.ssaoProgram, "noiseScale"),
        this.width / this.scale / noiceSize,
        this.height / this.scale / noiceSize
      );
      gl5.uniform1f(gl5.getUniformLocation(this.ssaoProgram, "zFar"), cameraProps.zfar);
      gl5.uniform1f(gl5.getUniformLocation(this.ssaoProgram, "zNear"), cameraProps.znear);
      gl5.uniform1f(gl5.getUniformLocation(this.ssaoProgram, "bias"), Math.sqrt(this.camera.modelSize) * 0.03);
      gl5.uniformMatrix4fv(gl5.getUniformLocation(this.ssaoProgram, "proj"), false, this.camera.projection.elements);
      gl5.uniformMatrix4fv(gl5.getUniformLocation(this.ssaoProgram, "view"), false, this.camera.matrixWorldInvert.elements);
      gl5.uniformMatrix4fv(
        gl5.getUniformLocation(this.ssaoProgram, "projI"),
        false,
        new Matrix4().setInverseOf(this.camera.projection).elements
      );
      gl5.uniform3fv(gl5.getUniformLocation(this.ssaoProgram, "kernels"), this.kernels);
      gl5.viewport(0, 0, this.width / this.scale, this.height / this.scale);
      gl5.drawArrays(gl5.TRIANGLE_STRIP, 0, 4);
      gl5.framebufferTexture2D(gl5.FRAMEBUFFER, gl5.COLOR_ATTACHMENT0, gl5.TEXTURE_2D, this.ssaoBlurTexture, 0);
      gl5.clear(gl5.COLOR_BUFFER_BIT | gl5.DEPTH_BUFFER_BIT);
      gl5.useProgram(this.ssaoBlurProgram);
      gl5.uniform1i(gl5.getUniformLocation(this.ssaoBlurProgram, "uTexture"), this.ssaoTexture.index);
      gl5.uniform2f(gl5.getUniformLocation(this.ssaoBlurProgram, "denom"), 1, 0);
      gl5.drawArrays(gl5.TRIANGLE_STRIP, 0, 4);
      gl5.framebufferTexture2D(gl5.FRAMEBUFFER, gl5.COLOR_ATTACHMENT0, gl5.TEXTURE_2D, this.ssaoTexture, 0);
      gl5.uniform1i(gl5.getUniformLocation(this.ssaoBlurProgram, "uTexture"), this.ssaoBlurTexture.index);
      gl5.uniform2f(gl5.getUniformLocation(this.ssaoBlurProgram, "denom"), 0, 1);
      gl5.drawArrays(gl5.TRIANGLE_STRIP, 0, 4);
      gl5.bindFramebuffer(gl5.FRAMEBUFFER, null);
      gl5.viewport(0, 0, this.width, this.height);
    }
    buildScreenBuffer(pp) {
      this.framebuffer = gl5.createFramebuffer();
      gl5.bindFramebuffer(gl5.FRAMEBUFFER, this.framebuffer);
      this.ssaoTexture = pp.createOneChannelTexture(this.scale);
      this.ssaoBlurTexture = pp.createOneChannelTexture(this.scale);
      gl5.framebufferTexture2D(gl5.FRAMEBUFFER, gl5.COLOR_ATTACHMENT0, gl5.TEXTURE_2D, this.ssaoTexture, 0);
      this.ssaoProgram = createProgram(quad_default, ssao_default);
      this.ssaoBlurProgram = createProgram(quad_default, blur_default);
      this.buildNoice(pp);
      this.buildKernels();
      gl5.bindFramebuffer(gl5.FRAMEBUFFER, null);
      return { name: "SSAO" };
    }
    buildNoice(pp) {
      const noice = new Float32Array(noiceSize * noiceSize * 3);
      for (let i = 0; i < noiceSize * noiceSize; i++) {
        const v = new Vector3([random(0, 1) * 2 - 1, random(0, 1) * 2 - 1, 0.1]);
        noice[i * 3] = v.elements[0];
        noice[i * 3 + 1] = v.elements[1];
        noice[i * 3 + 2] = v.elements[2];
      }
      this.noice = pp.createNoiceTexture(noiceSize, noice);
    }
    buildKernels() {
      const kernels = new Array(kernelSize);
      for (let i = 0; i < kernels.length; i++) {
        kernels[i] = new Vector3([random(0, 1) * 2 - 1, random(0, 1) * 2 - 1, random(0, 1)]);
        kernels[i].normalize();
        kernels[i].scale(random(0, 1));
        let scale = i / kernels.length;
        scale = lerp(0.1, 1, scale * scale);
        kernels[i].scale(scale);
      }
      this.kernels = new Float32Array(kernels.length * 3);
      let j = 0;
      for (const m of kernels) {
        this.kernels.set(m.elements, j * 3);
        j++;
      }
    }
    preProcessing() {
    }
  };

  // src/shaders/bloom.glsl
  var bloom_default = "#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\nout vec4 color;\r\n\r\nuniform sampler2D diff;\r\n\r\nconst vec3 hdrColor = vec3(0.2126, 0.7152, 0.0722);\r\nconst float brightnessThreshold = 0.8;\r\n\r\nvoid main() {\r\n    vec3 c = texture(diff, uv).rgb;\r\n    float brightness = dot(c, hdrColor);\r\n    if (brightness > brightnessThreshold) {\r\n        color = vec4(c, 1.0);\r\n    } else {\r\n        color = vec4(0.0, 0.0, 0.0, 1.0);\r\n    }\r\n}\r\n";

  // src/postprocessors/bloom.ts
  var gl6;
  var Bloom = class extends PostProcessor {
    tempBlurTexture;
    blurTexture;
    blurTexture2;
    blurTexture3;
    blurTexture4;
    program;
    bloorProgram;
    hdrTexture;
    setGL(g) {
      gl6 = g;
    }
    attachUniform(program) {
      gl6.uniform1i(gl6.getUniformLocation(program, "bloom"), this.blurTexture.index);
    }
    postProcessing(PP) {
      gl6.bindFramebuffer(gl6.FRAMEBUFFER, this.framebuffer);
      gl6.useProgram(this.bloorProgram);
      gl6.framebufferTexture2D(gl6.FRAMEBUFFER, gl6.COLOR_ATTACHMENT0, gl6.TEXTURE_2D, this.hdrTexture, 0);
      gl6.uniform1i(gl6.getUniformLocation(this.bloorProgram, "diff"), PP.screenTexture.index);
      gl6.drawArrays(gl6.TRIANGLE_STRIP, 0, 4);
      gl6.useProgram(this.program);
      gl6.viewport(0, 0, this.width / 2, this.height / 2);
      this.renderBlur(this.hdrTexture, this.program);
      this.renderBlur(this.blurTexture, this.program);
      this.renderBlur(this.blurTexture, this.program);
      this.renderBlur(this.blurTexture, this.program);
      this.renderBlur(this.blurTexture, this.program);
      gl6.bindFramebuffer(gl6.FRAMEBUFFER, null);
      gl6.viewport(0, 0, this.width, this.height);
    }
    buildScreenBuffer(pp) {
      this.framebuffer = gl6.createFramebuffer();
      gl6.bindFramebuffer(gl6.FRAMEBUFFER, this.framebuffer);
      this.tempBlurTexture = pp.createDefaultTexture(2);
      this.blurTexture = pp.createDefaultTexture(2);
      this.hdrTexture = pp.createByteTexture();
      gl6.bindFramebuffer(gl6.FRAMEBUFFER, null);
      this.program = createProgram(quad_default, blur_default);
      this.bloorProgram = createProgram(quad_default, bloom_default);
      return { name: "BLOOM" };
    }
    renderBlur(inTexture, program) {
      gl6.framebufferTexture2D(gl6.FRAMEBUFFER, gl6.COLOR_ATTACHMENT0, gl6.TEXTURE_2D, this.tempBlurTexture, 0);
      gl6.clearColor(...clearColor);
      gl6.clear(gl6.COLOR_BUFFER_BIT | gl6.DEPTH_BUFFER_BIT | gl6.STENSIL_BUFFER_BIT);
      gl6.uniform1i(gl6.getUniformLocation(program, "uTexture"), inTexture.index);
      gl6.uniform2f(gl6.getUniformLocation(program, "denom"), 1, 0);
      gl6.drawArrays(gl6.TRIANGLE_STRIP, 0, 4);
      gl6.framebufferTexture2D(gl6.FRAMEBUFFER, gl6.COLOR_ATTACHMENT0, gl6.TEXTURE_2D, this.blurTexture, 0);
      gl6.uniform1i(gl6.getUniformLocation(program, "uTexture"), this.tempBlurTexture.index);
      gl6.uniform2f(gl6.getUniformLocation(program, "denom"), 0, 1);
      gl6.drawArrays(gl6.TRIANGLE_STRIP, 0, 4);
    }
    preProcessing() {
    }
  };

  // src/postprocessors/shadow.ts
  var gl7;
  var Shadow = class extends PostProcessor {
    setGL(g) {
      gl7 = g;
    }
    preProcessing(PP) {
      gl7.clear(gl7.COLOR_BUFFER_BIT | gl7.DEPTH_BUFFER_BIT);
      PP.renderScene({ isprepender: true });
    }
    buildScreenBuffer() {
      return { name: "SHADOW" };
    }
    attachUniform() {
    }
    postProcessing() {
    }
  };

  // src/postprocessors/refraction.ts
  var gl8;
  var Refraction = class extends PostProcessor {
    texture;
    setGL(g) {
      gl8 = g;
    }
    preProcessing(PP) {
      gl8.clear(gl8.COLOR_BUFFER_BIT | gl8.DEPTH_BUFFER_BIT);
      PP.renderScene({ isprerefraction: true });
      gl8.bindFramebuffer(gl8.FRAMEBUFFER, null);
      gl8.activeTexture(gl8[`TEXTURE${this.texture.index}`]);
      gl8.bindTexture(gl8.TEXTURE_2D, this.texture);
      gl8.generateMipmap(gl8.TEXTURE_2D);
    }
    preProcessingWebGPU(PP) {
      PP.target = [
        {
          // @ts-expect-error
          view: this.texture.view,
          storeOp: "store",
          loadOp: "clear",
          clearValue: { r: 0, g: 0, b: 0, a: 1 }
        },
        ...PP.pipeline.pass.colorAttachments.slice(1)
      ];
      PP.renderScene({ isprerefraction: true });
      const mipLevelCount = Math.max(1, Math.floor(Math.log2(Math.max(PP.width, PP.height))) - 2);
      generateMipmaps(gl8.device, this.texture.texture, PP.width, PP.height, mipLevelCount);
    }
    buildScreenBuffer(pp) {
      this.texture = pp.createDefaultTexture(1, true);
      gl8.generateMipmap(gl8.TEXTURE_2D);
      gl8.bindFramebuffer(gl8.FRAMEBUFFER, pp.preframebuffer);
      gl8.framebufferTexture2D(gl8.FRAMEBUFFER, gl8.COLOR_ATTACHMENT0, gl8.TEXTURE_2D, this.texture, 0);
      gl8.bindFramebuffer(gl8.FRAMEBUFFER, null);
      return { name: "REFRACTION" };
    }
    buildScreenBufferWebGPU(pp) {
      this.texture = pp.createDefaultTexture("refractionTexture");
      return { name: "REFRACTION" };
    }
    attachUniform() {
    }
    postProcessing() {
    }
    postProcessingWebGPU() {
    }
  };

  // src/shaders/composer.webgpu.glsl
  var composer_webgpu_default = "#version 460\r\nprecision highp float;\r\n\r\nlayout(location = 0) in vec2 inuv;\r\nlayout(location = 0) out vec4 color;\r\n\r\nlayout(set = 0, binding = 0) uniform texture2D original;\r\nlayout(set = 0, binding = 1) uniform texture2D position;\r\nlayout(set = 0, binding = 2) uniform texture2D normal;\r\nlayout(set = 0, binding = 3) uniform texture2D ssao;\r\nlayout(set = 0, binding = 4) uniform texture2D bloom;\r\nlayout(set = 0, binding = 5) uniform texture2D depth;\r\nlayout(set = 0, binding = 6) uniform texture2D preDepth;\r\nlayout(set = 0, binding = 7) uniform texture2D light;\r\nlayout(set = 0, binding = 8) uniform texture2D scattering;\r\nlayout(set = 0, binding = 9) uniform texture2D spec;\r\nlayout(set = 0, binding = 10) uniform sampler baseSampler;\r\n\r\nconst float gamma = 2.2;\r\n\r\nvoid main() {\r\n    vec2 uv = inuv;\r\n    uv.y = 1.0 - inuv.y;\r\n    vec3 c = texture(sampler2D(original, baseSampler), uv).rgb;\r\n    #ifdef BLOOM\r\n        c += texture(sampler2D(bloom, baseSampler), uv).rgb;\r\n    #endif\r\n    #ifdef SSAO\r\n        c *= texture(sampler2D(ssao, baseSampler), uv).r;\r\n    #endif\r\n    #ifdef LIGHT\r\n        c += texture(sampler2D(light, baseSampler), uv).r;\r\n    #endif\r\n    #ifdef SCATTERING\r\n        c = texture(sampler2D(scattering, baseSampler), uv).rgb;\r\n        c += texture(sampler2D(spec, baseSampler), uv).rgb;\r\n    #endif\r\n\r\n    c.rgb = pow(c.rgb, vec3(1.0 / gamma));\r\n\r\n    color = vec4(c, 1.0);\r\n}\r\n";

  // src/shaders/scattering.glsl
  var scattering_default = "#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\nout vec4 color;\r\n\r\n#define rcp(x) 1./x\r\n#define GOLDEN_RATIO 1.618033988749895\r\n#define TWO_PI 6.2831855\r\nvec2 Golden2dSeq(int i, float n) {\r\n    return vec2(float(i) / n + (0.5f / n), fract(float(i) * rcp(GOLDEN_RATIO)));\r\n}\r\nvec2 SampleDiskGolden(int i, int sampleCount) {\r\n    vec2 f = Golden2dSeq(i, float(sampleCount));\r\n    return vec2(sqrt(f.x), TWO_PI * f.y);\r\n}\r\nconst float PI = 3.1415926535897932384626433832795f;\r\nconst float RECIPROCAL_PI = 0.3183098861837907f;\r\nconst float RECIPROCAL_PI2 = 0.15915494309189535f;\r\nconst float HALF_MIN = 5.96046448e-08f;\r\nconst float LinearEncodePowerApprox = 2.2f;\r\nconst float GammaEncodePowerApprox = 1.0f / LinearEncodePowerApprox;\r\nconst vec3 LuminanceEncodeApprox = vec3(0.2126f, 0.7152f, 0.0722f);\r\nconst float Epsilon = 0.0000001f;\r\n#define saturate(x) clamp(x, 0.0, 1.0)\r\n#define absEps(x) abs(x)+Epsilon\r\n#define maxEps(x) max(x, Epsilon)\r\n#define saturateEps(x) clamp(x, Epsilon, 1.0)\r\nmat3 transposeMat3(mat3 inMatrix) {\r\n    vec3 i0 = inMatrix[0];\r\n    vec3 i1 = inMatrix[1];\r\n    vec3 i2 = inMatrix[2];\r\n    mat3 outMatrix = mat3(vec3(i0.x, i1.x, i2.x), vec3(i0.y, i1.y, i2.y), vec3(i0.z, i1.z, i2.z));\r\n    return outMatrix;\r\n}\r\nmat3 inverseMat3(mat3 inMatrix) {\r\n    float a00 = inMatrix[0][0], a01 = inMatrix[0][1], a02 = inMatrix[0][2];\r\n    float a10 = inMatrix[1][0], a11 = inMatrix[1][1], a12 = inMatrix[1][2];\r\n    float a20 = inMatrix[2][0], a21 = inMatrix[2][1], a22 = inMatrix[2][2];\r\n    float b01 = a22 * a11 - a12 * a21;\r\n    float b11 = -a22 * a10 + a12 * a20;\r\n    float b21 = a21 * a10 - a11 * a20;\r\n    float det = a00 * b01 + a01 * b11 + a02 * b21;\r\n    return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11), b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10), b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\r\n}\r\nfloat toLinearSpace(float color) {\r\n    return pow(color, LinearEncodePowerApprox);\r\n}\r\nvec3 toLinearSpace(vec3 color) {\r\n    return pow(color, vec3(LinearEncodePowerApprox));\r\n}\r\nvec4 toLinearSpace(vec4 color) {\r\n    return vec4(pow(color.rgb, vec3(LinearEncodePowerApprox)), color.a);\r\n}\r\nfloat toGammaSpace(float color) {\r\n    return pow(color, GammaEncodePowerApprox);\r\n}\r\nvec3 toGammaSpace(vec3 color) {\r\n    return pow(color, vec3(GammaEncodePowerApprox));\r\n}\r\nvec4 toGammaSpace(vec4 color) {\r\n    return vec4(pow(color.rgb, vec3(GammaEncodePowerApprox)), color.a);\r\n}\r\nfloat square(float value) {\r\n    return value * value;\r\n}\r\nvec3 square(vec3 value) {\r\n    return value * value;\r\n}\r\nfloat pow5(float value) {\r\n    float sq = value * value;\r\n    return sq * sq * value;\r\n}\r\nfloat getLuminance(vec3 color) {\r\n    return clamp(dot(color, LuminanceEncodeApprox), 0.f, 1.f);\r\n}\r\nfloat getRand(vec2 seed) {\r\n    return fract(sin(dot(seed.xy, vec2(12.9898f, 78.233f))) * 43758.5453f);\r\n}\r\nfloat dither(vec2 seed, float varianceAmount) {\r\n    float rand = getRand(seed);\r\n    float normVariance = varianceAmount / 255.0f;\r\n    float dither = mix(-normVariance, normVariance, rand);\r\n    return dither;\r\n}\r\nconst float rgbdMaxRange = 255.0f;\r\nvec4 toRGBD(vec3 color) {\r\n    float maxRGB = maxEps(max(color.r, max(color.g, color.b)));\r\n    float D = max(rgbdMaxRange / maxRGB, 1.f);\r\n    D = clamp(floor(D) / 255.0f, 0.f, 1.f);\r\n    vec3 rgb = color.rgb * D;\r\n    rgb = toGammaSpace(rgb);\r\n    return vec4(clamp(rgb, 0.f, 1.f), D);\r\n}\r\nvec3 fromRGBD(vec4 rgbd) {\r\n    rgbd.rgb = toLinearSpace(rgbd.rgb);\r\n    return rgbd.rgb / rgbd.a;\r\n}\r\nvec3 parallaxCorrectNormal(vec3 vertexPos, vec3 origVec, vec3 cubeSize, vec3 cubePos) {\r\n    vec3 invOrigVec = vec3(1.0f, 1.0f, 1.0f) / origVec;\r\n    vec3 halfSize = cubeSize * 0.5f;\r\n    vec3 intersecAtMaxPlane = (cubePos + halfSize - vertexPos) * invOrigVec;\r\n    vec3 intersecAtMinPlane = (cubePos - halfSize - vertexPos) * invOrigVec;\r\n    vec3 largestIntersec = max(intersecAtMaxPlane, intersecAtMinPlane);\r\n    float distance = min(min(largestIntersec.x, largestIntersec.y), largestIntersec.z);\r\n    vec3 intersectPositionWS = vertexPos + origVec * distance;\r\n    return intersectPositionWS - cubePos;\r\n}\r\nbool testLightingForSSS(float diffusionProfile) {\r\n    return diffusionProfile < 1.f;\r\n}\r\n\r\nconst vec3 diffusionS = vec3(1.0);\r\nconst float diffusionD = 1.0;\r\nconst float filterRadii = 16.5644;\r\n\r\nuniform sampler2D textureSampler;\r\nuniform sampler2D irradianceSampler;\r\nuniform sampler2D depthSampler;\r\nuniform sampler2D albedoSampler;\r\nconst float metersPerUnit = 0.1;\r\n\r\nconst float LOG2_E = 1.4426950408889634f;\r\nconst float SSS_PIXELS_PER_SAMPLE = 4.f;\r\nconst int _SssSampleBudget = 40;\r\n#define rcp(x) 1./x\r\n#define Sq(x) x*x\r\n#define SSS_BILATERAL_FILTER true\r\nvec3 EvalBurleyDiffusionProfile(float r, vec3 S) {\r\n    vec3 exp_13 = exp2(((LOG2_E * (-1.0f / 3.0f)) * r) * S);\r\n    vec3 expSum = exp_13 * (1.f + exp_13 * exp_13);\r\n    return (S * rcp(8.f * PI)) * expSum;\r\n}\r\nvec2 SampleBurleyDiffusionProfile(float u, float rcpS) {\r\n    u = 1.f - u;\r\n    float g = 1.f + (4.f * u) * (2.f * u + sqrt(1.f + (4.f * u) * u));\r\n    float n = exp2(log2(g) * (-1.0f / 3.0f));\r\n    float p = (g * n) * n;\r\n    float c = 1.f + p + n;\r\n    float d = (3.f / LOG2_E * 2.f) + (3.f / LOG2_E) * log2(u);\r\n    float x = (3.f / LOG2_E) * log2(c) - d;\r\n    float rcpExp = ((c * c) * c) * rcp((4.f * u) * ((c * c) + (4.f * u) * (4.f * u)));\r\n    float r = x * rcpS;\r\n    float rcpPdf = (8.f * PI * rcpS) * rcpExp;\r\n    return vec2(r, rcpPdf);\r\n}\r\nvec3 ComputeBilateralWeight(float xy2, float z, float mmPerUnit, vec3 S, float rcpPdf) {\r\n    float r = sqrt(xy2 + (z * mmPerUnit) * (z * mmPerUnit));\r\n    float area = rcpPdf;\r\n    return EvalBurleyDiffusionProfile(r, S) * area;\r\n}\r\nvoid EvaluateSample(int i, int n, vec3 S, float d, vec3 centerPosVS, float mmPerUnit, float pixelsPerMm, float phase, inout vec3 totalIrradiance, inout vec3 totalWeight) {\r\n    float scale = rcp(float(n));\r\n    float offset = rcp(float(n)) * 0.5f;\r\n    float sinPhase, cosPhase;\r\n    sinPhase = sin(phase);\r\n    cosPhase = cos(phase);\r\n    vec2 bdp = SampleBurleyDiffusionProfile(float(i) * scale + offset, d);\r\n    float r = bdp.x;\r\n    float rcpPdf = bdp.y;\r\n    float phi = SampleDiskGolden(i, n).y;\r\n    float sinPhi, cosPhi;\r\n    sinPhi = sin(phi);\r\n    cosPhi = cos(phi);\r\n    float sinPsi = cosPhase * sinPhi + sinPhase * cosPhi;\r\n    float cosPsi = cosPhase * cosPhi - sinPhase * sinPhi;\r\n    vec2 vec = r * vec2(cosPsi, sinPsi);\r\n    vec2 position;\r\n    float xy2;\r\n    vec2 texelSize = 1.0 / vec2(textureSize(depthSampler, 0));\r\n    position = uv + round((pixelsPerMm * r) * vec2(cosPsi, sinPsi)) * texelSize;\r\n    xy2 = r * r;\r\n    vec4 textureSample = texture(irradianceSampler, position);\r\n    float viewZ = texture(depthSampler, position).r;\r\n    vec3 irradiance = textureSample.rgb;\r\n    //if(testLightingForSSS(textureSample.a)) {\r\n        float relZ = viewZ - centerPosVS.z;\r\n        vec3 weight = ComputeBilateralWeight(xy2, relZ, mmPerUnit, S, rcpPdf);\r\n        totalIrradiance += weight * irradiance;\r\n        totalWeight += weight;\r\n    // } else {\r\n\r\n    // }\r\n}\r\n\r\nvoid main(void) {\r\n    vec4 irradianceAndDiffusionProfile = texture(irradianceSampler, uv);\r\n    vec3 centerIrradiance = irradianceAndDiffusionProfile.rgb;\r\n    int diffusionProfileIndex = int(round(irradianceAndDiffusionProfile.a * 255.f));\r\n    float centerDepth = 0.f;\r\n    vec4 inputColor = texture(textureSampler, uv);\r\n    bool passedStencilTest = testLightingForSSS(irradianceAndDiffusionProfile.a);\r\n    //if(passedStencilTest) {\r\n        centerDepth = texture(depthSampler, uv).r;\r\n    //}\r\n    if(!passedStencilTest) {\r\n        color = inputColor;\r\n        //return;\r\n    }\r\n    float distScale = 1.f;\r\n    vec3 S = diffusionS;\r\n    float d = diffusionD;\r\n    float filterRadius = filterRadii;\r\n    vec2 centerPosNDC = uv;\r\n    vec2 viewportSize = vec2(0.6520661863788713, 0.5773502691896256);\r\n    vec2 texelSize = 1.0 / vec2(textureSize(depthSampler, 0));\r\n    vec2 cornerPosNDC = uv + 0.5f * texelSize;\r\n    vec3 centerPosVS = vec3(centerPosNDC * viewportSize, 1.0f) * centerDepth;\r\n    vec3 cornerPosVS = vec3(cornerPosNDC * viewportSize, 1.0f) * centerDepth;\r\n    float mmPerUnit = 1000.f * (metersPerUnit * rcp(distScale));\r\n    float unitsPerMm = rcp(mmPerUnit);\r\n    float unitsPerPixel = 2.f * abs(cornerPosVS.x - centerPosVS.x);\r\n    float pixelsPerMm = rcp(unitsPerPixel) * unitsPerMm;\r\n    float filterArea = PI * Sq(filterRadius * pixelsPerMm);\r\n    int sampleCount = int(filterArea * rcp(SSS_PIXELS_PER_SAMPLE));\r\n    int sampleBudget = _SssSampleBudget;\r\n    int texturingMode = 0;\r\n    vec3 albedo = texture(albedoSampler, uv).rgb;\r\n    if(distScale == 0.f || sampleCount < 1) {\r\n        color = vec4(inputColor.rgb + albedo * centerIrradiance, 1.0f);\r\n        //return;\r\n    }\r\n    float phase = 0.f;\r\n    int n = min(sampleCount, sampleBudget);\r\n    vec3 centerWeight = vec3(0.f);\r\n    vec3 totalIrradiance = vec3(0.f);\r\n    vec3 totalWeight = vec3(0.f);\r\n    for(int i = 0; i < n; i++) {\r\n        EvaluateSample(i, n, S, d, centerPosVS, mmPerUnit, pixelsPerMm, phase, totalIrradiance, totalWeight);\r\n    }\r\n    totalWeight = max(totalWeight, HALF_MIN);\r\n    color = vec4(inputColor.rgb + albedo * max(totalIrradiance / totalWeight, vec3(0.0f)), 1.f);\r\n    //color = vec4(inputColor.rgb, 1.f);\r\n}\r\n";

  // src/shaders/scattering.webgpu.glsl
  var scattering_webgpu_default = "#version 460\r\nprecision highp float;\r\n\r\n#define DISABLE_UNIFORMITY_ANALYSIS\r\n\r\n#extension GL_EXT_samplerless_texture_functions:require\r\n\r\nlayout(location = 0) in vec2 inuv;\r\nlayout(location = 0) out vec4 color;\r\n\r\n#define rcp(x) 1./x\r\n#define GOLDEN_RATIO 1.618033988749895\r\n#define TWO_PI 6.2831855\r\nvec2 Golden2dSeq(int i, float n) {\r\n    return vec2(float(i) / n + (0.5f / n), fract(float(i) * rcp(GOLDEN_RATIO)));\r\n}\r\nvec2 SampleDiskGolden(int i, int sampleCount) {\r\n    vec2 f = Golden2dSeq(i, float(sampleCount));\r\n    return vec2(sqrt(f.x), TWO_PI * f.y);\r\n}\r\nconst float PI = 3.1415926535897932384626433832795f;\r\nconst float RECIPROCAL_PI = 0.3183098861837907f;\r\nconst float RECIPROCAL_PI2 = 0.15915494309189535f;\r\nconst float HALF_MIN = 5.96046448e-08f;\r\nconst float LinearEncodePowerApprox = 2.2f;\r\nconst float GammaEncodePowerApprox = 1.0f / LinearEncodePowerApprox;\r\nconst vec3 LuminanceEncodeApprox = vec3(0.2126f, 0.7152f, 0.0722f);\r\nconst float Epsilon = 0.0000001f;\r\n#define saturate(x) clamp(x, 0.0, 1.0)\r\n#define absEps(x) abs(x)+Epsilon\r\n#define maxEps(x) max(x, Epsilon)\r\n#define saturateEps(x) clamp(x, Epsilon, 1.0)\r\nmat3 transposeMat3(mat3 inMatrix) {\r\n    vec3 i0 = inMatrix[0];\r\n    vec3 i1 = inMatrix[1];\r\n    vec3 i2 = inMatrix[2];\r\n    mat3 outMatrix = mat3(vec3(i0.x, i1.x, i2.x), vec3(i0.y, i1.y, i2.y), vec3(i0.z, i1.z, i2.z));\r\n    return outMatrix;\r\n}\r\nmat3 inverseMat3(mat3 inMatrix) {\r\n    float a00 = inMatrix[0][0], a01 = inMatrix[0][1], a02 = inMatrix[0][2];\r\n    float a10 = inMatrix[1][0], a11 = inMatrix[1][1], a12 = inMatrix[1][2];\r\n    float a20 = inMatrix[2][0], a21 = inMatrix[2][1], a22 = inMatrix[2][2];\r\n    float b01 = a22 * a11 - a12 * a21;\r\n    float b11 = -a22 * a10 + a12 * a20;\r\n    float b21 = a21 * a10 - a11 * a20;\r\n    float det = a00 * b01 + a01 * b11 + a02 * b21;\r\n    return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11), b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10), b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\r\n}\r\nfloat toLinearSpace(float color) {\r\n    return pow(color, LinearEncodePowerApprox);\r\n}\r\nvec3 toLinearSpace(vec3 color) {\r\n    return pow(color, vec3(LinearEncodePowerApprox));\r\n}\r\nvec4 toLinearSpace(vec4 color) {\r\n    return vec4(pow(color.rgb, vec3(LinearEncodePowerApprox)), color.a);\r\n}\r\nfloat toGammaSpace(float color) {\r\n    return pow(color, GammaEncodePowerApprox);\r\n}\r\nvec3 toGammaSpace(vec3 color) {\r\n    return pow(color, vec3(GammaEncodePowerApprox));\r\n}\r\nvec4 toGammaSpace(vec4 color) {\r\n    return vec4(pow(color.rgb, vec3(GammaEncodePowerApprox)), color.a);\r\n}\r\nfloat square(float value) {\r\n    return value * value;\r\n}\r\nvec3 square(vec3 value) {\r\n    return value * value;\r\n}\r\nfloat pow5(float value) {\r\n    float sq = value * value;\r\n    return sq * sq * value;\r\n}\r\nfloat getLuminance(vec3 color) {\r\n    return clamp(dot(color, LuminanceEncodeApprox), 0.f, 1.f);\r\n}\r\nfloat getRand(vec2 seed) {\r\n    return fract(sin(dot(seed.xy, vec2(12.9898f, 78.233f))) * 43758.5453f);\r\n}\r\nfloat dither(vec2 seed, float varianceAmount) {\r\n    float rand = getRand(seed);\r\n    float normVariance = varianceAmount / 255.0f;\r\n    float dither = mix(-normVariance, normVariance, rand);\r\n    return dither;\r\n}\r\nconst float rgbdMaxRange = 255.0f;\r\nvec4 toRGBD(vec3 color) {\r\n    float maxRGB = maxEps(max(color.r, max(color.g, color.b)));\r\n    float D = max(rgbdMaxRange / maxRGB, 1.f);\r\n    D = clamp(floor(D) / 255.0f, 0.f, 1.f);\r\n    vec3 rgb = color.rgb * D;\r\n    rgb = toGammaSpace(rgb);\r\n    return vec4(clamp(rgb, 0.f, 1.f), D);\r\n}\r\nvec3 fromRGBD(vec4 rgbd) {\r\n    rgbd.rgb = toLinearSpace(rgbd.rgb);\r\n    return rgbd.rgb / rgbd.a;\r\n}\r\nvec3 parallaxCorrectNormal(vec3 vertexPos, vec3 origVec, vec3 cubeSize, vec3 cubePos) {\r\n    vec3 invOrigVec = vec3(1.0f, 1.0f, 1.0f) / origVec;\r\n    vec3 halfSize = cubeSize * 0.5f;\r\n    vec3 intersecAtMaxPlane = (cubePos + halfSize - vertexPos) * invOrigVec;\r\n    vec3 intersecAtMinPlane = (cubePos - halfSize - vertexPos) * invOrigVec;\r\n    vec3 largestIntersec = max(intersecAtMaxPlane, intersecAtMinPlane);\r\n    float distance = min(min(largestIntersec.x, largestIntersec.y), largestIntersec.z);\r\n    vec3 intersectPositionWS = vertexPos + origVec * distance;\r\n    return intersectPositionWS - cubePos;\r\n}\r\nbool testLightingForSSS(float diffusionProfile) {\r\n    return diffusionProfile < 1.f;\r\n}\r\n\r\nconst vec3 diffusionS = vec3(1.0);\r\nconst float diffusionD = 1.0;\r\nconst float filterRadii = 16.5644;\r\n\r\nlayout(set = 0, binding = 0) uniform texture2D textureSampler;\r\nlayout(set = 0, binding = 3) uniform texture2D irradianceSampler;\r\nlayout(set = 0, binding = 1) uniform texture2D depthSampler;\r\nlayout(set = 0, binding = 2) uniform texture2D albedoSampler;\r\nlayout(set = 0, binding = 4) uniform sampler baseSampler2;\r\nlayout(set = 0, binding = 5) uniform sampler baseSampler;\r\nconst float metersPerUnit = 0.1;\r\n\r\nconst float LOG2_E = 1.4426950408889634f;\r\nconst float SSS_PIXELS_PER_SAMPLE = 4.f;\r\nconst int _SssSampleBudget = 40;\r\n#define rcp(x) 1./x\r\n#define Sq(x) x*x\r\n#define SSS_BILATERAL_FILTER true\r\nvec3 EvalBurleyDiffusionProfile(float r, vec3 S) {\r\n    vec3 exp_13 = exp2(((LOG2_E * (-1.0f / 3.0f)) * r) * S);\r\n    vec3 expSum = exp_13 * (1.f + exp_13 * exp_13);\r\n    return (S * rcp(8.f * PI)) * expSum;\r\n}\r\nvec2 SampleBurleyDiffusionProfile(float u, float rcpS) {\r\n    u = 1.f - u;\r\n    float g = 1.f + (4.f * u) * (2.f * u + sqrt(1.f + (4.f * u) * u));\r\n    float n = exp2(log2(g) * (-1.0f / 3.0f));\r\n    float p = (g * n) * n;\r\n    float c = 1.f + p + n;\r\n    float d = (3.f / LOG2_E * 2.f) + (3.f / LOG2_E) * log2(u);\r\n    float x = (3.f / LOG2_E) * log2(c) - d;\r\n    float rcpExp = ((c * c) * c) * rcp((4.f * u) * ((c * c) + (4.f * u) * (4.f * u)));\r\n    float r = x * rcpS;\r\n    float rcpPdf = (8.f * PI * rcpS) * rcpExp;\r\n    return vec2(r, rcpPdf);\r\n}\r\nvec3 ComputeBilateralWeight(float xy2, float z, float mmPerUnit, vec3 S, float rcpPdf) {\r\n    float r = sqrt(xy2 + (z * mmPerUnit) * (z * mmPerUnit));\r\n    float area = rcpPdf;\r\n    return EvalBurleyDiffusionProfile(r, S) * area;\r\n}\r\n\r\nvoid main(void) {\r\n    vec2 uv = inuv;\r\n    uv.y = 1.0 - inuv.y;\r\n    vec4 irradianceAndDiffusionProfile = texture(sampler2D(irradianceSampler, baseSampler), uv);\r\n    vec3 centerIrradiance = irradianceAndDiffusionProfile.rgb;\r\n    int diffusionProfileIndex = int(round(irradianceAndDiffusionProfile.a * 255.f));\r\n    float centerDepth = 0.f;\r\n    vec4 inputColor = texture(sampler2D(textureSampler, baseSampler), uv);\r\n    bool passedStencilTest = testLightingForSSS(irradianceAndDiffusionProfile.a);\r\n    //if(passedStencilTest) {\r\n        centerDepth = texture(sampler2D(depthSampler, baseSampler2), uv).x;\r\n    //}\r\n    if(!passedStencilTest) {\r\n        color = inputColor;\r\n        //return;\r\n    }\r\n    float distScale = 1.f;\r\n    vec3 S = diffusionS;\r\n    float d = diffusionD;\r\n    float filterRadius = filterRadii;\r\n    vec2 centerPosNDC = uv;\r\n    vec2 viewportSize = vec2(0.6520661863788713, 0.5773502691896256);\r\n    vec2 texelSize = 1.0 / vec2(textureSize(depthSampler, 0));\r\n    vec2 cornerPosNDC = uv + 0.5f * texelSize;\r\n    vec3 centerPosVS = vec3(centerPosNDC * viewportSize, 1.0f) * centerDepth;\r\n    vec3 cornerPosVS = vec3(cornerPosNDC * viewportSize, 1.0f) * centerDepth;\r\n    float mmPerUnit = 1000.f * (metersPerUnit * rcp(distScale));\r\n    float unitsPerMm = rcp(mmPerUnit);\r\n    float unitsPerPixel = 2.f * abs(cornerPosVS.x - centerPosVS.x);\r\n    float pixelsPerMm = rcp(unitsPerPixel) * unitsPerMm;\r\n    float filterArea = PI * Sq(filterRadius * pixelsPerMm);\r\n    int sampleCount = int(filterArea * rcp(SSS_PIXELS_PER_SAMPLE));\r\n    int sampleBudget = _SssSampleBudget;\r\n    int texturingMode = 0;\r\n    vec3 albedo = texture(sampler2D(albedoSampler, baseSampler), uv).rgb;\r\n    if(distScale == 0.f || sampleCount < 1) {\r\n        color = vec4(inputColor.rgb + albedo * centerIrradiance, 1.0f);\r\n        //return;\r\n    }\r\n    float phase = 0.f;\r\n    int n = min(sampleCount, sampleBudget);\r\n    vec3 centerWeight = vec3(0.f);\r\n    vec3 totalIrradiance = vec3(0.f);\r\n    vec3 totalWeight = vec3(0.f);\r\n    for(int i = 0; i < n; i++) {\r\n        float scale = rcp(float(n));\r\n        float offset = rcp(float(n)) * 0.5f;\r\n        float sinPhase, cosPhase;\r\n        sinPhase = sin(phase);\r\n        cosPhase = cos(phase);\r\n        vec2 bdp = SampleBurleyDiffusionProfile(float(i) * scale + offset, d);\r\n        float r = bdp.x;\r\n        float rcpPdf = bdp.y;\r\n        float phi = SampleDiskGolden(i, n).y;\r\n        float sinPhi, cosPhi;\r\n        sinPhi = sin(phi);\r\n        cosPhi = cos(phi);\r\n        float sinPsi = cosPhase * sinPhi + sinPhase * cosPhi;\r\n        float cosPsi = cosPhase * cosPhi - sinPhase * sinPhi;\r\n        vec2 vec = r * vec2(cosPsi, sinPsi);\r\n        vec2 position;\r\n        float xy2;\r\n        vec2 texelSize = 1.0 / vec2(textureSize(depthSampler, 0));\r\n        position = uv + round((pixelsPerMm * r) * vec2(cosPsi, sinPsi)) * texelSize;\r\n        xy2 = r * r;\r\n        vec3 irradiance = texture(sampler2D(irradianceSampler, baseSampler), position).rgb;\r\n        float viewZ = texture(sampler2D(depthSampler, baseSampler2), position).r;\r\n        //if(testLightingForSSS(textureSample.a)) {\r\n            float relZ = viewZ - centerPosVS.z;\r\n            vec3 weight = ComputeBilateralWeight(xy2, relZ, mmPerUnit, S, rcpPdf);\r\n            totalIrradiance += weight * irradiance;\r\n            totalWeight += weight;\r\n        // } else {\r\n\r\n        // }\r\n    }\r\n    totalWeight = max(totalWeight, HALF_MIN);\r\n    color = vec4(inputColor.rgb + albedo * max(totalIrradiance / totalWeight, vec3(0.0f)), 1.f);\r\n    //color = vec4(inputColor.rgb, 1.f);\r\n}\r\n";

  // src/postprocessors/scattering.ts
  var gl9;
  var Scattering = class extends PostProcessor {
    output;
    program;
    pipeline;
    bindGroup;
    setGL(g) {
      gl9 = g;
    }
    attachUniform(program) {
      gl9.uniform1i(gl9.getUniformLocation(program, "scattering"), this.output.index);
    }
    attachUniformWebGPU() {
      return {
        binding: 8,
        // @ts-expect-error
        resource: this.output.view
      };
    }
    postProcessing(PP) {
      gl9.bindFramebuffer(gl9.FRAMEBUFFER, this.framebuffer);
      gl9.useProgram(this.program);
      gl9.framebufferTexture2D(gl9.FRAMEBUFFER, gl9.COLOR_ATTACHMENT0, gl9.TEXTURE_2D, this.output, 0);
      gl9.uniform1i(gl9.getUniformLocation(this.program, "textureSampler"), PP.screenTexture.index);
      gl9.uniform1i(gl9.getUniformLocation(this.program, "depthSampler"), PP.depthTexture.index);
      gl9.uniform1i(gl9.getUniformLocation(this.program, "albedoSampler"), PP.albedoTexture.index);
      gl9.uniform1i(gl9.getUniformLocation(this.program, "irradianceSampler"), PP.irradianceTexture.index);
      gl9.drawArrays(gl9.TRIANGLE_STRIP, 0, 4);
    }
    postProcessingWebGPU(PP) {
      const { device } = gl9;
      const commandEncoder = device.createCommandEncoder();
      const shadowPass = commandEncoder.beginRenderPass({
        colorAttachments: [{
          // @ts-expect-error
          view: this.output.view,
          storeOp: "store",
          loadOp: "clear",
          clearValue: { r: 0, g: 0, b: 0, a: 1 }
        }]
      });
      shadowPass.setPipeline(this.pipeline);
      shadowPass.setVertexBuffer(0, PP.vertexBuffer);
      shadowPass.setBindGroup(
        0,
        this.bindGroup
      );
      shadowPass.draw(6);
      shadowPass.end();
      device.queue.submit([commandEncoder.finish()]);
    }
    buildScreenBuffer(pp) {
      this.framebuffer = gl9.createFramebuffer();
      gl9.bindFramebuffer(gl9.FRAMEBUFFER, this.framebuffer);
      this.output = pp.createByteTexture();
      gl9.bindFramebuffer(gl9.FRAMEBUFFER, null);
      this.program = createProgram(quad_default, scattering_default);
      return { name: "SCATTERING" };
    }
    buildScreenBufferWebGPU(pp) {
      const entries = [
        {
          binding: 4,
          resource: pp.depthTexture.sampler
        },
        {
          binding: 5,
          resource: pp.screenTexture.sampler
        },
        {
          binding: 0,
          resource: pp.screenTexture.view
        },
        {
          binding: 1,
          resource: pp.depthTexture.view
        },
        {
          binding: 2,
          resource: pp.albedoTexture.view
        },
        {
          binding: 3,
          resource: pp.irradianceTexture.view
        }
      ];
      this.pipeline = pp.buildPipeline(
        gl9,
        quad_webgpu_default,
        scattering_webgpu_default,
        2,
        [
          {
            binding: 4,
            visibility: GPUShaderStage.FRAGMENT,
            sampler: {
              type: "non-filtering"
            }
          },
          {
            binding: 5,
            visibility: GPUShaderStage.FRAGMENT,
            sampler: {}
          },
          {
            binding: 1,
            visibility: GPUShaderStage.FRAGMENT,
            texture: {
              sampleType: "unfilterable-float"
            }
          },
          {
            binding: 2,
            visibility: GPUShaderStage.FRAGMENT,
            texture: {}
          },
          {
            binding: 3,
            visibility: GPUShaderStage.FRAGMENT,
            texture: {}
          },
          {
            binding: 0,
            visibility: GPUShaderStage.FRAGMENT,
            texture: {}
          }
        ],
        false,
        "scaterring"
      );
      this.bindGroup = gl9.device.createBindGroup({
        layout: this.pipeline.getBindGroupLayout(0),
        entries
      });
      this.output = pp.createDefaultTexture();
      return { name: "SCATTERING" };
    }
    preProcessing() {
    }
    preProcessingWebGPU() {
    }
  };

  // src/postprocessing.webgpu.ts
  var gl10;
  var processorsMap = {
    bloom: Bloom,
    ssao: SSAO,
    shadow: Shadow,
    light: Light2,
    refraction: Refraction,
    scattering: Scattering
  };
  var PostProcessing = class {
    screenTexture;
    normalTexture;
    irradianceTexture;
    specTexture;
    albedoTexture;
    depthTexture;
    preDepthTexture;
    fakeDepth;
    camera;
    renderer;
    canvas;
    framebuffer;
    preframebuffer;
    postprocessors;
    VAO;
    program;
    renderframebuffer;
    MSAA;
    renderScene;
    pipeline;
    target;
    vertexBuffer;
    bindGroup;
    hasPostPass = false;
    hasPrePass = false;
    constructor(processors, renderScene) {
      this.renderScene = renderScene;
      this.postprocessors = processors.map((name) => new processorsMap[name]());
    }
    add(name) {
      const p = new processorsMap[name]();
      p.setGL(gl10);
      this.postprocessors.push(p);
      this.hasPostPass = true;
    }
    addPrepass(name) {
      const p = new processorsMap[name]();
      p.setGL(gl10);
      this.postprocessors.push(p);
      this.hasPrePass = true;
    }
    setCamera(camera) {
      this.camera = camera;
      this.postprocessors.forEach((postProcessor) => {
        postProcessor.setCamera(camera);
      });
    }
    setLight(light) {
      this.postprocessors.forEach((postProcessor) => {
        postProcessor.light = light;
      });
    }
    setGl(g) {
      if (g) {
        gl10 = g;
        this.postprocessors.forEach((postProcessor) => {
          postProcessor.setGL(gl10);
        });
        this.fakeDepth = this.createNoiceTexture(1);
        this.fakeDepth.view = this.fakeDepth.texture.createView();
      }
    }
    setCanvas(canvas) {
      this.canvas = canvas;
      this.postprocessors.forEach((postProcessor) => {
        postProcessor.setCanvas(canvas);
      });
    }
    get width() {
      return this.canvas.offsetWidth * devicePixelRatio;
    }
    get height() {
      return this.canvas.offsetHeight * devicePixelRatio;
    }
    bindPrePass() {
    }
    bindPostPass() {
      this.target = this.pipeline.pass.colorAttachments;
    }
    preProcessing() {
      this.postprocessors.forEach((postProcessor) => postProcessor.preProcessingWebGPU(this));
    }
    postProcessing() {
      const { device, context } = gl10;
      this.postprocessors.forEach((postProcessor) => postProcessor.postProcessingWebGPU(this));
      const commandEncoder = device.createCommandEncoder({ label: "compose-command-encoder" });
      const shadowPass = commandEncoder.beginRenderPass({
        colorAttachments: [{
          // attachment is acquired in render loop.
          view: context.getCurrentTexture().createView(),
          storeOp: "store",
          loadOp: "clear",
          clearValue: { r: 0, g: 0, b: 0, a: 1 }
        }],
        depthStencilAttachment: {
          view: this.depthTexture.view,
          depthLoadOp: "clear",
          depthClearValue: 1,
          depthStoreOp: "store"
        }
      });
      shadowPass.setPipeline(this.pipeline);
      shadowPass.setVertexBuffer(0, this.vertexBuffer);
      shadowPass.setBindGroup(
        0,
        this.bindGroup
      );
      shadowPass.draw(6);
      shadowPass.end();
      device.queue.submit([commandEncoder.finish()]);
    }
    createByteTexture(label) {
      const sampler = gl10.device.createSampler({
        magFilter: "nearest",
        minFilter: "nearest"
      });
      const texture = gl10.device.createTexture({
        size: [this.width, this.height, 1],
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
        format: "bgra8unorm",
        label
      });
      return { texture, sampler, view: texture.createView() };
    }
    createDefaultTexture(label, scale = 1, hasMipmap = false) {
      const sampler = gl10.device.createSampler({
        magFilter: "linear",
        minFilter: "linear",
        mipmapFilter: hasMipmap ? "linear" : void 0
      });
      const mipLevelCount = Math.max(1, Math.floor(Math.log2(Math.max(this.width, this.height))) - 2);
      const texture = gl10.device.createTexture({
        label,
        mipLevelCount,
        size: [this.width / scale, this.height / scale, 1],
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
        format: "bgra8unorm"
      });
      return { texture, sampler, view: texture.createView({
        baseMipLevel: 0,
        mipLevelCount: 1
      }) };
    }
    createOneChannelTexture(scale = 1) {
      const sampler = gl10.device.createSampler({
        magFilter: "linear",
        minFilter: "linear"
      });
      const texture = gl10.device.createTexture({
        size: [this.width / scale, this.height / scale, 1],
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
        format: "r8uint"
      });
      return { texture, sampler, view: texture.createView() };
    }
    createDepthTexture(label) {
      const sampler = gl10.device.createSampler({
        magFilter: "nearest",
        minFilter: "nearest"
      });
      const texture = gl10.device.createTexture({
        size: [this.width, this.height, 1],
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
        format: "depth32float",
        label
      });
      return { texture, sampler, view: texture.createView() };
    }
    createNoiceTexture(size) {
      const sampler = gl10.device.createSampler({
        magFilter: "nearest",
        minFilter: "nearest",
        addressModeU: "repeat",
        addressModeV: "repeat"
      });
      const texture = gl10.device.createTexture({
        size: [size, size, 1],
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
        format: "rgba16float"
      });
      return { texture, sampler, view: texture.createView() };
    }
    buildVertex(WebGPU2, g) {
      const { device } = WebGPU2;
      const verticesBuffer = device.createBuffer({
        size: g.byteLength,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true
      });
      new Float32Array(verticesBuffer.getMappedRange()).set(g);
      verticesBuffer.unmap();
      return verticesBuffer;
    }
    buildPipeline(WebGPU2, vertex, fragment, vertexId, entries, screen = false, label) {
      const { device, glslang, wgsl } = WebGPU2;
      function convertGLSLtoWGSL(code, type) {
        const spirv = glslang.compileGLSL(code, type);
        return wgsl.convertSpirV2WGSL(spirv);
      }
      const bindGroupLayout = device.createBindGroupLayout({
        entries,
        label
      });
      const pipelineLayout = device.createPipelineLayout({
        bindGroupLayouts: [bindGroupLayout]
      });
      const fragmentCode = "diagnostic(off,derivative_uniformity);\n" + convertGLSLtoWGSL(fragment, "fragment");
      const pipeline = device.createRenderPipeline({
        label: "g-pipeline",
        layout: pipelineLayout,
        vertex: {
          module: device.createShaderModule({
            code: convertGLSLtoWGSL(vertex, "vertex")
          }),
          entryPoint: "main",
          buffers: [
            {
              arrayStride: Float32Array.BYTES_PER_ELEMENT * vertexId,
              attributes: [
                {
                  // position
                  shaderLocation: 0,
                  offset: 0,
                  format: `float32x${vertexId}`
                }
              ]
            }
          ]
        },
        fragment: {
          module: device.createShaderModule({
            code: fragmentCode,
            label
          }),
          entryPoint: "main",
          targets: [
            {
              format: screen ? "bgra8unorm" : "bgra8unorm"
            }
          ]
        },
        primitive: {
          topology: "triangle-list",
          cullMode: "none"
        },
        depthStencil: screen ? {
          depthWriteEnabled: true,
          depthCompare: "less",
          format: "depth32float"
        } : void 0
      });
      return pipeline;
    }
    buildScreenBuffer() {
      if (this.postprocessors.length === 0) {
        return true;
      }
      this.vertexBuffer = this.buildVertex(gl10, quadFull);
      this.screenTexture = this.createDefaultTexture("screenTexture");
      this.normalTexture = this.createByteTexture("normalTexture");
      this.irradianceTexture = this.createDefaultTexture("irradianceTexture");
      this.specTexture = this.createDefaultTexture("specTexture");
      this.albedoTexture = this.createDefaultTexture("albedoTexture");
      this.depthTexture = this.createDepthTexture("depthTexture");
      this.preDepthTexture = this.createDepthTexture("preDepthTexture");
      const colorAttachments = [
        {
          view: this.screenTexture.texture.createView(),
          storeOp: "store",
          loadOp: "clear",
          clearValue: { r: 0, g: 0, b: 0, a: 1 }
        }
        // {
        //     view: this.normalTexture.texture.createView(),
        //     storeOp: 'store' as GPUStoreOp,
        //     loadOp: 'clear',
        //     clearValue: { r: 0, g: 0, b: 0, a: 1.0 }
        // },
        // {
        //     view: this.irradianceTexture.texture.createView(),
        //     storeOp: 'store' as GPUStoreOp,
        //     loadOp: 'clear',
        //     clearValue: { r: 0, g: 0, b: 0, a: 1.0 }
        // },
        // {
        //     view: this.albedoTexture.texture.createView(),
        //     storeOp: 'store' as GPUStoreOp,
        //     loadOp: 'clear',
        //     clearValue: { r: 0, g: 0, b: 0, a: 1.0 }
        // },
        // {
        //     view: this.specTexture.texture.createView(),
        //     storeOp: 'store' as GPUStoreOp,
        //     loadOp: 'clear',
        //     clearValue: { r: 0, g: 0, b: 0, a: 1.0 }
        // }
      ];
      const defines = this.postprocessors.map((postProcessor) => postProcessor.buildScreenBufferWebGPU(this));
      const defineStr = defines.map((define2) => `#define ${define2.name} ${define2.value ?? 1}
`).join("");
      this.program = [quad_webgpu_default.replace(/\n/, `
${defineStr}`), composer_webgpu_default.replace(/\n/, `
${defineStr}`)];
      this.pipeline = this.buildPipeline(
        gl10,
        this.program[0],
        this.program[1],
        2,
        [
          {
            binding: 10,
            visibility: GPUShaderStage.FRAGMENT,
            sampler: {}
          },
          {
            binding: 0,
            visibility: GPUShaderStage.FRAGMENT,
            texture: {}
          },
          // {
          //     binding: 8,
          //     visibility: GPUShaderStage.FRAGMENT,
          //     texture: {}
          // },
          {
            binding: 9,
            visibility: GPUShaderStage.FRAGMENT,
            texture: {}
          }
        ],
        true,
        "screen"
      );
      this.pipeline.pass = {
        colorAttachments,
        depthStencilAttachment: {
          view: this.depthTexture.texture.createView(),
          depthLoadOp: "clear",
          depthClearValue: 1,
          depthStoreOp: "store"
        }
      };
      const entriesExternal = this.postprocessors.filter((p) => p.attachUniformWebGPU).map((postProcessor) => postProcessor.attachUniformWebGPU());
      const entries = [
        {
          binding: 10,
          resource: this.screenTexture.sampler
        },
        {
          binding: 0,
          resource: this.screenTexture.view
        },
        {
          binding: 9,
          resource: this.specTexture.view
        },
        ...entriesExternal
      ];
      this.bindGroup = gl10.device.createBindGroup({
        layout: this.pipeline.getBindGroupLayout(0),
        entries
      });
    }
    clear() {
      console.error("implement");
    }
  };

  // webgpu-memory.js
  var kFormatUniversalDefaults = {
    /** Texel block width. */
    blockWidth: void 0,
    /** Texel block height. */
    blockHeight: void 0,
    color: void 0,
    depth: void 0,
    stencil: void 0,
    /**
     * Info when this format can be used as a color render target. The format may require a feature
     * to actually be used as a render target. Eg: rg11b10ufloat which requires rg11b10ufloat-renderable
     * Call {@link isTextureFormatPossiblyUsableAsColorRenderAttachment} before having a device
     * Call {@link isTextureFormatColorRenderable}(device, format) to find out for a particular device.
     * Use {@link kPossibleColorRenderableTextureFormats} for params.
     */
    colorRender: void 0,
    /**
     * Whether the format can possibly be used as a multisample texture. The format may require a
     * feature to actually multisampled. Eg: rg11b10ufloat which requires rg11b10ufloat-renderable
     * Call {@link isTextureFormatPossiblyMultisampled} before having a device
     * Call {@link isTextureFormatMultisampled}(device, format) to find out for a particular device.
     * Use {@link kPossibleMultisampledTextureFormats} for params.
     */
    multisample: void 0,
    /** Optional feature required to use this format, or `undefined` if none. */
    feature: void 0,
    /** The base format for srgb formats. Specified on both srgb and equivalent non-srgb formats. */
    baseFormat: void 0,
    /** @deprecated Use `.color.bytes`, `.depth.bytes`, or `.stencil.bytes`. */
    bytesPerBlock: void 0
    // IMPORTANT:
    // Add new top-level keys both here and in TextureFormatInfo_TypeCheck.
  };
  function formatTableWithDefaults({ defaults, table }) {
    return Object.fromEntries(
      Object.entries(table).map(([k, row]) => [
        k,
        { ...kFormatUniversalDefaults, ...defaults, ...row }
      ])
      /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    );
  }
  var kRegularTextureFormatInfo = formatTableWithDefaults({
    defaults: { blockWidth: 1, blockHeight: 1 },
    table: {
      // plain, 8 bits per component
      r8unorm: {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 1
        },
        colorRender: { blend: true, resolve: true, byteCost: 1, alignment: 1 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      r8snorm: {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 1
        },
        multisample: false,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      r8uint: {
        color: {
          type: "uint",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 1
        },
        colorRender: { blend: false, resolve: false, byteCost: 1, alignment: 1 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      r8sint: {
        color: {
          type: "sint",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 1
        },
        colorRender: { blend: false, resolve: false, byteCost: 1, alignment: 1 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rg8unorm: {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 2
        },
        colorRender: { blend: true, resolve: true, byteCost: 2, alignment: 1 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rg8snorm: {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 2
        },
        multisample: false,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rg8uint: {
        color: {
          type: "uint",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 2
        },
        colorRender: { blend: false, resolve: false, byteCost: 2, alignment: 1 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rg8sint: {
        color: {
          type: "sint",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 2
        },
        colorRender: { blend: false, resolve: false, byteCost: 2, alignment: 1 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rgba8unorm: {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: true,
          readWriteStorage: false,
          bytes: 4
        },
        colorRender: { blend: true, resolve: true, byteCost: 8, alignment: 1 },
        multisample: true,
        baseFormat: "rgba8unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "rgba8unorm-srgb": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 4
        },
        colorRender: { blend: true, resolve: true, byteCost: 8, alignment: 1 },
        multisample: true,
        baseFormat: "rgba8unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rgba8snorm: {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: true,
          readWriteStorage: false,
          bytes: 4
        },
        multisample: false,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rgba8uint: {
        color: {
          type: "uint",
          copySrc: true,
          copyDst: true,
          storage: true,
          readWriteStorage: false,
          bytes: 4
        },
        colorRender: { blend: false, resolve: false, byteCost: 4, alignment: 1 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rgba8sint: {
        color: {
          type: "sint",
          copySrc: true,
          copyDst: true,
          storage: true,
          readWriteStorage: false,
          bytes: 4
        },
        colorRender: { blend: false, resolve: false, byteCost: 4, alignment: 1 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      bgra8unorm: {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 4
        },
        colorRender: { blend: true, resolve: true, byteCost: 8, alignment: 1 },
        multisample: true,
        baseFormat: "bgra8unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "bgra8unorm-srgb": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 4
        },
        colorRender: { blend: true, resolve: true, byteCost: 8, alignment: 1 },
        multisample: true,
        baseFormat: "bgra8unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      // plain, 16 bits per component
      r16uint: {
        color: {
          type: "uint",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 2
        },
        colorRender: { blend: false, resolve: false, byteCost: 2, alignment: 2 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      r16sint: {
        color: {
          type: "sint",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 2
        },
        colorRender: { blend: false, resolve: false, byteCost: 2, alignment: 2 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      r16float: {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 2
        },
        colorRender: { blend: true, resolve: true, byteCost: 2, alignment: 2 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rg16uint: {
        color: {
          type: "uint",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 4
        },
        colorRender: { blend: false, resolve: false, byteCost: 4, alignment: 2 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rg16sint: {
        color: {
          type: "sint",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 4
        },
        colorRender: { blend: false, resolve: false, byteCost: 4, alignment: 2 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rg16float: {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 4
        },
        colorRender: { blend: true, resolve: true, byteCost: 4, alignment: 2 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rgba16uint: {
        color: {
          type: "uint",
          copySrc: true,
          copyDst: true,
          storage: true,
          readWriteStorage: false,
          bytes: 8
        },
        colorRender: { blend: false, resolve: false, byteCost: 8, alignment: 2 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rgba16sint: {
        color: {
          type: "sint",
          copySrc: true,
          copyDst: true,
          storage: true,
          readWriteStorage: false,
          bytes: 8
        },
        colorRender: { blend: false, resolve: false, byteCost: 8, alignment: 2 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rgba16float: {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: true,
          readWriteStorage: false,
          bytes: 8
        },
        colorRender: { blend: true, resolve: true, byteCost: 8, alignment: 2 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      // plain, 32 bits per component
      r32uint: {
        color: {
          type: "uint",
          copySrc: true,
          copyDst: true,
          storage: true,
          readWriteStorage: true,
          bytes: 4
        },
        colorRender: { blend: false, resolve: false, byteCost: 4, alignment: 4 },
        multisample: false,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      r32sint: {
        color: {
          type: "sint",
          copySrc: true,
          copyDst: true,
          storage: true,
          readWriteStorage: true,
          bytes: 4
        },
        colorRender: { blend: false, resolve: false, byteCost: 4, alignment: 4 },
        multisample: false,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      r32float: {
        color: {
          type: "unfilterable-float",
          copySrc: true,
          copyDst: true,
          storage: true,
          readWriteStorage: true,
          bytes: 4
        },
        colorRender: { blend: false, resolve: false, byteCost: 4, alignment: 4 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rg32uint: {
        color: {
          type: "uint",
          copySrc: true,
          copyDst: true,
          storage: true,
          readWriteStorage: false,
          bytes: 8
        },
        colorRender: { blend: false, resolve: false, byteCost: 8, alignment: 4 },
        multisample: false,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rg32sint: {
        color: {
          type: "sint",
          copySrc: true,
          copyDst: true,
          storage: true,
          readWriteStorage: false,
          bytes: 8
        },
        colorRender: { blend: false, resolve: false, byteCost: 8, alignment: 4 },
        multisample: false,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rg32float: {
        color: {
          type: "unfilterable-float",
          copySrc: true,
          copyDst: true,
          storage: true,
          readWriteStorage: false,
          bytes: 8
        },
        colorRender: { blend: false, resolve: false, byteCost: 8, alignment: 4 },
        multisample: false,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rgba32uint: {
        color: {
          type: "uint",
          copySrc: true,
          copyDst: true,
          storage: true,
          readWriteStorage: false,
          bytes: 16
        },
        colorRender: { blend: false, resolve: false, byteCost: 16, alignment: 4 },
        multisample: false,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rgba32sint: {
        color: {
          type: "sint",
          copySrc: true,
          copyDst: true,
          storage: true,
          readWriteStorage: false,
          bytes: 16
        },
        colorRender: { blend: false, resolve: false, byteCost: 16, alignment: 4 },
        multisample: false,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rgba32float: {
        color: {
          type: "unfilterable-float",
          copySrc: true,
          copyDst: true,
          storage: true,
          readWriteStorage: false,
          bytes: 16
        },
        colorRender: { blend: false, resolve: false, byteCost: 16, alignment: 4 },
        multisample: false,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      // plain, mixed component width, 32 bits per texel
      rgb10a2uint: {
        color: {
          type: "uint",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 4
        },
        colorRender: { blend: false, resolve: false, byteCost: 8, alignment: 4 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rgb10a2unorm: {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 4
        },
        colorRender: { blend: true, resolve: true, byteCost: 8, alignment: 4 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      rg11b10ufloat: {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 4
        },
        colorRender: { blend: true, resolve: true, byteCost: 8, alignment: 4 },
        multisample: true,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      // packed
      rgb9e5ufloat: {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 4
        },
        multisample: false,
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      }
    }
  });
  var kSizedDepthStencilFormatInfo = formatTableWithDefaults({
    defaults: { blockWidth: 1, blockHeight: 1, multisample: true },
    table: {
      stencil8: {
        stencil: {
          type: "uint",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 1
        },
        bytesPerBlock: 1
      },
      depth16unorm: {
        depth: {
          type: "depth",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 2
        },
        bytesPerBlock: 2
      },
      depth32float: {
        depth: {
          type: "depth",
          copySrc: true,
          copyDst: false,
          storage: false,
          readWriteStorage: false,
          bytes: 4
        },
        bytesPerBlock: 4
      }
    }
  });
  var kUnsizedDepthStencilFormatInfo = formatTableWithDefaults({
    defaults: { blockWidth: 1, blockHeight: 1, multisample: true },
    table: {
      depth24plus: {
        depth: {
          type: "depth",
          copySrc: false,
          copyDst: false,
          storage: false,
          readWriteStorage: false,
          bytes: void 0
        },
        bytesPerBlock: 4
      },
      "depth24plus-stencil8": {
        depth: {
          type: "depth",
          copySrc: false,
          copyDst: false,
          storage: false,
          readWriteStorage: false,
          bytes: void 0
        },
        stencil: {
          type: "uint",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 1
        },
        bytesPerBlock: 4
      },
      "depth32float-stencil8": {
        depth: {
          type: "depth",
          copySrc: true,
          copyDst: false,
          storage: false,
          readWriteStorage: false,
          bytes: 4
        },
        stencil: {
          type: "uint",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 1
        },
        feature: "depth32float-stencil8",
        bytesPerBlock: 5
      }
    }
  });
  var kBCTextureFormatInfo = formatTableWithDefaults({
    defaults: {
      blockWidth: 4,
      blockHeight: 4,
      multisample: false,
      feature: "texture-compression-bc"
    },
    table: {
      "bc1-rgba-unorm": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 8
        },
        baseFormat: "bc1-rgba-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "bc1-rgba-unorm-srgb": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 8
        },
        baseFormat: "bc1-rgba-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "bc2-rgba-unorm": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "bc2-rgba-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "bc2-rgba-unorm-srgb": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "bc2-rgba-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "bc3-rgba-unorm": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "bc3-rgba-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "bc3-rgba-unorm-srgb": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "bc3-rgba-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "bc4-r-unorm": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 8
        },
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "bc4-r-snorm": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 8
        },
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "bc5-rg-unorm": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "bc5-rg-snorm": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "bc6h-rgb-ufloat": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "bc6h-rgb-float": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "bc7-rgba-unorm": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "bc7-rgba-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "bc7-rgba-unorm-srgb": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "bc7-rgba-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      }
    }
  });
  var kETC2TextureFormatInfo = formatTableWithDefaults({
    defaults: {
      blockWidth: 4,
      blockHeight: 4,
      multisample: false,
      feature: "texture-compression-etc2"
    },
    table: {
      "etc2-rgb8unorm": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 8
        },
        baseFormat: "etc2-rgb8unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "etc2-rgb8unorm-srgb": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 8
        },
        baseFormat: "etc2-rgb8unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "etc2-rgb8a1unorm": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 8
        },
        baseFormat: "etc2-rgb8a1unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "etc2-rgb8a1unorm-srgb": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 8
        },
        baseFormat: "etc2-rgb8a1unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "etc2-rgba8unorm": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "etc2-rgba8unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "etc2-rgba8unorm-srgb": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "etc2-rgba8unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "eac-r11unorm": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 8
        },
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "eac-r11snorm": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 8
        },
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "eac-rg11unorm": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "eac-rg11snorm": {
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      }
    }
  });
  var kASTCTextureFormatInfo = formatTableWithDefaults({
    defaults: {
      multisample: false,
      feature: "texture-compression-astc"
    },
    table: {
      "astc-4x4-unorm": {
        blockWidth: 4,
        blockHeight: 4,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-4x4-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-4x4-unorm-srgb": {
        blockWidth: 4,
        blockHeight: 4,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-4x4-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-5x4-unorm": {
        blockWidth: 5,
        blockHeight: 4,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-5x4-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-5x4-unorm-srgb": {
        blockWidth: 5,
        blockHeight: 4,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-5x4-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-5x5-unorm": {
        blockWidth: 5,
        blockHeight: 5,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-5x5-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-5x5-unorm-srgb": {
        blockWidth: 5,
        blockHeight: 5,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-5x5-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-6x5-unorm": {
        blockWidth: 6,
        blockHeight: 5,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-6x5-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-6x5-unorm-srgb": {
        blockWidth: 6,
        blockHeight: 5,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-6x5-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-6x6-unorm": {
        blockWidth: 6,
        blockHeight: 6,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-6x6-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-6x6-unorm-srgb": {
        blockWidth: 6,
        blockHeight: 6,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-6x6-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-8x5-unorm": {
        blockWidth: 8,
        blockHeight: 5,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-8x5-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-8x5-unorm-srgb": {
        blockWidth: 8,
        blockHeight: 5,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-8x5-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-8x6-unorm": {
        blockWidth: 8,
        blockHeight: 6,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-8x6-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-8x6-unorm-srgb": {
        blockWidth: 8,
        blockHeight: 6,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-8x6-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-8x8-unorm": {
        blockWidth: 8,
        blockHeight: 8,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-8x8-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-8x8-unorm-srgb": {
        blockWidth: 8,
        blockHeight: 8,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-8x8-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-10x5-unorm": {
        blockWidth: 10,
        blockHeight: 5,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-10x5-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-10x5-unorm-srgb": {
        blockWidth: 10,
        blockHeight: 5,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-10x5-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-10x6-unorm": {
        blockWidth: 10,
        blockHeight: 6,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-10x6-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-10x6-unorm-srgb": {
        blockWidth: 10,
        blockHeight: 6,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-10x6-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-10x8-unorm": {
        blockWidth: 10,
        blockHeight: 8,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-10x8-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-10x8-unorm-srgb": {
        blockWidth: 10,
        blockHeight: 8,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-10x8-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-10x10-unorm": {
        blockWidth: 10,
        blockHeight: 10,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-10x10-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-10x10-unorm-srgb": {
        blockWidth: 10,
        blockHeight: 10,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-10x10-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-12x10-unorm": {
        blockWidth: 12,
        blockHeight: 10,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-12x10-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-12x10-unorm-srgb": {
        blockWidth: 12,
        blockHeight: 10,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-12x10-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-12x12-unorm": {
        blockWidth: 12,
        blockHeight: 12,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-12x12-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      },
      "astc-12x12-unorm-srgb": {
        blockWidth: 12,
        blockHeight: 12,
        color: {
          type: "float",
          copySrc: true,
          copyDst: true,
          storage: false,
          readWriteStorage: false,
          bytes: 16
        },
        baseFormat: "astc-12x12-unorm",
        /*prettier-ignore*/
        get bytesPerBlock() {
          return this.color.bytes;
        }
      }
    }
  });
  ({ ...kBCTextureFormatInfo, ...kETC2TextureFormatInfo, ...kASTCTextureFormatInfo });
  ({ ...kRegularTextureFormatInfo });
  ({ ...kRegularTextureFormatInfo, ...kSizedDepthStencilFormatInfo });
  ({ ...kRegularTextureFormatInfo, ...kSizedDepthStencilFormatInfo });
  ({ ...kSizedDepthStencilFormatInfo, ...kUnsizedDepthStencilFormatInfo });
  ({ ...kRegularTextureFormatInfo, ...kSizedDepthStencilFormatInfo, ...kUnsizedDepthStencilFormatInfo });
  var kTextureFormatInfo = {
    ...kRegularTextureFormatInfo,
    ...kSizedDepthStencilFormatInfo,
    ...kUnsizedDepthStencilFormatInfo,
    ...kBCTextureFormatInfo,
    ...kETC2TextureFormatInfo,
    ...kASTCTextureFormatInfo
  };
  var webgpuMemoryIdSymbol = Symbol("webgpu-memory-object-id");
  var deviceIdToDeviceWeakRef = /* @__PURE__ */ new Map();
  var nextId = 1;
  var allWebGPUObjectsById = /* @__PURE__ */ new Map();
  var globalRunningTotal = 0;
  var globalMaxTotal = 0;
  function addDeviceObject(device, webgpuObject, category, size) {
    let id = webgpuObject[webgpuMemoryIdSymbol];
    if (!id) {
      id = nextId++;
      webgpuObject[webgpuMemoryIdSymbol] = id;
    }
    const deviceId = device[webgpuMemoryIdSymbol];
    const info = {
      ref: new WeakRef(webgpuObject),
      id,
      deviceId,
      category,
      size
    };
    allWebGPUObjectsById.set(id, info);
    if (typeof size === "function") {
      size = size(webgpuObject);
      info.oldSize = size;
    }
    if (!isNaN(size)) {
      const deviceInfo = allWebGPUObjectsById.get(deviceId);
      updateDeviceInfoRunningTotal(deviceInfo, size);
    }
  }
  function updateDeviceInfoRunningTotal(deviceInfo, size) {
    deviceInfo.runningTotal = (deviceInfo.runningTotal ?? 0) + size;
    deviceInfo.maxTotal = Math.max(deviceInfo.maxTotal ?? 0, deviceInfo.runningTotal);
    globalRunningTotal = globalRunningTotal + size;
    globalMaxTotal = Math.max(globalMaxTotal, globalRunningTotal);
  }
  function addDeviceMem(device, webgpuObject, category, size) {
    addDeviceObject(device, webgpuObject, category, size);
  }
  function deviceExists(deviceId) {
    const ref = deviceIdToDeviceWeakRef.get(deviceId);
    return ref && !!ref.deref();
  }
  function freeObjectById(id, webgpuObject) {
    const obj = allWebGPUObjectsById.get(id);
    const sizer = obj?.size;
    const size = webgpuObject && typeof sizer === "function" ? sizer(webgpuObject) : sizer;
    if (!isNaN(size)) {
      const deviceInfo = allWebGPUObjectsById.get(obj.deviceId);
      if (deviceInfo) {
        updateDeviceInfoRunningTotal(deviceInfo, -size);
      }
    }
    allWebGPUObjectsById.delete(id);
  }
  function freeObject(webgpuObject) {
    const id = webgpuObject[webgpuMemoryIdSymbol];
    freeObjectById(id, webgpuObject);
  }
  function getWebGPUMemoryUsage(device) {
    const memory = {
      total: 0,
      buffer: 0,
      texture: 0,
      querySet: 0,
      canvas: 0,
      maxTotal: 0
    };
    const resources = {
      buffer: 0,
      texture: 0,
      querySet: 0
    };
    const info = { memory, resources };
    const requestedDeviceId = device && device[webgpuMemoryIdSymbol];
    const idsToDelete = [];
    for (const [id, info2] of allWebGPUObjectsById.entries()) {
      const { ref, deviceId, category, size } = info2;
      const webgpuObject = ref.deref();
      if (!webgpuObject || !deviceExists(deviceId)) {
        idsToDelete.push(id);
      } else {
        if (!requestedDeviceId || deviceId === requestedDeviceId) {
          resources[category] = (resources[category] || 0) + 1;
          if (size) {
            const numBytes = typeof size === "function" ? size(webgpuObject) : size;
            memory.total += numBytes;
            memory[category] += numBytes;
          }
          if (category === "device") {
            memory.maxTotal += info2.maxTotal;
          }
        }
      }
    }
    if (!device) {
      memory.maxTotal = globalMaxTotal;
    }
    idsToDelete.forEach((id) => freeObjectById(id));
    return info;
  }
  function computeTextureMemorySize(texture) {
    const { blockWidth, blockHeight, bytesPerBlock } = kTextureFormatInfo[texture.format];
    let size = 0;
    let width = texture.width;
    let height = texture.height;
    let depth = texture.depthOrArrayLayers;
    for (let level = 0; level < texture.mipLevelCount; ++level) {
      const blocksAcross = Math.ceil(width * texture.sampleCount / blockWidth);
      const blocksDown = Math.ceil(height * texture.sampleCount / blockHeight);
      const numBlocks = blocksAcross * blocksDown * depth;
      const bytesUsed = numBlocks * bytesPerBlock;
      size += bytesUsed;
      width = Math.max(1, width / 2 | 0);
      height = Math.max(1, height / 2 | 0);
      depth = texture.dimension === "3d" ? Math.max(1, depth / 2 | 0) : depth;
    }
    return size;
  }
  function addBuffer(device, buffer) {
    const bytesUsed = buffer.size;
    addDeviceMem(device, buffer, "buffer", bytesUsed);
  }
  function removeBuffer(buffer) {
    freeObject(buffer);
  }
  function addTexture(device, texture) {
    const bytesUsed = computeTextureMemorySize(texture);
    addDeviceMem(device, texture, "texture", bytesUsed);
  }
  function removeTexture(texture) {
    freeObject(texture);
  }
  function addQuerySet(device, querySet) {
    const bytesUsed = querySet.count * 8;
    addDeviceMem(device, querySet, "querySet", bytesUsed);
  }
  function removeQuerySet(querySet) {
    freeObject(querySet);
  }
  function addDevice(adapter, device) {
    addDeviceMem(device, device, "device", 0);
    const id = device[webgpuMemoryIdSymbol];
    deviceIdToDeviceWeakRef.set(id, new WeakRef(device));
  }
  function removeDevice(device) {
    const id = device[webgpuMemoryIdSymbol];
    deviceIdToDeviceWeakRef.delete(id);
    freeObject(device);
  }
  var kTexturesPerCanvas = 2;
  function computeCanvasBytesUsed(context, format) {
    const { width, height } = context.canvas;
    return computeTextureMemorySize({
      format,
      width,
      height,
      depthOrArrayLayers: 1,
      sampleCount: 1,
      mipLevelCount: 1,
      dimension: "2d"
    }) * kTexturesPerCanvas;
  }
  function addContext(context, dummy, config) {
    freeObject(context);
    const format = config.format;
    addDeviceMem(config.device, context, "canvas", (context2) => computeCanvasBytesUsed(context2, format));
  }
  function removeContext(context) {
    freeObject(context);
  }
  function resizeContext(context) {
    const id = context[webgpuMemoryIdSymbol];
    const info = allWebGPUObjectsById.get(id);
    const deviceInfo = allWebGPUObjectsById.get(info.deviceId);
    updateDeviceInfoRunningTotal(deviceInfo, -info.oldSize);
    const size = info.size(context);
    info.oldSize = size;
    updateDeviceInfoRunningTotal(deviceInfo, size);
  }
  function wrapFunction(API, fnName, fn) {
    const origFn = API.prototype[fnName];
    API.prototype[fnName] = function(...args) {
      const result = origFn.call(this, ...args);
      fn(this, result, ...args);
      return result;
    };
  }
  function wrapAsyncFunction(API, fnName, fn) {
    const origFn = API.prototype[fnName];
    API.prototype[fnName] = async function(...args) {
      const result = await origFn.call(this, ...args);
      fn(this, result, ...args);
      return result;
    };
  }
  function wrapCreationDestroy(factoryClass, objectClass, fnName, category) {
    wrapFunction(factoryClass, fnName, function(device, object) {
      addDeviceObject(device, object, category, 0);
    });
    if (objectClass.prototype.destroy) {
      wrapFunction(objectClass, "destroy", function(object) {
        freeObject(object);
      });
    }
  }
  if (typeof GPUAdapter !== "undefined") {
    wrapAsyncFunction(GPUAdapter, "requestDevice", addDevice);
    wrapFunction(GPUDevice, "destroy", removeDevice);
    wrapFunction(GPUCanvasContext, "configure", addContext);
    wrapFunction(GPUCanvasContext, "unconfigure", removeContext);
    wrapFunction(GPUCanvasContext, "getCurrentTexture", resizeContext);
    wrapFunction(GPUDevice, "createBuffer", addBuffer);
    wrapFunction(GPUBuffer, "destroy", removeBuffer);
    wrapFunction(GPUDevice, "createTexture", addTexture);
    wrapFunction(GPUTexture, "destroy", removeTexture);
    wrapFunction(GPUDevice, "createQuerySet", addQuerySet);
    wrapFunction(GPUQuerySet, "destroy", removeQuerySet);
    wrapCreationDestroy(GPUDevice, GPUSampler, "createSampler", "sampler");
    wrapCreationDestroy(GPUDevice, GPUBindGroup, "createBindGroup", "bindGroup");
    wrapCreationDestroy(GPUDevice, GPUBindGroupLayout, "createBindGroupLayout", "bindGroupLayout");
    wrapCreationDestroy(GPUDevice, GPUPipelineLayout, "createPipelineLayout", "pipelineLayout");
    wrapCreationDestroy(GPUDevice, GPUShaderModule, "createShaderModule", "shaderModule");
    wrapCreationDestroy(GPUDevice, GPUComputePipeline, "createComputePipeline", "computePipeline");
    wrapCreationDestroy(GPUDevice, GPURenderPipeline, "createRenderPipeline", "renderPipeline");
    wrapCreationDestroy(GPUDevice, GPUComputePipeline, "createComputePipelineAsync", "computePipeline");
    wrapCreationDestroy(GPUDevice, GPURenderPipeline, "createRenderPipelineAsync", "renderPipeline");
  }

  // src/redcube.webgpu.ts
  var FOV = 60;
  var RedCube = class {
    url;
    envUrl;
    canvas;
    events;
    ioc;
    isIBL = true;
    isDefaultLight = true;
    renderState = {};
    stateBuffer = {};
    cameraBuffer;
    lightPosBuffer;
    storage2;
    storage;
    constructor(url, canvas, _pp, envUrl = "env") {
      if (!url) {
        throw new Error("Url not found");
      }
      this.envUrl = envUrl;
      this.url = url;
      this.canvas = canvas;
      this.events = new Events(canvas, this.redraw.bind(this));
    }
    async webgpuInit() {
      const glslangModule2 = await Promise.resolve().then(() => (init_glslang(), glslang_exports));
      await Promise.resolve().then(() => (init_twgsl(), twgsl_exports));
      const adapter = await navigator.gpu.requestAdapter();
      const required = ["float32-filterable"];
      if (adapter.features.has("timestamp-query")) {
        required.push("timestamp-query");
      }
      const device = await adapter.requestDevice({
        requiredFeatures: required
      });
      const glslang = await glslangModule2.default();
      const wgsl = await twgsl("twgsl.wasm");
      const context = this.canvas.getContext("webgpu");
      context.configure({
        device,
        format: "bgra8unorm",
        alphaMode: "opaque"
      });
      const depthTexture = device.createTexture({
        size: {
          width: this.canvas.offsetWidth * devicePixelRatio,
          height: this.canvas.offsetHeight * devicePixelRatio,
          depthOrArrayLayers: 1
        },
        format: "depth32float",
        usage: GPUTextureUsage.RENDER_ATTACHMENT
      });
      const renderPassDescriptor = {
        colorAttachments: [],
        depthStencilAttachment: {
          view: depthTexture.createView(),
          depthLoadOp: "clear",
          depthClearValue: 1,
          depthStoreOp: "store"
        }
      };
      return { glslang, wgsl, context, device, renderPassDescriptor, features: adapter.features };
    }
    get camera() {
      return this.ioc.get("camera");
    }
    get light() {
      return this.ioc.get("light");
    }
    get renderer() {
      return this.ioc.get("renderer");
    }
    get scene() {
      return this.ioc.get("scene");
    }
    get parse() {
      return this.ioc.get("parser");
    }
    get env() {
      return this.ioc.get("env");
    }
    get PP() {
      return this.ioc.get("pp");
    }
    async init(cb) {
      const ioc = new Container();
      this.ioc = ioc;
      try {
        const WebGPU2 = await this.webgpuInit();
        ioc.register("canvas", this.canvas);
        ioc.register("gl", WebGPU2);
        ioc.register("scene", Scene);
        ioc.register("light", Light, [], {
          type: "directional",
          intensity: 5,
          color: [1, 1, 1],
          isInitial: true,
          spot: {}
        });
        this.ioc.register("pp", PostProcessing, ["light", "camera", "canvas", "gl"], [], this.renderScene.bind(this));
        ioc.register("parser", Parse, ["gl", "scene", "camera", "light"], this.url, [], () => {
        });
        ioc.register("env", Env, ["camera", "canvas"], this.envUrl);
        ioc.register("renderer", RendererWebGPU, ["gl", "scene", "parser", "env", "pp"], this.getState.bind(this));
        ioc.register(
          "camera",
          Camera,
          [],
          {
            type: "perspective",
            isInitial: true,
            zoom: 1,
            aspect: this.canvas.offsetWidth / this.canvas.offsetHeight,
            perspective: {
              yfov: FOV * Math.PI / 180
            }
          },
          "perspective"
        );
        await this.parse.getJson();
        await this.parse.getBuffer();
        await this.parse.initTextures(false);
        this.parse.buildSkin();
        await this.parse.buildMesh();
        this.parse.buildAnimation();
        this.parse.cameras.push(this.camera);
        this.parse.createSamplersWebGPU(WebGPU2);
        this.parse.createTexturesWebGPU(WebGPU2);
        const envData = await this.parse.getEnv(true);
        await this.env.createEnvironmentBuffer(envData, WebGPU2);
        this.parse.calculateFov(this.camera.props.isInitial);
        this.resize();
        WebGPU2.nearestSampler = WebGPU2.device.createSampler({
          mipmapFilter: "nearest",
          magFilter: "nearest",
          minFilter: "nearest",
          addressModeU: "repeat",
          addressModeV: "repeat",
          addressModeW: "repeat"
        });
        WebGPU2.linearSampler = WebGPU2.device.createSampler({
          mipmapFilter: "linear",
          magFilter: "linear",
          minFilter: "linear",
          addressModeU: "repeat",
          addressModeV: "repeat",
          addressModeW: "repeat"
        });
        await this.env.createTexture(WebGPU2);
        this.env.drawBRDF(WebGPU2);
        this.env.drawMips(WebGPU2);
        this.env.drawIrradiance(WebGPU2);
        this.env.drawPrefilter(WebGPU2);
        const { renderState, isIBL, isDefaultLight, lights } = this.getState();
        const stateBuffer = new UniformBuffer();
        stateBuffer.add("isTone", renderState.isprerefraction ? 0 : 1);
        stateBuffer.add("isIBL", isIBL ? 1 : 0);
        stateBuffer.add("isDefaultLight", isDefaultLight || lights.some((l) => !l.isInitial) ? 1 : 0);
        stateBuffer.done();
        this.stateBuffer = stateBuffer;
        const uniformBuffer = WebGPU2.device.createBuffer({
          size: 256 + stateBuffer.store.byteLength,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });
        stateBuffer.bufferWebGPU = uniformBuffer;
        WebGPU2.device.queue.writeBuffer(
          uniformBuffer,
          0,
          stateBuffer.store.buffer,
          stateBuffer.store.byteOffset,
          stateBuffer.store.byteLength
        );
        const hasTransmission = this.parse.json.extensionsUsed && this.parse.json.extensionsUsed.includes("KHR_materials_transmission");
        if (hasTransmission) {
          this.PP.addPrepass("refraction");
        }
        if (this.PP.hasPostPass || this.PP.hasPrePass) {
          this.PP.buildScreenBuffer();
        }
        const refraction = this.PP.postprocessors.find((p) => p instanceof Refraction);
        const cameraBuffer = new UniformBuffer();
        cameraBuffer.add("view", this.camera.matrixWorldInvert.elements);
        cameraBuffer.add("projection", this.camera.projection.elements);
        cameraBuffer.add("light", this.light.matrixWorldInvert.elements);
        cameraBuffer.add("isShadow", 0);
        cameraBuffer.done();
        this.cameraBuffer = cameraBuffer;
        this.scene.meshes[0].geometry.updateUniformsWebGPU(WebGPU2, cameraBuffer);
        const lightEnum2 = {
          directional: 0,
          point: 1,
          spot: 2
        };
        const spotDirs = new Float32Array(this.parse.lights.length * 4);
        const lightPos = new Float32Array(this.parse.lights.length * 4);
        const lightColor = new Float32Array(this.parse.lights.length * 4);
        const lightProps = new Float32Array(this.parse.lights.length * 4);
        this.parse.lights.forEach((light, i) => {
          spotDirs.set(
            new Vector3([light.matrixWorld.elements[8], light.matrixWorld.elements[9], light.matrixWorld.elements[10]]).normalize().elements,
            i * 4
          );
          lightPos.set(light.getPosition(), i * 4);
          lightColor.set(light.color.elements, i * 4);
          lightProps.set([light.intensity, light.spot.innerConeAngle ?? 0, light.spot.outerConeAngle ?? 0, lightEnum2[light.type]], i * 4);
        });
        const materialUniformBuffer = new UniformBuffer();
        materialUniformBuffer.add("lightPos", lightPos);
        materialUniformBuffer.done();
        this.lightPosBuffer = materialUniformBuffer;
        const materialUniformBuffer2 = new UniformBuffer();
        materialUniformBuffer2.add("lightColor", lightColor);
        materialUniformBuffer2.done();
        const materialUniformBuffer3 = new UniformBuffer();
        materialUniformBuffer3.add("spotdir", spotDirs);
        materialUniformBuffer3.done();
        const materialUniformBuffer4 = new UniformBuffer();
        materialUniformBuffer4.add("lightIntensity", lightProps);
        materialUniformBuffer4.done();
        this.scene.meshes[0].geometry.updateUniformsWebGPU(WebGPU2, materialUniformBuffer);
        this.scene.meshes[0].geometry.updateUniformsWebGPU(WebGPU2, materialUniformBuffer2);
        this.scene.meshes[0].geometry.updateUniformsWebGPU(WebGPU2, materialUniformBuffer3);
        this.scene.meshes[0].geometry.updateUniformsWebGPU(WebGPU2, materialUniformBuffer4);
        this.scene.meshes.forEach((mesh) => {
          mesh.material.createUniforms(this.camera, this.parse.lights);
        });
        const storage = new Float32Array(this.scene.meshes.length * this.scene.meshes[0].material.materialUniformBuffer.store.length);
        this.scene.meshes.forEach((mesh, i) => {
          storage.set(mesh.material.materialUniformBuffer.store, i * mesh.material.materialUniformBuffer.store.length);
        });
        const storageBuffer = { store: storage };
        this.scene.meshes[0].geometry.updateUniformsWebGPU(WebGPU2, storageBuffer, GPUBufferUsage.STORAGE);
        this.scene.meshes.forEach((mesh) => {
          mesh.geometry.createUniforms(mesh.matrixWorld);
        });
        const storage2 = new Float32Array(this.scene.meshes.length * this.scene.meshes[0].geometry.uniformBuffer.store.length);
        this.scene.meshes.forEach((mesh, i) => {
          mesh.order = i;
          storage2.set(mesh.geometry.uniformBuffer.store, i * mesh.geometry.uniformBuffer.store.length);
        });
        const storageBuffer2 = { store: storage2 };
        this.scene.meshes[0].geometry.updateUniformsWebGPU(WebGPU2, storageBuffer2, GPUBufferUsage.STORAGE);
        this.storage2 = storageBuffer2;
        this.storage = storageBuffer;
        const uniformBindGroup1 = [
          {
            binding: 0,
            // @ts-expect-error
            resource: storageBuffer2.bufferWebGPU
          },
          {
            binding: 1,
            // @ts-expect-error
            resource: storageBuffer.bufferWebGPU
          },
          {
            binding: 39,
            resource: cameraBuffer.bufferWebGPU
          },
          {
            binding: 16,
            resource: materialUniformBuffer.bufferWebGPU
          },
          {
            binding: 15,
            resource: materialUniformBuffer2.bufferWebGPU
          },
          {
            binding: 17,
            resource: materialUniformBuffer3.bufferWebGPU
          },
          {
            binding: 18,
            resource: materialUniformBuffer4.bufferWebGPU
          }
        ];
        const prevProgramHash = /* @__PURE__ */ new Map();
        const uniformBindGroup2 = [];
        this.scene.meshes.forEach((mesh, i) => {
          mesh.geometry.createGeometryForWebGPU(WebGPU2);
          mesh.geometry.uniformBindGroup1 = [];
          mesh.material.updateUniformsWebGPU(WebGPU2);
          mesh.material.uniformBindGroup1.push(
            {
              binding: 19,
              // @ts-expect-error
              resource: this.env.prefilterTexture?.view
            },
            {
              binding: 20,
              // @ts-expect-error
              resource: this.env.irradianceTexture?.view
            },
            {
              binding: 21,
              // @ts-expect-error
              resource: this.env.bdrfTexture?.view
            },
            {
              binding: 28,
              // @ts-expect-error
              resource: this.env.Sheen_E?.view
            },
            {
              binding: 26,
              resource: mesh.defines.find((i2) => i2.name === "TRANSMISSION") ? refraction.texture.texture.createView() : this.PP.fakeDepth.view
            },
            {
              binding: 35,
              // @ts-expect-error
              resource: this.env.charlieTexture?.view
            },
            {
              binding: 30,
              resource: uniformBuffer
            }
          );
          if (this.env.uniformBuffer) {
            mesh.material.uniformBindGroup1.push({
              binding: 27,
              resource: this.env.uniformBuffer.bufferWebGPU
            });
          }
          if (mesh instanceof SkinnedMesh) {
            for (const join of this.parse.skins[mesh.skin].jointNames) {
              walk(this.scene, this.buildBones.bind(this, join, this.parse.skins[mesh.skin]));
            }
            mesh.geometry.uniformBindGroup1.push(mesh.setSkinWebGPU(WebGPU2, this.parse.skins[mesh.skin]));
          }
          const programHash = mesh.material.defines.map((define2) => `${define2.name}${define2.value ?? 1}`).join("");
          if (!prevProgramHash.has(programHash)) {
            prevProgramHash.set(programHash, create(WebGPU2.device, WebGPU2.glslang, WebGPU2.wgsl, mesh.material.uniformBindGroup1, mesh.defines, hasTransmission, mesh.mode, mesh.frontFace));
          }
          let group = check(uniformBindGroup2, mesh.material.uniformBindGroup1);
          if (!group) {
            group = { k: mesh.material.uniformBindGroup1, v: WebGPU2.device.createBindGroup({
              layout: prevProgramHash.get(programHash).getBindGroupLayout(0),
              entries: [...uniformBindGroup1, ...mesh.geometry.uniformBindGroup1, ...mesh.material.uniformBindGroup1]
            }) };
            uniformBindGroup2.push(group);
          }
          mesh.pipeline = prevProgramHash.get(programHash);
          mesh.uniformBindGroup1 = group.v;
        });
      } catch (e) {
        console.log(e);
      }
      this.scene.tracks = this.parse.tracks;
      this.scene.cameras = this.parse.cameras;
      this.scene.lights = this.parse.lights;
      this.renderer.render();
      const info = getWebGPUMemoryUsage();
      console.log(info);
      window.__TEST_READY__ = true;
      cb(this.scene);
    }
    buildBones(join, v, node) {
      if (node.name === join) {
        v.bones.push(node);
      }
    }
    resize() {
      this.camera.props.aspect = this.canvas.offsetWidth / this.canvas.offsetHeight;
      this.canvas.width = this.canvas.offsetWidth * devicePixelRatio;
      this.canvas.height = this.canvas.offsetHeight * devicePixelRatio;
      const z = this.camera.modelSize;
      if (this.camera.props.isInitial) {
        this.camera.setZ(z);
      }
      if (this.light.isInitial || this.light.type === "directional") {
        this.light.setZ(z);
      }
      this.camera.updateNF();
    }
    renderScene(renderState) {
      this.renderState = renderState;
      this.renderer.renderScene();
      this.renderState = {};
    }
    redraw(type, coordsStart, coordsMove) {
      if (type === "zoom") {
        this.camera.zoom(coordsStart);
        this.renderer.needUpdateView = true;
        this.renderer.needUpdateProjection = true;
      }
      if (type === "rotate") {
        this.camera.rotate(coordsStart, coordsMove);
        this.renderer.needUpdateView = true;
      }
      if (type === "pan") {
        this.camera.pan(coordsStart, coordsMove, this.canvas.offsetWidth, this.canvas.offsetHeight);
        this.renderer.needUpdateView = true;
      }
      if (type === "resize") {
        this.resize();
        this.renderer.needUpdateProjection = true;
      }
      this.renderer.reflow = true;
    }
    setVariant() {
      console.warn("Not implemented");
    }
    draw() {
      console.warn("Not implemented");
    }
    getState() {
      return {
        storage2: this.storage2,
        storage: this.storage,
        lightPosBuffer: this.lightPosBuffer,
        cameraBuffer: this.cameraBuffer,
        stateBuffer: this.stateBuffer,
        renderState: this.renderState,
        lights: [],
        isIBL: this.isIBL,
        isDefaultLight: this.isDefaultLight,
        camera: this.camera,
        light: this.light,
        needUpdateView: this.renderer.needUpdateView,
        needUpdateProjection: this.renderer.needUpdateProjection
      };
    }
  };
  function check(source, candidate) {
    return source.find((item) => {
      for (let i = 0; i < candidate.length; i++) {
        if (item.k[i].binding !== candidate[i].binding || item.k[i].resource !== candidate[i].resource) {
          return false;
        }
      }
      return true;
    });
  }
  return __toCommonJS(redcube_webgpu_exports);
})();
//# sourceMappingURL=redcube.webgpu.js.map
