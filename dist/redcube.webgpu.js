!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("redcube",[],t):"object"==typeof exports?exports.redcube=t():e.redcube=t()}(self,(function(){return(()=>{var e,t,n,r,i={510:(e,t,n)=>{"use strict";n.r(t),n.d(t,{RedCube:()=>ce});class r{constructor(){this._services=new Map,this._singletons=new Map,this.update=this.update.bind(this)}register(e,t,n=[],...r){this._services.set(e,{definition:t,dependencies:n,args:r}),this._isClass(t)?t.__update=this.update:this._updateDep(e,t)}get(e){const t=this._services.get(e);if(!t)return null;if(this._isClass(t.definition)){const n=this._singletons.get(e);if(n)return n;{const n=this._createInstance(t);return this._singletons.set(e,n),n}}return t.definition}update(e,...t){this._services.get(e).args=t,this._singletons.delete(e);const n=this.get(e);this._updateDep(e,n)}_updateDep(e,t){for(const[n,r]of this._singletons)this._services.get(n).dependencies.some((t=>t===e))&&r[`set${e.charAt(0).toUpperCase()+e.slice(1)}`].call(r,t);this._singletons.set(e,t)}_getResolvedDependencies(e){let t=[];return e.dependencies&&(t=e.dependencies.map((e=>[e,this.get(e)]))),t}_createInstance(e){const t=new e.definition(...e.args);return this._getResolvedDependencies(e).forEach((([e,n])=>{t[`set${e.charAt(0).toUpperCase()+e.slice(1)}`].call(t,n)})),t}_isClass(e){return"function"==typeof e&&/^class\s/.test(Function.prototype.toString.call(e))}}class i{constructor(e){let t,n,r;if(e&&"object"==typeof e&&e.hasOwnProperty("elements")){for(n=e.elements,r=new Float32Array(9),t=0;t<9;++t)r[t]=n[t];this.elements=r}else this.elements=new Float32Array([1,0,0,0,1,0,0,0,1])}set(e){let t,n,r;if(n=e,r=this.elements,n!==r){for(t=0;t<9;++t)r[t]=n[t];return this}}normalFromMat4(e){const t=this.elements,n=(e=e.elements)[0],r=e[1],i=e[2],s=e[3],a=e[4],o=e[5],l=e[6],c=e[7],u=e[8],h=e[9],f=e[10],m=e[11],d=e[12],T=e[13],E=e[14],p=e[15],g=n*o-r*a,R=n*l-i*a,A=n*c-s*a,_=r*l-i*o,x=r*c-s*o,v=i*c-s*l,b=u*T-h*d,S=u*E-f*d,N=u*p-m*d,U=h*E-f*T,I=h*p-m*T,M=f*p-m*E;let F=g*M-R*I+A*U+_*N-x*S+v*b;return F?(F=1/F,t[0]=(o*M-l*I+c*U)*F,t[1]=(l*N-a*M-c*S)*F,t[2]=(a*I-o*N+c*b)*F,t[3]=(i*I-r*M-s*U)*F,t[4]=(n*M-i*N+s*S)*F,t[5]=(r*N-n*I-s*b)*F,t[6]=(T*v-E*x+p*_)*F,t[7]=(E*A-d*v-p*R)*F,t[8]=(d*x-T*A+p*g)*F,this):null}multiply(e){const t=this.elements,n=e.elements,r=this.elements,i=t[0],s=t[3],a=t[6],o=t[1],l=t[4],c=t[7],u=t[2],h=t[5],f=t[8],m=n[0],d=n[3],T=n[6],E=n[1],p=n[4],g=n[7],R=n[2],A=n[5],_=n[8];return r[0]=i*m+s*E+a*R,r[3]=i*d+s*p+a*A,r[6]=i*T+s*g+a*_,r[1]=o*m+l*E+c*R,r[4]=o*d+l*p+c*A,r[7]=o*T+l*g+c*_,r[2]=u*m+h*E+f*R,r[5]=u*d+h*p+f*A,r[8]=u*T+h*g+f*_,this}}class s{constructor(e){let t,n,r;if(e&&"object"==typeof e&&e.hasOwnProperty("elements")){for(n=e.elements,r=new Float32Array(16),t=0;t<16;++t)r[t]=n[t];this.elements=r}else this.elements=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}set(e){let t,n,r;if(n=e,r=this.elements,n!==r){for(t=0;t<16;++t)r[t]=n[t];return this}}multiply(e){return this.concat(e),this}concat({elements:e}){let t,n,r,i,s,a,o,l;if(n=this.elements,r=this.elements,i=e,n===i)for(i=new Float32Array(16),t=0;t<16;++t)i[t]=n[t];for(t=0;t<4;t++)s=r[t],a=r[t+4],o=r[t+8],l=r[t+12],n[t]=s*i[0]+a*i[1]+o*i[2]+l*i[3],n[t+4]=s*i[4]+a*i[5]+o*i[6]+l*i[7],n[t+8]=s*i[8]+a*i[9]+o*i[10]+l*i[11],n[t+12]=s*i[12]+a*i[13]+o*i[14]+l*i[15];return this}setInverseOf({elements:e}){let t,n,r,i,s;if(n=e,r=this.elements,i=new Float32Array(16),i[0]=n[5]*n[10]*n[15]-n[5]*n[11]*n[14]-n[9]*n[6]*n[15]+n[9]*n[7]*n[14]+n[13]*n[6]*n[11]-n[13]*n[7]*n[10],i[4]=-n[4]*n[10]*n[15]+n[4]*n[11]*n[14]+n[8]*n[6]*n[15]-n[8]*n[7]*n[14]-n[12]*n[6]*n[11]+n[12]*n[7]*n[10],i[8]=n[4]*n[9]*n[15]-n[4]*n[11]*n[13]-n[8]*n[5]*n[15]+n[8]*n[7]*n[13]+n[12]*n[5]*n[11]-n[12]*n[7]*n[9],i[12]=-n[4]*n[9]*n[14]+n[4]*n[10]*n[13]+n[8]*n[5]*n[14]-n[8]*n[6]*n[13]-n[12]*n[5]*n[10]+n[12]*n[6]*n[9],i[1]=-n[1]*n[10]*n[15]+n[1]*n[11]*n[14]+n[9]*n[2]*n[15]-n[9]*n[3]*n[14]-n[13]*n[2]*n[11]+n[13]*n[3]*n[10],i[5]=n[0]*n[10]*n[15]-n[0]*n[11]*n[14]-n[8]*n[2]*n[15]+n[8]*n[3]*n[14]+n[12]*n[2]*n[11]-n[12]*n[3]*n[10],i[9]=-n[0]*n[9]*n[15]+n[0]*n[11]*n[13]+n[8]*n[1]*n[15]-n[8]*n[3]*n[13]-n[12]*n[1]*n[11]+n[12]*n[3]*n[9],i[13]=n[0]*n[9]*n[14]-n[0]*n[10]*n[13]-n[8]*n[1]*n[14]+n[8]*n[2]*n[13]+n[12]*n[1]*n[10]-n[12]*n[2]*n[9],i[2]=n[1]*n[6]*n[15]-n[1]*n[7]*n[14]-n[5]*n[2]*n[15]+n[5]*n[3]*n[14]+n[13]*n[2]*n[7]-n[13]*n[3]*n[6],i[6]=-n[0]*n[6]*n[15]+n[0]*n[7]*n[14]+n[4]*n[2]*n[15]-n[4]*n[3]*n[14]-n[12]*n[2]*n[7]+n[12]*n[3]*n[6],i[10]=n[0]*n[5]*n[15]-n[0]*n[7]*n[13]-n[4]*n[1]*n[15]+n[4]*n[3]*n[13]+n[12]*n[1]*n[7]-n[12]*n[3]*n[5],i[14]=-n[0]*n[5]*n[14]+n[0]*n[6]*n[13]+n[4]*n[1]*n[14]-n[4]*n[2]*n[13]-n[12]*n[1]*n[6]+n[12]*n[2]*n[5],i[3]=-n[1]*n[6]*n[11]+n[1]*n[7]*n[10]+n[5]*n[2]*n[11]-n[5]*n[3]*n[10]-n[9]*n[2]*n[7]+n[9]*n[3]*n[6],i[7]=n[0]*n[6]*n[11]-n[0]*n[7]*n[10]-n[4]*n[2]*n[11]+n[4]*n[3]*n[10]+n[8]*n[2]*n[7]-n[8]*n[3]*n[6],i[11]=-n[0]*n[5]*n[11]+n[0]*n[7]*n[9]+n[4]*n[1]*n[11]-n[4]*n[3]*n[9]-n[8]*n[1]*n[7]+n[8]*n[3]*n[5],i[15]=n[0]*n[5]*n[10]-n[0]*n[6]*n[9]-n[4]*n[1]*n[10]+n[4]*n[2]*n[9]+n[8]*n[1]*n[6]-n[8]*n[2]*n[5],s=n[0]*i[0]+n[1]*i[4]+n[2]*i[8]+n[3]*i[12],0===s)return this;for(s=1/s,t=0;t<16;t++)r[t]=i[t]*s;return this}invert(){return this.setInverseOf(this)}makeOrthographic(e,t,n,r,i,s){var a=this.elements,o=1/(t-e),l=1/(n-r),c=1/(s-i),u=(t+e)*o,h=(n+r)*l,f=(s+i)*c;return a[0]=2*o,a[4]=0,a[8]=0,a[12]=-u,a[1]=0,a[5]=2*l,a[9]=0,a[13]=-h,a[2]=0,a[6]=0,a[10]=-2*c,a[14]=-f,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}setOrtho(e,t,n,r){let i,s,a,o;return s=1/e,a=1/t,o=2/(n-r),i=this.elements,i[0]=s,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=a,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=o,i[11]=(r+n)/(n-r),i[12]=0,i[13]=0,i[14]=0,i[15]=1,this}setPerspective(e,t,n,r){let i,s,a,o;if(n===r||0===t)throw"null frustum";if(n<=0)throw"near <= 0";if(r<=0)throw"far <= 0";if(e/=2,a=Math.sin(e),0===a)throw"null frustum";return s=1/(r-n),o=Math.cos(e)/a,i=this.elements,i[0]=o/t,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=o,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=-(r+n)*s,i[11]=-1,i[12]=0,i[13]=0,i[14]=-2*n*r*s,i[15]=0,this}perspective(e,t,n,r){return this.concat((new s).setPerspective(e,t,n,r))}multiplyVector4({elements:e}){const t=this.elements,n=e,r=new c,i=r.elements;return i[0]=n[0]*t[0]+n[1]*t[4]+n[2]*t[8]+n[3]*t[12],i[1]=n[0]*t[1]+n[1]*t[5]+n[2]*t[9]+n[3]*t[13],i[2]=n[0]*t[2]+n[1]*t[6]+n[2]*t[10]+n[3]*t[14],i[3]=n[0]*t[3]+n[1]*t[7]+n[2]*t[11]+n[3]*t[15],r}getScaling(){let e=this.elements,t=e[0],n=e[1],r=e[2],i=e[4],s=e[5],a=e[6],l=e[8],c=e[9],u=e[10];return new o([Math.sqrt(t*t+n*n+r*r),Math.sqrt(i*i+s*s+a*a),Math.sqrt(l*l+c*c+u*u)])}scale(e){const t=e.elements[0],n=e.elements[1],r=e.elements[2],i=this.elements;return i[0]*=t,i[4]*=n,i[8]*=r,i[1]*=t,i[5]*=n,i[9]*=r,i[2]*=t,i[6]*=n,i[10]*=r,i[3]*=t,i[7]*=n,i[11]*=r,this}restoreScale(e){const t=e.elements[0],n=e.elements[1],r=e.elements[2],i=this.elements;return i[0]/=t,i[4]/=n,i[8]/=r,i[1]/=t,i[5]/=n,i[9]/=r,i[2]/=t,i[6]/=n,i[10]/=r,i[3]/=t,i[7]/=n,i[11]/=r,this}setTranslate(e){const t=this.elements,n=e.elements[0],r=e.elements[1],i=e.elements[2];return t[12]=n,t[13]=r,t[14]=i,t[15]=1,this}translate(e,t,n){const r=this.elements;return r[12]+=r[0]*e+r[4]*t+r[8]*n,r[13]+=r[1]*e+r[5]*t+r[9]*n,r[14]+=r[2]*e+r[6]*t+r[10]*n,r[15]+=r[3]*e+r[7]*t+r[11]*n,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,r))}rotate(e,t){let n,r,i,s,a,o,l,c,u,h,f,m,d,T,E,p,g,R,A,_,x,v,b,S,N=e.elements[0],U=e.elements[1],I=e.elements[2],M=Math.hypot(N,U,I);if(M<Number.EPSILON)return null;M=1/M,N*=M,U*=M,I*=M,n=Math.sin(t),r=Math.cos(t),i=1-r;let F=this.elements;return s=F[0],a=F[1],o=F[2],l=F[3],c=F[4],u=F[5],h=F[6],f=F[7],m=F[8],d=F[9],T=F[10],E=F[11],p=N*N*i+r,g=U*N*i+I*n,R=I*N*i-U*n,A=N*U*i-I*n,_=U*U*i+r,x=I*U*i+N*n,v=N*I*i+U*n,b=U*I*i-N*n,S=I*I*i+r,F[0]=s*p+c*g+m*R,F[1]=a*p+u*g+d*R,F[2]=o*p+h*g+T*R,F[3]=l*p+f*g+E*R,F[4]=s*A+c*_+m*x,F[5]=a*A+u*_+d*x,F[6]=o*A+h*_+T*x,F[7]=l*A+f*_+E*x,F[8]=s*v+c*b+m*S,F[9]=a*v+u*b+d*S,F[10]=o*v+h*b+T*S,F[11]=l*v+f*b+E*S,this}makeRotationAxis(e,t){const n=this.elements,r=Math.cos(t),i=Math.sin(t),s=1-r,a=e.elements[0],o=e.elements[1],l=e.elements[2],c=s*a,u=s*o;return n[0]=c*a+r,n[1]=c*o-i*l,n[2]=c*l+i*o,n[3]=0,n[4]=c*o+i*l,n[5]=u*o+r,n[6]=u*l-i*a,n[7]=0,n[8]=c*l-i*o,n[9]=u*l+i*a,n[10]=s*l*l+r,n[11]=0,n[15]=1,this}makeRotationFromQuaternion(e){const t=this.elements,n=e[0],r=e[1],i=e[2],s=e[3],a=n+n,o=r+r,l=i+i,c=n*a,u=n*o,h=n*l,f=r*o,m=r*l,d=i*l,T=s*a,E=s*o,p=s*l;return t[0]=1-(f+d),t[4]=u-p,t[8]=h+E,t[1]=u+p,t[5]=1-(c+d),t[9]=m-T,t[2]=h-E,t[6]=m+T,t[10]=1-(c+f),this}transpose(){let e,t;return e=this.elements,t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}}class a{constructor(e){this.elements=e.slice()}lerp(e,t,n){const r=this.elements;for(let i=0;i<r.length;i++)r[i]=e[i]+n*(t[i]-e[i]);return this}}class o{constructor(e){const t=new Float32Array(3);e&&"object"==typeof e&&(t[0]=e[0],t[1]=e[1],t[2]=e[2]),this.elements=t}get x(){return this.elements[0]}get y(){return this.elements[1]}get z(){return this.elements[2]}set x(e){this.elements[0]=e}set y(e){this.elements[1]=e}set z(e){this.elements[2]=e}static FromArrayToRef(e,t,n){n.x=e[t],n.y=e[t+1],n.z=e[t+2]}projectOnVector(e){const t=o.dot(e,this)/e.lengthSq();return new o(e).scale(t)}applyQuaternion({elements:e}){const t=this.elements[0],n=this.elements[1],r=this.elements[2],i=e[0],s=e[1],a=e[2],o=e[3],l=o*t+s*r-a*n,c=o*n+a*t-i*r,u=o*r+i*n-s*t,h=-i*t-s*n-a*r;return this.elements[0]=l*o+h*-i+c*-a-u*-s,this.elements[1]=c*o+h*-s+u*-i-l*-a,this.elements[2]=u*o+h*-a+l*-s-c*-i,this}normalize(){const e=this.elements,t=e[0],n=e[1],r=e[2];let i=Math.sqrt(t*t+n*n+r*r);return i?(1==i||(i=1/i,e[0]=t*i,e[1]=n*i,e[2]=r*i),this):(e[0]=0,e[1]=0,e[2]=0,this)}add(e){const t=this.elements;return e=e.elements,t[0]=t[0]+e[0],t[1]=t[1]+e[1],t[2]=t[2]+e[2],this}addS(e){const t=this.elements;return t[0]=t[0]+e,t[1]=t[1]+e,t[2]=t[2]+e,this}scale(e){const t=this.elements;return t[0]=t[0]*e,t[1]=t[1]*e,t[2]=t[2]*e,this}scale2(e){return new o([this.x*e,this.y*e,this.z*e])}subtract2(e){return new o([this.x-e.x,this.y-e.y,this.z-e.z])}add2(e){return new o([this.x+e.x,this.y+e.y,this.z+e.z])}distanceToSquared(e,t,n){const r=this.elements[0]-e,i=this.elements[1]-t,s=this.elements[2]-n;return r*r+i*i+s*s}subtract(e){const t=this.elements;return e=e.elements,t[0]=t[0]-e[0],t[1]=t[1]-e[1],t[2]=t[2]-e[2],this}divideScalar(e){return this.scale(1/e)}applyMatrix4({elements:e}){const t=this.elements[0],n=this.elements[1],r=this.elements[2],i=e;this.elements[0]=i[0]*t+i[4]*n+i[8]*r+i[12],this.elements[1]=i[1]*t+i[5]*n+i[9]*r+i[13],this.elements[2]=i[2]*t+i[6]*n+i[10]*r+i[14];const s=i[3]*t+i[7]*n+i[11]*r+i[15];return this.divideScalar(s)}lerp(e,t,n){const r=this.elements,i=e[0],s=e[1],a=e[2];return r[0]=i+n*(t[0]-i),r[1]=s+n*(t[1]-s),r[2]=a+n*(t[2]-a),this}lengthSq(){return this.elements[0]*this.elements[0]+this.elements[1]*this.elements[1]+this.elements[2]*this.elements[2]}multiply({elements:e}){return this.elements[0]*=e[0],this.elements[1]*=e[1],this.elements[2]*=e[2],this}static angle(e,t){const n=new o(e.elements),r=new o(t.elements);n.normalize(),r.normalize();const i=o.dot(n,r);return i>1?0:Math.acos(i)}static cross(e,t){e=e.elements,t=t.elements;const n=e[0],r=e[1],i=e[2],s=t[0],a=t[1],l=t[2],c=new o;return c.elements[0]=r*l-i*a,c.elements[1]=i*s-n*l,c.elements[2]=n*a-r*s,c}static dot(e,t){return e=e.elements,t=t.elements,e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}}class l{constructor(){this.min=new o([1/0,1/0,1/0]),this.max=new o([-1/0,-1/0,-1/0])}expand(e){this.min.min(e.min),this.max.max(e.max)}getSize(){const e=new o;return e.subVectors(this.max,this.min),e.length()}}class c{constructor(e){const t=new Float32Array(4);e&&"object"==typeof e&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3]),this.elements=t}set(e){const t=this.elements;return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],this}add(e){const t=this.elements;return e=e.elements,t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=t[3]+e[3],this}normalize(){const e=this.elements[0],t=this.elements[1],n=this.elements[2],r=this.elements[3];let i=e*e+t*t+n*n+r*r;return i>0&&(i=1/Math.sqrt(i),this.elements[0]=e*i,this.elements[1]=t*i,this.elements[2]=n*i,this.elements[3]=r*i),this}setFromRotationMatrix({elements:e}){const t=e,n=t[0],r=t[4],i=t[8],s=t[1],a=t[5],o=t[9],l=t[2],c=t[6],u=t[10],h=n+a+u;let f;return h>0?(f=.5/Math.sqrt(h+1),this.elements[3]=.25/f,this.elements[0]=(c-o)*f,this.elements[1]=(i-l)*f,this.elements[2]=(s-r)*f):n>a&&n>u?(f=2*Math.sqrt(1+n-a-u),this.elements[3]=(c-o)/f,this.elements[0]=.25*f,this.elements[1]=(r+s)/f,this.elements[2]=(i+l)/f):a>u?(f=2*Math.sqrt(1+a-n-u),this.elements[3]=(i-l)/f,this.elements[0]=(r+s)/f,this.elements[1]=.25*f,this.elements[2]=(o+c)/f):(f=2*Math.sqrt(1+u-n-a),this.elements[3]=(s-r)/f,this.elements[0]=(i+l)/f,this.elements[1]=(o+c)/f,this.elements[2]=.25*f),this}lerp(e,t,n){const r=this.elements;if(0===n)return this;if(1===n)return r[0]=t[0],r[1]=t[1],r[2]=t[2],r[3]=t[3],this;const i=e[0],s=e[1],a=e[2],o=e[3];let l=o*t[3]+i*t[0]+s*t[1]+a*t[2];if(l<0?(r[3]=-t[3],r[0]=-t[0],r[1]=-t[1],r[2]=-t[2],l=-l):(r[0]=t[0],r[1]=t[1],r[2]=t[2],r[3]=t[3]),l>=1)return r[3]=o,r[0]=i,r[1]=s,r[2]=a,this;const c=1-l*l;if(c<=Number.EPSILON){var u=1-n;return r[3]=u*o+n*r[3],r[0]=u*i+n*r[0],r[1]=u*s+n*r[1],r[2]=u*a+n*r[2],this.normalize()}const h=Math.sqrt(c),f=Math.atan2(h,l),m=Math.sin((1-n)*f)/h,d=Math.sin(n*f)/h;return r[3]=o*m+r[3]*d,r[0]=i*m+r[0]*d,r[1]=s*m+r[1]*d,r[2]=a*m+r[2]*d,this}inverse(){return this.elements[0]=-this.elements[0],this.elements[1]=-this.elements[1],this.elements[2]=-this.elements[2],this}}class u{constructor(e){const t=new Float32Array(2);e&&"object"==typeof e&&(t[0]=e[0],t[1]=e[1]),this.elements=t}get x(){return this.elements[0]}get y(){return this.elements[1]}set x(e){this.elements[0]=e}set y(e){this.elements[1]=e}subtract(e){const t=this.elements;return e=e.elements,t[0]=t[0]-e[0],t[1]=t[1]-e[1],this}lerp(e,t,n){const r=this.elements,i=e[0],s=e[1];return r[0]=i+n*(t[0]-i),r[1]=s+n*(t[1]-s),this}}class h{constructor(){this.opaqueChildren=[],this.transparentChildren=[],this.meshes=[],this.children=[],this.bin=[],this.matrixWorld=new s,this.matrix=new s,this.variants=[]}}class f{constructor(e,t){this.uuid=Math.floor(Date.now()*Math.random()),this.name=e,this.children=[],this.matrix=new s,this.matrixWorld=new s,this.parent=t}getPosition(){return new Float32Array([this.matrixWorld.elements[12],this.matrixWorld.elements[13],this.matrixWorld.elements[14]])}setPosition(e,t,n){t&&this.matrix.makeRotationFromQuaternion(t),n&&this.matrix.scale(new o(n)),e&&this.matrix.setTranslate(new o(e))}setMatrix(e){this.matrix.set(e)}setMatrixWorld(e){this.matrixWorld.set(e)}updateMatrix(){const e=new s;e.multiply(this.parent.matrixWorld),e.multiply(this.matrix),this.setMatrixWorld(e.elements)}}const m={0:"NONE",1:"ONE",2:"LINE_LOOP",3:"LINE_STRIP",4:"TRIANGLES",5:"TRIANGLE_STRIP",6:"TRIANGLE_FAN",256:"DEPTH_BUFFER_BIT",512:"NEVER",513:"LESS",514:"EQUAL",515:"LEQUAL",516:"GREATER",517:"NOTEQUAL",518:"GEQUAL",519:"ALWAYS",768:"SRC_COLOR",769:"ONE_MINUS_SRC_COLOR",770:"SRC_ALPHA",771:"ONE_MINUS_SRC_ALPHA",772:"DST_ALPHA",773:"ONE_MINUS_DST_ALPHA",774:"DST_COLOR",775:"ONE_MINUS_DST_COLOR",776:"SRC_ALPHA_SATURATE",1024:"STENCIL_BUFFER_BIT",1028:"FRONT",1029:"BACK",1032:"FRONT_AND_BACK",1280:"INVALID_ENUM",1281:"INVALID_VALUE",1282:"INVALID_OPERATION",1285:"OUT_OF_MEMORY",1286:"INVALID_FRAMEBUFFER_OPERATION",1798:"drawingBufferHeight",2304:"CW",2305:"CCW",2712:"drawingBufferWidth",2849:"LINE_WIDTH",2884:"CULL_FACE",2885:"CULL_FACE_MODE",2886:"FRONT_FACE",2928:"DEPTH_RANGE",2929:"DEPTH_TEST",2930:"DEPTH_WRITEMASK",2931:"DEPTH_CLEAR_VALUE",2932:"DEPTH_FUNC",2960:"STENCIL_TEST",2961:"STENCIL_CLEAR_VALUE",2962:"STENCIL_FUNC",2963:"STENCIL_VALUE_MASK",2964:"STENCIL_FAIL",2965:"STENCIL_PASS_DEPTH_FAIL",2966:"STENCIL_PASS_DEPTH_PASS",2967:"STENCIL_REF",2968:"STENCIL_WRITEMASK",2978:"VIEWPORT",3024:"DITHER",3042:"BLEND",3074:"READ_BUFFER",3088:"SCISSOR_BOX",3089:"SCISSOR_TEST",3106:"COLOR_CLEAR_VALUE",3107:"COLOR_WRITEMASK",3314:"UNPACK_ROW_LENGTH",3315:"UNPACK_SKIP_ROWS",3316:"UNPACK_SKIP_PIXELS",3317:"UNPACK_ALIGNMENT",3330:"PACK_ROW_LENGTH",3331:"PACK_SKIP_ROWS",3332:"PACK_SKIP_PIXELS",3333:"PACK_ALIGNMENT",3379:"MAX_TEXTURE_SIZE",3386:"MAX_VIEWPORT_DIMS",3408:"SUBPIXEL_BITS",3410:"RED_BITS",3411:"GREEN_BITS",3412:"BLUE_BITS",3413:"ALPHA_BITS",3414:"DEPTH_BITS",3415:"STENCIL_BITS",3553:"TEXTURE_2D",4352:"DONT_CARE",4353:"FASTEST",4354:"NICEST",5120:"BYTE",5121:"UNSIGNED_BYTE",5122:"SHORT",5123:"UNSIGNED_SHORT",5124:"INT",5125:"UNSIGNED_INT",5126:"FLOAT",5131:"HALF_FLOAT",5386:"INVERT",5890:"TEXTURE",6144:"COLOR",6145:"DEPTH",6146:"STENCIL",6402:"DEPTH_COMPONENT",6403:"RED",6406:"ALPHA",6407:"RGB",6408:"RGBA",6409:"LUMINANCE",6410:"LUMINANCE_ALPHA",7680:"KEEP",7681:"REPLACE",7682:"INCR",7683:"DECR",7936:"VENDOR",7937:"RENDERER",7938:"VERSION",9728:"NEAREST",9729:"LINEAR",9984:"NEAREST_MIPMAP_NEAREST",9985:"LINEAR_MIPMAP_NEAREST",9986:"NEAREST_MIPMAP_LINEAR",9987:"LINEAR_MIPMAP_LINEAR",10240:"TEXTURE_MAG_FILTER",10241:"TEXTURE_MIN_FILTER",10242:"TEXTURE_WRAP_S",10243:"TEXTURE_WRAP_T",10497:"REPEAT",10752:"POLYGON_OFFSET_UNITS",16384:"COLOR_BUFFER_BIT",32769:"CONSTANT_COLOR",32770:"ONE_MINUS_CONSTANT_COLOR",32771:"CONSTANT_ALPHA",32772:"ONE_MINUS_CONSTANT_ALPHA",32773:"BLEND_COLOR",32774:"FUNC_ADD",32775:"MIN",32776:"MAX",32777:"BLEND_EQUATION_RGB",32778:"FUNC_SUBTRACT",32779:"FUNC_REVERSE_SUBTRACT",32819:"UNSIGNED_SHORT_4_4_4_4",32820:"UNSIGNED_SHORT_5_5_5_1",32823:"POLYGON_OFFSET_FILL",32824:"POLYGON_OFFSET_FACTOR",32849:"RGB8",32854:"RGBA4",32855:"RGB5_A1",32856:"RGBA8",32857:"RGB10_A2",32873:"TEXTURE_BINDING_2D",32874:"TEXTURE_BINDING_3D",32877:"UNPACK_SKIP_IMAGES",32878:"UNPACK_IMAGE_HEIGHT",32879:"TEXTURE_3D",32882:"TEXTURE_WRAP_R",32883:"MAX_3D_TEXTURE_SIZE",32926:"SAMPLE_ALPHA_TO_COVERAGE",32928:"SAMPLE_COVERAGE",32936:"SAMPLE_BUFFERS",32937:"SAMPLES",32938:"SAMPLE_COVERAGE_VALUE",32939:"SAMPLE_COVERAGE_INVERT",32968:"BLEND_DST_RGB",32969:"BLEND_SRC_RGB",32970:"BLEND_DST_ALPHA",32971:"BLEND_SRC_ALPHA",33e3:"MAX_ELEMENTS_VERTICES",33001:"MAX_ELEMENTS_INDICES",33071:"CLAMP_TO_EDGE",33082:"TEXTURE_MIN_LOD",33083:"TEXTURE_MAX_LOD",33084:"TEXTURE_BASE_LEVEL",33085:"TEXTURE_MAX_LEVEL",33170:"GENERATE_MIPMAP_HINT",33189:"DEPTH_COMPONENT16",33190:"DEPTH_COMPONENT24",33296:"FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING",33297:"FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE",33298:"FRAMEBUFFER_ATTACHMENT_RED_SIZE",33299:"FRAMEBUFFER_ATTACHMENT_GREEN_SIZE",33300:"FRAMEBUFFER_ATTACHMENT_BLUE_SIZE",33301:"FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE",33302:"FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE",33303:"FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE",33304:"FRAMEBUFFER_DEFAULT",33306:"DEPTH_STENCIL_ATTACHMENT",33319:"RG",33320:"RG_INTEGER",33321:"R8",33323:"RG8",33325:"R16F",33326:"R32F",33327:"RG16F",33328:"RG32F",33329:"R8I",33330:"R8UI",33331:"R16I",33332:"R16UI",33333:"R32I",33334:"R32UI",33335:"RG8I",33336:"RG8UI",33337:"RG16I",33338:"RG16UI",33339:"RG32I",33340:"RG32UI",33503:"TEXTURE_IMMUTABLE_LEVELS",33635:"UNSIGNED_SHORT_5_6_5",33640:"UNSIGNED_INT_2_10_10_10_REV",33648:"MIRRORED_REPEAT",33901:"ALIASED_POINT_SIZE_RANGE",33902:"ALIASED_LINE_WIDTH_RANGE",33984:"TEXTURE0",33985:"TEXTURE1",33986:"TEXTURE2",33987:"TEXTURE3",33988:"TEXTURE4",33989:"TEXTURE5",33990:"TEXTURE6",33991:"TEXTURE7",33992:"TEXTURE8",33993:"TEXTURE9",33994:"TEXTURE10",33995:"TEXTURE11",33996:"TEXTURE12",33997:"TEXTURE13",33998:"TEXTURE14",33999:"TEXTURE15",34e3:"TEXTURE16",34001:"TEXTURE17",34002:"TEXTURE18",34003:"TEXTURE19",34004:"TEXTURE20",34005:"TEXTURE21",34006:"TEXTURE22",34007:"TEXTURE23",34008:"TEXTURE24",34009:"TEXTURE25",34010:"TEXTURE26",34011:"TEXTURE27",34012:"TEXTURE28",34013:"TEXTURE29",34014:"TEXTURE30",34015:"TEXTURE31",34016:"ACTIVE_TEXTURE",34024:"MAX_RENDERBUFFER_SIZE",34041:"DEPTH_STENCIL",34042:"UNSIGNED_INT_24_8",34045:"MAX_TEXTURE_LOD_BIAS",34055:"INCR_WRAP",34056:"DECR_WRAP",34067:"TEXTURE_CUBE_MAP",34068:"TEXTURE_BINDING_CUBE_MAP",34069:"TEXTURE_CUBE_MAP_POSITIVE_X",34070:"TEXTURE_CUBE_MAP_NEGATIVE_X",34071:"TEXTURE_CUBE_MAP_POSITIVE_Y",34072:"TEXTURE_CUBE_MAP_NEGATIVE_Y",34073:"TEXTURE_CUBE_MAP_POSITIVE_Z",34074:"TEXTURE_CUBE_MAP_NEGATIVE_Z",34076:"MAX_CUBE_MAP_TEXTURE_SIZE",34229:"VERTEX_ARRAY_BINDING",34338:"VERTEX_ATTRIB_ARRAY_ENABLED",34339:"VERTEX_ATTRIB_ARRAY_SIZE",34340:"VERTEX_ATTRIB_ARRAY_STRIDE",34341:"VERTEX_ATTRIB_ARRAY_TYPE",34342:"CURRENT_VERTEX_ATTRIB",34373:"VERTEX_ATTRIB_ARRAY_POINTER",34467:"COMPRESSED_TEXTURE_FORMATS",34660:"BUFFER_SIZE",34661:"BUFFER_USAGE",34816:"STENCIL_BACK_FUNC",34817:"STENCIL_BACK_FAIL",34818:"STENCIL_BACK_PASS_DEPTH_FAIL",34819:"STENCIL_BACK_PASS_DEPTH_PASS",34836:"RGBA32F",34837:"RGB32F",34842:"RGBA16F",34843:"RGB16F",34852:"MAX_DRAW_BUFFERS",34853:"DRAW_BUFFER0",34854:"DRAW_BUFFER1",34855:"DRAW_BUFFER2",34856:"DRAW_BUFFER3",34857:"DRAW_BUFFER4",34858:"DRAW_BUFFER5",34859:"DRAW_BUFFER6",34860:"DRAW_BUFFER7",34861:"DRAW_BUFFER8",34862:"DRAW_BUFFER9",34863:"DRAW_BUFFER10",34864:"DRAW_BUFFER11",34865:"DRAW_BUFFER12",34866:"DRAW_BUFFER13",34867:"DRAW_BUFFER14",34868:"DRAW_BUFFER15",34877:"BLEND_EQUATION_ALPHA",34892:"TEXTURE_COMPARE_MODE",34893:"TEXTURE_COMPARE_FUNC",34894:"COMPARE_REF_TO_TEXTURE",34917:"CURRENT_QUERY",34918:"QUERY_RESULT",34919:"QUERY_RESULT_AVAILABLE",34921:"MAX_VERTEX_ATTRIBS",34922:"VERTEX_ATTRIB_ARRAY_NORMALIZED",34930:"MAX_TEXTURE_IMAGE_UNITS",34962:"ARRAY_BUFFER",34963:"ELEMENT_ARRAY_BUFFER",34964:"ARRAY_BUFFER_BINDING",34965:"ELEMENT_ARRAY_BUFFER_BINDING",34975:"VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",35040:"STREAM_DRAW",35041:"STREAM_READ",35042:"STREAM_COPY",35044:"STATIC_DRAW",35045:"STATIC_READ",35046:"STATIC_COPY",35048:"DYNAMIC_DRAW",35049:"DYNAMIC_READ",35050:"DYNAMIC_COPY",35051:"PIXEL_PACK_BUFFER",35052:"PIXEL_UNPACK_BUFFER",35053:"PIXEL_PACK_BUFFER_BINDING",35055:"PIXEL_UNPACK_BUFFER_BINDING",35056:"DEPTH24_STENCIL8",35069:"VERTEX_ATTRIB_ARRAY_INTEGER",35070:"VERTEX_ATTRIB_ARRAY_DIVISOR",35071:"MAX_ARRAY_TEXTURE_LAYERS",35076:"MIN_PROGRAM_TEXEL_OFFSET",35077:"MAX_PROGRAM_TEXEL_OFFSET",35097:"SAMPLER_BINDING",35345:"UNIFORM_BUFFER",35368:"UNIFORM_BUFFER_BINDING",35369:"UNIFORM_BUFFER_START",35370:"UNIFORM_BUFFER_SIZE",35371:"MAX_VERTEX_UNIFORM_BLOCKS",35373:"MAX_FRAGMENT_UNIFORM_BLOCKS",35374:"MAX_COMBINED_UNIFORM_BLOCKS",35375:"MAX_UNIFORM_BUFFER_BINDINGS",35376:"MAX_UNIFORM_BLOCK_SIZE",35377:"MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS",35379:"MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS",35380:"UNIFORM_BUFFER_OFFSET_ALIGNMENT",35382:"ACTIVE_UNIFORM_BLOCKS",35383:"UNIFORM_TYPE",35384:"UNIFORM_SIZE",35386:"UNIFORM_BLOCK_INDEX",35387:"UNIFORM_OFFSET",35388:"UNIFORM_ARRAY_STRIDE",35389:"UNIFORM_MATRIX_STRIDE",35390:"UNIFORM_IS_ROW_MAJOR",35391:"UNIFORM_BLOCK_BINDING",35392:"UNIFORM_BLOCK_DATA_SIZE",35394:"UNIFORM_BLOCK_ACTIVE_UNIFORMS",35395:"UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES",35396:"UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER",35398:"UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER",35632:"FRAGMENT_SHADER",35633:"VERTEX_SHADER",35657:"MAX_FRAGMENT_UNIFORM_COMPONENTS",35658:"MAX_VERTEX_UNIFORM_COMPONENTS",35659:"MAX_VARYING_COMPONENTS",35660:"MAX_VERTEX_TEXTURE_IMAGE_UNITS",35661:"MAX_COMBINED_TEXTURE_IMAGE_UNITS",35663:"SHADER_TYPE",35664:"FLOAT_VEC2",35665:"FLOAT_VEC3",35666:"FLOAT_VEC4",35667:"INT_VEC2",35668:"INT_VEC3",35669:"INT_VEC4",35670:"BOOL",35671:"BOOL_VEC2",35672:"BOOL_VEC3",35673:"BOOL_VEC4",35674:"FLOAT_MAT2",35675:"FLOAT_MAT3",35676:"FLOAT_MAT4",35678:"SAMPLER_2D",35679:"SAMPLER_3D",35680:"SAMPLER_CUBE",35682:"SAMPLER_2D_SHADOW",35685:"FLOAT_MAT2x3",35686:"FLOAT_MAT2x4",35687:"FLOAT_MAT3x2",35688:"FLOAT_MAT3x4",35689:"FLOAT_MAT4x2",35690:"FLOAT_MAT4x3",35712:"DELETE_STATUS",35713:"COMPILE_STATUS",35714:"LINK_STATUS",35715:"VALIDATE_STATUS",35717:"ATTACHED_SHADERS",35718:"ACTIVE_UNIFORMS",35721:"ACTIVE_ATTRIBUTES",35723:"FRAGMENT_SHADER_DERIVATIVE_HINT",35724:"SHADING_LANGUAGE_VERSION",35725:"CURRENT_PROGRAM",35738:"IMPLEMENTATION_COLOR_READ_TYPE",35739:"IMPLEMENTATION_COLOR_READ_FORMAT",35863:"UNSIGNED_NORMALIZED",35866:"TEXTURE_2D_ARRAY",35869:"TEXTURE_BINDING_2D_ARRAY",35887:"ANY_SAMPLES_PASSED",35898:"R11F_G11F_B10F",35899:"UNSIGNED_INT_10F_11F_11F_REV",35901:"RGB9_E5",35902:"UNSIGNED_INT_5_9_9_9_REV",35904:"SRGB",35905:"SRGB8",35907:"SRGB8_ALPHA8",35967:"TRANSFORM_FEEDBACK_BUFFER_MODE",35968:"MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS",35971:"TRANSFORM_FEEDBACK_VARYINGS",35972:"TRANSFORM_FEEDBACK_BUFFER_START",35973:"TRANSFORM_FEEDBACK_BUFFER_SIZE",35976:"TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN",35977:"RASTERIZER_DISCARD",35978:"MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS",35979:"MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS",35980:"INTERLEAVED_ATTRIBS",35981:"SEPARATE_ATTRIBS",35982:"TRANSFORM_FEEDBACK_BUFFER",35983:"TRANSFORM_FEEDBACK_BUFFER_BINDING",36003:"STENCIL_BACK_REF",36004:"STENCIL_BACK_VALUE_MASK",36005:"STENCIL_BACK_WRITEMASK",36006:"FRAMEBUFFER_BINDING",36007:"RENDERBUFFER_BINDING",36008:"READ_FRAMEBUFFER",36009:"DRAW_FRAMEBUFFER",36010:"READ_FRAMEBUFFER_BINDING",36011:"RENDERBUFFER_SAMPLES",36012:"DEPTH_COMPONENT32F",36013:"DEPTH32F_STENCIL8",36048:"FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",36049:"FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",36050:"FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",36051:"FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",36052:"FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER",36053:"FRAMEBUFFER_COMPLETE",36054:"FRAMEBUFFER_INCOMPLETE_ATTACHMENT",36055:"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",36057:"FRAMEBUFFER_INCOMPLETE_DIMENSIONS",36061:"FRAMEBUFFER_UNSUPPORTED",36063:"MAX_COLOR_ATTACHMENTS",36064:"COLOR_ATTACHMENT0",36065:"COLOR_ATTACHMENT1",36066:"COLOR_ATTACHMENT2",36067:"COLOR_ATTACHMENT3",36068:"COLOR_ATTACHMENT4",36069:"COLOR_ATTACHMENT5",36070:"COLOR_ATTACHMENT6",36071:"COLOR_ATTACHMENT7",36072:"COLOR_ATTACHMENT8",36073:"COLOR_ATTACHMENT9",36074:"COLOR_ATTACHMENT10",36075:"COLOR_ATTACHMENT11",36076:"COLOR_ATTACHMENT12",36077:"COLOR_ATTACHMENT13",36078:"COLOR_ATTACHMENT14",36079:"COLOR_ATTACHMENT15",36096:"DEPTH_ATTACHMENT",36128:"STENCIL_ATTACHMENT",36160:"FRAMEBUFFER",36161:"RENDERBUFFER",36162:"RENDERBUFFER_WIDTH",36163:"RENDERBUFFER_HEIGHT",36164:"RENDERBUFFER_INTERNAL_FORMAT",36168:"STENCIL_INDEX8",36176:"RENDERBUFFER_RED_SIZE",36177:"RENDERBUFFER_GREEN_SIZE",36178:"RENDERBUFFER_BLUE_SIZE",36179:"RENDERBUFFER_ALPHA_SIZE",36180:"RENDERBUFFER_DEPTH_SIZE",36181:"RENDERBUFFER_STENCIL_SIZE",36182:"FRAMEBUFFER_INCOMPLETE_MULTISAMPLE",36183:"MAX_SAMPLES",36194:"RGB565",36202:"ANY_SAMPLES_PASSED_CONSERVATIVE",36203:"MAX_ELEMENT_INDEX",36208:"RGBA32UI",36209:"RGB32UI",36214:"RGBA16UI",36215:"RGB16UI",36220:"RGBA8UI",36221:"RGB8UI",36226:"RGBA32I",36227:"RGB32I",36232:"RGBA16I",36233:"RGB16I",36238:"RGBA8I",36239:"RGB8I",36244:"RED_INTEGER",36248:"RGB_INTEGER",36249:"RGBA_INTEGER",36255:"INT_2_10_10_10_REV",36269:"FLOAT_32_UNSIGNED_INT_24_8_REV",36289:"SAMPLER_2D_ARRAY",36292:"SAMPLER_2D_ARRAY_SHADOW",36293:"SAMPLER_CUBE_SHADOW",36294:"UNSIGNED_INT_VEC2",36295:"UNSIGNED_INT_VEC3",36296:"UNSIGNED_INT_VEC4",36298:"INT_SAMPLER_2D",36299:"INT_SAMPLER_3D",36300:"INT_SAMPLER_CUBE",36303:"INT_SAMPLER_2D_ARRAY",36306:"UNSIGNED_INT_SAMPLER_2D",36307:"UNSIGNED_INT_SAMPLER_3D",36308:"UNSIGNED_INT_SAMPLER_CUBE",36311:"UNSIGNED_INT_SAMPLER_2D_ARRAY",36336:"LOW_FLOAT",36337:"MEDIUM_FLOAT",36338:"HIGH_FLOAT",36339:"LOW_INT",36340:"MEDIUM_INT",36341:"HIGH_INT",36347:"MAX_VERTEX_UNIFORM_VECTORS",36348:"MAX_VARYING_VECTORS",36349:"MAX_FRAGMENT_UNIFORM_VECTORS",36386:"TRANSFORM_FEEDBACK",36387:"TRANSFORM_FEEDBACK_PAUSED",36388:"TRANSFORM_FEEDBACK_ACTIVE",36389:"TRANSFORM_FEEDBACK_BINDING",36662:"COPY_READ_BUFFER_BINDING",36663:"COPY_WRITE_BUFFER_BINDING",36756:"R8_SNORM",36757:"RG8_SNORM",36758:"RGB8_SNORM",36759:"RGBA8_SNORM",36764:"SIGNED_NORMALIZED",36975:"RGB10_A2UI",37137:"MAX_SERVER_WAIT_TIMEOUT",37138:"OBJECT_TYPE",37139:"SYNC_CONDITION",37140:"SYNC_STATUS",37141:"SYNC_FLAGS",37142:"SYNC_FENCE",37143:"SYNC_GPU_COMMANDS_COMPLETE",37144:"UNSIGNALED",37145:"SIGNALED",37146:"ALREADY_SIGNALED",37147:"TIMEOUT_EXPIRED",37148:"CONDITION_SATISFIED",37149:"WAIT_FAILED",37154:"MAX_VERTEX_OUTPUT_COMPONENTS",37157:"MAX_FRAGMENT_INPUT_COMPONENTS",37167:"TEXTURE_IMMUTABLE_FORMAT",37440:"UNPACK_FLIP_Y_WEBGL",37441:"UNPACK_PREMULTIPLY_ALPHA_WEBGL",37442:"CONTEXT_LOST_WEBGL",37443:"UNPACK_COLORSPACE_CONVERSION_WEBGL",37444:"BROWSER_DEFAULT_WEBGL",37447:"MAX_CLIENT_WAIT_TIMEOUT_WEBGL",4294967295:"INVALID_INDEX","-1":"TIMEOUT_IGNORED"};let d;function T(e){let t;switch(e){case"MAT2":t=4;break;case"MAT3":t=9;break;case"MAT4":t=16;break;case"VEC4":t=4;break;case"VEC3":t=3;break;case"VEC2":t=2;break;case"SCALAR":t=1}return t}function E(e){return"rotation"===e?4:"translation"===e||"scale"===e?3:void 0}function p(e,t){if(0===t.length)return[-1,-1,0];let n=-1;for(let r=t.length-1;r>=0;r--)if(e>=t[r].time){n=r;break}if(-1===n||n===t.length-1)return n<0&&(n=0),[n,n,0];{const s=t[n],a=t[n+1];return e=Math.max(s.time,Math.min(e,a.time)),[n,n+1,(r=s.time,i=a.time,(e-r)/(i-r))]}var r,i}const g=new Map;function R(e,t,n){const r=function(e){let t;switch(m[e]){case"BYTE":case"UNSIGNED_BYTE":t=1;break;case"SHORT":case"UNSIGNED_SHORT":t=2;break;case"UNSIGNED_INT":case"FLOAT":t=4}return t}(t.componentType),i=T(t.type),s=(n.byteOffset||0)+(t.byteOffset||0),a=n.byteStride,o=a*t.count/r,l=t.count*i;let c,u=o||l;switch(e.byteLength<u*r+s&&(u-=t.byteOffset),m[t.componentType]){case"BYTE":c=new Int8Array(e,s,u);break;case"UNSIGNED_BYTE":c=new Uint8Array(e,s,u);break;case"SHORT":c=new Int16Array(e,s,u);break;case"UNSIGNED_SHORT":c=new Uint16Array(e,s,u);break;case"UNSIGNED_INT":c=new Uint32Array(e,s,u);break;case"FLOAT":c=new Float32Array(e,s,u)}if(u!==l){const e=new c.constructor(l);let t=0;for(let n=0;n<e.length;n+=i){for(let r=0;r<i;r++)e[n+r]=c[t+r];t+=a/r}return e}return c}function A(e,t,n,r){let i;switch(m[t]){case"BYTE":i=new Int8Array(e,n,r);break;case"UNSIGNED_BYTE":i=new Uint8Array(e,n,r);break;case"SHORT":i=new Int16Array(e,n,r);break;case"UNSIGNED_SHORT":i=new Uint16Array(e,n,r);break;case"UNSIGNED_INT":i=new Uint32Array(e,n,r);break;case"FLOAT":i=new Float32Array(e,n,r)}return i}function _(e,t,n){const r=d.createShader(e);d.shaderSource(r,t),d.compileShader(r),d.attachShader(n,r);const i=d.getShaderInfoLog(r);if(i)throw new Error(i)}function x(e,t){const n=d.createProgram();if(_(d.VERTEX_SHADER,e,n),_(d.FRAGMENT_SHADER,t,n),d.linkProgram(n),d.validateProgram(n),!d.getProgramParameter(n,d.LINK_STATUS)){const e=d.getProgramInfoLog(n);throw new Error(`Could not compile WebGL program. ${e}`)}return n}function v(e,t){!function e(n){t(n),n.children&&n.children.forEach(e)}(e)}function b(e,t,n,r){const[i,a]=e,l=new s;l.setTranslate(new o([0,0,.05]));const u=new s(t);u.multiply(l);const h=u.multiplyVector4(new c([0,0,0,1]));h.elements[0]=(2*i/n-1)*h.elements[3],h.elements[1]=(-2*a/r+1)*h.elements[3];const f=u.invert().multiplyVector4(h);return[f.elements[0],f.elements[1]]}function S(e){const{aspect:t,zoom:n}=e;let r;if("perspective"===e.type&&e.perspective){const{yfov:n}=e.perspective;r=(new s).setPerspective(n,t,e.perspective.znear||1,e.perspective.zfar||2e6)}else"orthographic"===e.type&&e.orthographic&&(r=(new s).setOrtho(e.orthographic.xmag*n,e.orthographic.ymag*n,e.orthographic.znear,e.orthographic.zfar));return r}function N(e=0,t=0){return e+t}function U(e){let t;switch(!0){case e instanceof Uint8Array:t=e=>e/255;break;case e instanceof Int8Array:t=e=>Math.max(e/127,-1);break;case e instanceof Uint16Array:t=e=>e/65535;break;case e instanceof Int16Array:t=e=>Math.max(e/32767,-1)}if(t){const n=new Float32Array(e.length);for(let r=0;r<e.length;r++)n[r]=t(e[r]);return n}return e}g.set(Int8Array,"BYTE"),g.set(Uint8Array,"UNSIGNED_BYTE"),g.set(Int16Array,"SHORT"),g.set(Uint16Array,"UNSIGNED_SHORT"),g.set(Uint32Array,"UNSIGNED_INT"),g.set(Float32Array,"FLOAT");class I extends f{constructor(e,t){super(e,t),this.program=null,this.defines=null,this.mode=4,this.variants=[]}setDefines(e){this.defines=e}setBlend(e){this.material.blend=e}setMaterial(e){this.material=e}drawWebGPU(e,t,{needUpdateView:n,needUpdateProjection:r,camera:i,light:a}){if(this.reflow){const t=new s(this.matrixWorld);t.invert().transpose(),this.geometry.uniformBuffer.updateWebGPU(e,"model",this.matrixWorld.elements),this.geometry.uniformBuffer.updateWebGPU(e,"normalMatrix",t.elements)}if(n&&(this.geometry.uniformBuffer.updateWebGPU(e,"view",i.matrixWorldInvert.elements),this.geometry.uniformBuffer.updateWebGPU(e,"light",a.matrixWorldInvert.elements)),r&&this.geometry.uniformBuffer.updateWebGPU(e,"projection",i.projection.elements),this instanceof M&&this.bones.some((e=>e.reflow))){const t=this.getJointMatrix(),n=new Float32Array(16*t.length);let r=0;for(const e of t)n.set(e.elements,0+16*r),r++;e.device.queue.writeBuffer(this.skinBuffer,0*Float32Array.BYTES_PER_ELEMENT,n.buffer,n.byteOffset,n.byteLength)}t.setBindGroup(0,this.uniformBindGroup1),t.setVertexBuffer(0,this.geometry.verticesWebGPUBuffer),this.geometry.indicesBuffer?(t.setIndexBuffer(this.geometry.indicesWebGPUBuffer,"uint32"),t.drawIndexed(this.geometry.indicesBuffer.length)):t.draw(this.geometry.attributes.POSITION.length/3,1,0,0)}draw(e,{lights:t,camera:n,light:r,needUpdateView:i,needUpdateProjection:a,preDepthTexture:o,colorTexture:l,renderState:c,fakeDepth:u,isIBL:h,isDefaultLight:f}){const{isprepender:m,isprerefraction:d}=c;if(!this.material.transmissionFactor||!d){if(e.useProgram(this.program),e.bindVertexArray(this.geometry.VAO),e.bindBufferBase(e.UNIFORM_BUFFER,0,this.geometry.UBO),this.reflow){const t=new s(this.matrixWorld);t.invert().transpose(),this.geometry.uniformBuffer.update(e,"model",this.matrixWorld.elements),this.geometry.uniformBuffer.update(e,"normalMatrix",t.elements)}if(i&&(this.geometry.uniformBuffer.update(e,"view",n.matrixWorldInvert.elements),this.geometry.uniformBuffer.update(e,"light",r.matrixWorldInvert.elements)),a&&this.geometry.uniformBuffer.update(e,"projection",n.projection.elements),this.geometry.uniformBuffer.update(e,"isShadow",m?1:0),this instanceof M&&(e.bindBufferBase(e.UNIFORM_BUFFER,2,this.geometry.SKIN),this.bones.some((e=>e.reflow)))){const t=this.getJointMatrix(),n=new Float32Array(16*t.length);let r=0;for(const e of t)n.set(e.elements,0+16*r),r++;e.bufferSubData(e.UNIFORM_BUFFER,0,n)}if(this.material.UBO&&(e.bindBufferBase(e.UNIFORM_BUFFER,1,this.material.UBO),i)){const r=new Float32Array(3*t.length);t.forEach(((e,t)=>{r.set(e.getPosition(),3*t)})),this.material.materialUniformBuffer.update(e,"viewPos",n.getPosition()),e.bindBufferBase(e.UNIFORM_BUFFER,4,this.material.lightUBO2),this.material.lightPosBuffer.update(e,"lightPos",r)}this.material.lightUBO1&&(e.bindBufferBase(e.UNIFORM_BUFFER,3,this.material.lightUBO1),e.bindBufferBase(e.UNIFORM_BUFFER,4,this.material.lightUBO2),e.bindBufferBase(e.UNIFORM_BUFFER,5,this.material.lightUBO3),e.bindBufferBase(e.UNIFORM_BUFFER,6,this.material.lightUBO4)),this.material.sphericalHarmonics&&e.bindBufferBase(e.UNIFORM_BUFFER,7,this.material.sphericalHarmonics),e.uniform1i(this.material.uniforms.depthTexture,o&&!m?o.index:u.index),e.uniform1i(this.material.uniforms.colorTexture,d?u.index:l.index),e.uniform1i(e.getUniformLocation(this.program,"isTone"),d?0:1),e.uniform1i(e.getUniformLocation(this.program,"isIBL"),h?1:0),e.uniform1i(e.getUniformLocation(this.program,"isDefaultLight"),f||t.some((e=>!e.isInitial))?1:0),this.material.baseColorTexture&&(e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,this.material.baseColorTexture),e.bindSampler(0,this.material.baseColorTexture.sampler)),this.material.metallicRoughnessTexture&&(e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,this.material.metallicRoughnessTexture),e.bindSampler(1,this.material.metallicRoughnessTexture.sampler)),this.material.normalTexture&&(e.activeTexture(e.TEXTURE2),e.bindTexture(e.TEXTURE_2D,this.material.normalTexture),e.bindSampler(2,this.material.normalTexture.sampler)),this.material.occlusionTexture&&(e.activeTexture(e.TEXTURE3),e.bindTexture(e.TEXTURE_2D,this.material.occlusionTexture),e.bindSampler(3,this.material.occlusionTexture.sampler)),this.material.emissiveTexture&&(e.activeTexture(e.TEXTURE4),e.bindTexture(e.TEXTURE_2D,this.material.emissiveTexture),e.bindSampler(4,this.material.emissiveTexture.sampler)),this.material.clearcoatTexture&&(e.activeTexture(e.TEXTURE8),e.bindTexture(e.TEXTURE_2D,this.material.clearcoatTexture),e.bindSampler(8,this.material.clearcoatTexture.sampler)),this.material.clearcoatRoughnessTexture&&(e.activeTexture(e.TEXTURE9),e.bindTexture(e.TEXTURE_2D,this.material.clearcoatRoughnessTexture),e.bindSampler(9,this.material.clearcoatRoughnessTexture.sampler)),this.material.sheenColorTexture&&(e.activeTexture(e.TEXTURE11),e.bindTexture(e.TEXTURE_2D,this.material.sheenColorTexture),e.bindSampler(11,this.material.sheenColorTexture.sampler)),this.material.sheenRoughnessTexture&&(e.activeTexture(e.TEXTURE12),e.bindTexture(e.TEXTURE_2D,this.material.sheenRoughnessTexture),e.bindSampler(12,this.material.sheenRoughnessTexture.sampler)),this.material.clearcoatNormalTexture&&(e.activeTexture(e.TEXTURE10),e.bindTexture(e.TEXTURE_2D,this.material.clearcoatNormalTexture),e.bindSampler(10,this.material.clearcoatNormalTexture.sampler)),this.material.transmissionTexture&&(e.activeTexture(e.TEXTURE14),e.bindTexture(e.TEXTURE_2D,this.material.transmissionTexture),e.bindSampler(14,this.material.transmissionTexture.sampler)),this.material.specularTexture&&(e.activeTexture(e.TEXTURE15),e.bindTexture(e.TEXTURE_2D,this.material.specularTexture),e.bindSampler(15,this.material.specularTexture.sampler)),this.material.thicknessTexture&&(e.activeTexture(e.TEXTURE16),e.bindTexture(e.TEXTURE_2D,this.material.thicknessTexture),e.bindSampler(16,this.material.thicknessTexture.sampler)),this.material.doubleSided&&e.disable(e.CULL_FACE),this.geometry.indicesBuffer?e.drawElements(this.mode,this.geometry.indicesBuffer.length,e[g.get(this.geometry.indicesBuffer.constructor)],0):e.drawArrays(this.mode,0,this.geometry.attributes.POSITION.length/3),this.material.doubleSided&&e.enable(e.CULL_FACE)}}setGeometry(e){this.geometry=e}setProgram(e){this.program=e}setMode(e=4){this.mode=e}setVariants(e){this.variants=e}isVisible(e){const t=new o(this.geometry.boundingSphere.center.elements).applyMatrix4(this.matrixWorld),n=this.geometry.boundingSphere.radius*this.matrixWorld.getMaxScaleOnAxis();let r,i=!0;for(const s of e)if(r=s.elements[0]*t.elements[0]+s.elements[1]*t.elements[1]+s.elements[2]*t.elements[2]+s.elements[3],r<-n){i=!1;break}return this.distance=r+n,i}calculateBounding(){this.geometry.calculateBounding(this.matrixWorld)}}class M extends I{constructor(e,t){super(e,t)}setSkinWebGPU(e,t){this.bones=t.bones,this.boneInverses=t.boneInverses;const n=this.getJointMatrix(),r=new Float32Array(16*n.length);let i=0;for(const e of n)r.set(e.elements,0+16*i),i++;const s=r.byteLength,a=256+s,{device:o}=e,l=o.createBuffer({size:a,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});this.skinBuffer=l;const c={binding:22,resource:{buffer:l,offset:0,size:s}};return o.queue.writeBuffer(l,0,r.buffer,r.byteOffset,r.byteLength),c}setSkin(e,t){this.bones=t.bones,this.boneInverses=t.boneInverses;const n=this.getJointMatrix(),r=new Float32Array(16*n.length);let i=0;for(const e of n)r.set(e.elements,0+16*i),i++;const s=e.getUniformBlockIndex(this.program,"Skin");e.uniformBlockBinding(this.program,s,2);const a=e.createBuffer();return e.bindBuffer(e.UNIFORM_BUFFER,a),e.bufferData(e.UNIFORM_BUFFER,r,e.DYNAMIC_DRAW),this.geometry.SKIN=a,e.bindBuffer(e.UNIFORM_BUFFER,null),this}getJointMatrix(){const e=new s(this.matrixWorld).invert(),t=[];for(let n=0;n<this.boneInverses.length;n++){const r=(new s).multiply(e).multiply(this.bones[n].matrixWorld).multiply(this.boneInverses[n]);t.push(r)}return t}}class F extends f{}class C extends f{constructor(e,t,n){super(t,n),this.matrixWorldInvert=new s,this.projection=new s,this.props=e,this.yaw=0,this.pitch=-Math.PI,this.rotation=new s}setProjection(e){this.projection.set(e.elements)}setMatrixWorld(e){super.setMatrixWorld(e),this.matrixWorldInvert.setInverseOf(this.matrixWorld),this.matrixInitial||(this.matrixInitial=new s(this.matrixWorld))}setZ(e){this.matrix.elements[14]=e,this.matrixInitial=new s(this.matrix),this.setMatrixWorld(this.matrix.elements)}getViewProjMatrix(){const e=new s;return e.multiply(this.projection),e.multiply(this.matrixWorldInvert),e}pan(e,t,n,r){const i=b(e,this.projection,n,r),a=b(t,this.projection,n,r),l=new o([...i,0]),c=new o([...a,0]);if("orthographic"===this.props.type){const e=2*this.matrixWorld.elements[14],t=l.subtract(c).scale(e);this.matrixInitial.translate(t.elements[0],t.elements[1],0)}else{const e=10*this.matrixWorld.elements[14],t=c.subtract(l).scale(e);this.matrixInitial.translate(t.elements[0],t.elements[1],0)}const u=new s(this.rotation);u.multiply(this.matrixInitial),this.setMatrixWorld(u.elements)}rotate(e,t){var n,r,i;this.yaw+=.01*(e[0]-t[0]),this.pitch+=.01*(e[1]-t[1]),this.pitch=(n=this.pitch,r=-1.5*Math.PI,i=-.5*Math.PI,n<r?r:n>i?i:n);const a=new s;a.rotate(new o([1,0,0]),this.pitch),a.rotate(new o([0,1,0]),-this.yaw),a.rotate(new o([1,0,0]),Math.PI),this.rotation=a;const l=new s(a);l.multiply(this.matrixInitial),this.setMatrixWorld(l.elements)}zoom(e){this.matrixInitial.elements[14]+=e*this.modelSize*.001;const t=new s(this.rotation);t.multiply(this.matrixInitial),this.setMatrixWorld(t.elements),this.updateNF()}updateNF(){if(this.props.isInitial){const e=Math.min(...this.matrixWorld.getScaling().elements),t=this.modelSize/e,n=Math.abs(this.matrixWorldInvert.elements[14]),r=this.props.perspective||this.props.orthographic;r.znear=Math.max(n-t,.05*t),r.zfar=n+t}this.setProjection(S(this.props))}}class L extends f{constructor(e,t,n){super(t,n);const{type:r,color:i,intensity:a,isInitial:l,spot:c={}}=e;this.type=r,this.color=new o(i),this.intensity=a,this.isInitial=l,this.spot=c,this.matrixWorldInvert=new s}setMatrixWorld(e){super.setMatrixWorld(e),this.matrixWorldInvert.setInverseOf(this.matrixWorld)}setZ(e){this.matrix.elements[13]=e,this.matrix.elements[14]=e,this.setMatrixWorld(this.matrix.elements)}update(e){if(this.isInitial||"directional"===this.type){const t=new s;t.makeRotationAxis(new o([0,1,0]),e),t.multiply(this.matrix),this.setMatrixWorld(t.elements)}}}class O{constructor(){this.map=new Map,this.tempStore={},this.offset=0}getBuffer(e){const{length:t}=e;return 3===t?new Float32Array([e[0],e[1],e[2],0]):9===t?new Float32Array([e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0]):12===t?new Float32Array([e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,e[9],e[10],e[11],0]):6===t?new Float32Array([e[0],e[1],e[2],0,e[3],e[4],e[5],0]):e}add(e,t){void 0===t.length&&(t=[t]),this.map.set(e,this.offset);const n=this.getBuffer(t);this.tempStore[e]=n,this.offset+=Math.max(n.length,4)}update(e,t,n){void 0===n.length&&(n=new Float32Array([n]));const r=this.map.get(t),i=this.getBuffer(n);this.store.set(i,r),e.bufferSubData(e.UNIFORM_BUFFER,r*Float32Array.BYTES_PER_ELEMENT,i)}updateWebGPU(e,t,n){const{device:r}=e;void 0===n.length&&(n=new Float32Array([n]));const i=this.map.get(t),s=this.getBuffer(n);this.store.set(s,i),r.queue.writeBuffer(this.bufferWebGPU,i*Float32Array.BYTES_PER_ELEMENT,s.buffer,s.byteOffset,s.byteLength)}done(){this.store=new Float32Array(this.offset);for(const[e,t]of this.map)this.store.set(this.tempStore[e],t);this.tempStore=null}}const P={baseColorFactor:[1,0,0,1]},y={directional:0,point:1,spot:2};class B extends class{}{constructor(e=P,t,n,r){super();const i=Object.assign({},e);if(this.defines=n,this.name=i.name,!i.pbrMetallicRoughness&&i.extensions&&i.extensions.KHR_materials_pbrSpecularGlossiness){i.pbrMetallicRoughness={};const e=i.extensions.KHR_materials_pbrSpecularGlossiness;i.pbrMetallicRoughness.baseColorTexture=e.diffuseTexture,i.pbrMetallicRoughness.metallicRoughnessTexture=e.specularGlossinessTexture,i.pbrMetallicRoughness.baseColorFactor=e.diffuseFactor,i.pbrMetallicRoughness.specularFactor=e.specularFactor,i.pbrMetallicRoughness.glossinessFactor=e.glossinessFactor,n.push({name:"SPECULARGLOSSINESSMAP"})}if(i.extensions&&i.extensions.KHR_materials_clearcoat){const e=i.extensions.KHR_materials_clearcoat;if(this.clearcoatFactor=e.clearcoatFactor,this.clearcoatRoughnessFactor=e.clearcoatRoughnessFactor,n.push({name:"CLEARCOAT"}),e.clearcoatTexture){const{extensions:r,texCoord:i}=e.clearcoatTexture;if(this.clearcoatTexture=t[e.clearcoatTexture.index],n.push({name:"CLEARCOATMAP",value:i?2:1}),r){const e=r.KHR_texture_transform;e&&this.buildTrans(e,n,"CLEARCOATMAP")}}if(e.clearcoatNormalTexture){const{extensions:r,texCoord:i}=e.clearcoatNormalTexture;if(this.clearcoatNormalTexture=t[e.clearcoatNormalTexture.index],n.push({name:"CLEARCOATNORMALMAP",value:i?2:1}),r){const e=r.KHR_texture_transform;e&&this.buildTrans(e,n,"CLEARCOATNORMALMAP")}}if(e.clearcoatRoughnessTexture){const{extensions:r,texCoord:i}=e.clearcoatRoughnessTexture;if(this.clearcoatRoughnessTexture=t[e.clearcoatRoughnessTexture.index],n.push({name:"CLEARCOATROUGHMAP",value:i?2:1}),r){const e=r.KHR_texture_transform;e&&this.buildTrans(e,n,"CLEARCOATROUGHMAP")}}}if(i.extensions&&i.extensions.KHR_materials_sheen){const{sheenColorTexture:e,sheenColorFactor:r,sheenRoughnessFactor:s,sheenRoughnessTexture:a}=i.extensions.KHR_materials_sheen;if(this.sheenColorFactor=r,this.sheenRoughnessFactor=s,e){const{extensions:r,texCoord:i}=e;if(this.sheenColorTexture=t[e.index],n.push({name:"SHEENMAP",value:i?2:1}),r){const e=r.KHR_texture_transform;e&&this.buildTrans(e,n,"SHEENMAP")}}if(a){const{extensions:e,texCoord:r}=a;if(this.sheenRoughnessTexture=t[a.index],n.push({name:"SHEENMAP",value:r?2:1}),e){const t=e.KHR_texture_transform;t&&this.buildTrans(t,n,"SHEENMAP")}}}if(i.extensions&&i.extensions.KHR_materials_transmission){const{transmissionFactor:e,transmissionTexture:r}=i.extensions.KHR_materials_transmission;this.transmissionFactor=e,r&&(this.transmissionTexture=t[r.index],n.push({name:"TRANSMISSIONMAP"})),n.push({name:"TRANSMISSION"})}if(i.extensions&&i.extensions.KHR_materials_volume){const{attenuationColor:e,attenuationDistance:r,thicknessFactor:s,thicknessTexture:a}=i.extensions.KHR_materials_volume;this.attenuationColor=e,this.attenuationDistance=r,this.thicknessFactor=s,this.ior=1/1.5,a&&(this.thicknessTexture=t[a.index],n.push({name:"THICKNESSMAP"}))}if(i.extensions&&i.extensions.KHR_materials_ior&&(this.ior=i.extensions.KHR_materials_ior.ior),i.extensions&&i.extensions.KHR_materials_specular){const{specularTexture:e,specularColorFactor:r}=i.extensions.KHR_materials_specular;this.specularFactor=r,e&&(this.specularTexture=t[e.index],n.push({name:"SPECULARMAP"})),n.push({name:"SPECULAR"})}this.uniforms={baseColorTexture:null,metallicRoughnessTexture:null,normalTexture:null,occlusionTexture:null,clearcoatTexture:null,clearcoatRoughnessTexture:null,sheenRoughnessTexture:null,sheenColorTexture:null,clearcoatNormalTexture:null,emissiveTexture:null,prefilterMap:null,brdfLUT:null,irradianceMap:null,transmissionTexture:null,specularTexture:null,thicknessTexture:null,colorTexture:null,Sheen_E:null,depthTexture:null};const{pbrMetallicRoughness:s}=i;if(s&&(this.baseColorFactor=s.baseColorFactor,this.roughnessFactor=s.roughnessFactor,this.metallicFactor=s.metallicFactor,s.specularFactor&&(this.specularFactor=s.specularFactor),s.glossinessFactor&&(this.glossinessFactor=s.glossinessFactor)),this.alpha="BLEND"===i.alphaMode,this.doubleSided=i.doubleSided,this.emissiveFactor=i.emissiveFactor,this.extras=i.extras,s&&s.metallicRoughnessTexture){const{extensions:e,texCoord:r}=s.metallicRoughnessTexture;if(this.metallicRoughnessTexture=t[s.metallicRoughnessTexture.index],n.push({name:"METALROUGHNESSMAP",value:r?2:1}),e){const t=e.KHR_texture_transform;t&&this.buildTrans(t,n,"METALROUGHNESSMAP")}}if(i.normalTexture){const{extensions:e,texCoord:r}=i.normalTexture;if(this.normalTexture=t[i.normalTexture.index],this.normalTextureScale=i.normalTexture.scale,n.push({name:"NORMALMAP",value:r?2:1}),e){const t=e.KHR_texture_transform;t&&this.buildTrans(t,n,"NORMALMAP")}}if(i.occlusionTexture){const{extensions:e,texCoord:r}=i.occlusionTexture;if(this.occlusionTexture=t[i.occlusionTexture.index],n.push({name:"OCCLUSIONMAP",value:r?2:1}),e){const t=e.KHR_texture_transform;t&&this.buildTrans(t,n,"OCCLUSIONMAP")}}if(s&&s.baseColorTexture){const{extensions:e,texCoord:r}=s.baseColorTexture;if(this.baseColorTexture=t[s.baseColorTexture.index],n.push({name:"BASECOLORTEXTURE",value:r?2:1}),e){const t=e.KHR_texture_transform;t&&this.buildTrans(t,n,"BASECOLORTEXTURE")}}if(i.emissiveTexture){const{extensions:e,texCoord:r}=i.emissiveTexture;if(this.emissiveTexture=t[i.emissiveTexture.index],n.push({name:"EMISSIVEMAP",value:r?2:1}),e){const t=e.KHR_texture_transform;t&&this.buildTrans(t,n,"EMISSIVEMAP")}}"MASK"===i.alphaMode?n.push({name:"ALPHATEST",value:i.alphaCutoff??.5}):"BLEND"===i.alphaMode&&n.push({name:"ALPHATEST",value:.01}),this.doubleSided&&n.push({name:"DOUBLESIDED"}),n.push({name:"LIGHTNUMBER",value:r.length}),i.extensions&&i.extensions.KHR_materials_unlit&&n.push({name:"NOLIGHT"})}buildTrans(e,t,n=""){if(e.offset||e.scale||e.rotation){const r=e.offset||[0,0],s=e.scale||[1,1],a=e.rotation||0;this.matrix=(new i).set([...r,0,...s,0,a,0,0]),t.push({name:`${n}_TEXTURE_TRANSFORM`})}}setHarmonics(e){this.sphericalHarmonics=e}updateUniformsWebgl(e,t){e.useProgram(t),this.baseColorTexture&&(this.uniforms.baseColorTexture=e.getUniformLocation(t,"baseColorTexture"),e.uniform1i(this.uniforms.baseColorTexture,0)),this.metallicRoughnessTexture&&(this.uniforms.metallicRoughnessTexture=e.getUniformLocation(t,"metallicRoughnessTexture"),e.uniform1i(this.uniforms.metallicRoughnessTexture,1)),this.normalTexture&&(this.uniforms.normalTexture=e.getUniformLocation(t,"normalTexture"),e.uniform1i(this.uniforms.normalTexture,2)),this.occlusionTexture&&(this.uniforms.occlusionTexture=e.getUniformLocation(t,"occlusionTexture"),e.uniform1i(this.uniforms.occlusionTexture,3)),this.emissiveTexture&&(this.uniforms.emissiveTexture=e.getUniformLocation(t,"emissiveTexture"),e.uniform1i(this.uniforms.emissiveTexture,4)),this.clearcoatTexture&&(this.uniforms.clearcoatTexture=e.getUniformLocation(t,"clearcoatTexture"),e.uniform1i(this.uniforms.clearcoatTexture,8)),this.clearcoatRoughnessTexture&&(this.uniforms.clearcoatRoughnessTexture=e.getUniformLocation(t,"clearcoatRoughnessTexture"),e.uniform1i(this.uniforms.clearcoatRoughnessTexture,9)),this.clearcoatNormalTexture&&(this.uniforms.clearcoatNormalTexture=e.getUniformLocation(t,"clearcoatNormalTexture"),e.uniform1i(this.uniforms.clearcoatNormalTexture,10)),this.sheenRoughnessTexture&&(this.uniforms.sheenRoughnessTexture=e.getUniformLocation(t,"sheenRoughnessTexture"),e.uniform1i(this.uniforms.sheenRoughnessTexture,12)),this.sheenColorTexture&&(this.uniforms.sheenColorTexture=e.getUniformLocation(t,"sheenColorTexture"),e.uniform1i(this.uniforms.sheenColorTexture,11)),this.transmissionTexture&&(this.uniforms.transmissionTexture=e.getUniformLocation(t,"transmissionTexture"),e.uniform1i(this.uniforms.transmissionTexture,14)),this.specularTexture&&(this.uniforms.specularTexture=e.getUniformLocation(t,"specularTexture"),e.uniform1i(this.uniforms.specularTexture,15)),this.thicknessTexture&&(this.uniforms.thicknessTexture=e.getUniformLocation(t,"thicknessTexture"),e.uniform1i(this.uniforms.thicknessTexture,16)),this.uniforms.prefilterMap=e.getUniformLocation(t,"prefilterMap"),this.uniforms.brdfLUT=e.getUniformLocation(t,"brdfLUT"),this.uniforms.irradianceMap=e.getUniformLocation(t,"irradianceMap"),this.uniforms.depthTexture=e.getUniformLocation(t,"depthTexture"),this.uniforms.colorTexture=e.getUniformLocation(t,"colorTexture"),this.uniforms.Sheen_E=e.getUniformLocation(t,"Sheen_E"),e.uniform1i(this.uniforms.prefilterMap,6),e.uniform1i(this.uniforms.brdfLUT,7),e.uniform1i(this.uniforms.irradianceMap,5),e.uniform1i(this.uniforms.Sheen_E,13);{const n=e.getUniformBlockIndex(t,"Material");e.uniformBlockBinding(t,n,1);const r=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,r),e.bufferData(e.UNIFORM_BUFFER,this.materialUniformBuffer.store,e.STATIC_DRAW),this.UBO=r}{const n=e.getUniformBlockIndex(t,"LightColor");e.uniformBlockBinding(t,n,3);const r=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,r),e.bufferData(e.UNIFORM_BUFFER,this.lightColorBuffer.store,e.STATIC_DRAW),this.lightUBO1=r}{const n=e.getUniformBlockIndex(t,"LightPos");e.uniformBlockBinding(t,n,4);const r=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,r),e.bufferData(e.UNIFORM_BUFFER,this.lightPosBuffer.store,e.STATIC_DRAW),this.lightUBO2=r}{const n=e.getUniformBlockIndex(t,"Spotdir");e.uniformBlockBinding(t,n,5);const r=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,r),e.bufferData(e.UNIFORM_BUFFER,this.spotdirBuffer.store,e.STATIC_DRAW),this.lightUBO3=r}{const n=e.getUniformBlockIndex(t,"LightIntensity");e.uniformBlockBinding(t,n,6);const r=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,r),e.bufferData(e.UNIFORM_BUFFER,this.lightIntensityBuffer.store,e.STATIC_DRAW),this.lightUBO4=r}}createUniforms(e,t){const n=new Float32Array(3*t.length),r=new Float32Array(3*t.length),s=new Float32Array(3*t.length),a=new Float32Array(4*t.length);t.forEach(((e,t)=>{n.set(new o([e.matrixWorld.elements[8],e.matrixWorld.elements[9],e.matrixWorld.elements[10]]).normalize().elements,3*t),r.set(e.getPosition(),3*t),s.set(e.color.elements,3*t),a.set([e.intensity,e.spot.innerConeAngle??0,e.spot.outerConeAngle??0,y[e.type]],4*t)}));{const t=new O;t.add("baseColorFactor",this.baseColorFactor??[.8,.8,.8,1]),t.add("viewPos",e.getPosition()),t.add("textureMatrix",this.matrix&&this.matrix.elements||(new i).elements),t.add("specularFactor",this.specularFactor??[1,1,1]),t.add("emissiveFactor",this.emissiveFactor??[0,0,0]),t.add("glossinessFactor",this.glossinessFactor??.5),t.add("metallicFactor",this.metallicFactor??1),t.add("roughnessFactor",this.roughnessFactor??1),t.add("clearcoatFactor",this.clearcoatFactor??0),t.add("clearcoatRoughnessFactor",this.clearcoatRoughnessFactor??0),t.add("sheenColorFactor",this.sheenColorFactor??0),t.add("sheenRoughnessFactor",this.sheenRoughnessFactor??0),t.add("transmissionFactor",this.transmissionFactor??0),t.add("ior",this.ior??1),t.add("normalTextureScale",this.normalTextureScale??1),t.add("attenuationColor",this.attenuationColor??[1,1,1]),t.add("attenuationDistance",this.attenuationDistance??1),t.add("thicknessFactor",this.thicknessFactor??1),t.done(),this.materialUniformBuffer=t}{const e=new O;e.add("lightColor",s),e.done(),this.lightColorBuffer=e}{const e=new O;e.add("lightPos",r),e.done(),this.lightPosBuffer=e}{const e=new O;e.add("spotdir",n),e.done(),this.spotdirBuffer=e}{const e=new O;e.add("lightIntensity",a),e.done(),this.lightIntensityBuffer=e}}updateUniformsWebGPU(e){const{device:t}=e,n=t.createBuffer({size:256+this.materialUniformBuffer.store.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),r=t.createBuffer({size:256+this.lightColorBuffer.store.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),i=t.createBuffer({size:256+this.lightPosBuffer.store.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),s=t.createBuffer({size:256+this.spotdirBuffer.store.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),a=t.createBuffer({size:256+this.lightIntensityBuffer.store.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),o=this.baseColorTexture?this.baseColorTexture.sampler:t.createSampler({magFilter:"linear",minFilter:"linear",addressModeU:"repeat",addressModeV:"repeat",addressModeW:"repeat"}),l=[{binding:1,resource:{buffer:n,offset:0,size:this.materialUniformBuffer.store.byteLength}},{binding:2,resource:o},{binding:3,resource:this.baseColorTexture?.createView()},{binding:4,resource:this.metallicRoughnessTexture?.createView()},{binding:5,resource:this.normalTexture?.createView()},{binding:6,resource:this.emissiveTexture?.createView()},{binding:7,resource:this.occlusionTexture?.createView()},{binding:8,resource:this.clearcoatTexture?.createView()},{binding:9,resource:this.clearcoatRoughnessTexture?.createView()},{binding:10,resource:this.transmissionTexture?.createView()},{binding:11,resource:this.sheenColorTexture?.createView()},{binding:12,resource:this.sheenRoughnessTexture?.createView()},{binding:13,resource:this.clearcoatNormalTexture?.createView()},{binding:14,resource:this.specularTexture?.createView()},{binding:15,resource:{buffer:r,offset:0,size:this.lightColorBuffer.store.byteLength}},{binding:16,resource:{buffer:i,offset:0,size:this.lightPosBuffer.store.byteLength}},{binding:17,resource:{buffer:s,offset:0,size:this.spotdirBuffer.store.byteLength}},{binding:18,resource:{buffer:a,offset:0,size:this.lightIntensityBuffer.store.byteLength}}];t.queue.writeBuffer(n,0,this.materialUniformBuffer.store.buffer,this.materialUniformBuffer.store.byteOffset,this.materialUniformBuffer.store.byteLength),t.queue.writeBuffer(r,0,this.lightColorBuffer.store.buffer,this.lightColorBuffer.store.byteOffset,this.lightColorBuffer.store.byteLength),t.queue.writeBuffer(i,0,this.lightPosBuffer.store.buffer,this.lightPosBuffer.store.byteOffset,this.lightPosBuffer.store.byteLength),t.queue.writeBuffer(s,0,this.spotdirBuffer.store.buffer,this.spotdirBuffer.store.byteOffset,this.spotdirBuffer.store.byteLength),t.queue.writeBuffer(a,0,this.lightIntensityBuffer.store.buffer,this.lightIntensityBuffer.store.byteOffset,this.lightIntensityBuffer.store.byteLength),this.uniformBindGroup1=l.filter((e=>e.resource))}hasNormal(){return Boolean(this.normalTexture)||Boolean(this.clearcoatNormalTexture)}}class w{constructor(e,t){this.redraw=t,document.addEventListener("wheel",this,{passive:!1}),e.addEventListener("mousedown",this),e.addEventListener("mousemove",this),e.addEventListener("mouseup",this),document.addEventListener("keyup",this),document.addEventListener("keydown",this),addEventListener("resize",this)}handleEvent(e){switch(e.type){case"wheel":this.zoom(e);break;case"mousedown":this.onStart(e);break;case"mousemove":this.onMove(e);break;case"mouseup":this.onEnd();break;case"keyup":this.onKeyUp();break;case"keydown":this.onKeyDown(e);break;case"resize":this.onResize()}}onResize(){this.redraw("resize")}onKeyDown(e){(e.shiftKey||e.ctrlKey)&&(this.isPan=!0)}onKeyUp(){this.isPan=!1}onStart(e){this.x=e.clientX,this.y=e.clientY,this.isDrag=!0}onMove(e){this.isDrag&&(this.isPan?this.redraw("pan",[this.x,this.y],[e.clientX,e.clientY]):this.redraw("rotate",[this.x,this.y],[e.clientX,e.clientY]),this.x=e.clientX,this.y=e.clientY)}onEnd(){this.isDrag=!1}zoom(e){e.preventDefault(),this.redraw("zoom",e.deltaY)}}var D=n(870),G=n.n(D);const V="#version 460\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 inPosition;\r\n\r\nlayout(set = 0, binding = 0) uniform Uniforms {\r\n    vec4 index;\r\n    mat4 projection;\r\n    mat4 view[6];\r\n} uniforms;\r\n\r\n\r\nlayout (location = 0) out vec3 outUV;\r\n\r\nvoid main() {\r\n\toutUV = inPosition;\r\n    mat4 rotView = mat4(mat3(uniforms.view[int(uniforms.index.x)]));\r\n    gl_Position = uniforms.projection * rotView * vec4(inPosition, 1.0);\r\n}\r\n",H=new Float32Array([-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1]),X=new Float32Array([-1,1,-1,-1,1,1,1,-1]),k=new Float32Array([-1,1,-1,-1,1,-1,1,-1,1,1,-1,1]);let W;class z{constructor(e){this.url=e,this.envMatrix=new s}setCamera(e){this.camera=e}setGl(e){W=e}setCanvas(e){this.canvas=e}get width(){return this.canvas.offsetWidth*devicePixelRatio}get height(){return this.canvas.offsetHeight*devicePixelRatio}drawQuad(e){const t=new s,n=Object.assign({},this.camera.props,{perspective:{yfov:.3,znear:.01,zfar:1e4}});t.multiply(S(n));const{device:r,context:i}=e;let a;{const e=r.createTexture({size:[this.width,this.height,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,format:"depth32float"}).createView();a={colorAttachments:[{view:i.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1}}],depthStencilAttachment:{view:e,depthLoadOp:"clear",depthClearValue:1,depthStoreOp:"store"}}}const o=[{binding:0,resource:r.createSampler({magFilter:"linear",minFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge"})},{binding:1,resource:this.bdrfTexture.createView()}],l=r.createCommandEncoder(),c=l.beginRenderPass(a),u=this.buildPipeline(e,"#version 460\n        precision highp float;\n        \n        layout (location = 0) in vec2 inPosition;\n        \n        layout (location = 0) out vec2 outUV;\n\n        //uniform mat4 projection;\n        //uniform mat4 view;\n        \n        void main() {\n            outUV = inPosition * 0.5 + 0.5;\n            gl_Position = vec4(inPosition, 0.0, 1.0);\n        }\n        ","#version 460\n        precision highp float;\n        \n        layout (location = 0) in vec2 outUV;\n        layout (location = 0) out vec4 color;\n\n        layout(set = 0, binding = 0) uniform sampler baseSampler;\n        layout(set = 0, binding = 1) uniform texture2D environmentMap;\n        \n        void main() {\n            vec3 c = texture(sampler2D(environmentMap, baseSampler), outUV).rgb;\n            \n            color = vec4(c, 1.0);\n        }\n        ",2,[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}}],!0);c.setPipeline(u),c.setVertexBuffer(0,this.buildVertex(e,k)),c.setBindGroup(0,r.createBindGroup({layout:u.getBindGroupLayout(0),entries:o})),c.draw(6),c.end(),r.queue.submit([l.finish()])}drawCube(e){const{device:t,context:n}=e,r=new s,i=Object.assign({},this.camera.props,{perspective:{yfov:.3,znear:.01,zfar:1e4}});r.multiply(S(i));const a=new O;a.add("view",this.camera.matrixWorldInvert.elements),a.add("projection",r.elements),a.done();const o=a.store.byteLength,l=256+o,c=t.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});let u;t.queue.writeBuffer(c,0,a.store.buffer,a.store.byteOffset,a.store.byteLength);{const e=t.createTexture({size:[this.width,this.height,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,format:"depth32float"}).createView();u={colorAttachments:[{view:n.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1}}],depthStencilAttachment:{view:e,depthLoadOp:"clear",depthClearValue:1,depthStoreOp:"store"}}}const h=[{binding:0,resource:{buffer:c,offset:0,size:o}},{binding:1,resource:t.createSampler({magFilter:"linear",minFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge"})},{binding:2,resource:this.prefilterTexture.createView({dimension:"cube"})}],f=t.createCommandEncoder(),m=f.beginRenderPass(u),d=this.buildPipeline(e,"#version 460\n        precision highp float;\n        \n        layout (location = 0) in vec3 inPosition;\n        \n        layout (location = 0) out vec3 outUV;\n\n        layout(set = 0, binding = 0) uniform Uniforms {\n            mat4 view;\n            mat4 projection;\n        } uniforms;\n        \n        void main() {\n            outUV = inPosition;\n            gl_Position = uniforms.projection * uniforms.view * vec4(inPosition, 1.0);\n        }\n        ","#version 460\n        precision highp float;\n        \n        layout (location = 0) in vec3 outUV;\n        layout (location = 0) out vec4 color;\n\n        layout(set = 0, binding = 1) uniform sampler baseSampler;\n        layout(set = 0, binding = 2) uniform textureCube environmentMap;\n        \n        void main() {\n            vec3 c = textureLod(samplerCube(environmentMap, baseSampler), outUV, 0.0).rgb;\n            \n            color = vec4(c, 1.0);\n        }\n        ",3,[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube"}}],!0);m.setPipeline(d),m.setVertexBuffer(0,this.buildVertex(e,H)),m.setBindGroup(0,t.createBindGroup({layout:d.getBindGroupLayout(0),entries:h})),m.draw(36),m.end(),t.queue.submit([f.finish()])}async createTexture(e){const t=[[new o([0,1,0]),Math.PI/2],[new o([0,1,0]),-Math.PI/2],[new o([1,0,0]),Math.PI/2],[new o([1,0,0]),-Math.PI/2],[new o([0,1,0]),Math.PI],[new o([0,1,0]),0]];this.views=t.map(((e,t)=>{const n=new s;if(n.makeRotationAxis(e[0],e[1]),2!==t&&3!==t){const e=new s;e.makeRotationAxis(new o([0,0,1]),Math.PI),n.multiply(e)}return(new s).setInverseOf(n)}));const{device:n}=e;await fetch(this.url).then((e=>e.arrayBuffer())).then((e=>{const{data:t,shape:r}=G()(e),i=new Float32Array(t.length);let s,a,o,l,c,u;for(let e=0;e<=r[1];e++)for(let n=0;n<=r[0];n++)s=e*r[0]+n,a=t[4*s],o=t[4*s+1],l=t[4*s+2],c=t[4*s+3],u=(r[1]-e+1)*r[0]+n,i[4*u]=a,i[4*u+1]=o,i[4*u+2]=l,i[4*u+3]=c;const h=n.createTexture({size:[r[0],r[1],1],format:"rgba16float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST}),f=4*r[0]*4;return n.queue.writeTexture({texture:h},i,{bytesPerRow:f},[r[0],r[1],1]),this.originalCubeTexture=h,h}))}buildPass(e,t){const{device:n}=e,r=n.createTexture({size:[t,t,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,format:"depth32float"}).createView(),i=n.createTexture({size:[t,t,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC,format:"rgba16float"});return this.tempTexture=i,{colorAttachments:[{view:i.createView(),storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1}}],depthStencilAttachment:{view:r,depthLoadOp:"clear",depthClearValue:1,depthStoreOp:"store"}}}buildPipeline(e,t,n,r,i,s=!1){const{device:a,glslang:o}=e,l=a.createBindGroupLayout({entries:i}),c=a.createPipelineLayout({bindGroupLayouts:[l]});return a.createRenderPipeline({layout:c,vertex:{module:a.createShaderModule({code:o.compileGLSL(t,"vertex"),source:t,transform:e=>o.compileGLSL(e,"vertex")}),entryPoint:"main",buffers:[{arrayStride:Float32Array.BYTES_PER_ELEMENT*r,attributes:[{shaderLocation:0,offset:0,format:`float32x${r}`}]}]},fragment:{module:a.createShaderModule({code:o.compileGLSL(n,"fragment"),source:n,transform:e=>o.compileGLSL(e,"fragment")}),entryPoint:"main",targets:[{format:s?"bgra8unorm":"rgba16float"}]},primitive:{topology:"triangle-list",cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth32float"}})}buildVertex(e,t){const{device:n}=e,r=n.createBuffer({size:t.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Float32Array(r.getMappedRange()).set(t),r.unmap(),r}drawBRDF(e){const{device:t}=e;this.bdrfTexture=t.createTexture({size:[512,512,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba16float"});const n=t.createCommandEncoder(),r=this.buildPass(e,512),i=n.beginRenderPass(r),s=this.buildPipeline(e,"#version 460\r\nlayout (location = 0) in vec2 pos;\r\n\r\nlayout (location = 0) out vec2 uv;\r\n\r\nvoid main() {\r\n    uv = pos * 0.5 + 0.5;\r\n    gl_Position = vec4(pos, 0.0, 1.0); \r\n}\r\n","#version 460\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec2 uv;\r\nlayout (location = 0) out vec4 color;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\r\n    float a = roughness;\r\n    float k = (a * a) / 2.0;\r\n\r\n    float nom   = NdotV;\r\n    float denom = NdotV * (1.0 - k) + k;\r\n\r\n    return nom / denom;\r\n}\r\n\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float NdotV = max(dot(N, V), 0.0);\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\r\n\r\n    return ggx1 * ggx2;\r\n} \r\n\r\nfloat RadicalInverse_VdC(uint bits) {\r\n    bits = (bits << 16u) | (bits >> 16u);\r\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r\n}\r\n\r\nvec2 Hammersley(uint i, uint N) {\r\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\r\n}  \r\n\r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness) {\r\n    float a = roughness*roughness;\r\n\t\r\n    float phi = 2.0 * PI * Xi.x;\r\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\r\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\r\n\t\r\n    // from spherical coordinates to cartesian coordinates\r\n    vec3 H;\r\n    H.x = cos(phi) * sinTheta;\r\n    H.y = sin(phi) * sinTheta;\r\n    H.z = cosTheta;\r\n\t\r\n    // from tangent-space vector to world-space sample vector\r\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r\n    vec3 tangent   = normalize(cross(up, N));\r\n    vec3 bitangent = cross(N, tangent);\r\n\t\r\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\r\n    return normalize(sampleVec);\r\n} \r\n\r\nvec2 IntegrateBRDF(float NdotV, float roughness) {\r\n    vec3 V;\r\n    V.x = sqrt(1.0 - NdotV*NdotV);\r\n    V.y = 0.0;\r\n    V.z = NdotV;\r\n\r\n    float A = 0.0;\r\n    float B = 0.0;\r\n\r\n    vec3 N = vec3(0.0, 0.0, 1.0);\r\n\r\n    const uint SAMPLE_COUNT = 1024u;\r\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i) {\r\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\r\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\r\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\r\n\r\n        float NdotL = max(L.z, 0.0);\r\n        float NdotH = max(H.z, 0.0);\r\n        float VdotH = max(dot(V, H), 0.0);\r\n\r\n        if(NdotL > 0.0) {\r\n            float G = GeometrySmith(N, V, L, roughness);\r\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\r\n            float Fc = pow(1.0 - VdotH, 5.0);\r\n\r\n            A += (1.0 - Fc) * G_Vis;\r\n            B += Fc * G_Vis;\r\n        }\r\n    }\r\n    A /= float(SAMPLE_COUNT);\r\n    B /= float(SAMPLE_COUNT);\r\n    return vec2(A, B);\r\n}\r\n\r\nvoid main() {\t\t\r\n    vec2 integratedBRDF = IntegrateBRDF(uv.x, uv.y);\r\n    color = vec4(integratedBRDF, 0.0, 0.0);\r\n}\r\n",2,[]);i.setPipeline(s),i.setVertexBuffer(0,this.buildVertex(e,k)),i.setBindGroup(0,t.createBindGroup({layout:s.getBindGroupLayout(0),entries:[]})),i.setViewport(0,0,512,512,0,1),i.draw(6),i.end(),n.copyTextureToTexture({texture:this.tempTexture},{texture:this.bdrfTexture},[512,512,1]),t.queue.submit([n.finish()])}drawWebGPU(e,t,n,r,i){const{device:a}=e,o=new s,l=Object.assign({},this.camera.props,{aspect:1,perspective:{yfov:Math.PI/2,znear:.01,zfar:1e4}});o.multiply(S(l));const c=new O;c.add("index",new Float32Array([r,0,0,0])),c.add("projection",o.elements),c.add("view0",this.views[0].elements),c.add("view1",this.views[1].elements),c.add("view2",this.views[2].elements),c.add("view3",this.views[3].elements),c.add("view4",this.views[4].elements),c.add("view5",this.views[5].elements),c.done();const u=c.store.byteLength,h=256+u,f=a.createBuffer({size:h,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});a.queue.writeBuffer(f,0,c.store.buffer,c.store.byteOffset,c.store.byteLength);const m=[{binding:0,resource:{buffer:f,offset:0,size:u}},{binding:1,resource:a.createSampler({magFilter:"linear",minFilter:"linear",wrapS:"clamp-to-edge",wrapT:"clamp-to-edge",wrapR:"clamp-to-edge"})},{binding:2,resource:this.originalCubeTexture.createView()}],d=[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{}}],T=a.createCommandEncoder(),E=this.buildPass(e,512),p=T.beginRenderPass(E),g=this.buildPipeline(e,V,"#version 460\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 outUV;\r\nlayout (location = 0) out vec4 color;\r\n\r\nlayout(set = 0, binding = 1) uniform sampler baseSampler;\r\nlayout(set = 0, binding = 2) uniform texture2D diffuse;\r\n\r\nconst vec2 invAtan = vec2(0.1591, 0.3165);\r\nvec2 SampleSphericalMap(vec3 v) {\r\n    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\r\n    uv *= invAtan;\r\n    uv += 0.5;\r\n    return uv;\r\n}\r\n\r\nvoid main() {\t\t\r\n    vec2 uv = SampleSphericalMap(normalize(outUV));\r\n    vec3 c = texture(sampler2D(diffuse, baseSampler), uv).rgb;\r\n    \r\n    color = vec4(c, 1.0);\r\n}\r\n",3,d);p.setPipeline(g),p.setVertexBuffer(0,this.buildVertex(e,H)),p.setBindGroup(0,a.createBindGroup({layout:g.getBindGroupLayout(0),entries:m})),p.setViewport(0,0,t,n,0,1),p.draw(36),p.end(),T.copyTextureToTexture({texture:this.tempTexture},{texture:this.cubeTexture,mipLevel:i,origin:{z:r}},[t,n,1]),a.queue.submit([T.finish()])}drawWebGPU2(e,t,n,r,i){const{device:a}=e,o=new s,l=Object.assign({},this.camera.props,{aspect:1,perspective:{yfov:Math.PI/2,znear:.01,zfar:1e4}});o.multiply(S(l));const c=new O;c.add("index",new Float32Array([r,0,0,0])),c.add("projection",o.elements),c.add("view0",this.views[0].elements),c.add("view1",this.views[1].elements),c.add("view2",this.views[2].elements),c.add("view3",this.views[3].elements),c.add("view4",this.views[4].elements),c.add("view5",this.views[5].elements),c.done();const u=c.store.byteLength,h=256+u,f=a.createBuffer({size:h,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});a.queue.writeBuffer(f,0,c.store.buffer,c.store.byteOffset,c.store.byteLength);const m=[{binding:0,resource:{buffer:f,offset:0,size:u}},{binding:1,resource:a.createSampler({magFilter:"linear",minFilter:"linear",wrapS:"clamp-to-edge",wrapT:"clamp-to-edge",wrapR:"clamp-to-edge"})},{binding:2,resource:this.cubeTexture.createView({dimension:"cube"})}],d=[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube"}}],T=a.createCommandEncoder(),E=this.buildPass(e,32),p=T.beginRenderPass(E),g=this.buildPipeline(e,V,"#version 460\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 outUV;\r\nlayout (location = 0) out vec4 color;\r\n\r\nlayout(set = 0, binding = 1) uniform sampler baseSampler;\r\nlayout(set = 0, binding = 2) uniform textureCube environmentMap;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nvoid main() {\r\n    vec3 N = normalize(outUV);\r\n    vec3 irradiance = vec3(0.0);\r\n\r\n    vec3 up    = vec3(0.0, 1.0, 0.0);\r\n    vec3 right = cross(up, N);\r\n    up         = cross(N, right);\r\n\r\n    float sampleDelta = 0.025;\r\n    float nrSamples = 0.0; \r\n    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\r\n    {\r\n        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\r\n        {\r\n            // spherical to cartesian (in tangent space)\r\n            vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\r\n            // tangent space to world\r\n            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N; \r\n\r\n            irradiance += textureLod(samplerCube(environmentMap, baseSampler), sampleVec, 3.0).rgb * cos(theta) * sin(theta);\r\n            nrSamples++;\r\n        }\r\n    }\r\n    irradiance = PI * irradiance * (1.0 / float(nrSamples));\r\n    \r\n    color = vec4(irradiance, 1.0);\r\n}\r\n",3,d);p.setPipeline(g),p.setVertexBuffer(0,this.buildVertex(e,H)),p.setBindGroup(0,a.createBindGroup({layout:g.getBindGroupLayout(0),entries:m})),p.setViewport(0,0,t,n,0,1),p.draw(36),p.end(),T.copyTextureToTexture({texture:this.tempTexture},{texture:this.irradianceTexture,mipLevel:i,origin:{z:r}},[t,n,1]),a.queue.submit([T.finish()])}drawWebGPU3(e,t,n,r,i){const{device:a}=e,o=new s,l=Object.assign({},this.camera.props,{aspect:1,perspective:{yfov:Math.PI/2,znear:.01,zfar:1e4}});o.multiply(S(l));const c=i/4,u=new O;u.add("index",new Float32Array([r,c,0,0])),u.add("projection",o.elements),u.add("view0",this.views[0].elements),u.add("view1",this.views[1].elements),u.add("view2",this.views[2].elements),u.add("view3",this.views[3].elements),u.add("view4",this.views[4].elements),u.add("view5",this.views[5].elements),u.done();const h=u.store.byteLength,f=256+h,m=a.createBuffer({size:f,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});a.queue.writeBuffer(m,0,u.store.buffer,u.store.byteOffset,u.store.byteLength);const d=[{binding:0,resource:{buffer:m,offset:0,size:h}},{binding:1,resource:a.createSampler({magFilter:"linear",minFilter:"linear",wrapS:"clamp-to-edge",wrapT:"clamp-to-edge",wrapR:"clamp-to-edge"})},{binding:2,resource:this.cubeTexture.createView({dimension:"cube"})}],T=[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube"}}],E=a.createCommandEncoder(),p=this.buildPass(e,128),g=E.beginRenderPass(p),R=this.buildPipeline(e,V,"#version 460\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 outUV;\r\nlayout (location = 0) out vec4 color;\r\n\r\nlayout(set = 0, binding = 0) uniform Uniforms {\r\n    vec4 index;\r\n    mat4 projection;\r\n    mat4 view[6];\r\n} uniforms;\r\nlayout(set = 0, binding = 1) uniform sampler baseSampler;\r\nlayout(set = 0, binding = 2) uniform textureCube environmentMap;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nfloat RadicalInverse_VdC(uint bits) {\r\n    bits = (bits << 16u) | (bits >> 16u);\r\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r\n}\r\n// ----------------------------------------------------------------------------\r\nvec2 Hammersley(uint i, uint N) {\r\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\r\n}  \r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness) {\r\n    float a = roughness*roughness;\r\n\t\r\n    float phi = 2.0 * PI * Xi.x;\r\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\r\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\r\n\t\r\n    // from spherical coordinates to cartesian coordinates\r\n    vec3 H;\r\n    H.x = cos(phi) * sinTheta;\r\n    H.y = sin(phi) * sinTheta;\r\n    H.z = cosTheta;\r\n\t\r\n    // from tangent-space vector to world-space sample vector\r\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r\n    vec3 tangent   = normalize(cross(up, N));\r\n    vec3 bitangent = cross(N, tangent);\r\n\t\r\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\r\n    return normalize(sampleVec);\r\n} \r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = max(a*a, 0.0001);\r\n    float NdotH = max(dot(N, H), 0.0);\r\n    float NdotH2 = NdotH*NdotH;\r\n\r\n    float nom   = a2;\r\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n\r\n    return nom / max(denom, 0.0001);\r\n}\r\n\r\nvoid main() {\t\t\r\n    vec3 N = normalize(outUV);    \r\n    vec3 R = N;\r\n    vec3 V = R;\r\n\r\n    const uint SAMPLE_COUNT = 1024u;\r\n    float totalWeight = 0.0;   \r\n    vec3 prefilteredColor = vec3(0.0);     \r\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i) {\r\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\r\n        vec3 H  = ImportanceSampleGGX(Xi, N, uniforms.index.y);\r\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\r\n\r\n        float NdotL = max(dot(N, L), 0.0);\r\n        if (NdotL > 0.0) {\r\n            float D = DistributionGGX(N, H, uniforms.index.y);\r\n            float pdf = (D * max(dot(N, H), 0.0) / (4.0 * max(dot(H, V), 0.0))) + 0.0001;\r\n             \r\n            float saTexel = 4.0 * PI / (6.0 * 512.0 * 512.0);\r\n            float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.00001);\r\n             \r\n            float mipLevel = uniforms.index.y == 0.0 ? 0.0 :  0.5 * log2( saSample / saTexel )  ;\r\n                                 \r\n            prefilteredColor += textureLod( samplerCube(environmentMap, baseSampler), L, mipLevel ).rgb * NdotL;     \r\n            totalWeight += NdotL;\r\n        }\r\n    }\r\n    prefilteredColor = prefilteredColor / totalWeight;\r\n    \r\n    color = vec4(prefilteredColor, 1.0);\r\n}\r\n",3,T);g.setPipeline(R),g.setVertexBuffer(0,this.buildVertex(e,H)),g.setBindGroup(0,a.createBindGroup({layout:R.getBindGroupLayout(0),entries:d})),g.setViewport(0,0,t,n,0,1),g.draw(36),g.end(),E.copyTextureToTexture({texture:this.tempTexture},{texture:this.prefilterTexture,mipLevel:i,origin:{z:r}},[t,n,1]),a.queue.submit([E.finish()])}drawMips(e){const{device:t}=e;this.cubeTexture=t.createTexture({mipLevelCount:5,size:[512,512,6],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba16float"});for(let t=0;t<5;++t){const n=512*Math.pow(.5,t),r=512*Math.pow(.5,t);for(let i=0;i<6;i++)this.drawWebGPU(e,n,r,i,t)}}drawIrradiance(e){const{device:t}=e;this.irradianceTexture=t.createTexture({size:[32,32,6],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba16float"});for(let t=0;t<6;t++)this.drawWebGPU2(e,32,32,t,0)}drawPrefilter(e){const{device:t}=e;this.prefilterTexture=t.createTexture({mipLevelCount:5,size:[128,128,6],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba16float"});for(let t=0;t<5;++t){const n=128*Math.pow(.5,t),r=128*Math.pow(.5,t);for(let i=0;i<6;i++)this.drawWebGPU3(e,n,r,i,t)}}}var j=n(993);function Y(e){const{ktxTexture:t,TranscodeTarget:n,transcoderConfig:r}=window.LIBKTX,{astcSupported:i,dxtSupported:s,pvrtcSupported:a,etc1Supported:o,etc2Supported:l}=r,c=new Uint8Array(e);if(!function(e){if(e.byteLength>=12){const t=new Uint8Array(e.buffer,e.byteOffset,12);if(171===t[0]&&75===t[1]&&84===t[2]&&88===t[3]&&32===t[4]&&50===t[5]&&48===t[6]&&187===t[7]&&13===t[8]&&10===t[9]&&26===t[10]&&10===t[11])return!0}return!1}(c))throw new Error("Texture is not valid ktx 2.0 file");const u=new t(c);if(u.needsTranscoding){let e,t;if(i?(e="ASTC",t=n.ASTC_4x4_RGBA):s?(e="BC1 or BC3",t=n.BC1_OR_3):a?(e="PVRTC1",t=n.PVRTC1_4_RGBA):o||l?(e="ETC",t=n.ETC):(e="RGBA4444",t=n.RGBA4444),u.transcodeBasis(t,0)!==window.LIBKTX.ErrorCode.SUCCESS)throw new Error("Texture transcode failed. See console for details.");return u.glUpload().texture}}function K(e){return"undefined"!=typeof window?window.fetch(e).then((e=>e.arrayBuffer())):new Promise((t=>{j.readFile(e,((e,n)=>{if(e)throw e;t(new Uint8Array(n).buffer)}))}))}let q;function J(e,t,n,r,i){let s,a;switch(e){case"BYTE":s=new Int8Array(t),s.type="BYTE",a=new q.DracoInt8Array,n&&i.GetAttributeInt8ForAllPoints(n,r,a);break;case"UNSIGNED_BYTE":s=new Uint8Array(t),s.type="UNSIGNED_BYTE",a=new q.DracoUInt8Array,n&&i.GetAttributeUInt8ForAllPoints(n,r,a);break;case"SHORT":s=new Int16Array(t),s.type="SHORT",a=new q.DracoInt16Array,n&&i.GetAttributeInt16ForAllPoints(n,r,a);break;case"UNSIGNED_SHORT":s=new Uint16Array(t),s.type="UNSIGNED_SHORT",a=new q.DracoUInt16Array,n&&i.GetAttributeUInt16ForAllPoints(n,r,a);break;case"UNSIGNED_INT":s=new Uint32Array(t),s.type="UNSIGNED_INT",a=new q.DracoUInt32Array,n&&i.GetAttributeUInt32ForAllPoints(n,r,a);break;case"FLOAT":s=new Float32Array(t),s.type="FLOAT",a=new q.DracoFloat32Array,n&&i.GetAttributeFloatForAllPoints(n,r,a)}return[a,s]}const Z="#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec3 inPosition;\r\nlayout (location = 1) in vec3 inNormal;\r\nlayout (location = 2) in vec2 inUV;\r\nlayout (location = 3) in vec4 inJoint;\r\nlayout (location = 4) in vec4 inWeight;\r\nlayout (location = 5) in vec4 inTangent;\r\nlayout (location = 6) in vec4 inColor;\r\nlayout (location = 7) in vec2 inUV2;\r\n\r\nout vec4 vColor;\r\nout vec2 outUV0;\r\nout vec2 outUV2;\r\nout vec3 outPosition;\r\nout vec4 outPositionView;\r\n#ifdef TANGENT\r\n    out mat3 outTBN;\r\n#else\r\n    out vec3 outNormal;\r\n#endif\r\n\r\nuniform Matrices {\r\n    mat4 model;\r\n    mat4 normalMatrix;\r\n    mat4 view;\r\n    mat4 projection;\r\n    mat4 light;\r\n    vec4 isShadow;\r\n};\r\n\r\n#ifdef JOINTNUMBER\r\nuniform Skin {\r\n    mat4 joint[JOINTNUMBER];\r\n};\r\n#endif\r\n\r\nvoid main() {\r\n    #ifdef JOINTNUMBER\r\n        mat4 skin = inWeight.x * joint[int(inJoint.x)];\r\n        skin += inWeight.y * joint[int(inJoint.y)];\r\n        skin += inWeight.z * joint[int(inJoint.z)];\r\n        skin += inWeight.w * joint[int(inJoint.w)];\r\n    #else\r\n        mat4 skin = mat4(1.0);\r\n    #endif\r\n\r\n    #ifdef COLOR_255\r\n        vColor = inColor / 255.0;\r\n    #else\r\n        vColor = inColor;\r\n    #endif\r\n    outUV0 = inUV;\r\n    outUV2 = inUV2;\r\n    #ifdef TANGENT\r\n        vec3 normalW = normalize(vec3(model * vec4(inNormal.xyz, 0.0)));\r\n        vec3 tangentW = normalize(vec3(model * vec4(inTangent.xyz, 0.0)));\r\n        vec3 bitangentW = cross(normalW, tangentW) * inTangent.w;\r\n        #ifdef USERIGHTHANDEDSYSTEM\r\n        tangentW *= 1.0; // invertX\r\n        bitangentW *= -1.0; // invertY\r\n        #endif\r\n        outTBN = mat3(tangentW, bitangentW, normalW);\r\n    #else\r\n        outNormal = normalize(mat3(normalMatrix) * mat3(skin) * inNormal);\r\n    #endif\r\n    outPosition = vec3(model * skin * vec4(inPosition, 1.0));\r\n    outPositionView = projection * light * model * skin * vec4(inPosition, 1.0);\r\n    if (isShadow.x == 1.0) {\r\n        gl_Position = projection * light * model * skin * vec4(inPosition, 1.0);\r\n    } else {\r\n        gl_Position = projection * view * model * skin * vec4(inPosition, 1.0);\r\n    }\r\n}\r\n",$="#version 300 es\r\nprecision highp float;\r\n\r\nin vec4 vColor;\r\nin vec2 outUV0;\r\nin vec2 outUV2;\r\nin vec3 outPosition;\r\nin vec4 outPositionView;\r\n#ifdef TANGENT\r\n    in mat3 outTBN;\r\n#else\r\n    in vec3 outNormal;\r\n#endif\r\n\r\nlayout (location = 0) out vec4 color;\r\nlayout (location = 1) out vec3 normalColor;\r\n\r\nuniform Material {\r\n    vec4 baseColorFactor;\r\n    vec3 viewPos;\r\n    mat3 textureMatrix;\r\n    vec3 specularFactor;\r\n    vec3 emissiveFactor;\r\n    vec4 glossinessFactor;\r\n    vec4 metallicFactor;\r\n    vec4 roughnessFactor;\r\n    vec4 clearcoatFactor;\r\n    vec4 clearcoatRoughnessFactor;\r\n    vec4 sheenColorFactor;\r\n    vec4 sheenRoughnessFactor;\r\n    vec4 transmissionFactor;\r\n    vec4 ior;\r\n    vec4 normalTextureScale;\r\n    vec4 attenuationColor; \r\n    vec4 attenuationDistance; \r\n    vec4 thicknessFactor;\r\n};\r\nuniform Matrices {\r\n    mat4 model;\r\n    mat4 normalMatrix;\r\n    mat4 view;\r\n    mat4 projection;\r\n    mat4 light;\r\n    vec4 isShadow;\r\n};\r\nuniform LightColor {\r\n    vec3 lightColor[LIGHTNUMBER];\r\n};\r\nuniform Spotdir {\r\n    vec3 spotdir[LIGHTNUMBER];\r\n};\r\nuniform LightIntensity {\r\n    vec4 lightIntensity[LIGHTNUMBER];\r\n};\r\nuniform LightPos {\r\n    vec3 lightPos[LIGHTNUMBER];\r\n};\r\nuniform SphericalHarmonics {\r\n    vec4 vSphericalL00;\r\n    vec4 vSphericalL1_1;\r\n    vec4 vSphericalL10;\r\n    vec4 vSphericalL11;\r\n    vec4 vSphericalL2_2;\r\n    vec4 vSphericalL2_1;\r\n    vec4 vSphericalL20;\r\n    vec4 vSphericalL21;\r\n    vec4 vSphericalL22;\r\n    mat4 rotationMatrix;\r\n};\r\n\r\nuniform sampler2D baseColorTexture;\r\nuniform sampler2D metallicRoughnessTexture;\r\nuniform sampler2D normalTexture;\r\nuniform sampler2D emissiveTexture;\r\nuniform sampler2D occlusionTexture;\r\nuniform sampler2D clearcoatTexture;\r\nuniform sampler2D clearcoatRoughnessTexture;\r\nuniform sampler2D transmissionTexture;\r\nuniform sampler2D sheenColorTexture;\r\nuniform sampler2D sheenRoughnessTexture;\r\nuniform sampler2D clearcoatNormalTexture;\r\nuniform sampler2D specularTexture;\r\nuniform sampler2D thicknessTexture;\r\n\r\nuniform samplerCube prefilterMap;\r\nuniform sampler2D brdfLUT;  \r\nuniform samplerCube irradianceMap;\r\nuniform sampler2D depthTexture;\r\nuniform sampler2D colorTexture;\r\nuniform int isTone;\r\nuniform int isIBL;\r\nuniform int isDefaultLight;\r\nuniform sampler2D Sheen_E;\r\n\r\nconst float RECIPROCAL_PI = 0.31830988618;\r\nconst float PI = 3.14159265359;\r\nconst float EPSILON = 1e-6;\r\nconst float ambientStrength = 0.1;\r\nconst float specularStrength = 2.5;\r\nconst float specularPower = 32.0;\r\nconst float gamma = 2.2;\r\n\r\n\r\nvec2 getUV(int index) {\r\n    if (index == 1) {\r\n        return outUV0;\r\n    } else {\r\n        return outUV2;\r\n    }\r\n}\r\n\r\nfloat ShadowCalculation(vec4 fragPosLightSpace, float bias) {\r\n    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\r\n    projCoords = projCoords * 0.5 + 0.5;\r\n    float currentDepth = projCoords.z;\r\n\r\n    float shadow = 0.0;\r\n    vec2 texelSize = 1.0 / vec2(textureSize(depthTexture, 0));\r\n    for (int x = -2; x <= 2; ++x) {\r\n        for (int y = -2; y <= 2; ++y) {\r\n            float pcfDepth = texture(depthTexture, projCoords.xy + vec2(x, y) * texelSize).r;\r\n            shadow += currentDepth - bias > pcfDepth ? 0.5 : 0.0;\r\n        }\r\n    }\r\n    shadow /= 25.0;\r\n\r\n    return shadow;\r\n}\r\n\r\nvec3 srgbToLinear(vec4 srgbIn) {\r\n    #ifdef BASISU\r\n    return srgbIn.rgb;\r\n    #else\r\n    return pow(srgbIn.rgb, vec3(2.2));\r\n    #endif\r\n}\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = max(a*a, 0.0001);\r\n    float NdotH = max(dot(N, H), 0.0);\r\n    float NdotH2 = NdotH*NdotH;\r\n\r\n    float nom   = a2;\r\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n\r\n    return nom / max(denom, 0.0001);\r\n}\r\n\r\nfloat GeometrySchlickGGX(float cosTheta, float roughness) {\r\n    float r = (roughness + 1.0);\r\n    float k = (r * r) / 8.0;\r\n\r\n    float nom   = cosTheta;\r\n    float denom = cosTheta * (1.0 - k) + k;\r\n\r\n    return nom / denom;\r\n}\r\n\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float NdotV = max(dot(N, V), 0.0);\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\r\n\r\n    return ggx1 * ggx2;\r\n}\r\n\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nfloat fresnelSchlickRoughness(float cosTheta, float F0, float roughness) {\r\n    return F0 + (max(1.0 - roughness, F0) - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\r\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 calcTransmission(vec3 color, vec3 N, float roughness, vec3 V, float transmission, float thickness) {\r\n    vec4 refractS = projection * view * vec4(outPosition + refract(-V, N, ior.x) * thickness, 1.0);\r\n    refractS.xy = refractS.xy / refractS.w;\r\n    refractS.xy = refractS.xy * 0.5 + 0.5;\r\n    const float MAX_REFLECTION_LOD = 10.0;\r\n    vec3 baseColor = textureLod(colorTexture, refractS.xy, roughness * MAX_REFLECTION_LOD).xyz;\r\n\r\n    return transmission * baseColor * color;\r\n}\r\n\r\nvec3 computeEnvironmentIrradiance(vec3 normal) {\r\n    return vSphericalL00.xyz\r\n        + vSphericalL1_1.xyz * (normal.y)\r\n        + vSphericalL10.xyz * (normal.z)\r\n        + vSphericalL11.xyz * (normal.x)\r\n        + vSphericalL2_2.xyz * (normal.y * normal.x)\r\n        + vSphericalL2_1.xyz * (normal.y * normal.z)\r\n        + vSphericalL20.xyz * ((3.0 * normal.z * normal.z) - 1.0)\r\n        + vSphericalL21.xyz * (normal.z * normal.x)\r\n        + vSphericalL22.xyz * (normal.x * normal.x - (normal.y * normal.y));\r\n}\r\nfloat sheenDistribution(float sheenRoughness, vec3 N, vec3 H) {\r\n    float NdotH = max(dot(N, H), 0.0);\r\n    float alphaG = max(sheenRoughness * sheenRoughness, 0.01);\r\n    float invR = 1.0 / alphaG;\r\n    float cos2h = NdotH * NdotH;\r\n    float sin2h = 1.0 - cos2h;\r\n    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\r\n}\r\nfloat l(float x, float alphaG) {\r\n    float oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);\r\n    float a = mix(21.5473, 25.3245, oneMinusAlphaSq);\r\n    float b = mix(3.82987, 3.32435, oneMinusAlphaSq);\r\n    float c = mix(0.19823, 0.16801, oneMinusAlphaSq);\r\n    float d = mix(-1.97760, -1.27393, oneMinusAlphaSq);\r\n    float e = mix(-4.32054, -4.85967, oneMinusAlphaSq);\r\n    return a / (1.0 + b * pow(x, c)) + d * x + e;\r\n}\r\nfloat lambdaSheen(float cosTheta, float alphaG) {\r\n    return abs(cosTheta) < 0.5 ? exp(l(cosTheta, alphaG)) : exp(2.0 * l(0.5, alphaG) - l(1.0 - cosTheta, alphaG));\r\n}\r\nfloat sheenVisibility(vec3 N, vec3 V, vec3 L, float sheenRoughness) {\r\n    float alphaG = sheenRoughness * sheenRoughness;\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    float NdotV = max(dot(N, V), 0.0);\r\n    float v = 1.0 / (1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG));\r\n    return v;\r\n}\r\nfloat E(float x, float y) {\r\n    return texture(Sheen_E, vec2(x,y)).r;\r\n}\r\nfloat max3(vec3 v) { return max(max(v.x, v.y), v.z); }\r\nvec3 IBLAmbient(vec3 specularMap, vec3 baseColor, float metallic, vec3 n, float roughness, vec3 viewDir, float transmission, vec3 sheenColor, float sheenRoughness, float ior, out vec3 specular) {\r\n    vec3 F0 = mix(vec3(0.05), baseColor, metallic);\r\n\r\n    #if defined SPECULAR\r\n    if (metallic == 0.0) {\r\n        float relativeIOR = (1.0 - ior) / (1.0 + ior);\r\n        F0 = relativeIOR * relativeIOR * specularMap;\r\n    }\r\n    #endif\r\n    #if defined SPECULARGLOSSINESSMAP\r\n        F0 = specularMap;\r\n    #endif\r\n\r\n    vec3 F = fresnelSchlickRoughness(max(dot(n, viewDir), 0.0), F0, roughness);\r\n\r\n    vec3 kD = vec3(1.0) - F;\r\n    #if defined SPECULARGLOSSINESSMAP\r\n    #else\r\n        kD *= 1.0 - clamp(metallic, 0.0, 0.9);\r\n    #endif\r\n\r\n    vec3 R;\r\n    #ifdef SPHERICAL_HARMONICS\r\n    R = reflect(viewDir, n);\r\n    vec4 rotatedR = rotationMatrix * vec4(R.x * -1.0, R.y, R.z, 0.0);\r\n    R = rotatedR.xyz;\r\n    vec4 prefilterColor = textureLod(prefilterMap, R, roughness * float(SPHERICAL_HARMONICS));\r\n    vec3 prefilteredColor = srgbToLinear(vec4(prefilterColor.rgb, 0.0)) / pow(prefilterColor.a, 2.2);\r\n    vec3 irradianceVector = vec3(rotationMatrix * vec4(n.x, n.y, n.z * -1.0, 0)).xyz;\r\n    vec3 irradiance = computeEnvironmentIrradiance(irradianceVector).rgb;\r\n    #else\r\n    const float MAX_REFLECTION_LOD = 4.0;\r\n    R = reflect(-viewDir, n);\r\n    vec3 prefilteredColor = textureLod(prefilterMap, R, roughness * MAX_REFLECTION_LOD).rgb;\r\n    vec3 irradiance = texture(irradianceMap, n).rgb;\r\n    #endif\r\n    vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(n, viewDir), 0.0), roughness)).rg;\r\n    specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\r\n\r\n    vec3 H = normalize(viewDir + -R);\r\n    vec3 f_sheen = sheenColor * sheenDistribution(sheenRoughness, n, H) * sheenVisibility(n, viewDir, R, sheenRoughness);\r\n    // float sheenAlbedoScaling = min(1.0 - max3(sheenColor) * E(max(dot(viewDir, n), 0.0), sheenRoughness), 1.0 - max3(sheenColor) * E(max(dot(-R, n), 0.0), sheenRoughness));\r\n    f_sheen /= max(1.0, 4.0 * abs(dot(n, -R)) * abs(dot(n, viewDir)));\r\n\r\n    return ((1.0 - transmission) * kD * irradiance * clamp(baseColor, vec3(0.05), vec3(1.0))) + f_sheen;\r\n}\r\n\r\nfloat specEnv(vec3 N, vec3 V, float metallic, float roughness) {\r\n    float F0 = mix(0.05, 1.0, metallic);\r\n\r\n    float F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);\r\n    vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;\r\n    return (F * envBRDF.x + envBRDF.y);\r\n}\r\n\r\nvec3 CookTorranceSpecular(vec3 specularMap, vec3 baseColor, float metallic, vec3 n, vec3 H, float roughness, vec3 viewDir, vec3 lightDir, float ior) {\r\n    vec3 F0 = vec3(0.04); \r\n    F0 = mix(F0, baseColor, metallic);\r\n\r\n    #if defined SPECULAR\r\n    if (metallic == 0.0) {\r\n        float relativeIOR = (1.0 - ior) / (1.0 + ior);\r\n        F0 = relativeIOR * relativeIOR * specularMap;\r\n    }\r\n    #endif\r\n    #if defined SPECULARGLOSSINESSMAP\r\n        F0 = specularMap;\r\n    #endif\r\n\r\n    float D = DistributionGGX(n, H, roughness);\r\n    float G = GeometrySmith(n, viewDir, lightDir, roughness);      \r\n    vec3 F = fresnelSchlick(max(dot(H, viewDir), 0.0), F0); \r\n\r\n    vec3 nominator = D * G * F;\r\n    float denominator = 4.0 * max(dot(n, viewDir), 0.0) * max(dot(n, lightDir), 0.0);\r\n    return nominator / max(denominator, 0.001);\r\n}\r\n\r\nvec3 LambertDiffuse(vec3 specularMap, vec3 baseColor, float metallic, vec3 n, vec3 H, float roughness, vec3 viewDir, vec3 lightDir, float ior) {\r\n    float NdotL = max(dot(n, lightDir), 0.0);\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, baseColor, metallic);\r\n    #if defined SPECULAR\r\n    if (metallic == 0.0) {\r\n        float relativeIOR = (1.0 - ior) / (1.0 + ior);\r\n        F0 = relativeIOR * relativeIOR * specularMap;\r\n    }\r\n    #endif\r\n    #if defined SPECULARGLOSSINESSMAP\r\n        F0 = specularMap;\r\n    #endif\r\n\r\n    vec3 F = fresnelSchlick(max(dot(H, viewDir), 0.0), F0);    \r\n\r\n    vec3 kD = vec3(1.0) - F;\r\n    #if defined SPECULARGLOSSINESSMAP\r\n    #else\r\n        kD *= 1.0 - metallic;\r\n    #endif\r\n    return baseColor * kD / PI;\r\n}\r\n\r\nfloat saturate(float a) {\r\n\tif (a > 1.0) return 1.0;\r\n\tif (a < 0.0) return 0.0;\r\n\treturn a;\r\n}\r\nvec3 ImprovedOrenNayarDiffuse(vec3 specularMap, vec3 baseColor, float metallic, vec3 N, vec3 H, float a, vec3 V, vec3 L, float ior) {\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, baseColor, metallic);\r\n    #if defined SPECULAR\r\n    if (metallic == 0.0) {\r\n        float relativeIOR = (1.0 - ior) / (1.0 + ior);\r\n        F0 = relativeIOR * relativeIOR * specularMap;\r\n    }\r\n    #endif\r\n    #if defined SPECULARGLOSSINESSMAP\r\n        F0 = specularMap;\r\n    #endif\r\n    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);\r\n    vec3 kD = vec3(1.0) - F;\r\n    #if defined SPECULARGLOSSINESSMAP\r\n    #else\r\n        kD *= 1.0 - metallic;\r\n    #endif\r\n    vec3 diffuseColor = baseColor * kD;\r\n\t// calculate intermediary values\r\n\tfloat dotNL = saturate(dot(N, L));\r\n\tfloat dotNV = saturate(dot(N, V));\r\n\tfloat dotLV = saturate(dot(L, V));\r\n\tfloat dotLH = saturate(dot(L, H));\r\n\r\n\tfloat s = dotLV - dotNL * dotNV;\r\n\tfloat t = mix(1.0, max(max(dotNL, dotNV), 0.001), step(0.0, s));\r\n\tfloat st = s * (1.0 / (t + EPSILON));\r\n\r\n\tfloat sigma2 = a;\r\n\tvec3 A = diffuseColor * (0.17 * sigma2 / (sigma2 + 0.13)) + vec3(1.0 - 0.5 * sigma2 / (sigma2 + 0.33));\r\n\tfloat B = 0.45 * sigma2 / (sigma2 + 0.09);\r\n\treturn (diffuseColor * max(0.0, dotNL)) * (A + vec3(B * s / t) / PI);\r\n}\r\n\r\nvec2 applyTransform(vec2 uv) {\r\n    mat3 translation = mat3(1, 0, 0, 0, 1, 0, textureMatrix[0].x, textureMatrix[0].y, 1);\r\n    mat3 rotation = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\r\n    if (textureMatrix[2].x != 0.0) {\r\n        rotation = mat3(\r\n            cos(-textureMatrix[2].x), sin(-textureMatrix[2].x), 0,\r\n            -sin(-textureMatrix[2].x), cos(-textureMatrix[2].x), 0,\r\n            0, 0, 1\r\n        );\r\n    }\r\n    mat3 scale = mat3(textureMatrix[1].x, 0, 0, 0, textureMatrix[1].y, 0, 0, 0, 1);\r\n\r\n    mat3 matrix = translation * rotation * scale;\r\n    vec2 outUV = ( matrix * vec3(uv, 1.0) ).xy;\r\n    return outUV;\r\n}\r\n\r\nvec3 cocaLambert(vec3 alpha, float distance) {\r\n    return exp(-alpha*distance);\r\n}\r\n\r\nvec3 computeColorAtDistanceInMedia(vec3 color, float distance) {\r\n    return -log(color)/distance;\r\n}\r\n\r\nvoid main() {\r\n    vec2 outUV = outUV0;\r\n    #ifdef BASECOLORTEXTURE\r\n        outUV = getUV(BASECOLORTEXTURE);\r\n        #ifdef BASECOLORTEXTURE_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV);\r\n        #endif\r\n        vec3 baseColor = texture(baseColorTexture, outUV).rgb * baseColorFactor.rgb;\r\n        float alpha = min(texture(baseColorTexture, outUV).a, baseColorFactor.a);\r\n    #else\r\n        vec3 baseColor = baseColorFactor.rgb;\r\n        float alpha = baseColorFactor.a;\r\n    #endif\r\n\r\n    #ifdef ALPHATEST\r\n    if ( alpha < ALPHATEST ) {\r\n        discard;\r\n    }\r\n    if ( ALPHATEST > 0.01 ) {\r\n        alpha = 1.0;\r\n    }\r\n    #else\r\n        alpha = 1.0;\r\n    #endif\r\n\r\n    if ( length(vColor.rgb) != 0.0 ) {\r\n        baseColor.rgb *= vColor.rgb;\r\n    }\r\n\r\n    #ifdef NOLIGHT\r\n        color = vec4(baseColor, alpha);\r\n        return;\r\n    #endif\r\n\r\n    float ao = 1.0;\r\n    #ifdef OCCLUSIONMAP\r\n        outUV = getUV(OCCLUSIONMAP);\r\n        #ifdef OCCLUSIONMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV);\r\n        #endif\r\n        ao = texture(occlusionTexture, outUV).r;\r\n    #endif\r\n\r\n    float roughness = roughnessFactor.x;\r\n    float metallic = metallicFactor.x;\r\n    float clearcoatRoughness = clearcoatRoughnessFactor.x;\r\n    float clearcoat = clearcoatFactor.x;\r\n    float clearcoatBlendFactor = clearcoat;\r\n    vec3 sheenColor = sheenColorFactor.xyz;\r\n    float sheenRoughness = sheenRoughnessFactor.x;\r\n    float transmission = transmissionFactor.x;\r\n    float thickness = clamp(thicknessFactor.x, 0.0, 1.0);\r\n    #ifdef CLEARCOATMAP\r\n        outUV = getUV(CLEARCOATMAP);\r\n        #ifdef CLEARCOATMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV);\r\n        #endif\r\n        clearcoatBlendFactor = texture(clearcoatTexture, outUV).r * clearcoat;\r\n    #endif\r\n    #ifdef CLEARCOATROUGHMAP\r\n        outUV = getUV(CLEARCOATROUGHMAP);\r\n        #ifdef CLEARCOATROUGHMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV);\r\n        #endif\r\n        clearcoatRoughness = texture(clearcoatRoughnessTexture, outUV).g * clearcoatRoughness;\r\n    #endif\r\n    #ifdef SHEENMAP\r\n        outUV = getUV(SHEENMAP);\r\n        #ifdef SHEENMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV);\r\n        #endif\r\n        vec4 sheenRoughnessTextureV = texture(sheenRoughnessTexture, outUV);\r\n        vec3 sheenColorTextureV = texture(sheenColorTexture, outUV).rgb;\r\n        sheenColor = sheenColorTextureV * sheenColor;\r\n        sheenRoughness = sheenRoughnessTextureV.a * sheenRoughness;\r\n    #endif\r\n    #ifdef TRANSMISSIONMAP\r\n        float transmissionTextureV = texture(transmissionTexture, outUV).r;\r\n        transmission = transmissionTextureV * transmission;\r\n    #endif\r\n    #ifdef THICKNESSMAP\r\n        float thicknessTextureV = texture(thicknessTexture, outUV).g;\r\n        thickness = thicknessTextureV * thickness;\r\n    #endif\r\n    vec3 specularMap = vec3(0);\r\n    #ifdef SPECULARGLOSSINESSMAP\r\n        #ifdef METALROUGHNESSMAP\r\n            outUV = getUV(METALROUGHNESSMAP);\r\n            #ifdef METALROUGHNESSMAP_TEXTURE_TRANSFORM\r\n                outUV = applyTransform(outUV);\r\n            #endif\r\n            roughness = 1.0 - texture(metallicRoughnessTexture, outUV).a;\r\n            specularMap = texture(metallicRoughnessTexture, outUV).rgb;\r\n        #else\r\n            roughness = glossinessFactor.x;\r\n            specularMap = specularFactor;\r\n        #endif\r\n    #else\r\n        #ifdef METALROUGHNESSMAP\r\n            outUV = getUV(METALROUGHNESSMAP);\r\n            #ifdef METALROUGHNESSMAP_TEXTURE_TRANSFORM\r\n                outUV = applyTransform(outUV);\r\n            #endif\r\n            vec4 metallicRoughness = texture(metallicRoughnessTexture, outUV);\r\n            roughness *= metallicRoughness.g;\r\n            metallic *= metallicRoughness.b;\r\n        #endif\r\n    #endif\r\n    #ifdef SPECULAR\r\n        specularMap = specularFactor;\r\n        #ifdef SPECULARMAP\r\n        specularMap *= texture(specularTexture, outUV).rgb;\r\n        #endif\r\n    #endif\r\n\r\n    #ifdef TANGENT\r\n        #ifdef NORMALMAP\r\n            outUV = getUV(NORMALMAP);\r\n            #ifdef NORMALMAP_TEXTURE_TRANSFORM\r\n                outUV = applyTransform(outUV);\r\n            #endif\r\n            vec3 n = texture(normalTexture, outUV).rgb;\r\n            n = normalize(outTBN * (2.0 * n - 1.0) * vec3(normalTextureScale.x, normalTextureScale.x, 1.0));\r\n        #else\r\n            vec3 n = outTBN[2].xyz;\r\n        #endif\r\n    #else\r\n        vec3 n = outNormal;\r\n    #endif\r\n\r\n    #ifdef TANGENT\r\n    #ifdef CLEARCOATNORMALMAP\r\n        outUV = getUV(CLEARCOATNORMALMAP);\r\n        #ifdef CLEARCOATNORMALMAP_TEXTURE_TRANSFORM\r\n            outUV = applyTransform(outUV);\r\n        #endif\r\n        vec3 clearcoatNormal = texture(clearcoatNormalTexture, outUV).rgb;\r\n        clearcoatNormal = normalize(outTBN * (2.0 * clearcoatNormal - 1.0));\r\n    #else\r\n        vec3 clearcoatNormal = outTBN[2].xyz;\r\n    #endif\r\n    #else\r\n        vec3 clearcoatNormal = outNormal;\r\n    #endif\r\n\r\n    vec3 viewDir = normalize(viewPos - outPosition);\r\n\r\n    #ifdef DOUBLESIDED\r\n    if (dot(n, viewDir) < 0.0) {\r\n        n = -n;\r\n        clearcoatNormal = -clearcoatNormal;\r\n    }\r\n    #endif\r\n\r\n    float shadow = 1.0;\r\n    #ifdef SHADOWMAP\r\n        vec3 l = normalize(lightPos[0] - outPosition);\r\n        float shadowBias = max(0.05 * (1.0 - dot(n, l)), 0.005);\r\n        shadow = 1.0 - ShadowCalculation(outPositionView, shadowBias);\r\n    #endif\r\n\r\n    #ifdef USE_PBR\r\n        vec3 Lo = vec3(0.0);\r\n        if (isDefaultLight == 1) {\r\n        for (int i = 0; i < LIGHTNUMBER; ++i) {\r\n            vec3 lightDir = normalize(lightPos[i] - outPosition);\r\n            float NdotL = max(dot(n, lightDir), 0.0);\r\n            vec3 H = normalize(viewDir + lightDir);\r\n\r\n            vec3 radiance = lightColor[i] * lightIntensity[i].x;\r\n            float distance = length(lightPos[i] - outPosition);\r\n            float attenuation = 1.0 / (distance * distance);\r\n            if (lightIntensity[i].w == 1.0) { // point\r\n                radiance = radiance * attenuation;\r\n            }\r\n            if (lightIntensity[i].w == 2.0) { // spot\r\n                float lightAngleScale = 1.0 / max(0.001, cos(lightIntensity[i].y) - cos(lightIntensity[i].z));\r\n                float lightAngleOffset = -cos(lightIntensity[i].z) * lightAngleScale;\r\n\r\n                float cd = dot(spotdir[i], lightDir);\r\n                float attenuationSpot = saturate(cd * lightAngleScale + lightAngleOffset);\r\n                attenuationSpot *= attenuationSpot;\r\n\r\n                radiance = radiance * attenuationSpot * attenuation;\r\n            }\r\n\r\n            vec3 specular = CookTorranceSpecular(specularMap, baseColor, metallic, n, H, roughness, viewDir, lightDir, ior.x);\r\n            vec3 f_clearcoat = CookTorranceSpecular(specularMap, vec3(0.0), 0.0, clearcoatNormal, H, clearcoatRoughness, viewDir, lightDir, ior.x);\r\n            float NdotV = saturate(dot(clearcoatNormal, viewDir));\r\n            vec3 clearcoatFresnel = 1.0 - clearcoatBlendFactor * fresnelSchlick(NdotV, vec3(0.04));\r\n            vec3 diffuse = ImprovedOrenNayarDiffuse(specularMap, baseColor, metallic, n, H, roughness, viewDir, lightDir, ior.x);\r\n            #if defined SPECULARGLOSSINESSMAP\r\n                diffuse = baseColor * (1.0 - max(max(specularMap.r, specularMap.g), specularMap.b));\r\n            #endif\r\n            vec3 f_sheen = sheenColor * sheenDistribution(sheenRoughness, n, H) * sheenVisibility(n, viewDir, lightDir, sheenRoughness);\r\n            // f_sheen /= (4.0 * abs(dot(n, lightDir)) * abs(dot(n, viewDir)));\r\n            float sheenAlbedoScaling = min(1.0 - max3(sheenColor) * E(max(dot(viewDir, n), 0.0), sheenRoughness), 1.0 - max3(sheenColor) * E(max(dot(lightDir, n), 0.0), sheenRoughness));\r\n\r\n            diffuse *= (1.0 - transmission);\r\n            Lo += sheenAlbedoScaling * (diffuse + specular * NdotL) * radiance * clearcoatFresnel + f_clearcoat * clearcoatBlendFactor + f_sheen;\r\n        }\r\n        }\r\n\r\n        vec3 ambient = vec3(0.0);\r\n        vec3 ambientClearcoat = vec3(0.0);\r\n        vec3 clearcoatFresnel = vec3(1.0);\r\n        vec3 f_transmission = cocaLambert(computeColorAtDistanceInMedia(attenuationColor.rgb, attenuationDistance.x), thickness) * calcTransmission(baseColor, n, roughness, viewDir, transmission, thickness);\r\n        vec3 aSpecular;\r\n        vec3 cSpecular;\r\n        if (isIBL == 1) {\r\n            ambient = IBLAmbient(specularMap, baseColor, metallic, n, roughness, viewDir, transmission, sheenColor, sheenRoughness, ior.x, aSpecular);\r\n            ambientClearcoat = IBLAmbient(specularMap, vec3(0.0), 0.0, clearcoatNormal, clearcoatRoughness, viewDir, transmission, sheenColor, sheenRoughness, ior.x, cSpecular) * clearcoatBlendFactor;\r\n            #ifndef SPHERICAL_HARMONICS\r\n            ambient += aSpecular;\r\n            ambientClearcoat += cSpecular * clearcoatBlendFactor;\r\n            #endif\r\n            float NdotV = saturate(dot(clearcoatNormal, viewDir));\r\n            clearcoatFresnel = (1.0 - clearcoatBlendFactor * fresnelSchlick(NdotV, vec3(0.04)));\r\n        } else {\r\n            ambient = vec3(0.03) * baseColor * 0.2;\r\n        }\r\n\r\n        vec3 emissive = emissiveFactor;\r\n        #ifdef EMISSIVEMAP\r\n            outUV = getUV(EMISSIVEMAP);\r\n            #ifdef EMISSIVEMAP_TEXTURE_TRANSFORM\r\n                outUV = applyTransform(outUV);\r\n            #endif\r\n            emissive = texture(emissiveTexture, outUV).rgb;\r\n        #endif\r\n\r\n        #ifdef TRANSMISSION\r\n        color = vec4(ambient + Lo + f_transmission * (1.0 - specEnv(n, viewDir, metallic, roughness)), alpha);\r\n        #else\r\n        color = vec4(ao * shadow * ((emissive + ambient + Lo) * clearcoatFresnel + ambientClearcoat), alpha);\r\n        #endif\r\n    #else\r\n        vec3 lightDir = normalize(lightPos[0] - outPosition);\r\n        vec3 ambient = ambientStrength * lightColor[0];\r\n\r\n        float diff = max(dot(n, lightDir), 0.0);\r\n        vec3 diffuse = diff * lightColor[0];\r\n\r\n        vec3 reflectDir = reflect(-lightDir, n);\r\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), specularPower);\r\n        vec3 specular = specularStrength * spec * lightColor[0];\r\n\r\n        color = vec4(baseColor.rgb * (ambient + diffuse + specular) * shadow, alpha);\r\n    #endif\r\n\r\n    if (isTone == 1) {\r\n        #ifdef SPHERICAL_HARMONICS\r\n        color.rgb  *= 4.0;\r\n        vec3 X = max(vec3(0.0, 0.0, 0.0), color.rgb - 0.004);\r\n        vec3 retColor = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);\r\n        color.rgb = retColor * retColor;\r\n        #else\r\n        color.rgb = color.rgb / (color.rgb + vec3(1.0));\r\n        color.rgb = pow(color.rgb, vec3(1.0 / gamma));\r\n        #endif\r\n    }\r\n\r\n    #ifdef SPHERICAL_HARMONICS\r\n    color.rgb += aSpecular;\r\n    #endif\r\n\r\n    normalColor = n;\r\n}\r\n",Q={POSITION:[0,3],NORMAL:[1,3],TEXCOORD_0:[2,2],JOINTS_0:[3,4],WEIGHTS_0:[4,4],TANGENT:[5,4],COLOR_0:[6,4],TEXCOORD_1:[7,2]};class ee{constructor(e,t,n,r,i){let s;this.boundingSphere={center:new o,radius:null,min:null,max:null},this.uniformBuffer=null,this.UBO=null,this.VAO=null,this.indicesBuffer=null,this.attributes=null,this.targets=null,this.blend=null,this.uniforms=null,this.SKIN=null,this.targets=[];const a={},l=e.accessors[i.indices],c=new Map;for(const t in i.attributes)c.set(t,e.accessors[i.attributes[t]]);const h={min:c.get("POSITION").min,max:c.get("POSITION").max},f=i.extensions&&i.extensions.KHR_draco_mesh_compression;if(f){const n=e.bufferViews[f.bufferView],i=new r.Decoder,o=function(e,t,n,r){const i=new q.DecoderBuffer;i.Init(new Int8Array(e,n,r),e.byteLength);const s=new q.Mesh;return t.DecodeBufferToMesh(i,s),q.destroy(i),s}(t[n.buffer],i,n.byteOffset,n.byteLength),l=o.num_faces(),u=o.num_points();for(const e of c.keys()){const t=i.GetAttributeByUniqueId(o,f.attributes[e]),n=T(c.get(e).type),[s,l]=J((d=c.get(e).componentType,m[d]),u*n,o,t,i);for(let e=0;e<u*n;e+=n)l[e]=s.GetValue(e),l[e+1]=s.GetValue(e+1),n>2&&(l[e+2]=s.GetValue(e+2)),n>3&&(l[e+3]=s.GetValue(e+3));r.destroy(s),a[e]=l}{s=new Uint32Array(3*l),s.type="UNSIGNED_INT";const e=new r.DracoUInt32Array;for(let t=0;t<l;++t){i.GetFaceFromMesh(o,t,e);const n=3*t;s[n]=e.GetValue(0),s[n+1]=e.GetValue(1),s[n+2]=e.GetValue(2)}r.destroy(e)}r.destroy(i),r.destroy(o)}else{if(l){const n=e.bufferViews[l.bufferView];s=A(t[n.buffer],l.componentType,N(n.byteOffset,l.byteOffset),T(l.type)*l.count)}for(const n of c.keys()){const r=c.get(n),i=e.bufferViews[r.bufferView];a[n]=R(t[i.buffer],r,i)}}var d;if(i.targets){for(const n of i.targets){const r={};for(const i in n){r[i]=e.accessors[n[i]];const s=r[i],a=e.bufferViews[s.bufferView];r[i]=R(t[a.buffer],s,a)}this.targets.push(r)}for(const e of c.keys())if(this.targets[0][e]){let t=0;const r=a[e];a[e]=new r.constructor(r.length);for(let i=0;i<a[e].length;i++)"TANGENT"!==e||(i+1)%4!=0?a[e][i]=r[i]+n.reduce(((r,s,a)=>r+n[a]*this.targets[a][e][i-t]),0):t++}}for(const n of c.keys()){const r=c.get(n);if("COLOR_0"===n&&"VEC3"===r.type){const e=new a[n].constructor(4*r.count);let t=0;for(let r=0;r<e.length;r++)(r+1)%4==0?e[r]=1:(e[r]=a[n][t],t++);a[n]=e}if(void 0!==r.sparse){const i=T(r.type),s=e.bufferViews[r.sparse.indices.bufferView],o=e.bufferViews[r.sparse.values.bufferView],l=A(t[s.buffer],r.sparse.indices.componentType,N(s.byteOffset,r.sparse.indices.byteOffset),r.sparse.count),c=A(t[o.buffer],r.componentType,N(o.byteOffset,r.byteOffset),T(r.type)*r.sparse.count);for(let e=0,t=l.length;e<t;e++){const t=l[e];a[n][t*i]=c[e*i],i>=2&&(a[n][t*i+1]=c[e*i+1]),i>=3&&(a[n][t*i+2]=c[e*i+2]),i>=4&&(a[n][t*i+3]=c[e*i+3])}}}void 0===a.NORMAL&&s&&(a.NORMAL=function(e,t){const n=new Float32Array(t.length/3*3);for(let i=0;i<e.length;i+=3){const s=[e[i],e[i+1],e[i+2]].map((e=>r(t,e))),a=s[1].subtract(s[0]),l=s[2].subtract(s[0]),c=o.cross(a.normalize(),l.normalize()),[u,h,f]=c.elements;for(let t=0;t<3;t++)n[3*e[i+t]+0]=n[3*e[i+t]+0]+u,n[3*e[i+t]+1]=n[3*e[i+t]+1]+h,n[3*e[i+t]+2]=n[3*e[i+t]+2]+f}return n;function r(e,t,n=3){return new o([e[t*=n],e[t+1],e[t+2]])}}(s,a.POSITION),c.set("NORMAL",{componentType:5126})),void 0===a.NORMAL&&void 0===s&&(a.NORMAL=function(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;n+=9){const r=[new o([e[n],e[n+1],e[n+2]]),new o([e[n+3],e[n+4],e[n+5]]),new o([e[n+6],e[n+7],e[n+8]])],i=r[1].subtract(r[0]),s=r[2].subtract(r[0]),a=o.cross(i.normalize(),s.normalize()),[l,c,u]=a.elements;t[n]=l,t[n+1]=c,t[n+2]=u,t[n+3]=l,t[n+4]=c,t[n+5]=u,t[n+6]=l,t[n+7]=c,t[n+8]=u}return t}(a.POSITION),c.set("NORMAL",{componentType:5126})),void 0===a.TEXCOORD_0&&s&&(a.TEXCOORD_0=function(e,t){const n=new Float32Array(e.length/3*2),r=new u([1/0,1/0]),i=new u([-1/0,-1/0]);for(let s=0;s<e.length/3;++s){const a=[],l=[];for(let n=0;n<3;++n)a.push(e[3*s+n]),l.push(t[3*s+n]);const c=new o(l),u=["x","y","z"].sort(((e,t)=>Math.abs(c[e])-Math.abs(c[t]))),h=new o(a),f=h[u[0]],m=h[u[1]];n[2*s]=f,n[2*s+1]=m,i.x=Math.max(i.x,f),i.y=Math.max(i.y,m),r.x=Math.min(r.x,f),r.y=Math.min(r.y,m)}const s=new u(i.elements).subtract(r);for(let t=0;t<e.length/3;++t){const e=2*t;n[e]=(n[e]-r.x)/s.x,n[e+1]=(n[e+1]-r.y)/s.y}return n}(a.POSITION,a.NORMAL),c.set("TEXCOORD_0",{componentType:5126})),void 0===i.attributes.TANGENT&&s&&(a.TANGENT=function(e,t,n,r){const i=new Float32Array(n.length/3*4);for(let n=0;n<e.length;n+=3){const l=[e[n],e[n+1],e[n+2]],c=l.map((e=>s(t,e))),u=l.map((e=>s(r,e,2))),h=c[1].subtract(c[0]),f=c[2].subtract(c[0]),m=u[1].subtract(u[0]),d=u[2].subtract(u[0]);let T=m.elements[0]*d.elements[1]-m.elements[1]*d.elements[0];const E=T>0?1:-1;T=0!==T?1/T:1;const p=new o([(d.elements[1]*h.elements[0]-m.elements[1]*f.elements[0])*T,(d.elements[1]*h.elements[1]-m.elements[1]*f.elements[1])*T,(d.elements[1]*h.elements[2]-m.elements[1]*f.elements[2])*T]);p.normalize(),l.forEach((e=>{a(i,e,p,E)}))}return i;function s(e,t,n=3){return t*=n,3===n?new o([e[t],e[t+1],e[t+2]]):2===n?new u([e[t],e[t+1]]):void 0}function a(e,t,n,r,i=4,s=((e,t)=>e+t)){t*=i;for(let a=0;a<i;++a)e[t+a]=3===a?r:s(e[t+a],n.elements[a])}}(s,a.POSITION,a.NORMAL,a.TEXCOORD_0),c.set("TANGENT",{componentType:5126})),this.vertexAccessor=c,this.attributes=a,this.indicesBuffer=s;const{min:E,max:p}=h;this.boundingSphere.min=new o(E),this.boundingSphere.max=new o(p)}createGeometryForWebGPU(e){const{device:t}=e;let n=12;const r=this.attributes.POSITION.length/3,i=new Float32Array(3*r+2*r+3*r+4*r+(this.attributes.JOINTS_0?.length??0)+(this.attributes.WEIGHTS_0?.length??0)+(this.attributes.COLOR_0?.length??0)+(this.attributes.TEXCOORD_1?.length??0));this.attributes.WEIGHTS_0&&(n+=8),this.attributes.COLOR_0&&(n+=4),this.attributes.TEXCOORD_1&&(n+=2);let s=0,a=0,o=0;for(let e=0;e<i.length;e+=n)i[e]=this.attributes.POSITION[s],i[e+1]=this.attributes.POSITION[s+1],i[e+2]=this.attributes.POSITION[s+2],this.attributes.TEXCOORD_0&&(i[e+3]=this.attributes.TEXCOORD_0[a],i[e+4]=this.attributes.TEXCOORD_0[a+1]),i[e+5]=this.attributes.NORMAL[s],i[e+6]=this.attributes.NORMAL[s+1],i[e+7]=this.attributes.NORMAL[s+2],this.attributes.TANGENT&&(i[e+8]=this.attributes.TANGENT[o],i[e+9]=this.attributes.TANGENT[o+1],i[e+10]=this.attributes.TANGENT[o+2],i[e+11]=this.attributes.TANGENT[o+3]),this.attributes.WEIGHTS_0&&(i[e+12]=this.attributes.JOINTS_0[o],i[e+13]=this.attributes.JOINTS_0[o+1],i[e+14]=this.attributes.JOINTS_0[o+2],i[e+15]=this.attributes.JOINTS_0[o+3],i[e+16]=this.attributes.WEIGHTS_0[o],i[e+17]=this.attributes.WEIGHTS_0[o+1],i[e+18]=this.attributes.WEIGHTS_0[o+2],i[e+19]=this.attributes.WEIGHTS_0[o+3]),this.attributes.COLOR_0&&(i[e+12]=this.attributes.COLOR_0[o],i[e+13]=this.attributes.COLOR_0[o+1],i[e+14]=this.attributes.COLOR_0[o+2],i[e+15]=this.attributes.COLOR_0[o+3]),this.attributes.TEXCOORD_1&&(i[e+12]=this.attributes.TEXCOORD_1[a],i[e+13]=this.attributes.TEXCOORD_1[a+1]),s+=3,a+=2,o+=4;this.g=i;const l=t.createBuffer({size:i.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});if(new Float32Array(l.getMappedRange()).set(i),l.unmap(),this.verticesWebGPUBuffer=l,this.indicesBuffer){this.indicesBuffer=new Uint32Array(this.indicesBuffer);const e=t.createBuffer({size:this.indicesBuffer.byteLength,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0});new Uint32Array(e.getMappedRange()).set(this.indicesBuffer),e.unmap(),this.indicesWebGPUBuffer=e}}createGeometryForWebGl(e){const t=e.createVertexArray();e.bindVertexArray(t);for(const t in this.attributes){const n=this.vertexAccessor.get(t),r=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,r),e.bufferData(e.ARRAY_BUFFER,this.attributes[t],e.STATIC_DRAW);const i=Q[t];e.enableVertexAttribArray(i[0]),e.vertexAttribPointer(i[0],i[1],n.componentType,!1,0,0)}if(this.indicesBuffer){const t=e.createBuffer();e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t),e.bufferData(e.ELEMENT_ARRAY_BUFFER,this.indicesBuffer,e.STATIC_DRAW)}this.VAO=t,e.bindVertexArray(null)}calculateBounding(e){this.boundingSphere.min.applyMatrix4(e),this.boundingSphere.max.applyMatrix4(e);const t=this.attributes.POSITION;let n=0;this.boundingSphere.center.add(this.boundingSphere.min).add(this.boundingSphere.max).scale(.5);for(let e=0;e<t.length;e+=3)n=Math.max(n,this.boundingSphere.center.distanceToSquared(t[e],t[e+1],t[e+2]));this.boundingSphere.radius=Math.sqrt(n)}createUniforms(e,t,n){const r=new s(e);r.invert().transpose();const i=new O;i.add("model",e.elements),i.add("normalMatrix",r.elements),i.add("view",t.matrixWorldInvert.elements),i.add("projection",t.projection.elements),i.add("light",n.matrixWorldInvert.elements),i.add("isShadow",0),i.done(),this.uniformBuffer=i}updateUniformsWebGPU(e){const t=this.uniformBuffer.store.byteLength,n=256+t,{device:r}=e,i=r.createBuffer({size:n,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});this.uniformBuffer.bufferWebGPU=i;const s=[{binding:0,resource:{buffer:i,offset:0,size:t}}];r.queue.writeBuffer(i,0,this.uniformBuffer.store.buffer,this.uniformBuffer.store.byteOffset,this.uniformBuffer.store.byteLength),this.uniformBindGroup1=s}updateUniformsWebGl(e,t){const n=e.getUniformBlockIndex(t,"Matrices");e.uniformBlockBinding(t,n,0);const r=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,r),e.bufferData(e.UNIFORM_BUFFER,this.uniformBuffer.store,e.DYNAMIC_DRAW),this.UBO=r,e.bindBuffer(e.UNIFORM_BUFFER,null)}async updateWebGPU(e,t){const{device:n,commandEncoder:r}=e;let i=0,s=0,a=0;const{g:o}=this;for(let e=0;e<o.length;e+=12)t.POSITION&&(o[e]=t.POSITION[i],o[e+1]=t.POSITION[i+1],o[e+2]=t.POSITION[i+2]),t.TEXCOORD_0&&(o[e+3]=t.TEXCOORD_0[s],o[e+4]=t.TEXCOORD_0[s+1]),t.NORMAL&&(o[e+5]=t.NORMAL[i],o[e+6]=t.NORMAL[i+1],o[e+7]=t.NORMAL[i+2]),t.TANGENT&&(o[e+8]=t.TANGENT[a],o[e+9]=t.TANGENT[a+1],o[e+10]=t.TANGENT[a+2],o[e+11]=t.TANGENT[a+3]),i+=3,s+=2,a+=4;const l=n.createBuffer({size:o.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_SRC,mappedAtCreation:!0});new Float32Array(l.getMappedRange()).set(o),l.unmap(),r.copyBufferToBuffer(l,0,this.verticesWebGPUBuffer,0,o.byteLength)}update(e,t){e.bindVertexArray(this.VAO);for(const n in t){const r=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,r),e.bufferData(e.ARRAY_BUFFER,t[n],e.STATIC_DRAW);const i=Q[n];e.enableVertexAttribArray(i[0]),e.vertexAttribPointer(i[0],i[1],e[g.get(this.attributes[n].constructor)],!1,0,0)}e.bindVertexArray(null)}}let te;const ne=";base64,";class re{constructor(e,t,n){this.url=e,this.host=e.substr(0,e.lastIndexOf("/")+1),this.tracks=[],this.skins=[],this.textures=null,this.samplers=null,this.arrayBuffer=null,this.cameras=[],this.lights=[],this.programs={},this.defines=t,this.resize=n}setScene(e){this.scene=e}setGl(e){te=e}setCamera(e){this.camera=e}setLight(e){this.light=e}setCanvas(e){this.canvas=e}getBuffer(){return Promise.all(this.scene.bin.map((e=>{if("string"==typeof e){if(/base64/.test(e)){const t=e.indexOf(ne)+ne.length,n=e.substring(t),r=window.atob(n),i=new ArrayBuffer(r.length),s=new Uint8Array(i);for(let e=0;e<r.length;e++)s[e]=r.charCodeAt(e);return i}return K(`${this.host}${e}`)}return Promise.resolve(e)}))).then((e=>{this.arrayBuffer=e}))}createProgramWebGPU(e){let t;const n=e.map((e=>`${e.name}${e.value||1}`)).join("");if(this.programs[n])t=this.programs[n];else{const r=e.map((e=>`#define ${e.name} ${e.value||1}\n`)).join("");t=[Z.replace(/\n/,`\n${r}`),$.replace(/\n/,`\n${r}`)],this.programs[n]=t}return t}createProgram(e){let t;const n=e.map((e=>`${e.name}${e.value||1}`)).join("");if(this.programs[n])t=this.programs[n];else{const r=e.map((e=>`#define ${e.name} ${e.value||1}\n`)).join("");t=x(Z.replace(/\n/,`\n${r}`),$.replace(/\n/,`\n${r}`)),this.programs[n]=t}return t}buildPrim(e,t,n,r,i){const s=this.json.materials&&this.json.materials[i.material];this.json.extensions&&this.json.extensions.EXT_lights_image_based&&this.defines.push({name:"SPHERICAL_HARMONICS",value:Math.ceil(Math.log(this.json.extensions.EXT_lights_image_based.lights[0].specularImageSize)*Math.LOG2E)+10}),this.json.extensionsUsed&&this.json.extensionsUsed.includes("KHR_texture_basisu")&&this.defines.push({name:"BASISU"});const a=[...this.defines],o=new B(s,this.textures,a,this.lights);void 0!==n&&a.push({name:"JOINTNUMBER",value:this.skins[n].jointNames.length}),void 0===i.indices&&void 0===i.attributes.TANGENT||a.push({name:"TANGENT"}),void 0!==i.attributes.TEXCOORD_1&&a.push({name:"MULTIUV"}),i.attributes.COLOR_0&&a.push({name:"COLOR"});const l=void 0!==n?new M(t,e):new I(t,e),c=new ee(this.json,this.arrayBuffer,r,this.draco,i);if(c.attributes.COLOR_0&&c.attributes.COLOR_0.constructor!==Float32Array&&a.push({name:"COLOR_255"}),void 0===i.attributes.TANGENT&&a.push({name:"USERIGHTHANDEDSYSTEM"}),i.extensions&&i.extensions.KHR_materials_variants){const e=i.extensions.KHR_materials_variants.mappings.map((e=>({...e,m:new B(this.json.materials[e.material],this.textures,[...a],this.lights)})));l.setVariants(e)}return l.setMode(i.mode),l.setMaterial(o),l.setGeometry(c),l.setDefines(o.defines),l instanceof M&&(l.skin=n),l.updateMatrix(),l.calculateBounding(),l}buildNode(e,t){const n=this.json.nodes[t];let r;if(void 0!==n.camera){const i=Object.assign({zoom:1,aspect:this.canvas?this.canvas.offsetWidth/this.canvas.offsetHeight:1},this.json.cameras[n.camera]);re.__update?re.__update("camera",i,t,e):this.camera=new C(i,t,e),r=this.camera;const s=S(r.props);r.setProjection(s),this.cameras.push(r)}else if(n.extensions&&n.extensions.KHR_lights_punctual){const i=this.json.extensions.KHR_lights_punctual.lights[n.extensions.KHR_lights_punctual.light];i.isInitial=!1,re.__update?re.__update("light",i,t,e):this.light=new L(i,t,e),r=this.light,this.lights.push(r)}else r=void 0!==n.isBone?new F(t,e):new f(t,e);n.translation||n.rotation||n.scale?r.setPosition(n.translation,n.rotation,n.scale):n.matrix&&r.setMatrix(n.matrix),r.updateMatrix(),r.id=n.name,e.children.push(r),e=r,void 0!==n.mesh&&e.children.push(...this.json.meshes[n.mesh].primitives.map(this.buildPrim.bind(this,e,this.json.meshes[n.mesh].name,n.skin,this.json.meshes[n.mesh].weights))),n.children&&n.children.length&&n.children.forEach(this.buildNode.bind(this,e))}calculateFov(e){const t=new l;v(this.scene,(e=>{e instanceof I&&t.expand(e.geometry.boundingSphere)}));const n=t.getSize();if(e){const e=(new o).add(t.min).add(t.max).scale(.5),n=new s;n.translate(e.x,e.y,e.z),n.invert(),this.scene.matrixWorld.multiply(n),v(this.scene,(e=>{e instanceof f&&e.updateMatrix()}))}this.cameras.forEach((e=>{e.modelSize=n})),this.resize()}async buildMesh(){this.json.extensionsUsed&&this.json.extensionsUsed.includes("KHR_draco_mesh_compression")&&(this.draco=await new Promise((e=>{const t={onModuleLoaded(t){q=t,e(q)}};n.e(681).then(n.t.bind(n,55,23)).then((e=>e.default(t)))}))),this.json.extensions&&this.json.extensions.KHR_materials_variants&&(this.scene.variants=this.json.extensions.KHR_materials_variants.variants),this.json.scenes[void 0!==this.json.scene?this.json.scene:0].nodes.forEach((e=>{this.json.nodes[e].extensions&&this.buildNode(this.scene,e)})),0===this.lights.length&&this.light&&this.lights.push(this.light),this.json.scenes[void 0!==this.json.scene?this.json.scene:0].nodes.forEach((e=>{this.json.nodes[e].children&&this.json.nodes[e].children.length&&!this.json.nodes[e].extensions&&this.buildNode(this.scene,e),void 0!==this.json.nodes[e].mesh&&this.buildNode(this.scene,e),void 0!==this.json.nodes[e].camera&&this.buildNode(this.scene,e)})),v(this.scene,(e=>{e instanceof I&&(e.material.alpha?this.scene.transparentChildren.push(e):this.scene.opaqueChildren.push(e),this.scene.meshes.push(e))})),this.scene.opaqueChildren.sort(((e,t)=>e.distance-t.distance)),this.scene.transparentChildren.sort(((e,t)=>e.distance-t.distance))}buildAnimation(){if(!this.json.animations)return!0;for(const e of this.json.animations){const t=[];for(const n of e.channels){const r=0,i=e.samplers[n.sampler];if(i){const{target:s}=n,a=s.node,o=void 0!==e.parameters?e.parameters[i.input]:i.input,l=void 0!==e.parameters?e.parameters[i.output]:i.output,c=this.json.accessors[o],u=this.json.accessors[l],h=this.json.bufferViews[c.bufferView],m=this.json.bufferViews[u.bufferView],d=A(this.arrayBuffer[h.buffer],c.componentType,N(h.byteOffset,c.byteOffset),T(c.type)*c.count),p=A(this.arrayBuffer[m.buffer],u.componentType,N(m.byteOffset,u.byteOffset),T(u.type)*u.count),g=[];v(this.scene,(e=>{e.name===a&&("weights"===s.path&&e instanceof f?g.push(...e.children):g.push(e))}));let R=E(s.path)||g[0].geometry.targets.length;"CUBICSPLINE"===i.interpolation&&(R*=3);const _=[];for(let e=0;e<d.length;e++){const t=d[e],n=p.slice(e*R,(e+1)*R);_.push({time:t,value:U(n)})}_.length>=2&&g.length&&t.push({duration:Math.max(_[_.length-1].time,r),stoped:!1,meshes:g,type:s.path,name:`${g[0].name}.${s.path}`,keys:_,interpolation:i.interpolation})}}this.tracks.push(t)}}buildSkin(){if(!this.json.skins)return!0;for(const e of this.json.skins){const t=this.json.accessors[e.inverseBindMatrices],n=this.json.bufferViews[t.bufferView],r=A(this.arrayBuffer[n.buffer],t.componentType,N(n.byteOffset,t.byteOffset),T(t.type)*t.count),i={jointNames:e.joints,inverseBindMatrices:r,bones:[],boneInverses:[]};let a=0;for(const e of i.jointNames){this.json.nodes[e].isBone=!0;const t=i.inverseBindMatrices,n=(new s).set(t.slice(16*a,16*(a+1)));i.boneInverses.push(n),a++}this.skins.push(i)}}getJson(){return/glb/.test(this.url)?K(this.url).then((e=>{const t=new TextDecoder("utf-8"),[n]=new Uint32Array(e,12,1),r=new Uint8Array(e,20,n),i=JSON.parse(t.decode(r)),[s]=new Uint32Array(e,20+n,1),a=e.slice(28+n,28+n+s);this.json=i,this.scene.bin.push(a)})):(e=this.url,"undefined"!=typeof window?window.fetch(e).then((e=>e.json())):new Promise((t=>{j.readFile(e,"utf8",((e,n)=>{if(e)throw e;t(JSON.parse(n))}))}))).then((e=>{for(const t in e.buffers)this.scene.bin.push(e.buffers[t].uri);return this.json=e,!0}));var e}createSamplers(){const e=this.json.samplers||[{}];this.samplers=e.map((e=>{const t=te.createSampler();return te.samplerParameteri(t,te.TEXTURE_MIN_FILTER,e.minFilter||te.NEAREST_MIPMAP_LINEAR),te.samplerParameteri(t,te.TEXTURE_MAG_FILTER,e.magFilter||te.LINEAR),te.samplerParameteri(t,te.TEXTURE_WRAP_S,e.wrapS||te.REPEAT),te.samplerParameteri(t,te.TEXTURE_WRAP_T,e.wrapT||te.REPEAT),t}))}createSamplersWebGPU(e){function t(e){return{9729:"linear",9728:"nearest",10497:"repeat",33648:"mirror-repeat",33071:"clamp-to-edge"}[e]}const n=this.json.samplers||[{}];this.samplers=n.map((n=>e.device.createSampler({magFilter:t(n.minFilter)||"linear",minFilter:t(n.magFilter)||"linear",addressModeU:t(n.wrapS)||"repeat",addressModeV:t(n.wrapT)||"repeat",addressModeW:t(n.wrapS)||"repeat"})))}createTexturesWebGPU(e){this.createTextures(this.handleTextureLoadedWebGPU.bind(this,e))}createTexturesWebGL(){this.createTextures(this.handleTextureLoaded.bind(this))}createTextures(e){this.scene.meshes.forEach((t=>{const n=[t.material,...t.variants.map((e=>e.m))],r=["baseColorTexture","metallicRoughnessTexture","emissiveTexture","normalTexture","occlusionTexture","clearcoatTexture","clearcoatRoughnessTexture","clearcoatNormalTexture","sheenColorTexture","sheenRoughnessTexture","transmissionTexture","specularTexture","thicknessTexture"],i=["baseColorTexture","sheenColorTexture","emissiveTexture",t.defines.find((e=>"SPECULARGLOSSINESSMAP"===e.name))&&"metallicRoughnessTexture"];for(let t=0;t<r.length;t++)for(const s of n){const n=r[t],a=s[n];a&&(i.find((e=>e===n))&&(a.srgb=!0),s[n]=e(a))}}))}async initTextures(e){if(!this.json.textures)return!0;const t={};let r=!1;this.json.textures.forEach((e=>{e.extensions&&e.extensions.KHR_texture_basisu&&(r=!0);const n=e.extensions&&e.extensions.KHR_texture_basisu?e.extensions.KHR_texture_basisu.source:e.source,i=String(e.sampler)+String(n);t[i]=e,t[i].name=i,e.name=i})),r&&((await n.e(164).then(n.t.bind(n,308,23))).default({preinitializedWebGLContext:te}).then((e=>{const t={astcSupported:te.getExtension("WEBGL_compressed_texture_astc"),etc1Supported:te.getExtension("WEBGL_compressed_texture_etc1"),etc2Supported:te.getExtension("WEBGL_compressed_texture_etc"),dxtSupported:te.getExtension("WEBGL_compressed_texture_s3tc"),bptcSupported:te.getExtension("EXT_texture_compression_bptc"),pvrtcSupported:te.getExtension("WEBGL_compressed_texture_pvrtc")||te.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc")};window.LIBKTX=e,window.LIBKTX.transcoderConfig=t,window.LIBKTX.GL.makeContextCurrent(window.LIBKTX.GL.registerContext(te,{majorVersion:2}))})),await new Promise((e=>setTimeout(e,1e3))));const i=Object.values(t).map((t=>{const n=t.extensions&&t.extensions.KHR_texture_basisu?t.extensions.KHR_texture_basisu.source:t.source,r=this.json.images[n];return function(e,t,{bufferView:n,mimeType:r,uri:i},{url:s,name:a},o){return"undefined"!=typeof window?new Promise(((l,c)=>{if("image/ktx2"===r)window.fetch(s).then((e=>e.arrayBuffer())).then((e=>{l({sampler:o,mimeType:r,name:a,image:Y(e)})}));else{const u=new Image;if(u.onload=()=>{e?createImageBitmap(u).then((e=>{l({sampler:o,name:a,bitmap:e})})):l({sampler:o,name:a,image:u})},u.onerror=e=>{c(new Error("Cant load texture"))},u.crossOrigin="anonymous",void 0!==n){const e=t.json.bufferViews[n],i=new Uint8Array(t.arrayBuffer[e.buffer],e.byteOffset,e.byteLength),s=new Blob([i],{type:r});u.src=URL.createObjectURL(s)}else/base64/.test(i)?u.src=i:u.src=s}})):new Promise((e=>{j.readFile(s,((t,n)=>{if(t)throw t;e({sampler:o,url:s,name:a,image:new Uint8Array(n).buffer})}))}))}(e,this,r,{url:`${this.host}${r.uri}`,name:t.name},t.sampler)}));return Promise.all(i).then((e=>(this.textures=this.json.textures.map((t=>e.find((e=>e.name===t.name)))),!0)))}handleTextureLoadedWebGPU(e,{bitmap:t,sampler:n}){const{device:r}=e,i=this.samplers[void 0!==n?n:0],s=r.createTexture({size:[t.width,t.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return r.queue.copyExternalImageToTexture({source:t},{texture:s,mipLevel:0,origin:{x:0,y:0,z:0}},{width:t.width,height:t.height,depthOrArrayLayers:1}),s.sampler=i,s}handleTextureLoaded({image:e,name:t,mimeType:n,sampler:r,srgb:i}){const s=this.samplers[void 0!==r?r:0];if(n)return e.sampler=s,e;const a=te.createTexture();return a.name=t,a.image=e.src.substr(e.src.lastIndexOf("/")),a.sampler=s,te.activeTexture(te.TEXTURE31),te.bindTexture(te.TEXTURE_2D,a),te.pixelStorei(te.UNPACK_COLORSPACE_CONVERSION_WEBGL,te.NONE),te.texImage2D(te.TEXTURE_2D,0,i?te.SRGB8_ALPHA8:te.RGBA,te.RGBA,te.UNSIGNED_BYTE,e),te.generateMipmap(te.TEXTURE_2D),a}async getEnv(){if(this.json.extensions&&this.json.extensions.EXT_lights_image_based){const[e]=this.json.extensions.EXT_lights_image_based.lights;return e.specularImages=e.specularImages.map((e=>e.map((e=>{const t=this.json.images[e],n=this.json.bufferViews[t.bufferView],{buffer:r,byteLength:i,byteOffset:s}=n,a=new Uint8Array(this.arrayBuffer[r],s,i),o=new Blob([a],{type:t.mimeType}),l=window.URL.createObjectURL(o),c=new Image;return c.src=l,c})))),await new Promise((e=>setTimeout(e,200))),e}}}class ie{constructor(){this.counterEl=document.createElement("div"),this.counterEl.setAttribute("style","position: absolute; top: 0; right: 0; color: #fff; font-size: 30px; background: #000;"),document.body.appendChild(this.counterEl),this.fps=0,this.elapsedTime=0,this.lastTime=0}tick(e){this.fps++,this.elapsedTime+=e-this.lastTime,this.lastTime=e,this.elapsedTime>=1e3&&(this.counterEl.innerHTML=String(this.fps),this.fps=0,this.elapsedTime-=1e3)}}let se,ae,oe;class le extends class{constructor(e){this.reflow=!0,this.fps=new ie,this.getState=e,this.currentTrack=0}setEnv(e){this.env=e}setCamera(e){this.camera=e}setParticles(e){this.Particles=e}setScene(e){this.scene=e}setPp(e){this.PP=e}setGl(e){ae=e}setParser(e){this.parse=e}step(e,t){const n=p(e,t.keys);if(-1===n[0]||-1===n[1]||0===n[0]&&0===n[1])return!1;const r=t.keys[n[0]],i=E(t.type);let s;s=3===i?o:4===i?c:a;const l=new s(r.value);if("rotation"===t.type)for(const e of t.meshes){const t=e.matrix.getScaling();e.matrix.makeRotationFromQuaternion(l.elements),e.matrix.scale(t)}else if("scale"===t.type)for(const e of t.meshes){if(e.matrix.animated){const t=e.matrix.getScaling();e.matrix.restoreScale(t)}e.matrix.scale(l),e.matrix.animated=!0}else if("translation"===t.type)for(const e of t.meshes)e.matrix.setTranslate(l)}spline(e,t){const n=p(e,t.keys);if(-1===n[0]||-1===n[1]||0===n[0]&&0===n[1])return!1;const r=e,i=t.keys[n[1]].time,s=t.keys[n[0]].time,a=E(t.type),l=i-s,u=(r-s)/l,h=u*u,f=h*u,m=-2*f+3*h,d=f-h,T=1-m,g=d-h+u,R=new Float32Array(a);for(let e=0;e!==a;e++){const r=t.keys[n[0]].value[a+e],i=t.keys[n[0]].value[2*a+e]*l,s=t.keys[n[1]].value[a+e],o=t.keys[n[1]].value[e]*l;if(R[e]=T*r+g*i+m*s+d*o,isNaN(R[e]))return!1}if("rotation"===t.type){const e=new c(R).normalize();for(const n of t.meshes){const t=n.matrix.getScaling();n.matrix.makeRotationFromQuaternion(e.elements),n.matrix.scale(t)}}else if("scale"===t.type){const e=new o(R);for(const n of t.meshes){if(n.matrix.animated){const e=n.matrix.getScaling();n.matrix.restoreScale(e)}n.matrix.scale(e),n.matrix.animated=!0}}else if("translation"===t.type){const e=new o(R);for(const n of t.meshes)n.matrix.setTranslate(e)}}updateGeometry(e,t){e.geometry.update(ae,t)}interpolation(e,t){const n=p(e,t.keys);if(-1===n[0]||-1===n[1]||0===n[0]&&0===n[1])return!1;const r=t.keys[n[0]],i=t.keys[n[1]],s=n[2],l=E(t.type);let u;u=3===l?o:4===l?c:a;const h=new u(r.value),f=new u(i.value);if("rotation"===t.type){const e=new c;e.lerp(h.elements,f.elements,s);for(const n of t.meshes){const t=n.matrix.getScaling();n.matrix.makeRotationFromQuaternion(e.elements),n.matrix.scale(t)}}else if("scale"===t.type){const e=new o;e.lerp(h.elements,f.elements,s);for(const n of t.meshes){if(n.matrix.animated){const e=n.matrix.getScaling();n.matrix.restoreScale(e)}n.matrix.scale(e),n.matrix.animated=!0}}else if("weights"===t.type){const e=new a(h.elements);e.lerp(h.elements,f.elements,s);for(const n of t.meshes){const t={};for(const r in n.geometry.targets[0])if("POSITION"===r){t[r]=n.geometry.attributes[r].slice();for(let i=0;i<e.elements.length;i++){if(0===e.elements[i])continue;const s=0;for(let a=0;a<t[r].length;a++)t[r][a]+=e.elements[i]*n.geometry.targets[i][r][a-s]}}this.updateGeometry(n,t)}}else if("translation"===t.type){const e=new o;e.lerp(h.elements,f.elements,s);for(const n of t.meshes)n.matrix.setTranslate(e)}else console.error("ERROR")}animate(e){if(!this.parse.tracks.length)return;this.parse.tracks[this.currentTrack];const t=Math.max(...this.parse.tracks.map((e=>e[0].duration)));e-=Math.floor(e/t)*t;for(const t of this.parse.tracks.sort(((e,t)=>e[0].duration-t[0].duration)))for(const n of t){let t;switch(n.interpolation){case"LINEAR":t=this.interpolation(e,n);break;case"CUBICSPLINE":t=this.spline(e,n);break;case"STEP":t=this.step(e,n);break;default:t=this.interpolation(e,n)}if(!1!==t){for(const e of n.meshes)v(e,(e=>{e.updateMatrix(),e instanceof F&&(e.reflow=!0),e instanceof I&&(e.reflow=!0),e instanceof C&&e===this.camera&&(this.needUpdateView=!0)}));this.reflow=!0}}}render(e=0){const t=e/1e3;this.animate(t),this.reflow&&(this.PP.postprocessors.length>0&&(this.PP.bindPrePass(),this.PP.preProcessing()),ae.clear(ae.COLOR_BUFFER_BIT|ae.DEPTH_BUFFER_BIT),this.renderScene(),this.clean(),this.PP.postprocessors.some((e=>e instanceof class extends class{setCanvas(e){this.canvas=e}setCamera(e){this.camera=e}setLight(e){this.light=e}get width(){return this.canvas.offsetWidth*devicePixelRatio}get height(){return this.canvas.offsetHeight*devicePixelRatio}}{constructor(){super(),this.scale=2}setGL(e){se=e}preProcessing(e){se.clear(se.COLOR_BUFFER_BIT|se.DEPTH_BUFFER_BIT),e.renderScene({isprepender:!0}),se.bindFramebuffer(se.FRAMEBUFFER,this.framebuffer),se.framebufferTexture2D(se.FRAMEBUFFER,se.COLOR_ATTACHMENT0,se.TEXTURE_2D,this.texture,0),se.useProgram(this.program),se.viewport(0,0,this.width/this.scale,this.height/this.scale),se.bindVertexArray(this.quadVAO);const t=S(Object.assign({},this.camera.props,{zoom:1}));se.uniformMatrix4fv(se.getUniformLocation(this.program,"Iproj"),!1,(new s).setInverseOf(t).elements),se.uniformMatrix4fv(se.getUniformLocation(this.program,"proj"),!1,t.elements),se.uniformMatrix4fv(se.getUniformLocation(this.program,"Iview"),!1,this.camera.matrixWorld.elements),se.uniformMatrix4fv(se.getUniformLocation(this.program,"view"),!1,this.camera.matrixWorldInvert.elements),se.uniformMatrix4fv(se.getUniformLocation(this.program,"light"),!1,this.light.matrixWorldInvert.elements),se.uniform1i(se.getUniformLocation(this.program,"lightTexture"),e.preDepthTexture.index),se.uniform1i(se.getUniformLocation(this.program,"cameraTexture"),e.depthTexture.index),se.uniform3fv(se.getUniformLocation(this.program,"viewPos"),this.camera.getPosition()),se.uniform3fv(se.getUniformLocation(this.program,"lightPos"),this.light.getPosition()),se.drawArrays(se.TRIANGLE_STRIP,0,4),se.bindFramebuffer(se.FRAMEBUFFER,null),se.viewport(0,0,this.width,this.height)}buildScreenBuffer(e){this.framebuffer=se.createFramebuffer(),se.bindFramebuffer(se.FRAMEBUFFER,this.framebuffer),this.texture=e.createOneChannelTexture(this.scale),se.framebufferTexture2D(se.FRAMEBUFFER,se.COLOR_ATTACHMENT0,se.TEXTURE_2D,this.texture,0),this.program=x("#version 300 es\r\nprecision highp float;\r\n\r\nlayout (location = 0) in vec2 pos;\r\n\r\nout vec2 uv;\r\nout vec4 vPosLight1;\r\nout vec4 vPosLight2;\r\nout vec3 outPositionView;\r\nout vec3 outPositionLight;\r\n\r\nuniform mat4 proj;\r\nuniform mat4 light;\r\nuniform mat4 Iproj;\r\nuniform mat4 Iview;\r\nuniform mat4 view;\r\n\r\nvoid main() {\r\n    vec4 p1 = Iview * Iproj * vec4(pos, -1.0/16.0, 1.0);\r\n    vec4 p2 = Iview * Iproj * vec4(pos, 1.0/16.0, 1.0);\r\n\r\n\tvPosLight1 = proj * light * p1;\r\n    vPosLight2 = proj * light * p2;\r\n    outPositionLight = vec3(light * p1);\r\n    outPositionView = vec3(view * p1);\r\n\r\n\tuv = pos * 0.5 + 0.5;\r\n\tgl_Position = vec4(pos, 0.0, 1.0);\r\n}\r\n","#version 300 es\r\nprecision highp float;\r\n\r\nin vec2 uv;\r\n// in vec4 tPos1;\r\n// in vec4 tPos2;\r\nin vec4 vPosLight1;\r\nin vec4 vPosLight2;\r\nout float color;\r\n\r\nuniform sampler2D lightTexture;\r\nuniform sampler2D cameraTexture;\r\n\r\nuniform mat4 proj;\r\nuniform mat4 light;\r\nuniform mat4 view;\r\nuniform vec3 viewPos;\r\nuniform vec3 lightPos;\r\n\r\nin vec3 outPositionView;\r\nin vec3 outPositionLight;\r\n\r\nconst int samples = 80;\r\n\r\nvoid main() {\r\n    float stp = 1.0/float(samples);\r\n\tfloat k = 0.0;\r\n    float d = 0.0;\r\n\r\n    for (int i = 0; i < samples; i++) {\r\n\r\n        //vec4 vPos = mix(tPos1,tPos2,k);\r\n        vec4 vPosLight = mix(vPosLight1,vPosLight2,k);\r\n        k += stp;\r\n\r\n        vec3 ShadowTexC = (vPosLight.xyz/vPosLight.w) * 0.5 + 0.5;\r\n\r\n        float add = step(texture(lightTexture, ShadowTexC.xy).x, ShadowTexC.z);\r\n        d += add*stp;\r\n\t}\r\n\r\n    vec3 viewDir = normalize(viewPos - outPositionView);\r\n    vec3 L = normalize(lightPos - outPositionLight);\r\n    color = min((1.0 - d), (1.0 - dot(L, viewDir)) * 0.2);\r\n}\r\n"),this.quadVAO=se.createVertexArray(),se.bindVertexArray(this.quadVAO);const t=se.createBuffer();return se.bindBuffer(se.ARRAY_BUFFER,t),se.bufferData(se.ARRAY_BUFFER,new Float32Array(X),se.STATIC_DRAW),se.enableVertexAttribArray(0),se.vertexAttribPointer(0,2,se.FLOAT,!1,0,0),se.bindVertexArray(null),se.bindFramebuffer(se.FRAMEBUFFER,null),{name:"LIGHT"}}attachUniform(e){se.uniform1i(se.getUniformLocation(e,"light"),this.texture.index)}postProcessing(){}}))&&(ae.bindFramebuffer(ae.DRAW_FRAMEBUFFER,null),this.Particles.draw(e),this.reflow=!0)),this.fps.tick(e),requestAnimationFrame(this.render.bind(this))}renderScene(){if(this.needUpdateView){const e=function(e){const t=[new c,new c,new c,new c,new c,new c],n=e.elements;let r=n[0],i=n[1],s=n[2],a=n[3],o=n[4],l=n[5],u=n[6],h=n[7],f=n[8],m=n[9],d=n[10],T=n[11],E=n[12],p=n[13],g=n[14],R=n[15];return t[0].set([a-r,h-o,T-f,R-E]).normalize(),t[1].set([a+r,h+o,T+f,R+E]).normalize(),t[2].set([a+i,h+l,T+m,R+p]).normalize(),t[3].set([a-i,h-l,T-m,R-p]).normalize(),t[4].set([a-s,h-u,T-d,R-g]).normalize(),t[5].set([a+s,h+u,T+d,R+g]).normalize(),t}(this.camera.getViewProjMatrix());this.scene.meshes.forEach((t=>{t.visible=t.isVisible(e)}))}this.scene.opaqueChildren.forEach((e=>{e.visible&&e.draw(ae,this.getState())})),this.scene.transparentChildren.length&&(ae.enable(ae.BLEND),ae.blendFunc(ae.SRC_ALPHA,ae.ONE_MINUS_SRC_ALPHA),this.scene.transparentChildren.forEach((e=>{e.visible&&e.draw(ae,this.getState())})),ae.disable(ae.BLEND),ae.blendFunc(ae.ONE,ae.ZERO))}clean(){v(this.scene,(e=>{e.reflow=!1})),this.needUpdateView=!1,this.needUpdateProjection=!1,this.reflow=!1}}{setEnv(e){this.env=e}setGl(e){oe=e}render(e=0){const t=e/1e3,n=oe.device.createCommandEncoder();oe.commandEncoder=n,this.animate(t),this.reflow&&(this.renderScene(),this.clean()),this.fps.tick(e),requestAnimationFrame(this.render.bind(this))}updateGeometry(e,t){e.geometry.updateWebGPU(oe,t)}renderScene(){const{renderPassDescriptor:e,context:t,device:n}=oe;e.colorAttachments[0].view=t.getCurrentTexture().createView();const r=oe.commandEncoder.beginRenderPass(e);this.scene.opaqueChildren.forEach((e=>{r.setPipeline(e.pipeline),e.drawWebGPU(oe,r,this.getState())})),this.scene.transparentChildren.forEach((e=>{r.setPipeline(e.pipeline),e.drawWebGPU(oe,r,this.getState())})),r.end(),n.queue.submit([oe.commandEncoder.finish()])}}class ce{constructor(e,t,n,r="env"){if(!e)throw new Error("Url not found");this.envUrl=r,this.url=e,this.canvas=t,this.events=new w(t,this.redraw.bind(this))}async webgpuInit(){const e=await n.e(114).then(n.bind(n,237)),t=await navigator.gpu.requestAdapter(),r=await t.requestDevice(),i=await e.default(),s=this.canvas.getContext("webgpu");s.configure({device:r,format:"bgra8unorm",size:{width:this.canvas.offsetWidth*devicePixelRatio,height:this.canvas.offsetHeight*devicePixelRatio,depthOrArrayLayers:1},compositingAlphaMode:"opaque"});const a=r.createTexture({size:{width:this.canvas.offsetWidth*devicePixelRatio,height:this.canvas.offsetHeight*devicePixelRatio,depthOrArrayLayers:1},format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT}),o={colorAttachments:[{view:s.getCurrentTexture().createView(),storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1}}],depthStencilAttachment:{view:a.createView(),depthLoadOp:"clear",depthClearValue:1,depthStoreOp:"store"}};return{glslang:i,context:s,device:r,renderPassDescriptor:o}}get camera(){return this.ioc.get("camera")}get light(){return this.ioc.get("light")}get renderer(){return this.ioc.get("renderer")}get scene(){return this.ioc.get("scene")}get parse(){return this.ioc.get("parser")}get env(){return this.ioc.get("env")}async init(e){const t=new r;this.ioc=t;try{const e=await this.webgpuInit();t.register("canvas",this.canvas),t.register("gl",e),t.register("scene",h),t.register("light",L,[],{type:"directional",intensity:1,color:[1,1,1],isInitial:!0,spot:{}}),t.register("parser",re,["gl","scene","camera","light"],this.url,[],(()=>{})),t.register("env",z,["camera","canvas"],this.envUrl),t.register("renderer",le,["gl","scene","parser","env"],this.getState.bind(this)),t.register("camera",C,[],{type:"perspective",isInitial:!0,zoom:1,aspect:this.canvas.offsetWidth/this.canvas.offsetHeight,perspective:{yfov:45*Math.PI/180}},"perspective"),await this.parse.getJson(),await this.parse.getBuffer(),await this.parse.initTextures(!0),this.parse.buildSkin(),await this.parse.buildMesh(),this.parse.buildAnimation(),0===this.parse.cameras.length&&this.parse.cameras.push(this.camera),this.parse.createSamplersWebGPU(e),this.parse.createTexturesWebGPU(e),this.parse.calculateFov(this.camera.props.isInitial),this.resize(),await this.env.createTexture(e),this.env.drawBRDF(e),this.env.drawMips(e),this.env.drawIrradiance(e),this.env.drawPrefilter(e),this.scene.meshes.forEach((t=>{if(t.geometry.createGeometryForWebGPU(e),t.geometry.createUniforms(t.matrixWorld,this.camera,this.light),t.geometry.updateUniformsWebGPU(e),t.material.createUniforms(this.camera,this.parse.lights),t.material.updateUniformsWebGPU(e),t.material.uniformBindGroup1.push({binding:19,resource:this.env.prefilterTexture?.createView({dimension:"cube"})},{binding:20,resource:this.env.irradianceTexture?.createView({dimension:"cube"})},{binding:21,resource:this.env.bdrfTexture?.createView()}),t instanceof M){for(const e of this.parse.skins[t.skin].jointNames)v(this.scene,this.buildBones.bind(this,e,this.parse.skins[t.skin]));t.geometry.uniformBindGroup1.push(t.setSkinWebGPU(e,this.parse.skins[t.skin]))}t.pipeline=function(e,t,n,r){const i=r.map((e=>`#define ${e.name} ${e.value||1}\n`)).join(""),s=["#version 460\nprecision highp float;\n\nlayout (location = 0) in vec3 inPosition;\nlayout (location = 1) in vec2 inUv;\nlayout (location = 2) in vec3 inNormal;\n#ifdef JOINTNUMBER\nlayout (location = 4) in vec4 inJoint;\nlayout (location = 5) in vec4 inWeight;\n#endif\n#ifdef TANGENT\nlayout (location = 3) in vec4 inTangent;\n#endif\n#ifdef COLOR\nlayout (location = 6) in vec4 inColor;\n#endif\n#ifdef MULTIUV\nlayout (location = 7) in vec2 inUV2;\n#endif\n\nlayout(location = 0) out vec2 outUV0;\nlayout(location = 1) out vec2 outUV2;\nlayout(location = 4) out mat3 outTBN;\nlayout(location = 2) out vec3 outPosition;\nlayout(location = 3) out vec4 vColor;\n\nlayout(set = 0, binding = 0) uniform Uniforms {\n    mat4 model;\n    mat4 normalMatrix;\n    mat4 view;\n    mat4 projection;\n    mat4 light;\n    vec4 isShadow;\n} uniforms;\n\n#ifdef JOINTNUMBER\nlayout(set = 0, binding = 22) uniform Skin {\n    mat4 joint[JOINTNUMBER];\n};\n#endif\n\nvoid main() {\n    #ifdef JOINTNUMBER\n        mat4 skin = inWeight.x * joint[int(inJoint.x)];\n        skin += inWeight.y * joint[int(inJoint.y)];\n        skin += inWeight.z * joint[int(inJoint.z)];\n        skin += inWeight.w * joint[int(inJoint.w)];\n    #else\n        mat4 skin = mat4(1.0);\n    #endif\n\n    #ifdef TANGENT\n    vec3 normalW = normalize(vec3(uniforms.model * vec4(inNormal.xyz, 0.0)));\n    vec3 tangentW = normalize(vec3(uniforms.model * vec4(inTangent.xyz, 0.0)));\n    vec3 bitangentW = cross(normalW, tangentW) * inTangent.w;\n    outTBN = mat3(tangentW, bitangentW, normalW);\n    #else\n    outTBN = mat3(vec3(0), vec3(0), normalize(mat3(uniforms.normalMatrix) * mat3(skin) * inNormal));\n    #endif\n\n    gl_Position = uniforms.projection * uniforms.view * uniforms.model * skin * vec4(inPosition, 1.0);\n    outPosition = vec3(uniforms.model * skin * vec4(inPosition, 1.0));\n    outUV0 = inUv;\n    #ifdef MULTIUV\n    outUV2 = inUV2;\n    #endif\n    #ifdef COLOR\n    vColor = inColor;\n    #else\n    vColor = vec4(1);\n    #endif\n}".replace(/\n/,`\n${i}`),"#version 460\n\n#define IBL 1\n#define USE_PBR 1\n\nlayout(location = 0) in vec2 outUV0;\nlayout(location = 4) in mat3 outTBN;\nlayout(location = 1) in vec2 outUV2;\nlayout(location = 2) in vec3 outPosition;\nlayout(location = 3) in vec4 vColor;\n\nlayout(location = 0) out vec4 color;\n\nlayout(set = 0, binding = 0) uniform Matrices {\n    mat4 model;\n    mat4 normalMatrix;\n    mat4 view;\n    mat4 projection;\n    mat4 light;\n    vec4 isShadow;\n} matrices;\nlayout(set = 0, binding = 1) uniform Uniforms {\n    vec4 baseColorFactor;\n    vec3 viewPos;\n    mat3 textureMatrix;\n    vec3 specularFactor;\n    vec3 emissiveFactor;\n    vec4 glossinessFactor;\n    vec4 metallicFactor;\n    vec4 roughnessFactor;\n    vec4 clearcoatFactor;\n    vec4 clearcoatRoughnessFactor;\n    vec4 sheenColorFactor;\n    vec4 sheenRoughnessFactor;\n    vec4 transmissionFactor;\n    vec4 ior;\n} uniforms;\nlayout(set = 0, binding = 15) uniform LightColor {\n    vec3 lightColor[LIGHTNUMBER];\n} lightColor_;\nlayout(set = 0, binding = 17) uniform Spotdir {\n    vec3 spotdir[LIGHTNUMBER];\n} spotdir_;\nlayout(set = 0, binding = 18) uniform LightIntensity {\n    vec4 lightIntensity[LIGHTNUMBER];\n} lightIntensity_;\nlayout(set = 0, binding = 16) uniform LightPos {\n    vec3 lightPos[LIGHTNUMBER];\n} lightPos_;\n\nlayout(set = 0, binding = 2) uniform sampler baseSampler;\n#ifdef BASECOLORTEXTURE\nlayout(set = 0, binding = 3) uniform texture2D baseColorTexture;\n#endif\n#ifdef METALROUGHNESSMAP\nlayout(set = 0, binding = 4) uniform texture2D metallicRoughnessTexture;\n#endif\n#ifdef NORMALMAP\nlayout(set = 0, binding = 5) uniform texture2D normalTexture;\n#endif\n#ifdef EMISSIVEMAP\nlayout(set = 0, binding = 6) uniform texture2D emissiveTexture;\n#endif\n#ifdef OCCLUSIONMAP\nlayout(set = 0, binding = 7) uniform texture2D occlusionTexture;\n#endif\n#ifdef CLEARCOATMAP\nlayout(set = 0, binding = 8) uniform texture2D clearcoatTexture;\n#endif\n#ifdef CLEARCOATROUGHMAP\nlayout(set = 0, binding = 9) uniform texture2D clearcoatRoughnessTexture;\n#endif\n#ifdef TRANSMISSIONMAP\nlayout(set = 0, binding = 10) uniform texture2D transmissionTexture;\n#endif\n#ifdef SHEENMAP\nlayout(set = 0, binding = 11) uniform texture2D sheenColorTexture;\nlayout(set = 0, binding = 12) uniform texture2D sheenRoughnessTexture;\n#endif\n#ifdef CLEARCOATNORMALMAP\nlayout(set = 0, binding = 13) uniform texture2D clearcoatNormalTexture;\n#endif\n#ifdef SPECULARMAP\nlayout(set = 0, binding = 14) uniform texture2D specularTexture;\n#endif\nlayout(set = 0, binding = 19) uniform textureCube prefilterMap;\nlayout(set = 0, binding = 20) uniform textureCube irradianceMap;\nlayout(set = 0, binding = 21) uniform texture2D brdfLUT;\n\n\n\n\nconst float RECIPROCAL_PI = 0.31830988618;\nconst float PI = 3.14159265359;\nconst float EPSILON = 1e-6;\nconst float ambientStrength = 0.1;\nconst float specularStrength = 2.5;\nconst float specularPower = 32.0;\nconst float gamma = 2.2;\n\n\nvec2 getUV(int index) {\n    if (index == 1) {\n        return outUV0;\n    } else {\n        return outUV2;\n    }\n}\n\n// float ShadowCalculation(vec4 fragPosLightSpace, float bias) {\n//     vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\n//     projCoords = projCoords * 0.5 + 0.5;\n//     float currentDepth = projCoords.z;\n\n//     float shadow = 0.0;\n//     vec2 texelSize = 1.0 / vec2(textureSize(depthTexture, 0));\n//     for (int x = -2; x <= 2; ++x) {\n//         for (int y = -2; y <= 2; ++y) {\n//             float pcfDepth = texture(depthTexture, projCoords.xy + vec2(x, y) * texelSize).r;\n//             shadow += currentDepth - bias > pcfDepth ? 0.5 : 0.0;\n//         }\n//     }\n//     shadow /= 25.0;\n\n//     return shadow;\n// }\n\nvec3 srgbToLinear(vec4 srgbIn) {\n    #ifdef BASISU\n    return srgbIn.rgb;\n    #else\n    return pow(srgbIn.rgb, vec3(2.2));\n    #endif\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n    float a = roughness*roughness;\n    float a2 = max(a*a, 0.0001);\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / max(denom, 0.0001);\n}\n\nfloat GeometrySchlickGGX(float cosTheta, float roughness) {\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n\n    float nom   = cosTheta;\n    float denom = cosTheta * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\nfloat fresnelSchlickRoughness(float cosTheta, float F0, float roughness) {\n    return F0 + (max(1.0 - roughness, F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// vec3 computeEnvironmentIrradiance(vec3 normal) {\n//     return vSphericalL00\n//         + vSphericalL1_1 * (normal.y)\n//         + vSphericalL10 * (normal.z)\n//         + vSphericalL11 * (normal.x)\n//         + vSphericalL2_2 * (normal.y * normal.x)\n//         + vSphericalL2_1 * (normal.y * normal.z)\n//         + vSphericalL20 * ((3.0 * normal.z * normal.z) - 1.0)\n//         + vSphericalL21 * (normal.z * normal.x)\n//         + vSphericalL22 * (normal.x * normal.x - (normal.y * normal.y));\n// }\nvec3 IBLAmbient(vec3 specularMap, vec3 baseColor, float metallic, vec3 n, float roughness, vec3 viewDir) {\n    vec3 F0 = mix(vec3(0.05), baseColor, metallic);\n\n    #if defined SPECULARGLOSSINESSMAP || defined SPECULARMAP\n        F0 = specularMap;\n    #endif\n\n    vec3 F = fresnelSchlickRoughness(max(dot(n, viewDir), 0.0), F0, roughness);\n\n    vec3 kD = vec3(1.0) - F;\n    kD *= 1.0 - metallic;\n\n    const float MAX_REFLECTION_LOD = 3.0;\n    #ifdef SPHERICAL_HARMONICS\n    vec3 R = reflect(viewDir, n);\n    vec4 rotatedR = rotationMatrix * vec4(R, 0.0);\n    vec4 prefilterColor = textureLod(samplerCube(prefilterMap, baseSampler), rotatedR.xyz, roughness * MAX_REFLECTION_LOD);\n    vec3 prefilteredColor = srgbToLinear(vec4(prefilterColor.rgb, 0.0)) / prefilterColor.a;\n    vec3 irradianceVector = vec3(rotationMatrix * vec4(n, 0)).xyz;\n    vec3 irradiance = computeEnvironmentIrradiance(irradianceVector).rgb;\n    #else\n    vec3 R = reflect(-viewDir, n);\n    vec3 prefilteredColor = textureLod(samplerCube(prefilterMap, baseSampler), R, roughness * MAX_REFLECTION_LOD).rgb;\n    vec3 irradiance = texture(samplerCube(irradianceMap, baseSampler), n).rgb;\n    #endif\n    vec2 envBRDF  = texture(sampler2D(brdfLUT, baseSampler), vec2(max(dot(n, viewDir), 0.0), roughness)).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n\n    #if defined TRANSMISSION || defined CLEARCOAT\n    return specular;\n    #else\n    return (kD * irradiance * baseColor + specular);\n    #endif\n}\n\nfloat specEnv(vec3 N, vec3 V, float metallic, float roughness) {\n    float F0 = mix(0.05, 1.0, metallic);\n\n    float F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);\n    vec2 envBRDF  = texture(sampler2D(brdfLUT, baseSampler), vec2(max(dot(N, V), 0.0), roughness)).rg;\n    return (F * envBRDF.x + envBRDF.y);\n}\n\nvec3 CookTorranceSpecular(vec3 specularMap, vec3 baseColor, float metallic, vec3 n, vec3 H, float roughness, vec3 viewDir, vec3 lightDir) {\n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, baseColor, metallic);\n\n    #if defined SPECULARGLOSSINESSMAP || defined SPECULARMAP\n        F0 = specularMap;\n    #endif\n\n    float D = DistributionGGX(n, H, roughness);\n    float G = GeometrySmith(n, viewDir, lightDir, roughness);      \n    vec3 F = fresnelSchlick(max(dot(H, viewDir), 0.0), F0); \n\n    vec3 nominator = D * G * F;\n    float denominator = 4.0 * max(dot(n, viewDir), 0.0) * max(dot(n, lightDir), 0.0);\n    return nominator / max(denominator, 0.001);\n}\n\nvec3 LambertDiffuse(vec3 baseColor, float metallic, vec3 n, vec3 H, float roughness, vec3 viewDir, vec3 lightDir) {\n    float NdotL = max(dot(n, lightDir), 0.0);\n    vec3 F0 = vec3(0.04);\n    F0 = mix(F0, baseColor, metallic);\n\n    vec3 F = fresnelSchlick(max(dot(H, viewDir), 0.0), F0);    \n\n    vec3 kD = vec3(1.0) - F;\n    kD *= 1.0 - metallic;\n    return baseColor * kD / PI;\n}\n\nfloat saturate(float a) {\n\tif (a > 1.0) return 1.0;\n\tif (a < 0.0) return 0.0;\n\treturn a;\n}\nvec3 ImprovedOrenNayarDiffuse(vec3 baseColor, float metallic, vec3 N, vec3 H, float a, vec3 V, vec3 L) {\n    vec3 F0 = vec3(0.04);\n    F0 = mix(F0, baseColor, metallic);\n    // #if defined SPECULARGLOSSINESSMAP\n    //     F0 = specularMap;\n    // #endif\n    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);\n    vec3 kD = vec3(1.0) - F;\n    #if defined SPECULARGLOSSINESSMAP\n    #else\n        kD *= 1.0 - metallic;\n    #endif\n    vec3 diffuseColor = baseColor * kD;\n\t// calculate intermediary values\n\tfloat dotNL = saturate(dot(N, L));\n\tfloat dotNV = saturate(dot(N, V));\n\tfloat dotLV = saturate(dot(L, V));\n\tfloat dotLH = saturate(dot(L, H));\n\n\tfloat s = dotLV - dotNL * dotNV;\n\tfloat t = mix(1.0, max(max(dotNL, dotNV), 0.001), step(0.0, s));\n\tfloat st = s * (1.0 / (t + EPSILON));\n\n\tfloat sigma2 = a;\n\tvec3 A = diffuseColor * (0.17 * sigma2 / (sigma2 + 0.13)) + vec3(1.0 - 0.5 * sigma2 / (sigma2 + 0.33));\n\tfloat B = 0.45 * sigma2 / (sigma2 + 0.09);\n\treturn (diffuseColor * max(0.0, dotNL)) * (A + vec3(B * s / t) / PI);\n}\n\nfloat fresnelDielectric(float cosThetaI, float ni, float nt) {\n  cosThetaI = clamp(cosThetaI, -1.0, 1.0);\n\n  // Swap index of refraction if this is coming from inside the surface\n  if (cosThetaI < 0.0) {\n    float temp = ni;\n    ni = nt;\n    nt = temp;\n\n    cosThetaI = -cosThetaI;\n  }\n\n  float sinThetaI = sqrt(max(0.0, 1.0 - cosThetaI * cosThetaI));\n  float sinThetaT = ni / nt * sinThetaI;\n\n  // Check for total internal reflection\n  if (sinThetaT >= 1.0) {\n    return 1.0;\n  }\n\n  float cosThetaT = sqrt(max(0.0, 1.0 - sinThetaT * sinThetaT));\n\n  float rParallel = ((nt * cosThetaI) - (ni * cosThetaT)) /\n                    ((nt * cosThetaI) + (ni * cosThetaT));\n  float rPerpendicuar = ((ni * cosThetaI) - (nt * cosThetaT)) /\n                        ((ni * cosThetaI) + (nt * cosThetaT));\n  return (rParallel * rParallel + rPerpendicuar * rPerpendicuar) / 2.0;\n}\n\nbool Transmit(vec3 wm, vec3 wi, float n, out vec3 wo) {\n  float c = dot(wi, wm);\n  if (c < 0.0) {\n    c = -c;\n    wm = -wm;\n  }\n\n  float root = 1.0f - n * n * (1.0f - c * c);\n  if (root <= 0.0)\n    return false;\n\n  wo = (n * c - sqrt(root)) * wm - n * wi;\n  return true;\n}\n// vec3 calcTransmission(vec3 color, float metallic, vec3 N, vec3 H, float roughness, vec3 V, vec3 L, float transmission) {\n//     vec4 refractS = matrices.projection * matrices.view * vec4(outPosition + refract(-V, N, uniforms.ior.x), 1.0);\n//     refractS.xy = refractS.xy / refractS.w;\n//     refractS.xy = refractS.xy * 0.5 + 0.5;\n//     const float MAX_REFLECTION_LOD = 10.0;\n//     vec3 baseColor = textureLod(colorTexture, refractS.xy, roughness * MAX_REFLECTION_LOD).xyz;\n\n//     return transmission * baseColor * color;\n// }\n\nfloat sheenDistribution(float sheenRoughness, vec3 N, vec3 H) {\n    float NdotH = max(dot(N, H), 0.0);\n    float alphaG = max(sheenRoughness * sheenRoughness, 0.01);\n    float invR = 1.0 / alphaG;\n    float cos2h = NdotH * NdotH;\n    float sin2h = 1.0 - cos2h;\n    return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\n}\nfloat l(float x, float alphaG) {\n    float oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);\n    float a = mix(21.5473, 25.3245, oneMinusAlphaSq);\n    float b = mix(3.82987, 3.32435, oneMinusAlphaSq);\n    float c = mix(0.19823, 0.16801, oneMinusAlphaSq);\n    float d = mix(-1.97760, -1.27393, oneMinusAlphaSq);\n    float e = mix(-4.32054, -4.85967, oneMinusAlphaSq);\n    return a / (1.0 + b * pow(x, c)) + d * x + e;\n}\nfloat lambdaSheen(float cosTheta, float alphaG) {\n    return abs(cosTheta) < 0.5 ? exp(l(cosTheta, alphaG)) : exp(2.0 * l(0.5, alphaG) - l(1.0 - cosTheta, alphaG));\n}\nfloat sheenVisibility(vec3 N, vec3 V, vec3 L, float sheenRoughness) {\n    float alphaG = sheenRoughness * sheenRoughness;\n    float NdotL = max(dot(N, L), 0.0);\n    float NdotV = max(dot(N, V), 0.0);\n    float v = 1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL));\n    // if (isnan(v) || isinf(v)) {\n    //     v = 0.0;\n    // }\n    return v;\n}\n// float E(float x, float y) {\n//     return texture(Sheen_E, vec2(x,y)).r;\n// }\n\nfloat max3(vec3 v) { return max(max(v.x, v.y), v.z); }\n\nvec2 applyTransform(vec2 uv) {\n    mat3 translation = mat3(1, 0, 0, 0, 1, 0, uniforms.textureMatrix[0].x, uniforms.textureMatrix[0].y, 1);\n    mat3 rotation = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    if (uniforms.textureMatrix[2].x != 0.0) {\n        rotation = mat3(\n            cos(-uniforms.textureMatrix[2].x), sin(-uniforms.textureMatrix[2].x), 0,\n            -sin(-uniforms.textureMatrix[2].x), cos(-uniforms.textureMatrix[2].x), 0,\n            0, 0, 1\n        );\n    }\n    mat3 scale = mat3(uniforms.textureMatrix[1].x, 0, 0, 0, uniforms.textureMatrix[1].y, 0, 0, 0, 1);\n\n    mat3 matrix = translation * rotation * scale;\n    vec2 outUV = ( matrix * vec3(uv, 1.0) ).xy;\n    return outUV;\n}\n\nmat4 inverse2(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nvoid main() {\n    vec2 outUV = outUV0;\n    #ifdef BASECOLORTEXTURE\n        outUV = getUV(BASECOLORTEXTURE);\n        #ifdef BASECOLORTEXTURE_TEXTURE_TRANSFORM\n            outUV = applyTransform(outUV);\n        #endif\n        vec3 baseColor = srgbToLinear(texture(sampler2D(baseColorTexture, baseSampler), outUV)) * uniforms.baseColorFactor.rgb;\n        float alpha = min(texture(sampler2D(baseColorTexture, baseSampler), outUV).a, uniforms.baseColorFactor.a);\n    #else\n        vec3 baseColor = uniforms.baseColorFactor.rgb;\n        float alpha = uniforms.baseColorFactor.a;\n    #endif\n\n    #ifdef ALPHATEST\n    if ( alpha < ALPHATEST ) {\n        discard;\n    }\n    if ( ALPHATEST > 0.01 ) {\n        alpha = 1.0;\n    }\n    #else\n        alpha = 1.0;\n    #endif\n\n    if ( length(vColor.rgb) != 0.0 ) {\n        baseColor.rgb *= vColor.rgb;\n    }\n\n    #ifdef NOLIGHT\n        color = vec4(baseColor, alpha);\n        return;\n    #endif\n\n    float ao = 1.0;\n    #ifdef OCCLUSIONMAP\n        outUV = getUV(OCCLUSIONMAP);\n        #ifdef OCCLUSIONMAP_TEXTURE_TRANSFORM\n            outUV = applyTransform(outUV);\n        #endif\n        ao = texture(sampler2D(occlusionTexture, baseSampler), outUV).r;\n    #endif\n\n    float roughness = uniforms.roughnessFactor.x;\n    float metallic = uniforms.metallicFactor.x;\n    float clearcoatRoughness = uniforms.clearcoatRoughnessFactor.x;\n    float clearcoat = uniforms.clearcoatFactor.x;\n    float clearcoatBlendFactor = clearcoat;\n    vec3 sheenColor = uniforms.sheenColorFactor.xyz;\n    float sheenRoughness = uniforms.sheenRoughnessFactor.x;\n    float transmission = uniforms.transmissionFactor.x;\n    #ifdef CLEARCOATMAP\n        outUV = getUV(CLEARCOATMAP);\n        #ifdef CLEARCOATMAP_TEXTURE_TRANSFORM\n            outUV = applyTransform(outUV);\n        #endif\n        clearcoatBlendFactor = texture(sampler2D(clearcoatTexture, baseSampler), outUV).r * clearcoat;\n    #endif\n    #ifdef CLEARCOATROUGHMAP\n        outUV = getUV(CLEARCOATROUGHMAP);\n        #ifdef CLEARCOATROUGHMAP_TEXTURE_TRANSFORM\n            outUV = applyTransform(outUV);\n        #endif\n        clearcoatRoughness = texture(sampler2D(clearcoatRoughnessTexture, baseSampler), outUV).g * clearcoatRoughness;\n    #endif\n    #ifdef SHEENMAP\n        outUV = getUV(SHEENMAP);\n        #ifdef SHEENMAP_TEXTURE_TRANSFORM\n            outUV = applyTransform(outUV);\n        #endif\n        vec4 sheenRoughnessTextureV = texture(sampler2D(sheenRoughnessTexture, baseSampler), outUV);\n        vec3 sheenColorTextureV = srgbToLinear(texture(sampler2D(sheenColorTexture, baseSampler), outUV));\n        sheenColor = sheenColorTextureV * sheenColor;\n        sheenRoughness = sheenRoughnessTextureV.a * sheenRoughness;\n    #endif\n    #ifdef TRANSMISSIONMAP\n        float transmissionTextureV = texture(sampler2D(transmissionTexture, baseSampler), outUV).r;\n        transmission = transmissionTextureV * transmission;\n    #endif\n    vec3 specularMap = vec3(0);\n    #ifdef SPECULARGLOSSINESSMAP\n        #ifdef METALROUGHNESSMAP\n            outUV = getUV(METALROUGHNESSMAP);\n            #ifdef METALROUGHNESSMAP_TEXTURE_TRANSFORM\n                outUV = applyTransform(outUV);\n            #endif\n            roughness = 1.0 - texture(sampler2D(metallicRoughnessTexture, baseSampler), outUV).a;\n            specularMap = srgbToLinear(texture(sampler2D(metallicRoughnessTexture, baseSampler), outUV));\n        #else\n            roughness = uniforms.glossinessFactor.x;\n            specularMap = uniforms.specularFactor;\n        #endif\n    #else\n        #ifdef METALROUGHNESSMAP\n            outUV = getUV(METALROUGHNESSMAP);\n            #ifdef METALROUGHNESSMAP_TEXTURE_TRANSFORM\n                outUV = applyTransform(outUV);\n            #endif\n            vec4 metallicRoughness = texture(sampler2D(metallicRoughnessTexture, baseSampler), outUV);\n            roughness *= metallicRoughness.g;\n            metallic *= metallicRoughness.b;\n        #endif\n    #endif\n    #ifdef SPECULARMAP\n        specularMap = texture(sampler2D(specularTexture, baseSampler), outUV).rgb * specularFactor;\n    #endif\n\n    #ifdef TANGENT\n        #ifdef NORMALMAP\n            outUV = getUV(NORMALMAP);\n            #ifdef NORMALMAP_TEXTURE_TRANSFORM\n                outUV = applyTransform(outUV);\n            #endif\n            vec3 n = texture(sampler2D(normalTexture, baseSampler), outUV).rgb;\n            n = normalize(outTBN * (2.0 * n - 1.0));\n        #else\n            vec3 n = outTBN[2].xyz;\n        #endif\n    #else\n        vec3 n = outTBN[2].xyz;\n    #endif\n\n    #ifdef TANGENT\n    #ifdef CLEARCOATNORMALMAP\n        outUV = getUV(CLEARCOATNORMALMAP);\n        #ifdef CLEARCOATNORMALMAP_TEXTURE_TRANSFORM\n            outUV = applyTransform(outUV);\n        #endif\n        vec3 clearcoatNormal = texture(sampler2D(clearcoatNormalTexture, baseSampler), outUV).rgb;\n        clearcoatNormal = normalize(outTBN * (2.0 * clearcoatNormal - 1.0));\n    #else\n        vec3 clearcoatNormal = outTBN[2].xyz;\n    #endif\n    #else\n        vec3 clearcoatNormal = outTBN[2].xyz;\n    #endif\n\n    mat4 m = inverse2(matrices.view);\n    vec3 viewDir = normalize(m[3].xyz - outPosition);\n\n    #ifdef DOUBLESIDED\n    if (dot(n, viewDir) < 0.0) {\n        n = -n;\n        clearcoatNormal = -clearcoatNormal;\n    }\n    #endif\n\n    float shadow = 1.0;\n    // #ifdef SHADOWMAP\n    //     vec3 l = normalize(lightPos[0] - outPosition);\n    //     float shadowBias = max(0.05 * (1.0 - dot(n, l)), 0.005);\n    //     shadow = 1.0 - ShadowCalculation(outPositionView, shadowBias);\n    // #endif\n\n    #ifdef USE_PBR\n        vec3 Lo = vec3(0.0);\n        vec3 f_transmission = vec3(0.0);\n        for (int i = 0; i < LIGHTNUMBER; ++i) {\n            vec3 lightDir = normalize(lightPos_.lightPos[i] - outPosition);\n            float NdotL = max(dot(n, lightDir), 0.0);\n            vec3 H = normalize(viewDir + lightDir);\n\n            vec3 radiance = lightColor_.lightColor[i] * lightIntensity_.lightIntensity[i].x;\n            float distance = length(lightPos_.lightPos[i] - outPosition);\n            float attenuation = 1.0 / (distance * distance);\n            if (lightIntensity_.lightIntensity[i].w == 1.0) { // point\n                radiance = radiance * attenuation;\n            }\n            if (lightIntensity_.lightIntensity[i].w == 2.0) { // spot\n                float lightAngleScale = 1.0 / max(0.001, cos(lightIntensity_.lightIntensity[i].y) - cos(lightIntensity_.lightIntensity[i].z));\n                float lightAngleOffset = -cos(lightIntensity_.lightIntensity[i].z) * lightAngleScale;\n\n                float cd = dot(spotdir_.spotdir[i], lightDir);\n                float attenuationSpot = saturate(cd * lightAngleScale + lightAngleOffset);\n                attenuationSpot *= attenuationSpot;\n\n                radiance = radiance * attenuationSpot * attenuation;\n            }\n\n            vec3 specular = CookTorranceSpecular(specularMap, baseColor, metallic, n, H, roughness, viewDir, lightDir);\n            vec3 f_clearcoat = CookTorranceSpecular(specularMap, vec3(0.0), 0.0, clearcoatNormal, H, clearcoatRoughness, viewDir, lightDir);\n            float NdotV = saturate(dot(clearcoatNormal, viewDir));\n            vec3 clearcoatFresnel = 1.0 - clearcoatBlendFactor * fresnelSchlick(NdotV, vec3(0.04));\n            vec3 diffuse = ImprovedOrenNayarDiffuse(baseColor, metallic, n, H, roughness, viewDir, lightDir);\n            #if defined SPECULARGLOSSINESSMAP || defined SPECULARMAP\n                diffuse = baseColor * (1.0 - max(max(specularMap.r, specularMap.g), specularMap.b));\n            #endif\n            vec3 f_sheen = sheenColor * sheenDistribution(sheenRoughness, n, H) * sheenVisibility(n, viewDir, lightDir, sheenRoughness);\n            //float sheenAlbedoScaling = min(1.0 - max3(sheenColor) * E(max(dot(viewDir, n), 0.0), sheenRoughness), 1.0 - max3(sheenColor) * E(max(dot(lightDir, n), 0.0), sheenRoughness));\n            float sheenAlbedoScaling=1.0;\n\n            //f_transmission += calcTransmission(baseColor, metallic, n, H, roughness, viewDir, lightDir, transmission);\n            diffuse *= (1.0 - transmission);\n\n            Lo += sheenAlbedoScaling * (diffuse + specular * NdotL) * radiance * clearcoatFresnel + f_clearcoat * clearcoatBlendFactor + f_sheen;\n        }\n\n        vec3 ambient = vec3(0.0);\n        vec3 ambientClearcoat = vec3(0.0);\n        vec3 clearcoatFresnel = vec3(1.0);\n        #ifdef IBL\n            ambient = IBLAmbient(specularMap, baseColor, metallic, n, roughness, viewDir);\n            #ifdef CLEARCOAT\n            ambientClearcoat = IBLAmbient(specularMap, vec3(0.0), 0.0, clearcoatNormal, clearcoatRoughness, viewDir) * clearcoatBlendFactor;\n            float NdotV = saturate(dot(clearcoatNormal, viewDir));\n            clearcoatFresnel = (1.0 - clearcoatBlendFactor * fresnelSchlick(NdotV, vec3(0.04)));\n            #endif\n        #else\n            ambient = vec3(0.03) * baseColor * 0.2;\n        #endif\n\n        vec3 emissive = uniforms.emissiveFactor;\n        #ifdef EMISSIVEMAP\n            outUV = getUV(EMISSIVEMAP);\n            #ifdef EMISSIVEMAP_TEXTURE_TRANSFORM\n                outUV = applyTransform(outUV);\n            #endif\n            emissive = srgbToLinear(texture(sampler2D(emissiveTexture, baseSampler), outUV));\n        #endif\n\n        #ifdef TRANSMISSION\n        color = vec4(ambient + Lo + f_transmission * (1.0 - specEnv(n, viewDir, metallic, roughness)), alpha);\n        #else\n        color = vec4(ao * shadow * ((emissive + ambient + Lo) * clearcoatFresnel + ambientClearcoat), alpha);\n        #endif\n    #else\n        vec3 lightDir = normalize(lightPos_.lightPos[0] - outPosition);\n        vec3 ambient = ambientStrength * lightColor_.lightColor[0];\n\n        float diff = max(dot(n, lightDir), 0.0);\n        vec3 diffuse = diff * lightColor_.lightColor[0];\n\n        vec3 reflectDir = reflect(-lightDir, n);\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), specularPower);\n        vec3 specular = specularStrength * spec * lightColor_.lightColor[0];\n\n        color = vec4(baseColor.rgb * (ambient + diffuse + specular) * shadow, alpha);\n    #endif\n\n    //if (isTone == 1) {\n        color.rgb = color.rgb / (color.rgb + vec3(1.0));\n        color.rgb = pow(color.rgb, vec3(1.0 / gamma));\n    //}\n}\n".replace(/\n/,`\n${i}`)],a=[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{}},{binding:2,visibility:GPUShaderStage.FRAGMENT,sampler:{}}];n.forEach((e=>{e.binding>2&&e.binding<15&&a.push({binding:e.binding,visibility:GPUShaderStage.FRAGMENT,texture:{}})})),a.push({binding:15,visibility:GPUShaderStage.FRAGMENT,buffer:{}},{binding:16,visibility:GPUShaderStage.FRAGMENT,buffer:{}},{binding:17,visibility:GPUShaderStage.FRAGMENT,buffer:{}},{binding:18,visibility:GPUShaderStage.FRAGMENT,buffer:{}},{binding:19,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube"}},{binding:20,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube"}},{binding:21,visibility:GPUShaderStage.FRAGMENT,texture:{}}),r.find((e=>"JOINTNUMBER"===e.name))&&a.push({binding:22,visibility:GPUShaderStage.VERTEX,buffer:{}});const o=e.createBindGroupLayout({entries:a}),l=e.createPipelineLayout({bindGroupLayouts:[o]}),c=[3,2,3,4];r.find((e=>"JOINTNUMBER"===e.name))&&c.push(4,4),r.find((e=>"COLOR"===e.name))&&c.push(4),r.find((e=>"MULTIUV"===e.name))&&c.push(2);const u=[{arrayStride:Float32Array.BYTES_PER_ELEMENT*c.reduce(((e,t)=>e+t),0),attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:Float32Array.BYTES_PER_ELEMENT*c[0],format:"float32x2"},{shaderLocation:2,offset:Float32Array.BYTES_PER_ELEMENT*(c[0]+c[1]),format:"float32x3"},{shaderLocation:3,offset:Float32Array.BYTES_PER_ELEMENT*(c[0]+c[1]+c[2]),format:"float32x4"}]}];return r.find((e=>"JOINTNUMBER"===e.name))&&u[0].attributes.push({shaderLocation:4,offset:Float32Array.BYTES_PER_ELEMENT*(c[0]+c[1]+c[2]+c[3]),format:"float32x4"},{shaderLocation:5,offset:Float32Array.BYTES_PER_ELEMENT*(c[0]+c[1]+c[2]+c[3]+c[4]),format:"float32x4"}),r.find((e=>"COLOR"===e.name))&&u[0].attributes.push({shaderLocation:6,offset:Float32Array.BYTES_PER_ELEMENT*(c[0]+c[1]+c[2]+c[3]),format:"float32x4"}),r.find((e=>"MULTIUV"===e.name))&&u[0].attributes.push({shaderLocation:7,offset:Float32Array.BYTES_PER_ELEMENT*(c[0]+c[1]+c[2]+c[3]),format:"float32x2"}),e.createRenderPipeline({layout:l,vertex:{module:e.createShaderModule({code:t.compileGLSL(s[0],"vertex"),source:s[0],transform:e=>t.compileGLSL(e,"vertex")}),entryPoint:"main",buffers:u},fragment:{module:e.createShaderModule({code:t.compileGLSL(s[1],"fragment"),source:s[1],transform:e=>t.compileGLSL(e,"fragment")}),entryPoint:"main",targets:[{format:"bgra8unorm",blend:r.find((e=>"ALPHATEST"===e.name))?{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}}:void 0}]},primitive:{topology:"triangle-list",cullMode:r.find((e=>"DOUBLESIDED"===e.name))?"none":"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth32float"}})}(e.device,e.glslang,t.material.uniformBindGroup1,t.defines),t.uniformBindGroup1=e.device.createBindGroup({layout:t.pipeline.getBindGroupLayout(0),entries:[...t.geometry.uniformBindGroup1,...t.material.uniformBindGroup1]})}))}catch(e){console.log(e)}this.scene.tracks=this.parse.tracks,this.scene.cameras=this.parse.cameras,this.scene.lights=this.parse.lights,this.renderer.render(),e(this.scene)}buildBones(e,t,n){n.name===e&&t.bones.push(n)}resize(){this.camera.props.aspect=this.canvas.offsetWidth/this.canvas.offsetHeight,this.canvas.width=this.canvas.offsetWidth*devicePixelRatio,this.canvas.height=this.canvas.offsetHeight*devicePixelRatio;const e=this.camera.modelSize;this.camera.props.isInitial&&this.camera.setZ(1.5*e),(this.light.isInitial||"directional"===this.light.type)&&this.light.setZ(1.5*e),this.camera.updateNF()}redraw(e,t,n){"zoom"===e&&(this.camera.zoom(t),this.renderer.needUpdateView=!0,this.renderer.needUpdateProjection=!0),"rotate"===e&&(this.camera.rotate(t,n),this.renderer.needUpdateView=!0),"pan"===e&&(this.camera.pan(t,n,this.canvas.offsetWidth,this.canvas.offsetHeight),this.renderer.needUpdateView=!0),"resize"===e&&(this.resize(),this.renderer.needUpdateProjection=!0),this.renderer.reflow=!0}setVariant(){console.warn("Not implemented")}draw(){console.warn("Not implemented")}getState(){return{camera:this.camera,light:this.light,needUpdateView:this.renderer.needUpdateView,needUpdateProjection:this.renderer.needUpdateProjection}}}},870:e=>{e.exports=function(e){e instanceof ArrayBuffer&&(e=new Uint8Array(e));var t=0,n=e.length;function r(){var r="";do{var i=e[t];if(10==i){++t;break}r+=String.fromCharCode(i)}while(++t<n);return r}for(var i=0,s=0,a=1,o=!1,l=0;l<20;l++){var c,u=r();if(c=u.match("#\\?RADIANCE"));else if(c=u.match("FORMAT=32-bit_rle_rgbe"))o=!0;else if(c=u.match("EXPOSURE=\\s*([0-9]*[.][0-9]*)"))a=Number(c[1]);else if(c=u.match("#.*"));else if(c=u.match("-Y ([0-9]+) \\+X ([0-9]+)")){s=Number(c[1]),i=Number(c[2]);break}}if(!o)throw new Error("File is not run length encoded!");var h=new Uint8Array(i*s*4);!function(e,t,n,r,i,s){var a,o,l,c=new Array(4),u=null,h=new Array(2),f=e.length;function m(t){var n=0;do{t[n++]=e[r]}while(++r<f&&n<t.length);return n}function d(t,n,i){var s=0;do{t[n+s++]=e[r]}while(++r<f&&s<i);return s}function T(e,t,n,r){var i=4*r,s=d(t,n,i);if(s<i)throw new Error("Error reading raw pixels: got "+s+" bytes, expected "+i)}for(;s>0;){if(m(c)<c.length)throw new Error("Error reading bytes: expected "+c.length);if(2!=c[0]||2!=c[1]||0!=(128&c[2]))return t[n++]=c[0],t[n++]=c[1],t[n++]=c[2],t[n++]=c[3],void T(0,t,n,i*s-1);if(((255&c[2])<<8|255&c[3])!=i)throw new Error("Wrong scanline width "+((255&c[2])<<8|255&c[3])+", expected "+i);null==u&&(u=new Array(4*i)),a=0;for(var E=0;E<4;E++)for(o=(E+1)*i;a<o;){if(m(h)<h.length)throw new Error("Error reading 2-byte buffer");if((255&h[0])>128){if(0==(l=(255&h[0])-128)||l>o-a)throw new Error("Bad scanline data");for(;l-- >0;)u[a++]=h[1]}else{if(0==(l=255&h[0])||l>o-a)throw new Error("Bad scanline data");if(u[a++]=h[1],--l>0){if(d(u,a,l)<l)throw new Error("Error reading non-run data");a+=l}}}for(E=0;E<i;E++)t[n+0]=u[E],t[n+1]=u[E+i],t[n+2]=u[E+2*i],t[n+3]=u[E+3*i],n+=4;s--}}(e,h,0,t,i,s);for(var f=new Float32Array(i*s*4),m=0;m<h.length;m+=4){var d=h[m+0]/255,T=h[m+1]/255,E=h[m+2]/255,p=h[m+3],g=Math.pow(2,p-128);d*=g,T*=g,E*=g;var R=m;f[R+0]=d,f[R+1]=T,f[R+2]=E,f[R+3]=1}return{shape:[i,s],exposure:a,gamma:1,data:f}}},993:()=>{}},s={};function a(e){if(s[e])return s[e].exports;var t=s[e]={exports:{}};return i[e].call(t.exports,t,t.exports,a),t.exports}return a.m=i,a.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return a.d(t,{a:t}),t},t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,a.t=function(n,r){if(1&r&&(n=this(n)),8&r)return n;if("object"==typeof n&&n){if(4&r&&n.__esModule)return n;if(16&r&&"function"==typeof n.then)return n}var i=Object.create(null);a.r(i);var s={};e=e||[null,t({}),t([]),t(t)];for(var o=2&r&&n;"object"==typeof o&&!~e.indexOf(o);o=t(o))Object.getOwnPropertyNames(o).forEach((e=>s[e]=()=>n[e]));return s.default=()=>n,a.d(i,s),i},a.d=(e,t)=>{for(var n in t)a.o(t,n)&&!a.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},a.f={},a.e=e=>Promise.all(Object.keys(a.f).reduce(((t,n)=>(a.f[n](e,t),t)),[])),a.u=e=>"libs/"+{114:"glslang",164:"libktx",681:"draco3d"}[e]+".js",a.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),a.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n={},r="redcube:",a.l=(e,t,i)=>{if(n[e])n[e].push(t);else{var s,o;if(void 0!==i)for(var l=document.getElementsByTagName("script"),c=0;c<l.length;c++){var u=l[c];if(u.getAttribute("src")==e||u.getAttribute("data-webpack")==r+i){s=u;break}}s||(o=!0,(s=document.createElement("script")).charset="utf-8",s.timeout=120,a.nc&&s.setAttribute("nonce",a.nc),s.setAttribute("data-webpack",r+i),s.src=e),n[e]=[t];var h=(t,r)=>{s.onerror=s.onload=null,clearTimeout(f);var i=n[e];if(delete n[e],s.parentNode&&s.parentNode.removeChild(s),i&&i.forEach((e=>e(r))),t)return t(r)},f=setTimeout(h.bind(null,void 0,{type:"timeout",target:s}),12e4);s.onerror=h.bind(null,s.onerror),s.onload=h.bind(null,s.onload),o&&document.head.appendChild(s)}},a.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e;a.g.importScripts&&(e=a.g.location+"");var t=a.g.document;if(!e&&t&&(t.currentScript&&(e=t.currentScript.src),!e)){var n=t.getElementsByTagName("script");n.length&&(e=n[n.length-1].src)}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),a.p=e})(),(()=>{var e={179:0};a.f.j=(t,n)=>{var r=a.o(e,t)?e[t]:void 0;if(0!==r)if(r)n.push(r[2]);else{var i=new Promise(((n,i)=>{r=e[t]=[n,i]}));n.push(r[2]=i);var s=a.p+a.u(t),o=new Error;a.l(s,(n=>{if(a.o(e,t)&&(0!==(r=e[t])&&(e[t]=void 0),r)){var i=n&&("load"===n.type?"missing":n.type),s=n&&n.target&&n.target.src;o.message="Loading chunk "+t+" failed.\n("+i+": "+s+")",o.name="ChunkLoadError",o.type=i,o.request=s,r[1](o)}}),"chunk-"+t)}};var t=(t,n)=>{for(var r,i,[s,o,l]=n,c=0,u=[];c<s.length;c++)i=s[c],a.o(e,i)&&e[i]&&u.push(e[i][0]),e[i]=0;for(r in o)a.o(o,r)&&(a.m[r]=o[r]);for(l&&l(a),t&&t(n);u.length;)u.shift()()},n=self.webpackChunkredcube=self.webpackChunkredcube||[];n.forEach(t.bind(null,0)),n.push=t.bind(null,n.push.bind(n))})(),a(510)})()}));